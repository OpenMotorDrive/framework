
build/org.mro.perh_1.0/basic_uavcan_functionality.elf:     file format elf32-littlearm


Disassembly of section .text:

080031d0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80031d0:	b672      	cpsid	i
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80031d2:	4825      	ldr	r0, [pc, #148]	; (8003268 <endfiniloop+0x4>)
                msr     PSP, r0
 80031d4:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80031d8:	4824      	ldr	r0, [pc, #144]	; (800326c <endfiniloop+0x8>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80031da:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80031de:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80031e2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80031e4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80031e6:	f380 8814 	msr	CONTROL, r0
                isb
 80031ea:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
<<<<<<< HEAD
 80031ee:	f009 f9e3 	bl	800c5b8 <__core_init>
=======
 80031ee:	f009 fa27 	bl	800c640 <__core_init>
>>>>>>> 752c83b... update binaries
#endif

                /* Early initialization.*/
                bl      __early_init
 80031f2:	f001 f88f 	bl	8004314 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80031f6:	481e      	ldr	r0, [pc, #120]	; (8003270 <endfiniloop+0xc>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80031f8:	491e      	ldr	r1, [pc, #120]	; (8003274 <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 80031fa:	4a1f      	ldr	r2, [pc, #124]	; (8003278 <endfiniloop+0x14>)

080031fc <msloop>:
msloop:
                cmp     r1, r2
 80031fc:	4291      	cmp	r1, r2
                itt     lo
 80031fe:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8003200:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8003204:	e7fa      	bcc.n	80031fc <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8003206:	491d      	ldr	r1, [pc, #116]	; (800327c <endfiniloop+0x18>)
                ldr     r2, =__process_stack_end__
 8003208:	4a17      	ldr	r2, [pc, #92]	; (8003268 <endfiniloop+0x4>)

0800320a <psloop>:
psloop:
                cmp     r1, r2
 800320a:	4291      	cmp	r1, r2
                itt     lo
 800320c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800320e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8003212:	e7fa      	bcc.n	800320a <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8003214:	491a      	ldr	r1, [pc, #104]	; (8003280 <endfiniloop+0x1c>)
                ldr     r2, =_data_start
 8003216:	4a1b      	ldr	r2, [pc, #108]	; (8003284 <endfiniloop+0x20>)
                ldr     r3, =_data_end
 8003218:	4b1b      	ldr	r3, [pc, #108]	; (8003288 <endfiniloop+0x24>)

0800321a <dloop>:
dloop:
                cmp     r2, r3
 800321a:	429a      	cmp	r2, r3
                ittt    lo
 800321c:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800321e:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8003222:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8003226:	e7f8      	bcc.n	800321a <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8003228:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 800322a:	4918      	ldr	r1, [pc, #96]	; (800328c <endfiniloop+0x28>)
                ldr     r2, =_bss_end
 800322c:	4a18      	ldr	r2, [pc, #96]	; (8003290 <endfiniloop+0x2c>)

0800322e <bloop>:
bloop:
                cmp     r1, r2
 800322e:	4291      	cmp	r1, r2
                itt     lo
 8003230:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8003232:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8003236:	e7fa      	bcc.n	800322e <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
<<<<<<< HEAD
 8003238:	f009 f9ce 	bl	800c5d8 <__init_ram_areas>
=======
 8003238:	f009 fa12 	bl	800c660 <__init_ram_areas>
>>>>>>> 752c83b... update binaries
#endif

                /* Late initialization..*/
                bl      __late_init
<<<<<<< HEAD
 800323c:	f009 f9c2 	bl	800c5c4 <__late_init>
=======
 800323c:	f009 fa06 	bl	800c64c <__late_init>
>>>>>>> 752c83b... update binaries

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8003240:	4c14      	ldr	r4, [pc, #80]	; (8003294 <endfiniloop+0x30>)
                ldr     r5, =__init_array_end
 8003242:	4d15      	ldr	r5, [pc, #84]	; (8003298 <endfiniloop+0x34>)

08003244 <initloop>:
initloop:
                cmp     r4, r5
 8003244:	42ac      	cmp	r4, r5
                bge     endinitloop
 8003246:	da03      	bge.n	8003250 <endinitloop>
                ldr     r1, [r4], #4
 8003248:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800324c:	4788      	blx	r1
                b       initloop
 800324e:	e7f9      	b.n	8003244 <initloop>

08003250 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
<<<<<<< HEAD
 8003250:	f009 fbb4 	bl	800c9bc <main>
=======
 8003250:	f009 fbf8 	bl	800ca44 <main>
>>>>>>> 752c83b... update binaries

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8003254:	4c11      	ldr	r4, [pc, #68]	; (800329c <endfiniloop+0x38>)
                ldr     r5, =__fini_array_end
 8003256:	4d12      	ldr	r5, [pc, #72]	; (80032a0 <endfiniloop+0x3c>)

08003258 <finiloop>:
finiloop:
                cmp     r4, r5
 8003258:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800325a:	da03      	bge.n	8003264 <endfiniloop>
                ldr     r1, [r4], #4
 800325c:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8003260:	4788      	blx	r1
                b       finiloop
 8003262:	e7f9      	b.n	8003258 <finiloop>

08003264 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
<<<<<<< HEAD
 8003264:	f009 b9b4 	b.w	800c5d0 <__default_exit>
=======
 8003264:	f009 b9f8 	b.w	800c658 <__default_exit>
>>>>>>> 752c83b... update binaries
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8003268:	20000a00 	.word	0x20000a00
                msr     PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800326c:	08003000 	.word	0x08003000

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8003270:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8003274:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 8003278:	20000500 	.word	0x20000500
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800327c:	20000500 	.word	0x20000500
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8003280:	0800edd8 	.word	0x0800edd8
                ldr     r2, =_data_start
 8003284:	20000a00 	.word	0x20000a00
                ldr     r3, =_data_end
 8003288:	20000a1c 	.word	0x20000a1c

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 800328c:	20000a20 	.word	0x20000a20
                ldr     r2, =_bss_end
 8003290:	2000156c 	.word	0x2000156c
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8003294:	08003188 	.word	0x08003188
                ldr     r5, =__init_array_end
 8003298:	080031c4 	.word	0x080031c4
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800329c:	080031c4 	.word	0x080031c4
                ldr     r5, =__fini_array_end
 80032a0:	080031c4 	.word	0x080031c4

080032a4 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80032a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80032a8:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80032ac:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80032ae:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80032b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080032b4 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
<<<<<<< HEAD
 80032b4:	f007 fdda 	bl	800ae6c <_dbg_check_unlock>
=======
 80032b4:	f007 fe1e 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80032b8:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80032ba:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80032be:	4628      	mov	r0, r5
                blx     r4
 80032c0:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80032c2:	2000      	movs	r0, #0
                bl      chThdExit
<<<<<<< HEAD
 80032c4:	f006 ffe0 	bl	800a288 <chThdExit>
=======
 80032c4:	f007 f824 	bl	800a310 <chThdExit>
>>>>>>> 752c83b... update binaries

080032c8 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
<<<<<<< HEAD
 80032c8:	f007 fdba 	bl	800ae40 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80032cc:	f008 faa2 	bl	800b814 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80032d0:	f007 fdcc 	bl	800ae6c <_dbg_check_unlock>
=======
 80032c8:	f007 fdfe 	bl	800aec8 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80032cc:	f008 fae6 	bl	800b89c <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80032d0:	f007 fe10 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

080032d4 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80032d4:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80032d6:	e7fe      	b.n	80032d6 <_port_exit_from_isr+0x2>

080032d8 <__aeabi_f2uiz>:
 80032d8:	0042      	lsls	r2, r0, #1
 80032da:	d20e      	bcs.n	80032fa <__aeabi_f2uiz+0x22>
 80032dc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80032e0:	d30b      	bcc.n	80032fa <__aeabi_f2uiz+0x22>
 80032e2:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80032e6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80032ea:	d409      	bmi.n	8003300 <__aeabi_f2uiz+0x28>
 80032ec:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80032f0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80032f4:	fa23 f002 	lsr.w	r0, r3, r2
 80032f8:	4770      	bx	lr
 80032fa:	f04f 0000 	mov.w	r0, #0
 80032fe:	4770      	bx	lr
 8003300:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8003304:	d101      	bne.n	800330a <__aeabi_f2uiz+0x32>
 8003306:	0242      	lsls	r2, r0, #9
 8003308:	d102      	bne.n	8003310 <__aeabi_f2uiz+0x38>
 800330a:	f04f 30ff 	mov.w	r0, #4294967295
 800330e:	4770      	bx	lr
 8003310:	f04f 0000 	mov.w	r0, #0
 8003314:	4770      	bx	lr
 8003316:	bf00      	nop

08003318 <__aeabi_uldivmod>:
 8003318:	b953      	cbnz	r3, 8003330 <__aeabi_uldivmod+0x18>
 800331a:	b94a      	cbnz	r2, 8003330 <__aeabi_uldivmod+0x18>
 800331c:	2900      	cmp	r1, #0
 800331e:	bf08      	it	eq
 8003320:	2800      	cmpeq	r0, #0
 8003322:	bf1c      	itt	ne
 8003324:	f04f 31ff 	movne.w	r1, #4294967295
 8003328:	f04f 30ff 	movne.w	r0, #4294967295
 800332c:	f000 b83c 	b.w	80033a8 <__aeabi_idiv0>
 8003330:	b082      	sub	sp, #8
 8003332:	46ec      	mov	ip, sp
 8003334:	e92d 5000 	stmdb	sp!, {ip, lr}
 8003338:	f000 f81e 	bl	8003378 <__gnu_uldivmod_helper>
 800333c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8003340:	b002      	add	sp, #8
 8003342:	bc0c      	pop	{r2, r3}
 8003344:	4770      	bx	lr
 8003346:	bf00      	nop

08003348 <__gnu_ldivmod_helper>:
 8003348:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800334c:	9c06      	ldr	r4, [sp, #24]
 800334e:	4690      	mov	r8, r2
 8003350:	4606      	mov	r6, r0
 8003352:	460f      	mov	r7, r1
 8003354:	461d      	mov	r5, r3
 8003356:	f000 f829 	bl	80033ac <__divdi3>
 800335a:	fb08 fc01 	mul.w	ip, r8, r1
 800335e:	fba8 2300 	umull	r2, r3, r8, r0
 8003362:	fb00 c505 	mla	r5, r0, r5, ip
 8003366:	1ab2      	subs	r2, r6, r2
 8003368:	442b      	add	r3, r5
 800336a:	eb67 0303 	sbc.w	r3, r7, r3
 800336e:	4686      	mov	lr, r0
 8003370:	e9c4 2300 	strd	r2, r3, [r4]
 8003374:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08003378 <__gnu_uldivmod_helper>:
 8003378:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800337c:	9e08      	ldr	r6, [sp, #32]
 800337e:	4617      	mov	r7, r2
 8003380:	4680      	mov	r8, r0
 8003382:	4689      	mov	r9, r1
 8003384:	461d      	mov	r5, r3
 8003386:	f000 f967 	bl	8003658 <__udivdi3>
 800338a:	fb00 f305 	mul.w	r3, r0, r5
 800338e:	fba0 4507 	umull	r4, r5, r0, r7
 8003392:	fb07 3701 	mla	r7, r7, r1, r3
 8003396:	ebb8 0404 	subs.w	r4, r8, r4
 800339a:	443d      	add	r5, r7
 800339c:	eb69 0505 	sbc.w	r5, r9, r5
 80033a0:	e9c6 4500 	strd	r4, r5, [r6]
 80033a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080033a8 <__aeabi_idiv0>:
 80033a8:	4770      	bx	lr
 80033aa:	bf00      	nop

080033ac <__divdi3>:
 80033ac:	2900      	cmp	r1, #0
 80033ae:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80033b2:	f2c0 80a8 	blt.w	8003506 <__divdi3+0x15a>
 80033b6:	2600      	movs	r6, #0
 80033b8:	2b00      	cmp	r3, #0
 80033ba:	f2c0 809e 	blt.w	80034fa <__divdi3+0x14e>
 80033be:	4681      	mov	r9, r0
 80033c0:	468e      	mov	lr, r1
 80033c2:	4690      	mov	r8, r2
 80033c4:	469c      	mov	ip, r3
 80033c6:	4617      	mov	r7, r2
 80033c8:	4604      	mov	r4, r0
 80033ca:	460d      	mov	r5, r1
 80033cc:	2b00      	cmp	r3, #0
 80033ce:	d13d      	bne.n	800344c <__divdi3+0xa0>
 80033d0:	428a      	cmp	r2, r1
 80033d2:	d959      	bls.n	8003488 <__divdi3+0xdc>
 80033d4:	fab2 f382 	clz	r3, r2
 80033d8:	b13b      	cbz	r3, 80033ea <__divdi3+0x3e>
 80033da:	f1c3 0220 	rsb	r2, r3, #32
 80033de:	409d      	lsls	r5, r3
 80033e0:	fa20 f202 	lsr.w	r2, r0, r2
 80033e4:	409f      	lsls	r7, r3
 80033e6:	4315      	orrs	r5, r2
 80033e8:	409c      	lsls	r4, r3
 80033ea:	0c39      	lsrs	r1, r7, #16
 80033ec:	fbb5 f0f1 	udiv	r0, r5, r1
 80033f0:	fa1f fe87 	uxth.w	lr, r7
 80033f4:	fb01 5510 	mls	r5, r1, r0, r5
 80033f8:	fb0e f300 	mul.w	r3, lr, r0
 80033fc:	0c22      	lsrs	r2, r4, #16
 80033fe:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
 8003402:	42ab      	cmp	r3, r5
 8003404:	d909      	bls.n	800341a <__divdi3+0x6e>
 8003406:	19ed      	adds	r5, r5, r7
 8003408:	f100 32ff 	add.w	r2, r0, #4294967295
 800340c:	f080 810b 	bcs.w	8003626 <__divdi3+0x27a>
 8003410:	42ab      	cmp	r3, r5
 8003412:	f240 8108 	bls.w	8003626 <__divdi3+0x27a>
 8003416:	3802      	subs	r0, #2
 8003418:	443d      	add	r5, r7
 800341a:	1aed      	subs	r5, r5, r3
 800341c:	fbb5 f3f1 	udiv	r3, r5, r1
 8003420:	fb01 5513 	mls	r5, r1, r3, r5
 8003424:	fb0e fe03 	mul.w	lr, lr, r3
 8003428:	b2a4      	uxth	r4, r4
 800342a:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 800342e:	45ae      	cmp	lr, r5
 8003430:	d908      	bls.n	8003444 <__divdi3+0x98>
 8003432:	19ed      	adds	r5, r5, r7
 8003434:	f103 32ff 	add.w	r2, r3, #4294967295
 8003438:	f080 80f7 	bcs.w	800362a <__divdi3+0x27e>
 800343c:	45ae      	cmp	lr, r5
 800343e:	f240 80f4 	bls.w	800362a <__divdi3+0x27e>
 8003442:	3b02      	subs	r3, #2
 8003444:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8003448:	2200      	movs	r2, #0
 800344a:	e003      	b.n	8003454 <__divdi3+0xa8>
 800344c:	428b      	cmp	r3, r1
 800344e:	d90f      	bls.n	8003470 <__divdi3+0xc4>
 8003450:	2200      	movs	r2, #0
 8003452:	4613      	mov	r3, r2
 8003454:	1c34      	adds	r4, r6, #0
 8003456:	bf18      	it	ne
 8003458:	2401      	movne	r4, #1
 800345a:	4260      	negs	r0, r4
 800345c:	f04f 0500 	mov.w	r5, #0
 8003460:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 8003464:	4058      	eors	r0, r3
 8003466:	4051      	eors	r1, r2
 8003468:	1900      	adds	r0, r0, r4
 800346a:	4169      	adcs	r1, r5
 800346c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003470:	fab3 f283 	clz	r2, r3
 8003474:	2a00      	cmp	r2, #0
 8003476:	f040 8089 	bne.w	800358c <__divdi3+0x1e0>
 800347a:	428b      	cmp	r3, r1
 800347c:	d302      	bcc.n	8003484 <__divdi3+0xd8>
 800347e:	4580      	cmp	r8, r0
 8003480:	f200 80e2 	bhi.w	8003648 <__divdi3+0x29c>
 8003484:	2301      	movs	r3, #1
 8003486:	e7e5      	b.n	8003454 <__divdi3+0xa8>
 8003488:	b912      	cbnz	r2, 8003490 <__divdi3+0xe4>
 800348a:	2301      	movs	r3, #1
 800348c:	fbb3 f7f2 	udiv	r7, r3, r2
 8003490:	fab7 f887 	clz	r8, r7
 8003494:	f1b8 0f00 	cmp.w	r8, #0
 8003498:	d13b      	bne.n	8003512 <__divdi3+0x166>
 800349a:	1bed      	subs	r5, r5, r7
 800349c:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 80034a0:	fa1f fe87 	uxth.w	lr, r7
 80034a4:	2201      	movs	r2, #1
 80034a6:	fbb5 f0fc 	udiv	r0, r5, ip
 80034aa:	fb0c 5510 	mls	r5, ip, r0, r5
 80034ae:	fb0e f300 	mul.w	r3, lr, r0
 80034b2:	0c21      	lsrs	r1, r4, #16
 80034b4:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 80034b8:	42ab      	cmp	r3, r5
 80034ba:	d907      	bls.n	80034cc <__divdi3+0x120>
 80034bc:	19ed      	adds	r5, r5, r7
 80034be:	f100 31ff 	add.w	r1, r0, #4294967295
 80034c2:	d202      	bcs.n	80034ca <__divdi3+0x11e>
 80034c4:	42ab      	cmp	r3, r5
 80034c6:	f200 80c3 	bhi.w	8003650 <__divdi3+0x2a4>
 80034ca:	4608      	mov	r0, r1
 80034cc:	1aed      	subs	r5, r5, r3
 80034ce:	fbb5 f3fc 	udiv	r3, r5, ip
 80034d2:	fb0c 5513 	mls	r5, ip, r3, r5
 80034d6:	fb0e fe03 	mul.w	lr, lr, r3
 80034da:	b2a4      	uxth	r4, r4
 80034dc:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 80034e0:	45ae      	cmp	lr, r5
 80034e2:	d907      	bls.n	80034f4 <__divdi3+0x148>
 80034e4:	19ed      	adds	r5, r5, r7
 80034e6:	f103 31ff 	add.w	r1, r3, #4294967295
 80034ea:	d202      	bcs.n	80034f2 <__divdi3+0x146>
 80034ec:	45ae      	cmp	lr, r5
 80034ee:	f200 80ad 	bhi.w	800364c <__divdi3+0x2a0>
 80034f2:	460b      	mov	r3, r1
 80034f4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80034f8:	e7ac      	b.n	8003454 <__divdi3+0xa8>
 80034fa:	4252      	negs	r2, r2
 80034fc:	ea6f 0606 	mvn.w	r6, r6
 8003500:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8003504:	e75b      	b.n	80033be <__divdi3+0x12>
 8003506:	4240      	negs	r0, r0
 8003508:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800350c:	f04f 36ff 	mov.w	r6, #4294967295
 8003510:	e752      	b.n	80033b8 <__divdi3+0xc>
 8003512:	fa07 f708 	lsl.w	r7, r7, r8
 8003516:	f1c8 0220 	rsb	r2, r8, #32
 800351a:	fa25 f302 	lsr.w	r3, r5, r2
 800351e:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 8003522:	fbb3 f1fc 	udiv	r1, r3, ip
 8003526:	fa1f fe87 	uxth.w	lr, r7
 800352a:	fb0c 3311 	mls	r3, ip, r1, r3
 800352e:	fa24 f202 	lsr.w	r2, r4, r2
 8003532:	fa05 f508 	lsl.w	r5, r5, r8
 8003536:	fb0e f901 	mul.w	r9, lr, r1
 800353a:	432a      	orrs	r2, r5
 800353c:	0c10      	lsrs	r0, r2, #16
 800353e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8003542:	4599      	cmp	r9, r3
 8003544:	fa04 f408 	lsl.w	r4, r4, r8
 8003548:	d907      	bls.n	800355a <__divdi3+0x1ae>
 800354a:	19db      	adds	r3, r3, r7
 800354c:	f101 30ff 	add.w	r0, r1, #4294967295
 8003550:	d278      	bcs.n	8003644 <__divdi3+0x298>
 8003552:	4599      	cmp	r9, r3
 8003554:	d976      	bls.n	8003644 <__divdi3+0x298>
 8003556:	3902      	subs	r1, #2
 8003558:	443b      	add	r3, r7
 800355a:	ebc9 0303 	rsb	r3, r9, r3
 800355e:	fbb3 f0fc 	udiv	r0, r3, ip
 8003562:	fb0c 3310 	mls	r3, ip, r0, r3
 8003566:	fb0e f500 	mul.w	r5, lr, r0
 800356a:	b292      	uxth	r2, r2
 800356c:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8003570:	429d      	cmp	r5, r3
 8003572:	d907      	bls.n	8003584 <__divdi3+0x1d8>
 8003574:	19db      	adds	r3, r3, r7
 8003576:	f100 32ff 	add.w	r2, r0, #4294967295
 800357a:	d25f      	bcs.n	800363c <__divdi3+0x290>
 800357c:	429d      	cmp	r5, r3
 800357e:	d95d      	bls.n	800363c <__divdi3+0x290>
 8003580:	3802      	subs	r0, #2
 8003582:	443b      	add	r3, r7
 8003584:	1b5d      	subs	r5, r3, r5
 8003586:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
 800358a:	e78c      	b.n	80034a6 <__divdi3+0xfa>
 800358c:	f1c2 0320 	rsb	r3, r2, #32
 8003590:	fa28 f103 	lsr.w	r1, r8, r3
 8003594:	fa0c fc02 	lsl.w	ip, ip, r2
 8003598:	ea41 0c0c 	orr.w	ip, r1, ip
 800359c:	ea4f 401c 	mov.w	r0, ip, lsr #16
 80035a0:	fa2e f103 	lsr.w	r1, lr, r3
 80035a4:	fbb1 f5f0 	udiv	r5, r1, r0
 80035a8:	fa1f f78c 	uxth.w	r7, ip
 80035ac:	fb00 1115 	mls	r1, r0, r5, r1
 80035b0:	fa29 f303 	lsr.w	r3, r9, r3
 80035b4:	fa0e fe02 	lsl.w	lr, lr, r2
 80035b8:	fb07 f905 	mul.w	r9, r7, r5
 80035bc:	ea43 0e0e 	orr.w	lr, r3, lr
 80035c0:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80035c4:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80035c8:	4589      	cmp	r9, r1
 80035ca:	fa08 f802 	lsl.w	r8, r8, r2
 80035ce:	d908      	bls.n	80035e2 <__divdi3+0x236>
 80035d0:	eb11 010c 	adds.w	r1, r1, ip
 80035d4:	f105 33ff 	add.w	r3, r5, #4294967295
 80035d8:	d232      	bcs.n	8003640 <__divdi3+0x294>
 80035da:	4589      	cmp	r9, r1
 80035dc:	d930      	bls.n	8003640 <__divdi3+0x294>
 80035de:	3d02      	subs	r5, #2
 80035e0:	4461      	add	r1, ip
 80035e2:	ebc9 0101 	rsb	r1, r9, r1
 80035e6:	fbb1 f3f0 	udiv	r3, r1, r0
 80035ea:	fb00 1113 	mls	r1, r0, r3, r1
 80035ee:	fb07 f703 	mul.w	r7, r7, r3
 80035f2:	fa1f fe8e 	uxth.w	lr, lr
 80035f6:	ea4e 4e01 	orr.w	lr, lr, r1, lsl #16
 80035fa:	4577      	cmp	r7, lr
 80035fc:	d908      	bls.n	8003610 <__divdi3+0x264>
 80035fe:	eb1e 0e0c 	adds.w	lr, lr, ip
 8003602:	f103 31ff 	add.w	r1, r3, #4294967295
 8003606:	d217      	bcs.n	8003638 <__divdi3+0x28c>
 8003608:	4577      	cmp	r7, lr
 800360a:	d915      	bls.n	8003638 <__divdi3+0x28c>
 800360c:	3b02      	subs	r3, #2
 800360e:	44e6      	add	lr, ip
 8003610:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 8003614:	fba3 8908 	umull	r8, r9, r3, r8
 8003618:	ebc7 0e0e 	rsb	lr, r7, lr
 800361c:	45ce      	cmp	lr, r9
 800361e:	d309      	bcc.n	8003634 <__divdi3+0x288>
 8003620:	d005      	beq.n	800362e <__divdi3+0x282>
 8003622:	2200      	movs	r2, #0
 8003624:	e716      	b.n	8003454 <__divdi3+0xa8>
 8003626:	4610      	mov	r0, r2
 8003628:	e6f7      	b.n	800341a <__divdi3+0x6e>
 800362a:	4613      	mov	r3, r2
 800362c:	e70a      	b.n	8003444 <__divdi3+0x98>
 800362e:	4094      	lsls	r4, r2
 8003630:	4544      	cmp	r4, r8
 8003632:	d2f6      	bcs.n	8003622 <__divdi3+0x276>
 8003634:	3b01      	subs	r3, #1
 8003636:	e7f4      	b.n	8003622 <__divdi3+0x276>
 8003638:	460b      	mov	r3, r1
 800363a:	e7e9      	b.n	8003610 <__divdi3+0x264>
 800363c:	4610      	mov	r0, r2
 800363e:	e7a1      	b.n	8003584 <__divdi3+0x1d8>
 8003640:	461d      	mov	r5, r3
 8003642:	e7ce      	b.n	80035e2 <__divdi3+0x236>
 8003644:	4601      	mov	r1, r0
 8003646:	e788      	b.n	800355a <__divdi3+0x1ae>
 8003648:	4613      	mov	r3, r2
 800364a:	e703      	b.n	8003454 <__divdi3+0xa8>
 800364c:	3b02      	subs	r3, #2
 800364e:	e751      	b.n	80034f4 <__divdi3+0x148>
 8003650:	3802      	subs	r0, #2
 8003652:	443d      	add	r5, r7
 8003654:	e73a      	b.n	80034cc <__divdi3+0x120>
 8003656:	bf00      	nop

08003658 <__udivdi3>:
 8003658:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800365c:	2b00      	cmp	r3, #0
 800365e:	d144      	bne.n	80036ea <__udivdi3+0x92>
 8003660:	428a      	cmp	r2, r1
 8003662:	4615      	mov	r5, r2
 8003664:	4604      	mov	r4, r0
 8003666:	d94f      	bls.n	8003708 <__udivdi3+0xb0>
 8003668:	fab2 f782 	clz	r7, r2
 800366c:	460e      	mov	r6, r1
 800366e:	b14f      	cbz	r7, 8003684 <__udivdi3+0x2c>
 8003670:	f1c7 0320 	rsb	r3, r7, #32
 8003674:	40b9      	lsls	r1, r7
 8003676:	fa20 f603 	lsr.w	r6, r0, r3
 800367a:	fa02 f507 	lsl.w	r5, r2, r7
 800367e:	430e      	orrs	r6, r1
 8003680:	fa00 f407 	lsl.w	r4, r0, r7
 8003684:	0c2f      	lsrs	r7, r5, #16
 8003686:	fbb6 f0f7 	udiv	r0, r6, r7
 800368a:	fa1f fe85 	uxth.w	lr, r5
 800368e:	fb07 6210 	mls	r2, r7, r0, r6
 8003692:	fb0e f100 	mul.w	r1, lr, r0
 8003696:	0c26      	lsrs	r6, r4, #16
 8003698:	ea46 4302 	orr.w	r3, r6, r2, lsl #16
 800369c:	4299      	cmp	r1, r3
 800369e:	d909      	bls.n	80036b4 <__udivdi3+0x5c>
 80036a0:	195b      	adds	r3, r3, r5
 80036a2:	f100 32ff 	add.w	r2, r0, #4294967295
 80036a6:	f080 80ee 	bcs.w	8003886 <__udivdi3+0x22e>
 80036aa:	4299      	cmp	r1, r3
 80036ac:	f240 80eb 	bls.w	8003886 <__udivdi3+0x22e>
 80036b0:	3802      	subs	r0, #2
 80036b2:	442b      	add	r3, r5
 80036b4:	1a59      	subs	r1, r3, r1
 80036b6:	fbb1 f3f7 	udiv	r3, r1, r7
 80036ba:	fb07 1113 	mls	r1, r7, r3, r1
 80036be:	fb0e fe03 	mul.w	lr, lr, r3
 80036c2:	b2a4      	uxth	r4, r4
 80036c4:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 80036c8:	458e      	cmp	lr, r1
 80036ca:	d908      	bls.n	80036de <__udivdi3+0x86>
 80036cc:	1949      	adds	r1, r1, r5
 80036ce:	f103 32ff 	add.w	r2, r3, #4294967295
 80036d2:	f080 80da 	bcs.w	800388a <__udivdi3+0x232>
 80036d6:	458e      	cmp	lr, r1
 80036d8:	f240 80d7 	bls.w	800388a <__udivdi3+0x232>
 80036dc:	3b02      	subs	r3, #2
 80036de:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80036e2:	2600      	movs	r6, #0
 80036e4:	4631      	mov	r1, r6
 80036e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80036ea:	428b      	cmp	r3, r1
 80036ec:	d847      	bhi.n	800377e <__udivdi3+0x126>
 80036ee:	fab3 f683 	clz	r6, r3
 80036f2:	2e00      	cmp	r6, #0
 80036f4:	d148      	bne.n	8003788 <__udivdi3+0x130>
 80036f6:	428b      	cmp	r3, r1
 80036f8:	d302      	bcc.n	8003700 <__udivdi3+0xa8>
 80036fa:	4282      	cmp	r2, r0
 80036fc:	f200 80cf 	bhi.w	800389e <__udivdi3+0x246>
 8003700:	2001      	movs	r0, #1
 8003702:	4631      	mov	r1, r6
 8003704:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003708:	b912      	cbnz	r2, 8003710 <__udivdi3+0xb8>
 800370a:	2501      	movs	r5, #1
 800370c:	fbb5 f5f2 	udiv	r5, r5, r2
 8003710:	fab5 fc85 	clz	ip, r5
 8003714:	f1bc 0f00 	cmp.w	ip, #0
 8003718:	d178      	bne.n	800380c <__udivdi3+0x1b4>
 800371a:	1b49      	subs	r1, r1, r5
 800371c:	0c2f      	lsrs	r7, r5, #16
 800371e:	fa1f fe85 	uxth.w	lr, r5
 8003722:	2601      	movs	r6, #1
 8003724:	fbb1 f0f7 	udiv	r0, r1, r7
 8003728:	fb07 1110 	mls	r1, r7, r0, r1
 800372c:	fb0e f200 	mul.w	r2, lr, r0
 8003730:	0c23      	lsrs	r3, r4, #16
 8003732:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8003736:	428a      	cmp	r2, r1
 8003738:	d907      	bls.n	800374a <__udivdi3+0xf2>
 800373a:	1949      	adds	r1, r1, r5
 800373c:	f100 33ff 	add.w	r3, r0, #4294967295
 8003740:	d202      	bcs.n	8003748 <__udivdi3+0xf0>
 8003742:	428a      	cmp	r2, r1
 8003744:	f200 80bc 	bhi.w	80038c0 <__udivdi3+0x268>
 8003748:	4618      	mov	r0, r3
 800374a:	1a89      	subs	r1, r1, r2
 800374c:	fbb1 f3f7 	udiv	r3, r1, r7
 8003750:	fb07 1113 	mls	r1, r7, r3, r1
 8003754:	fb0e fe03 	mul.w	lr, lr, r3
 8003758:	b2a4      	uxth	r4, r4
 800375a:	ea44 4201 	orr.w	r2, r4, r1, lsl #16
 800375e:	4596      	cmp	lr, r2
 8003760:	d908      	bls.n	8003774 <__udivdi3+0x11c>
 8003762:	1952      	adds	r2, r2, r5
 8003764:	f103 31ff 	add.w	r1, r3, #4294967295
 8003768:	f080 8091 	bcs.w	800388e <__udivdi3+0x236>
 800376c:	4596      	cmp	lr, r2
 800376e:	f240 808e 	bls.w	800388e <__udivdi3+0x236>
 8003772:	3b02      	subs	r3, #2
 8003774:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8003778:	4631      	mov	r1, r6
 800377a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800377e:	2600      	movs	r6, #0
 8003780:	4630      	mov	r0, r6
 8003782:	4631      	mov	r1, r6
 8003784:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003788:	f1c6 0420 	rsb	r4, r6, #32
 800378c:	fa22 f504 	lsr.w	r5, r2, r4
 8003790:	40b3      	lsls	r3, r6
 8003792:	432b      	orrs	r3, r5
 8003794:	fa21 f704 	lsr.w	r7, r1, r4
 8003798:	ea4f 4813 	mov.w	r8, r3, lsr #16
 800379c:	fbb7 fcf8 	udiv	ip, r7, r8
 80037a0:	fa1f f983 	uxth.w	r9, r3
 80037a4:	fb08 771c 	mls	r7, r8, ip, r7
 80037a8:	fa20 fe04 	lsr.w	lr, r0, r4
 80037ac:	fa01 f506 	lsl.w	r5, r1, r6
 80037b0:	fb09 f40c 	mul.w	r4, r9, ip
 80037b4:	ea4e 0505 	orr.w	r5, lr, r5
 80037b8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80037bc:	ea4e 4707 	orr.w	r7, lr, r7, lsl #16
 80037c0:	42bc      	cmp	r4, r7
 80037c2:	fa02 f206 	lsl.w	r2, r2, r6
 80037c6:	d904      	bls.n	80037d2 <__udivdi3+0x17a>
 80037c8:	18ff      	adds	r7, r7, r3
 80037ca:	f10c 31ff 	add.w	r1, ip, #4294967295
 80037ce:	d368      	bcc.n	80038a2 <__udivdi3+0x24a>
 80037d0:	468c      	mov	ip, r1
 80037d2:	1b3f      	subs	r7, r7, r4
 80037d4:	fbb7 f4f8 	udiv	r4, r7, r8
 80037d8:	fb08 7714 	mls	r7, r8, r4, r7
 80037dc:	fb09 f904 	mul.w	r9, r9, r4
 80037e0:	b2ad      	uxth	r5, r5
 80037e2:	ea45 4107 	orr.w	r1, r5, r7, lsl #16
 80037e6:	4589      	cmp	r9, r1
 80037e8:	d904      	bls.n	80037f4 <__udivdi3+0x19c>
 80037ea:	18c9      	adds	r1, r1, r3
 80037ec:	f104 35ff 	add.w	r5, r4, #4294967295
 80037f0:	d35d      	bcc.n	80038ae <__udivdi3+0x256>
 80037f2:	462c      	mov	r4, r5
 80037f4:	ea44 440c 	orr.w	r4, r4, ip, lsl #16
 80037f8:	fba4 2302 	umull	r2, r3, r4, r2
 80037fc:	ebc9 0101 	rsb	r1, r9, r1
 8003800:	4299      	cmp	r1, r3
 8003802:	d349      	bcc.n	8003898 <__udivdi3+0x240>
 8003804:	d045      	beq.n	8003892 <__udivdi3+0x23a>
 8003806:	4620      	mov	r0, r4
 8003808:	2600      	movs	r6, #0
 800380a:	e76b      	b.n	80036e4 <__udivdi3+0x8c>
 800380c:	f1cc 0420 	rsb	r4, ip, #32
 8003810:	fa05 f50c 	lsl.w	r5, r5, ip
 8003814:	fa21 f304 	lsr.w	r3, r1, r4
 8003818:	0c2a      	lsrs	r2, r5, #16
 800381a:	fbb3 f6f2 	udiv	r6, r3, r2
 800381e:	fa1f fe85 	uxth.w	lr, r5
 8003822:	fb02 3816 	mls	r8, r2, r6, r3
 8003826:	fa20 f704 	lsr.w	r7, r0, r4
 800382a:	fa01 f10c 	lsl.w	r1, r1, ip
 800382e:	fb0e f906 	mul.w	r9, lr, r6
 8003832:	430f      	orrs	r7, r1
 8003834:	0c3c      	lsrs	r4, r7, #16
 8003836:	ea44 4308 	orr.w	r3, r4, r8, lsl #16
 800383a:	4599      	cmp	r9, r3
 800383c:	fa00 f40c 	lsl.w	r4, r0, ip
 8003840:	d907      	bls.n	8003852 <__udivdi3+0x1fa>
 8003842:	195b      	adds	r3, r3, r5
 8003844:	f106 31ff 	add.w	r1, r6, #4294967295
 8003848:	d238      	bcs.n	80038bc <__udivdi3+0x264>
 800384a:	4599      	cmp	r9, r3
 800384c:	d936      	bls.n	80038bc <__udivdi3+0x264>
 800384e:	3e02      	subs	r6, #2
 8003850:	442b      	add	r3, r5
 8003852:	ebc9 0303 	rsb	r3, r9, r3
 8003856:	fbb3 f0f2 	udiv	r0, r3, r2
 800385a:	fb02 3310 	mls	r3, r2, r0, r3
 800385e:	fb0e f100 	mul.w	r1, lr, r0
 8003862:	b2bf      	uxth	r7, r7
 8003864:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 8003868:	4299      	cmp	r1, r3
 800386a:	d907      	bls.n	800387c <__udivdi3+0x224>
 800386c:	195b      	adds	r3, r3, r5
 800386e:	f100 37ff 	add.w	r7, r0, #4294967295
 8003872:	d221      	bcs.n	80038b8 <__udivdi3+0x260>
 8003874:	4299      	cmp	r1, r3
 8003876:	d91f      	bls.n	80038b8 <__udivdi3+0x260>
 8003878:	3802      	subs	r0, #2
 800387a:	442b      	add	r3, r5
 800387c:	4617      	mov	r7, r2
 800387e:	1a59      	subs	r1, r3, r1
 8003880:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8003884:	e74e      	b.n	8003724 <__udivdi3+0xcc>
 8003886:	4610      	mov	r0, r2
 8003888:	e714      	b.n	80036b4 <__udivdi3+0x5c>
 800388a:	4613      	mov	r3, r2
 800388c:	e727      	b.n	80036de <__udivdi3+0x86>
 800388e:	460b      	mov	r3, r1
 8003890:	e770      	b.n	8003774 <__udivdi3+0x11c>
 8003892:	40b0      	lsls	r0, r6
 8003894:	4290      	cmp	r0, r2
 8003896:	d2b6      	bcs.n	8003806 <__udivdi3+0x1ae>
 8003898:	1e60      	subs	r0, r4, #1
 800389a:	2600      	movs	r6, #0
 800389c:	e722      	b.n	80036e4 <__udivdi3+0x8c>
 800389e:	4630      	mov	r0, r6
 80038a0:	e720      	b.n	80036e4 <__udivdi3+0x8c>
 80038a2:	42bc      	cmp	r4, r7
 80038a4:	d994      	bls.n	80037d0 <__udivdi3+0x178>
 80038a6:	f1ac 0c02 	sub.w	ip, ip, #2
 80038aa:	441f      	add	r7, r3
 80038ac:	e791      	b.n	80037d2 <__udivdi3+0x17a>
 80038ae:	4589      	cmp	r9, r1
 80038b0:	d99f      	bls.n	80037f2 <__udivdi3+0x19a>
 80038b2:	3c02      	subs	r4, #2
 80038b4:	4419      	add	r1, r3
 80038b6:	e79d      	b.n	80037f4 <__udivdi3+0x19c>
 80038b8:	4638      	mov	r0, r7
 80038ba:	e7df      	b.n	800387c <__udivdi3+0x224>
 80038bc:	460e      	mov	r6, r1
 80038be:	e7c8      	b.n	8003852 <__udivdi3+0x1fa>
 80038c0:	3802      	subs	r0, #2
 80038c2:	4429      	add	r1, r5
 80038c4:	e741      	b.n	800374a <__udivdi3+0xf2>
 80038c6:	bf00      	nop

080038c8 <__aeabi_frsub>:
 80038c8:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80038cc:	e002      	b.n	80038d4 <__addsf3>
 80038ce:	bf00      	nop

080038d0 <__aeabi_fsub>:
 80038d0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080038d4 <__addsf3>:
 80038d4:	0042      	lsls	r2, r0, #1
 80038d6:	bf1f      	itttt	ne
 80038d8:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80038dc:	ea92 0f03 	teqne	r2, r3
 80038e0:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80038e4:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80038e8:	d06a      	beq.n	80039c0 <__addsf3+0xec>
 80038ea:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80038ee:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80038f2:	bfc1      	itttt	gt
 80038f4:	18d2      	addgt	r2, r2, r3
 80038f6:	4041      	eorgt	r1, r0
 80038f8:	4048      	eorgt	r0, r1
 80038fa:	4041      	eorgt	r1, r0
 80038fc:	bfb8      	it	lt
 80038fe:	425b      	neglt	r3, r3
 8003900:	2b19      	cmp	r3, #25
 8003902:	bf88      	it	hi
 8003904:	4770      	bxhi	lr
 8003906:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 800390a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800390e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8003912:	bf18      	it	ne
 8003914:	4240      	negne	r0, r0
 8003916:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800391a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 800391e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8003922:	bf18      	it	ne
 8003924:	4249      	negne	r1, r1
 8003926:	ea92 0f03 	teq	r2, r3
 800392a:	d03f      	beq.n	80039ac <__addsf3+0xd8>
 800392c:	f1a2 0201 	sub.w	r2, r2, #1
 8003930:	fa41 fc03 	asr.w	ip, r1, r3
 8003934:	eb10 000c 	adds.w	r0, r0, ip
 8003938:	f1c3 0320 	rsb	r3, r3, #32
 800393c:	fa01 f103 	lsl.w	r1, r1, r3
 8003940:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8003944:	d502      	bpl.n	800394c <__addsf3+0x78>
 8003946:	4249      	negs	r1, r1
 8003948:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 800394c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8003950:	d313      	bcc.n	800397a <__addsf3+0xa6>
 8003952:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8003956:	d306      	bcc.n	8003966 <__addsf3+0x92>
 8003958:	0840      	lsrs	r0, r0, #1
 800395a:	ea4f 0131 	mov.w	r1, r1, rrx
 800395e:	f102 0201 	add.w	r2, r2, #1
 8003962:	2afe      	cmp	r2, #254	; 0xfe
 8003964:	d251      	bcs.n	8003a0a <__addsf3+0x136>
 8003966:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800396a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800396e:	bf08      	it	eq
 8003970:	f020 0001 	biceq.w	r0, r0, #1
 8003974:	ea40 0003 	orr.w	r0, r0, r3
 8003978:	4770      	bx	lr
 800397a:	0049      	lsls	r1, r1, #1
 800397c:	eb40 0000 	adc.w	r0, r0, r0
 8003980:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8003984:	f1a2 0201 	sub.w	r2, r2, #1
 8003988:	d1ed      	bne.n	8003966 <__addsf3+0x92>
 800398a:	fab0 fc80 	clz	ip, r0
 800398e:	f1ac 0c08 	sub.w	ip, ip, #8
 8003992:	ebb2 020c 	subs.w	r2, r2, ip
 8003996:	fa00 f00c 	lsl.w	r0, r0, ip
 800399a:	bfaa      	itet	ge
 800399c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80039a0:	4252      	neglt	r2, r2
 80039a2:	4318      	orrge	r0, r3
 80039a4:	bfbc      	itt	lt
 80039a6:	40d0      	lsrlt	r0, r2
 80039a8:	4318      	orrlt	r0, r3
 80039aa:	4770      	bx	lr
 80039ac:	f092 0f00 	teq	r2, #0
 80039b0:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80039b4:	bf06      	itte	eq
 80039b6:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80039ba:	3201      	addeq	r2, #1
 80039bc:	3b01      	subne	r3, #1
 80039be:	e7b5      	b.n	800392c <__addsf3+0x58>
 80039c0:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80039c4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80039c8:	bf18      	it	ne
 80039ca:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80039ce:	d021      	beq.n	8003a14 <__addsf3+0x140>
 80039d0:	ea92 0f03 	teq	r2, r3
 80039d4:	d004      	beq.n	80039e0 <__addsf3+0x10c>
 80039d6:	f092 0f00 	teq	r2, #0
 80039da:	bf08      	it	eq
 80039dc:	4608      	moveq	r0, r1
 80039de:	4770      	bx	lr
 80039e0:	ea90 0f01 	teq	r0, r1
 80039e4:	bf1c      	itt	ne
 80039e6:	2000      	movne	r0, #0
 80039e8:	4770      	bxne	lr
 80039ea:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80039ee:	d104      	bne.n	80039fa <__addsf3+0x126>
 80039f0:	0040      	lsls	r0, r0, #1
 80039f2:	bf28      	it	cs
 80039f4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80039f8:	4770      	bx	lr
 80039fa:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80039fe:	bf3c      	itt	cc
 8003a00:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8003a04:	4770      	bxcc	lr
 8003a06:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8003a0a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8003a0e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003a12:	4770      	bx	lr
 8003a14:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8003a18:	bf16      	itet	ne
 8003a1a:	4608      	movne	r0, r1
 8003a1c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8003a20:	4601      	movne	r1, r0
 8003a22:	0242      	lsls	r2, r0, #9
 8003a24:	bf06      	itte	eq
 8003a26:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8003a2a:	ea90 0f01 	teqeq	r0, r1
 8003a2e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8003a32:	4770      	bx	lr

08003a34 <__aeabi_ui2f>:
 8003a34:	f04f 0300 	mov.w	r3, #0
 8003a38:	e004      	b.n	8003a44 <__aeabi_i2f+0x8>
 8003a3a:	bf00      	nop

08003a3c <__aeabi_i2f>:
 8003a3c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8003a40:	bf48      	it	mi
 8003a42:	4240      	negmi	r0, r0
 8003a44:	ea5f 0c00 	movs.w	ip, r0
 8003a48:	bf08      	it	eq
 8003a4a:	4770      	bxeq	lr
 8003a4c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8003a50:	4601      	mov	r1, r0
 8003a52:	f04f 0000 	mov.w	r0, #0
 8003a56:	e01c      	b.n	8003a92 <__aeabi_l2f+0x2a>

08003a58 <__aeabi_ul2f>:
 8003a58:	ea50 0201 	orrs.w	r2, r0, r1
 8003a5c:	bf08      	it	eq
 8003a5e:	4770      	bxeq	lr
 8003a60:	f04f 0300 	mov.w	r3, #0
 8003a64:	e00a      	b.n	8003a7c <__aeabi_l2f+0x14>
 8003a66:	bf00      	nop

08003a68 <__aeabi_l2f>:
 8003a68:	ea50 0201 	orrs.w	r2, r0, r1
 8003a6c:	bf08      	it	eq
 8003a6e:	4770      	bxeq	lr
 8003a70:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8003a74:	d502      	bpl.n	8003a7c <__aeabi_l2f+0x14>
 8003a76:	4240      	negs	r0, r0
 8003a78:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8003a7c:	ea5f 0c01 	movs.w	ip, r1
 8003a80:	bf02      	ittt	eq
 8003a82:	4684      	moveq	ip, r0
 8003a84:	4601      	moveq	r1, r0
 8003a86:	2000      	moveq	r0, #0
 8003a88:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8003a8c:	bf08      	it	eq
 8003a8e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8003a92:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8003a96:	fabc f28c 	clz	r2, ip
 8003a9a:	3a08      	subs	r2, #8
 8003a9c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8003aa0:	db10      	blt.n	8003ac4 <__aeabi_l2f+0x5c>
 8003aa2:	fa01 fc02 	lsl.w	ip, r1, r2
 8003aa6:	4463      	add	r3, ip
 8003aa8:	fa00 fc02 	lsl.w	ip, r0, r2
 8003aac:	f1c2 0220 	rsb	r2, r2, #32
 8003ab0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8003ab4:	fa20 f202 	lsr.w	r2, r0, r2
 8003ab8:	eb43 0002 	adc.w	r0, r3, r2
 8003abc:	bf08      	it	eq
 8003abe:	f020 0001 	biceq.w	r0, r0, #1
 8003ac2:	4770      	bx	lr
 8003ac4:	f102 0220 	add.w	r2, r2, #32
 8003ac8:	fa01 fc02 	lsl.w	ip, r1, r2
 8003acc:	f1c2 0220 	rsb	r2, r2, #32
 8003ad0:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8003ad4:	fa21 f202 	lsr.w	r2, r1, r2
 8003ad8:	eb43 0002 	adc.w	r0, r3, r2
 8003adc:	bf08      	it	eq
 8003ade:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8003ae2:	4770      	bx	lr

08003ae4 <__aeabi_fmul>:
 8003ae4:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8003ae8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8003aec:	bf1e      	ittt	ne
 8003aee:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8003af2:	ea92 0f0c 	teqne	r2, ip
 8003af6:	ea93 0f0c 	teqne	r3, ip
 8003afa:	d06f      	beq.n	8003bdc <__aeabi_fmul+0xf8>
 8003afc:	441a      	add	r2, r3
 8003afe:	ea80 0c01 	eor.w	ip, r0, r1
 8003b02:	0240      	lsls	r0, r0, #9
 8003b04:	bf18      	it	ne
 8003b06:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8003b0a:	d01e      	beq.n	8003b4a <__aeabi_fmul+0x66>
 8003b0c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003b10:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8003b14:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8003b18:	fba0 3101 	umull	r3, r1, r0, r1
 8003b1c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8003b20:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8003b24:	bf3e      	ittt	cc
 8003b26:	0049      	lslcc	r1, r1, #1
 8003b28:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8003b2c:	005b      	lslcc	r3, r3, #1
 8003b2e:	ea40 0001 	orr.w	r0, r0, r1
 8003b32:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8003b36:	2afd      	cmp	r2, #253	; 0xfd
 8003b38:	d81d      	bhi.n	8003b76 <__aeabi_fmul+0x92>
 8003b3a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8003b3e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8003b42:	bf08      	it	eq
 8003b44:	f020 0001 	biceq.w	r0, r0, #1
 8003b48:	4770      	bx	lr
 8003b4a:	f090 0f00 	teq	r0, #0
 8003b4e:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8003b52:	bf08      	it	eq
 8003b54:	0249      	lsleq	r1, r1, #9
 8003b56:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8003b5a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8003b5e:	3a7f      	subs	r2, #127	; 0x7f
 8003b60:	bfc2      	ittt	gt
 8003b62:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8003b66:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8003b6a:	4770      	bxgt	lr
 8003b6c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003b70:	f04f 0300 	mov.w	r3, #0
 8003b74:	3a01      	subs	r2, #1
 8003b76:	dc5d      	bgt.n	8003c34 <__aeabi_fmul+0x150>
 8003b78:	f112 0f19 	cmn.w	r2, #25
 8003b7c:	bfdc      	itt	le
 8003b7e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8003b82:	4770      	bxle	lr
 8003b84:	f1c2 0200 	rsb	r2, r2, #0
 8003b88:	0041      	lsls	r1, r0, #1
 8003b8a:	fa21 f102 	lsr.w	r1, r1, r2
 8003b8e:	f1c2 0220 	rsb	r2, r2, #32
 8003b92:	fa00 fc02 	lsl.w	ip, r0, r2
 8003b96:	ea5f 0031 	movs.w	r0, r1, rrx
 8003b9a:	f140 0000 	adc.w	r0, r0, #0
 8003b9e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8003ba2:	bf08      	it	eq
 8003ba4:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8003ba8:	4770      	bx	lr
 8003baa:	f092 0f00 	teq	r2, #0
 8003bae:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8003bb2:	bf02      	ittt	eq
 8003bb4:	0040      	lsleq	r0, r0, #1
 8003bb6:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8003bba:	3a01      	subeq	r2, #1
 8003bbc:	d0f9      	beq.n	8003bb2 <__aeabi_fmul+0xce>
 8003bbe:	ea40 000c 	orr.w	r0, r0, ip
 8003bc2:	f093 0f00 	teq	r3, #0
 8003bc6:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8003bca:	bf02      	ittt	eq
 8003bcc:	0049      	lsleq	r1, r1, #1
 8003bce:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8003bd2:	3b01      	subeq	r3, #1
 8003bd4:	d0f9      	beq.n	8003bca <__aeabi_fmul+0xe6>
 8003bd6:	ea41 010c 	orr.w	r1, r1, ip
 8003bda:	e78f      	b.n	8003afc <__aeabi_fmul+0x18>
 8003bdc:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8003be0:	ea92 0f0c 	teq	r2, ip
 8003be4:	bf18      	it	ne
 8003be6:	ea93 0f0c 	teqne	r3, ip
 8003bea:	d00a      	beq.n	8003c02 <__aeabi_fmul+0x11e>
 8003bec:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8003bf0:	bf18      	it	ne
 8003bf2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8003bf6:	d1d8      	bne.n	8003baa <__aeabi_fmul+0xc6>
 8003bf8:	ea80 0001 	eor.w	r0, r0, r1
 8003bfc:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8003c00:	4770      	bx	lr
 8003c02:	f090 0f00 	teq	r0, #0
 8003c06:	bf17      	itett	ne
 8003c08:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8003c0c:	4608      	moveq	r0, r1
 8003c0e:	f091 0f00 	teqne	r1, #0
 8003c12:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8003c16:	d014      	beq.n	8003c42 <__aeabi_fmul+0x15e>
 8003c18:	ea92 0f0c 	teq	r2, ip
 8003c1c:	d101      	bne.n	8003c22 <__aeabi_fmul+0x13e>
 8003c1e:	0242      	lsls	r2, r0, #9
 8003c20:	d10f      	bne.n	8003c42 <__aeabi_fmul+0x15e>
 8003c22:	ea93 0f0c 	teq	r3, ip
 8003c26:	d103      	bne.n	8003c30 <__aeabi_fmul+0x14c>
 8003c28:	024b      	lsls	r3, r1, #9
 8003c2a:	bf18      	it	ne
 8003c2c:	4608      	movne	r0, r1
 8003c2e:	d108      	bne.n	8003c42 <__aeabi_fmul+0x15e>
 8003c30:	ea80 0001 	eor.w	r0, r0, r1
 8003c34:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8003c38:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8003c3c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003c40:	4770      	bx	lr
 8003c42:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8003c46:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8003c4a:	4770      	bx	lr

08003c4c <__aeabi_fdiv>:
 8003c4c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8003c50:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8003c54:	bf1e      	ittt	ne
 8003c56:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8003c5a:	ea92 0f0c 	teqne	r2, ip
 8003c5e:	ea93 0f0c 	teqne	r3, ip
 8003c62:	d069      	beq.n	8003d38 <__aeabi_fdiv+0xec>
 8003c64:	eba2 0203 	sub.w	r2, r2, r3
 8003c68:	ea80 0c01 	eor.w	ip, r0, r1
 8003c6c:	0249      	lsls	r1, r1, #9
 8003c6e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8003c72:	d037      	beq.n	8003ce4 <__aeabi_fdiv+0x98>
 8003c74:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8003c78:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8003c7c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8003c80:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8003c84:	428b      	cmp	r3, r1
 8003c86:	bf38      	it	cc
 8003c88:	005b      	lslcc	r3, r3, #1
 8003c8a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8003c8e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8003c92:	428b      	cmp	r3, r1
 8003c94:	bf24      	itt	cs
 8003c96:	1a5b      	subcs	r3, r3, r1
 8003c98:	ea40 000c 	orrcs.w	r0, r0, ip
 8003c9c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8003ca0:	bf24      	itt	cs
 8003ca2:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8003ca6:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8003caa:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8003cae:	bf24      	itt	cs
 8003cb0:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8003cb4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8003cb8:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8003cbc:	bf24      	itt	cs
 8003cbe:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8003cc2:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8003cc6:	011b      	lsls	r3, r3, #4
 8003cc8:	bf18      	it	ne
 8003cca:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8003cce:	d1e0      	bne.n	8003c92 <__aeabi_fdiv+0x46>
 8003cd0:	2afd      	cmp	r2, #253	; 0xfd
 8003cd2:	f63f af50 	bhi.w	8003b76 <__aeabi_fmul+0x92>
 8003cd6:	428b      	cmp	r3, r1
 8003cd8:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8003cdc:	bf08      	it	eq
 8003cde:	f020 0001 	biceq.w	r0, r0, #1
 8003ce2:	4770      	bx	lr
 8003ce4:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8003ce8:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8003cec:	327f      	adds	r2, #127	; 0x7f
 8003cee:	bfc2      	ittt	gt
 8003cf0:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8003cf4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8003cf8:	4770      	bxgt	lr
 8003cfa:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003cfe:	f04f 0300 	mov.w	r3, #0
 8003d02:	3a01      	subs	r2, #1
 8003d04:	e737      	b.n	8003b76 <__aeabi_fmul+0x92>
 8003d06:	f092 0f00 	teq	r2, #0
 8003d0a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8003d0e:	bf02      	ittt	eq
 8003d10:	0040      	lsleq	r0, r0, #1
 8003d12:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8003d16:	3a01      	subeq	r2, #1
 8003d18:	d0f9      	beq.n	8003d0e <__aeabi_fdiv+0xc2>
 8003d1a:	ea40 000c 	orr.w	r0, r0, ip
 8003d1e:	f093 0f00 	teq	r3, #0
 8003d22:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8003d26:	bf02      	ittt	eq
 8003d28:	0049      	lsleq	r1, r1, #1
 8003d2a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8003d2e:	3b01      	subeq	r3, #1
 8003d30:	d0f9      	beq.n	8003d26 <__aeabi_fdiv+0xda>
 8003d32:	ea41 010c 	orr.w	r1, r1, ip
 8003d36:	e795      	b.n	8003c64 <__aeabi_fdiv+0x18>
 8003d38:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8003d3c:	ea92 0f0c 	teq	r2, ip
 8003d40:	d108      	bne.n	8003d54 <__aeabi_fdiv+0x108>
 8003d42:	0242      	lsls	r2, r0, #9
 8003d44:	f47f af7d 	bne.w	8003c42 <__aeabi_fmul+0x15e>
 8003d48:	ea93 0f0c 	teq	r3, ip
 8003d4c:	f47f af70 	bne.w	8003c30 <__aeabi_fmul+0x14c>
 8003d50:	4608      	mov	r0, r1
 8003d52:	e776      	b.n	8003c42 <__aeabi_fmul+0x15e>
 8003d54:	ea93 0f0c 	teq	r3, ip
 8003d58:	d104      	bne.n	8003d64 <__aeabi_fdiv+0x118>
 8003d5a:	024b      	lsls	r3, r1, #9
 8003d5c:	f43f af4c 	beq.w	8003bf8 <__aeabi_fmul+0x114>
 8003d60:	4608      	mov	r0, r1
 8003d62:	e76e      	b.n	8003c42 <__aeabi_fmul+0x15e>
 8003d64:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8003d68:	bf18      	it	ne
 8003d6a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8003d6e:	d1ca      	bne.n	8003d06 <__aeabi_fdiv+0xba>
 8003d70:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8003d74:	f47f af5c 	bne.w	8003c30 <__aeabi_fmul+0x14c>
 8003d78:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8003d7c:	f47f af3c 	bne.w	8003bf8 <__aeabi_fmul+0x114>
 8003d80:	e75f      	b.n	8003c42 <__aeabi_fmul+0x15e>
 8003d82:	bf00      	nop

08003d84 <allocation_start_request_timer.lto_priv.72>:
        uavcan_set_node_id(instance->uavcan_idx, msg->node_id);
        allocation_stop_and_cleanup(instance);
    }
}

static void allocation_start_request_timer(struct allocatee_instance_s* instance) {
 8003d84:	b590      	push	{r4, r7, lr}
 8003d86:	b087      	sub	sp, #28
 8003d88:	af02      	add	r7, sp, #8
 8003d8a:	6078      	str	r0, [r7, #4]
    if (!allocation_running(instance)) {
 8003d8c:	6878      	ldr	r0, [r7, #4]
 8003d8e:	f000 f88d 	bl	8003eac <allocation_running.lto_priv.73>
 8003d92:	4603      	mov	r3, r0
 8003d94:	f083 0301 	eor.w	r3, r3, #1
 8003d98:	b2db      	uxtb	r3, r3
 8003d9a:	2b00      	cmp	r3, #0
 8003d9c:	d003      	beq.n	8003da6 <allocation_start_request_timer.lto_priv.72+0x22>
        allocation_stop_and_cleanup(instance);
 8003d9e:	6878      	ldr	r0, [r7, #4]
 8003da0:	f001 fcf8 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 8003da4:	e02e      	b.n	8003e04 <allocation_start_request_timer.lto_priv.72+0x80>
        return;
    }

    float request_delay_ms = UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS + (getRandomFloat() * (UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_REQUEST_PERIOD_MS-UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS));
 8003da6:	f000 f895 	bl	8003ed4 <getRandomFloat>
 8003daa:	4603      	mov	r3, r0
 8003dac:	4618      	mov	r0, r3
 8003dae:	4917      	ldr	r1, [pc, #92]	; (8003e0c <allocation_start_request_timer.lto_priv.72+0x88>)
 8003db0:	f7ff fe98 	bl	8003ae4 <__aeabi_fmul>
 8003db4:	4603      	mov	r3, r0
 8003db6:	4618      	mov	r0, r3
 8003db8:	4915      	ldr	r1, [pc, #84]	; (8003e10 <allocation_start_request_timer.lto_priv.72+0x8c>)
 8003dba:	f7ff fd8b 	bl	80038d4 <__addsf3>
 8003dbe:	4603      	mov	r3, r0
 8003dc0:	60fb      	str	r3, [r7, #12]

    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 8003dc2:	687b      	ldr	r3, [r7, #4]
 8003dc4:	3308      	adds	r3, #8
 8003dc6:	4813      	ldr	r0, [pc, #76]	; (8003e14 <allocation_start_request_timer.lto_priv.72+0x90>)
 8003dc8:	4619      	mov	r1, r3
<<<<<<< HEAD
 8003dca:	f004 fdfd 	bl	80089c8 <worker_thread_remove_timer_task>
=======
 8003dca:	f004 fe15 	bl	80089f8 <worker_thread_remove_timer_task>
>>>>>>> 752c83b... update binaries
    worker_thread_add_timer_task(&WT, &instance->request_transmit_task, allocation_timer_expired, instance, MS2ST(request_delay_ms), false);
 8003dce:	687b      	ldr	r3, [r7, #4]
 8003dd0:	f103 0408 	add.w	r4, r3, #8
 8003dd4:	68f8      	ldr	r0, [r7, #12]
 8003dd6:	f7ff fa7f 	bl	80032d8 <__aeabi_f2uiz>
 8003dda:	4602      	mov	r2, r0
 8003ddc:	f242 7310 	movw	r3, #10000	; 0x2710
 8003de0:	fb03 f302 	mul.w	r3, r3, r2
 8003de4:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8003de8:	4a0b      	ldr	r2, [pc, #44]	; (8003e18 <allocation_start_request_timer.lto_priv.72+0x94>)
 8003dea:	fba2 2303 	umull	r2, r3, r2, r3
 8003dee:	099b      	lsrs	r3, r3, #6
 8003df0:	b29b      	uxth	r3, r3
 8003df2:	9300      	str	r3, [sp, #0]
 8003df4:	2300      	movs	r3, #0
 8003df6:	9301      	str	r3, [sp, #4]
 8003df8:	4806      	ldr	r0, [pc, #24]	; (8003e14 <allocation_start_request_timer.lto_priv.72+0x90>)
 8003dfa:	4621      	mov	r1, r4
 8003dfc:	4a07      	ldr	r2, [pc, #28]	; (8003e1c <allocation_start_request_timer.lto_priv.72+0x98>)
 8003dfe:	687b      	ldr	r3, [r7, #4]
<<<<<<< HEAD
 8003e00:	f004 fd56 	bl	80088b0 <worker_thread_add_timer_task>
=======
 8003e00:	f004 fd62 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries
}
 8003e04:	3714      	adds	r7, #20
 8003e06:	46bd      	mov	sp, r7
 8003e08:	bd90      	pop	{r4, r7, pc}
 8003e0a:	bf00      	nop
 8003e0c:	43c80000 	.word	0x43c80000
 8003e10:	44160000 	.word	0x44160000
 8003e14:	20000a20 	.word	0x20000a20
 8003e18:	10624dd3 	.word	0x10624dd3
 8003e1c:	080057c1 	.word	0x080057c1

08003e20 <allocation_start_followup_timer.lto_priv.71>:

static void allocation_start_followup_timer(struct allocatee_instance_s* instance) {
 8003e20:	b590      	push	{r4, r7, lr}
 8003e22:	b087      	sub	sp, #28
 8003e24:	af02      	add	r7, sp, #8
 8003e26:	6078      	str	r0, [r7, #4]
    if (!allocation_running(instance)) {
 8003e28:	6878      	ldr	r0, [r7, #4]
 8003e2a:	f000 f83f 	bl	8003eac <allocation_running.lto_priv.73>
 8003e2e:	4603      	mov	r3, r0
 8003e30:	f083 0301 	eor.w	r3, r3, #1
 8003e34:	b2db      	uxtb	r3, r3
 8003e36:	2b00      	cmp	r3, #0
 8003e38:	d003      	beq.n	8003e42 <allocation_start_followup_timer.lto_priv.71+0x22>
        allocation_stop_and_cleanup(instance);
 8003e3a:	6878      	ldr	r0, [r7, #4]
 8003e3c:	f001 fcaa 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 8003e40:	e029      	b.n	8003e96 <allocation_start_followup_timer.lto_priv.71+0x76>
        return;
    }

    float request_delay_ms = UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_FOLLOWUP_DELAY_MS + (getRandomFloat() * (UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_FOLLOWUP_DELAY_MS-UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_FOLLOWUP_DELAY_MS));
 8003e42:	f000 f847 	bl	8003ed4 <getRandomFloat>
 8003e46:	4603      	mov	r3, r0
 8003e48:	4618      	mov	r0, r3
 8003e4a:	4914      	ldr	r1, [pc, #80]	; (8003e9c <allocation_start_followup_timer.lto_priv.71+0x7c>)
 8003e4c:	f7ff fe4a 	bl	8003ae4 <__aeabi_fmul>
 8003e50:	4603      	mov	r3, r0
 8003e52:	60fb      	str	r3, [r7, #12]

    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 8003e54:	687b      	ldr	r3, [r7, #4]
 8003e56:	3308      	adds	r3, #8
 8003e58:	4811      	ldr	r0, [pc, #68]	; (8003ea0 <allocation_start_followup_timer.lto_priv.71+0x80>)
 8003e5a:	4619      	mov	r1, r3
<<<<<<< HEAD
 8003e5c:	f004 fdb4 	bl	80089c8 <worker_thread_remove_timer_task>
=======
 8003e5c:	f004 fdcc 	bl	80089f8 <worker_thread_remove_timer_task>
>>>>>>> 752c83b... update binaries
    worker_thread_add_timer_task(&WT, &instance->request_transmit_task, allocation_timer_expired, instance, MS2ST(request_delay_ms), false);
 8003e60:	687b      	ldr	r3, [r7, #4]
 8003e62:	f103 0408 	add.w	r4, r3, #8
 8003e66:	68f8      	ldr	r0, [r7, #12]
 8003e68:	f7ff fa36 	bl	80032d8 <__aeabi_f2uiz>
 8003e6c:	4602      	mov	r2, r0
 8003e6e:	f242 7310 	movw	r3, #10000	; 0x2710
 8003e72:	fb03 f302 	mul.w	r3, r3, r2
 8003e76:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8003e7a:	4a0a      	ldr	r2, [pc, #40]	; (8003ea4 <allocation_start_followup_timer.lto_priv.71+0x84>)
 8003e7c:	fba2 2303 	umull	r2, r3, r2, r3
 8003e80:	099b      	lsrs	r3, r3, #6
 8003e82:	b29b      	uxth	r3, r3
 8003e84:	9300      	str	r3, [sp, #0]
 8003e86:	2300      	movs	r3, #0
 8003e88:	9301      	str	r3, [sp, #4]
 8003e8a:	4805      	ldr	r0, [pc, #20]	; (8003ea0 <allocation_start_followup_timer.lto_priv.71+0x80>)
 8003e8c:	4621      	mov	r1, r4
 8003e8e:	4a06      	ldr	r2, [pc, #24]	; (8003ea8 <allocation_start_followup_timer.lto_priv.71+0x88>)
 8003e90:	687b      	ldr	r3, [r7, #4]
<<<<<<< HEAD
 8003e92:	f004 fd0d 	bl	80088b0 <worker_thread_add_timer_task>
=======
 8003e92:	f004 fd19 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries
}
 8003e96:	3714      	adds	r7, #20
 8003e98:	46bd      	mov	sp, r7
 8003e9a:	bd90      	pop	{r4, r7, pc}
 8003e9c:	43c80000 	.word	0x43c80000
 8003ea0:	20000a20 	.word	0x20000a20
 8003ea4:	10624dd3 	.word	0x10624dd3
 8003ea8:	080057c1 	.word	0x080057c1

08003eac <allocation_running.lto_priv.73>:

static bool allocation_running(struct allocatee_instance_s* instance) {
 8003eac:	b580      	push	{r7, lr}
 8003eae:	b082      	sub	sp, #8
 8003eb0:	af00      	add	r7, sp, #0
 8003eb2:	6078      	str	r0, [r7, #4]
    return uavcan_get_node_id(instance->uavcan_idx) == 0;
 8003eb4:	687b      	ldr	r3, [r7, #4]
 8003eb6:	781b      	ldrb	r3, [r3, #0]
 8003eb8:	4618      	mov	r0, r3
 8003eba:	f002 fc89 	bl	80067d0 <uavcan_get_node_id>
 8003ebe:	4603      	mov	r3, r0
 8003ec0:	2b00      	cmp	r3, #0
 8003ec2:	bf0c      	ite	eq
 8003ec4:	2301      	moveq	r3, #1
 8003ec6:	2300      	movne	r3, #0
 8003ec8:	b2db      	uxtb	r3, r3
}
 8003eca:	4618      	mov	r0, r3
 8003ecc:	3708      	adds	r7, #8
 8003ece:	46bd      	mov	sp, r7
 8003ed0:	bd80      	pop	{r7, pc}
 8003ed2:	bf00      	nop

08003ed4 <getRandomFloat>:

static float getRandomFloat(void) {
 8003ed4:	b580      	push	{r7, lr}
 8003ed6:	b086      	sub	sp, #24
 8003ed8:	af00      	add	r7, sp, #0
    static uint32_t state;
    if (state == 0) {
 8003eda:	4b1f      	ldr	r3, [pc, #124]	; (8003f58 <getRandomFloat+0x84>)
 8003edc:	681b      	ldr	r3, [r3, #0]
 8003ede:	2b00      	cmp	r3, #0
 8003ee0:	d11a      	bne.n	8003f18 <getRandomFloat+0x44>
        uint8_t unique_id[16];
        board_get_unique_id(unique_id, sizeof(unique_id));
 8003ee2:	1d3b      	adds	r3, r7, #4
 8003ee4:	4618      	mov	r0, r3
 8003ee6:	2110      	movs	r1, #16
 8003ee8:	f000 fa1a 	bl	8004320 <board_get_unique_id>

        const uint32_t* unique_32 = (uint32_t*)&unique_id[0];
 8003eec:	1d3b      	adds	r3, r7, #4
 8003eee:	617b      	str	r3, [r7, #20]

        state = micros() ^ unique_32[0] ^ unique_32[1] ^ unique_32[2] ^ unique_32[3];
<<<<<<< HEAD
 8003ef0:	f003 fece 	bl	8007c90 <micros>
=======
 8003ef0:	f003 ff0c 	bl	8007d0c <micros>
>>>>>>> 752c83b... update binaries
 8003ef4:	4602      	mov	r2, r0
 8003ef6:	697b      	ldr	r3, [r7, #20]
 8003ef8:	681b      	ldr	r3, [r3, #0]
 8003efa:	405a      	eors	r2, r3
 8003efc:	697b      	ldr	r3, [r7, #20]
 8003efe:	3304      	adds	r3, #4
 8003f00:	681b      	ldr	r3, [r3, #0]
 8003f02:	405a      	eors	r2, r3
 8003f04:	697b      	ldr	r3, [r7, #20]
 8003f06:	3308      	adds	r3, #8
 8003f08:	681b      	ldr	r3, [r3, #0]
 8003f0a:	405a      	eors	r2, r3
 8003f0c:	697b      	ldr	r3, [r7, #20]
 8003f0e:	330c      	adds	r3, #12
 8003f10:	681b      	ldr	r3, [r3, #0]
 8003f12:	4053      	eors	r3, r2
 8003f14:	4a10      	ldr	r2, [pc, #64]	; (8003f58 <getRandomFloat+0x84>)
 8003f16:	6013      	str	r3, [r2, #0]
    }

    state = state * 747796405U;
 8003f18:	4b0f      	ldr	r3, [pc, #60]	; (8003f58 <getRandomFloat+0x84>)
 8003f1a:	681b      	ldr	r3, [r3, #0]
 8003f1c:	4a0f      	ldr	r2, [pc, #60]	; (8003f5c <getRandomFloat+0x88>)
 8003f1e:	fb02 f303 	mul.w	r3, r2, r3
 8003f22:	4a0d      	ldr	r2, [pc, #52]	; (8003f58 <getRandomFloat+0x84>)
 8003f24:	6013      	str	r3, [r2, #0]
    return (float)(uint16_t)(((state >> 11u) ^ state) >> ((state >> 30u) + 11u)) / UINT16_MAX;
 8003f26:	4b0c      	ldr	r3, [pc, #48]	; (8003f58 <getRandomFloat+0x84>)
 8003f28:	681b      	ldr	r3, [r3, #0]
 8003f2a:	0ada      	lsrs	r2, r3, #11
 8003f2c:	4b0a      	ldr	r3, [pc, #40]	; (8003f58 <getRandomFloat+0x84>)
 8003f2e:	681b      	ldr	r3, [r3, #0]
 8003f30:	4053      	eors	r3, r2
 8003f32:	4a09      	ldr	r2, [pc, #36]	; (8003f58 <getRandomFloat+0x84>)
 8003f34:	6812      	ldr	r2, [r2, #0]
 8003f36:	0f92      	lsrs	r2, r2, #30
 8003f38:	320b      	adds	r2, #11
 8003f3a:	40d3      	lsrs	r3, r2
 8003f3c:	b29b      	uxth	r3, r3
 8003f3e:	4618      	mov	r0, r3
 8003f40:	f7ff fd78 	bl	8003a34 <__aeabi_ui2f>
 8003f44:	4603      	mov	r3, r0
 8003f46:	4618      	mov	r0, r3
 8003f48:	4905      	ldr	r1, [pc, #20]	; (8003f60 <getRandomFloat+0x8c>)
 8003f4a:	f7ff fe7f 	bl	8003c4c <__aeabi_fdiv>
 8003f4e:	4603      	mov	r3, r0
}
 8003f50:	4618      	mov	r0, r3
 8003f52:	3718      	adds	r7, #24
 8003f54:	46bd      	mov	sp, r7
 8003f56:	bd80      	pop	{r7, pc}
 8003f58:	20001504 	.word	0x20001504
 8003f5c:	2c9277b5 	.word	0x2c9277b5
 8003f60:	477fff00 	.word	0x477fff00

08003f64 <NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
 8003f64:	b480      	push	{r7}
 8003f66:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8003f68:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8003f6c:	4905      	ldr	r1, [pc, #20]	; (8003f84 <NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8003f6e:	4b05      	ldr	r3, [pc, #20]	; (8003f84 <NVIC_SystemReset+0x20>)
 8003f70:	68db      	ldr	r3, [r3, #12]
 8003f72:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8003f76:	4b04      	ldr	r3, [pc, #16]	; (8003f88 <NVIC_SystemReset+0x24>)
 8003f78:	4313      	orrs	r3, r2
 8003f7a:	60cb      	str	r3, [r1, #12]
 8003f7c:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8003f80:	bf00      	nop
 8003f82:	e7fd      	b.n	8003f80 <NVIC_SystemReset+0x1c>
 8003f84:	e000ed00 	.word	0xe000ed00
 8003f88:	05fa0004 	.word	0x05fa0004

08003f8c <LL_MS2ST>:
 * @param[in] msec      number of milliseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_MS2ST(unsigned int msec) {
 8003f8c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8003f90:	b086      	sub	sp, #24
 8003f92:	af00      	add	r7, sp, #0
 8003f94:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)msec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999ULL)
 8003f96:	68f9      	ldr	r1, [r7, #12]
 8003f98:	460c      	mov	r4, r1
 8003f9a:	f04f 0500 	mov.w	r5, #0
 8003f9e:	4620      	mov	r0, r4
 8003fa0:	4629      	mov	r1, r5
 8003fa2:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 8003fa6:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 8003faa:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 8003fae:	4650      	mov	r0, sl
 8003fb0:	4659      	mov	r1, fp
 8003fb2:	014b      	lsls	r3, r1, #5
 8003fb4:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 8003fb8:	0142      	lsls	r2, r0, #5
 8003fba:	1a12      	subs	r2, r2, r0
 8003fbc:	eb63 0301 	sbc.w	r3, r3, r1
 8003fc0:	18a4      	adds	r4, r4, r2
 8003fc2:	eb45 0503 	adc.w	r5, r5, r3
 8003fc6:	4622      	mov	r2, r4
 8003fc8:	462b      	mov	r3, r5
 8003fca:	0099      	lsls	r1, r3, #2
 8003fcc:	6079      	str	r1, [r7, #4]
 8003fce:	6879      	ldr	r1, [r7, #4]
 8003fd0:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 8003fd4:	6079      	str	r1, [r7, #4]
 8003fd6:	0091      	lsls	r1, r2, #2
 8003fd8:	6039      	str	r1, [r7, #0]
 8003fda:	e9d7 0100 	ldrd	r0, r1, [r7]
 8003fde:	1880      	adds	r0, r0, r2
 8003fe0:	eb41 0103 	adc.w	r1, r1, r3
 8003fe4:	4602      	mov	r2, r0
 8003fe6:	460b      	mov	r3, r1
 8003fe8:	ea4f 1903 	mov.w	r9, r3, lsl #4
 8003fec:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 8003ff0:	ea4f 1802 	mov.w	r8, r2, lsl #4
 8003ff4:	4642      	mov	r2, r8
 8003ff6:	464b      	mov	r3, r9
 8003ff8:	4610      	mov	r0, r2
 8003ffa:	4619      	mov	r1, r3
 8003ffc:	f240 32e7 	movw	r2, #999	; 0x3e7
 8004000:	f04f 0300 	mov.w	r3, #0
 8004004:	1812      	adds	r2, r2, r0
 8004006:	eb43 0301 	adc.w	r3, r3, r1
 800400a:	4610      	mov	r0, r2
 800400c:	4619      	mov	r1, r3
 800400e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8004012:	f04f 0300 	mov.w	r3, #0
 8004016:	f7ff f97f 	bl	8003318 <__aeabi_uldivmod>
 800401a:	4602      	mov	r2, r0
 800401c:	460b      	mov	r3, r1
 800401e:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 8004022:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8004026:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 800402a:	f04f 0100 	mov.w	r1, #0
 800402e:	4299      	cmp	r1, r3
 8004030:	bf08      	it	eq
 8004032:	4290      	cmpeq	r0, r2
 8004034:	d202      	bcs.n	800403c <LL_MS2ST+0xb0>
 8004036:	4804      	ldr	r0, [pc, #16]	; (8004048 <LL_MS2ST+0xbc>)
<<<<<<< HEAD
 8004038:	f006 feb4 	bl	800ada4 <chSysHalt>
=======
 8004038:	f006 fef8 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

  return (systime_t)ticks;
 800403c:	8a3b      	ldrh	r3, [r7, #16]
}
 800403e:	4618      	mov	r0, r3
 8004040:	3718      	adds	r7, #24
 8004042:	46bd      	mov	sp, r7
 8004044:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8004048:	0800edb4 	.word	0x0800edb4

0800404c <_local_ctor_25>:

static struct worker_thread_timer_task_s delayed_restart_task;
static struct worker_thread_listener_task_s restart_req_listener_task;
static void restart_req_handler(size_t msg_size, const void* buf, void* ctx);

RUN_AFTER(UAVCAN_INIT) {
 800404c:	b580      	push	{r7, lr}
 800404e:	b084      	sub	sp, #16
 8004050:	af02      	add	r7, sp, #8
    struct pubsub_topic_s* restart_topic = uavcan_get_message_topic(0, &uavcan_protocol_RestartNode_req_descriptor);
 8004052:	2000      	movs	r0, #0
 8004054:	4907      	ldr	r1, [pc, #28]	; (8004074 <_local_ctor_25+0x28>)
 8004056:	f002 fb7b 	bl	8006750 <uavcan_get_message_topic>
 800405a:	6078      	str	r0, [r7, #4]
    worker_thread_add_listener_task(&WT, &restart_req_listener_task, restart_topic, restart_req_handler, NULL);
 800405c:	2300      	movs	r3, #0
 800405e:	9300      	str	r3, [sp, #0]
 8004060:	4805      	ldr	r0, [pc, #20]	; (8004078 <_local_ctor_25+0x2c>)
 8004062:	4906      	ldr	r1, [pc, #24]	; (800407c <_local_ctor_25+0x30>)
 8004064:	687a      	ldr	r2, [r7, #4]
 8004066:	4b06      	ldr	r3, [pc, #24]	; (8004080 <_local_ctor_25+0x34>)
<<<<<<< HEAD
 8004068:	f004 fcd0 	bl	8008a0c <worker_thread_add_listener_task>
=======
 8004068:	f004 fce8 	bl	8008a3c <worker_thread_add_listener_task>
>>>>>>> 752c83b... update binaries
}
 800406c:	3708      	adds	r7, #8
 800406e:	46bd      	mov	sp, r7
 8004070:	bd80      	pop	{r7, pc}
 8004072:	bf00      	nop
 8004074:	0800e810 	.word	0x0800e810
 8004078:	20000a20 	.word	0x20000a20
 800407c:	20001520 	.word	0x20001520
 8004080:	08004099 	.word	0x08004099

08004084 <delayed_restart_func>:

static void delayed_restart_func(struct worker_thread_timer_task_s* task) {
 8004084:	b580      	push	{r7, lr}
 8004086:	b082      	sub	sp, #8
 8004088:	af00      	add	r7, sp, #0
 800408a:	6078      	str	r0, [r7, #4]
    union shared_msg_payload_u msg;
    boot_msg_fill_shared_canbus_info(&msg.canbus_info);
    shared_msg_finalize_and_write(SHARED_MSG_CANBUS_INFO, &msg);
#endif

    NVIC_SystemReset();
 800408c:	f7ff ff6a 	bl	8003f64 <NVIC_SystemReset>
}
 8004090:	3708      	adds	r7, #8
 8004092:	46bd      	mov	sp, r7
 8004094:	bd80      	pop	{r7, pc}
 8004096:	bf00      	nop

08004098 <restart_req_handler>:

static void restart_req_handler(size_t msg_size, const void* buf, void* ctx) {
 8004098:	b580      	push	{r7, lr}
 800409a:	b08a      	sub	sp, #40	; 0x28
 800409c:	af02      	add	r7, sp, #8
 800409e:	60f8      	str	r0, [r7, #12]
 80040a0:	60b9      	str	r1, [r7, #8]
 80040a2:	607a      	str	r2, [r7, #4]
    (void)msg_size;
    (void)ctx;

    const struct uavcan_deserialized_message_s* msg_wrapper = buf;
 80040a4:	68bb      	ldr	r3, [r7, #8]
 80040a6:	61fb      	str	r3, [r7, #28]
    const struct uavcan_protocol_RestartNode_req_s* msg = (const struct uavcan_protocol_RestartNode_req_s*)msg_wrapper->msg;
 80040a8:	69fb      	ldr	r3, [r7, #28]
 80040aa:	3310      	adds	r3, #16
 80040ac:	61bb      	str	r3, [r7, #24]

    struct uavcan_protocol_RestartNode_res_s res;

    res.ok = false;
 80040ae:	2300      	movs	r3, #0
 80040b0:	753b      	strb	r3, [r7, #20]

    if (msg->magic_number == UAVCAN_PROTOCOL_RESTARTNODE_REQ_MAGIC_NUMBER && system_get_restart_allowed()) {
 80040b2:	69bb      	ldr	r3, [r7, #24]
 80040b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80040b8:	a116      	add	r1, pc, #88	; (adr r1, 8004114 <restart_req_handler+0x7c>)
 80040ba:	e9d1 0100 	ldrd	r0, r1, [r1]
 80040be:	428b      	cmp	r3, r1
 80040c0:	bf08      	it	eq
 80040c2:	4282      	cmpeq	r2, r0
 80040c4:	d113      	bne.n	80040ee <restart_req_handler+0x56>
<<<<<<< HEAD
 80040c6:	f003 fed5 	bl	8007e74 <system_get_restart_allowed>
=======
 80040c6:	f003 fefd 	bl	8007ec4 <system_get_restart_allowed>
>>>>>>> 752c83b... update binaries
 80040ca:	4603      	mov	r3, r0
 80040cc:	2b00      	cmp	r3, #0
 80040ce:	d00e      	beq.n	80040ee <restart_req_handler+0x56>
        res.ok = true;
 80040d0:	2301      	movs	r3, #1
 80040d2:	753b      	strb	r3, [r7, #20]
        worker_thread_add_timer_task(&WT, &delayed_restart_task, delayed_restart_func, NULL, LL_MS2ST(UAVCAN_RESTART_DELAY_MS), false);
 80040d4:	200a      	movs	r0, #10
 80040d6:	f7ff ff59 	bl	8003f8c <LL_MS2ST>
 80040da:	4603      	mov	r3, r0
 80040dc:	9300      	str	r3, [sp, #0]
 80040de:	2300      	movs	r3, #0
 80040e0:	9301      	str	r3, [sp, #4]
 80040e2:	4809      	ldr	r0, [pc, #36]	; (8004108 <restart_req_handler+0x70>)
 80040e4:	4909      	ldr	r1, [pc, #36]	; (800410c <restart_req_handler+0x74>)
 80040e6:	4a0a      	ldr	r2, [pc, #40]	; (8004110 <restart_req_handler+0x78>)
 80040e8:	2300      	movs	r3, #0
<<<<<<< HEAD
 80040ea:	f004 fbe1 	bl	80088b0 <worker_thread_add_timer_task>
=======
 80040ea:	f004 fbed 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries
    }

    uavcan_respond(msg_wrapper->uavcan_idx, msg_wrapper, &res);
 80040ee:	69fb      	ldr	r3, [r7, #28]
 80040f0:	781a      	ldrb	r2, [r3, #0]
 80040f2:	f107 0314 	add.w	r3, r7, #20
 80040f6:	4610      	mov	r0, r2
 80040f8:	69f9      	ldr	r1, [r7, #28]
 80040fa:	461a      	mov	r2, r3
 80040fc:	f000 ff68 	bl	8004fd0 <uavcan_respond>
}
 8004100:	3720      	adds	r7, #32
 8004102:	46bd      	mov	sp, r7
 8004104:	bd80      	pop	{r7, pc}
 8004106:	bf00      	nop
 8004108:	20000a20 	.word	0x20000a20
 800410c:	20001508 	.word	0x20001508
 8004110:	08004085 	.word	0x08004085
 8004114:	ce551b1e 	.word	0xce551b1e
 8004118:	000000ac 	.word	0x000000ac

0800411c <uavcan_send_debug_msg>:
#include <string.h>
#include <chprintf.h>
#include <memstreams.h>

void uavcan_send_debug_msg(uint8_t debug_level, char* source, const char *fmt, ...)
{
 800411c:	b40c      	push	{r2, r3}
 800411e:	b580      	push	{r7, lr}
 8004120:	b0a8      	sub	sp, #160	; 0xa0
 8004122:	af00      	add	r7, sp, #0
 8004124:	4603      	mov	r3, r0
 8004126:	6039      	str	r1, [r7, #0]
 8004128:	71fb      	strb	r3, [r7, #7]
    MemoryStream ms;
    BaseSequentialStream *chp;

    /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
    msObjectInit(&ms, (uint8_t *)log_msg.text, sizeof(log_msg.text), 0);
 800412a:	f107 0208 	add.w	r2, r7, #8
 800412e:	f107 0320 	add.w	r3, r7, #32
 8004132:	3322      	adds	r3, #34	; 0x22
 8004134:	4610      	mov	r0, r2
 8004136:	4619      	mov	r1, r3
 8004138:	225a      	movs	r2, #90	; 0x5a
 800413a:	2300      	movs	r3, #0
 800413c:	f000 fc52 	bl	80049e4 <msObjectInit>

    /* Performing the print operation using the common code.*/
    chp = (BaseSequentialStream *)(void *)&ms;
 8004140:	f107 0308 	add.w	r3, r7, #8
 8004144:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    va_start(ap, fmt);
 8004148:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 800414c:	61fb      	str	r3, [r7, #28]
    log_msg.text_len = MIN((size_t)chvprintf(chp, fmt, ap), sizeof(log_msg.text));
 800414e:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8004152:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 8004156:	69fa      	ldr	r2, [r7, #28]
 8004158:	f000 f97c 	bl	8004454 <chvprintf>
 800415c:	4603      	mov	r3, r0
 800415e:	2b59      	cmp	r3, #89	; 0x59
 8004160:	d809      	bhi.n	8004176 <uavcan_send_debug_msg+0x5a>
 8004162:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8004166:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 800416a:	69fa      	ldr	r2, [r7, #28]
 800416c:	f000 f972 	bl	8004454 <chvprintf>
 8004170:	4603      	mov	r3, r0
 8004172:	b2db      	uxtb	r3, r3
 8004174:	e000      	b.n	8004178 <uavcan_send_debug_msg+0x5c>
 8004176:	235a      	movs	r3, #90	; 0x5a
 8004178:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
    va_end(ap);

    log_msg.source_len = strnlen(source, sizeof(log_msg.source));
 800417c:	6838      	ldr	r0, [r7, #0]
 800417e:	211f      	movs	r1, #31
<<<<<<< HEAD
 8004180:	f00a fa2a 	bl	800e5d8 <strnlen>
=======
 8004180:	f00a fa6e 	bl	800e660 <strnlen>
>>>>>>> 752c83b... update binaries
 8004184:	4603      	mov	r3, r0
 8004186:	b2db      	uxtb	r3, r3
 8004188:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
    memcpy(log_msg.source, source, log_msg.source_len);
 800418c:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8004190:	461a      	mov	r2, r3
 8004192:	f107 0320 	add.w	r3, r7, #32
 8004196:	3302      	adds	r3, #2
 8004198:	4618      	mov	r0, r3
 800419a:	6839      	ldr	r1, [r7, #0]
<<<<<<< HEAD
 800419c:	f00a f9ee 	bl	800e57c <memcpy>
=======
 800419c:	f00a fa32 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries

    log_msg.level.value = debug_level;
 80041a0:	79fb      	ldrb	r3, [r7, #7]
 80041a2:	f887 3020 	strb.w	r3, [r7, #32]

    uavcan_broadcast(0, &uavcan_protocol_debug_LogMessage_descriptor, CANARD_TRANSFER_PRIORITY_LOWEST, &log_msg);
 80041a6:	f107 0320 	add.w	r3, r7, #32
 80041aa:	2000      	movs	r0, #0
 80041ac:	4904      	ldr	r1, [pc, #16]	; (80041c0 <uavcan_send_debug_msg+0xa4>)
 80041ae:	221f      	movs	r2, #31
 80041b0:	f000 feca 	bl	8004f48 <uavcan_broadcast>
}
 80041b4:	37a0      	adds	r7, #160	; 0xa0
 80041b6:	46bd      	mov	sp, r7
 80041b8:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80041bc:	b002      	add	sp, #8
 80041be:	4770      	bx	lr
 80041c0:	0800e850 	.word	0x0800e850

080041c4 <_local_ctor_31>:
WORKER_THREAD_DECLARE_EXTERN(WT)

static struct worker_thread_timer_task_s stack_print_task;
static void stack_print_task_func(struct worker_thread_timer_task_s* task);

RUN_AFTER(WORKER_THREADS_INIT) {
 80041c4:	b580      	push	{r7, lr}
 80041c6:	b082      	sub	sp, #8
 80041c8:	af02      	add	r7, sp, #8
    worker_thread_add_timer_task(&WT, &stack_print_task, stack_print_task_func, NULL, S2ST(5), true);
 80041ca:	f24c 3350 	movw	r3, #50000	; 0xc350
 80041ce:	9300      	str	r3, [sp, #0]
 80041d0:	2301      	movs	r3, #1
 80041d2:	9301      	str	r3, [sp, #4]
 80041d4:	4803      	ldr	r0, [pc, #12]	; (80041e4 <_local_ctor_31+0x20>)
 80041d6:	4904      	ldr	r1, [pc, #16]	; (80041e8 <_local_ctor_31+0x24>)
 80041d8:	4a04      	ldr	r2, [pc, #16]	; (80041ec <_local_ctor_31+0x28>)
 80041da:	2300      	movs	r3, #0
<<<<<<< HEAD
 80041dc:	f004 fb68 	bl	80088b0 <worker_thread_add_timer_task>
=======
 80041dc:	f004 fb74 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries
}
 80041e0:	46bd      	mov	sp, r7
 80041e2:	bd80      	pop	{r7, pc}
 80041e4:	20000a20 	.word	0x20000a20
 80041e8:	20001554 	.word	0x20001554
 80041ec:	080042a9 	.word	0x080042a9

080041f0 <_print_thread_free_stack>:

extern uint8_t __process_stack_base__;
extern uint8_t __main_stack_base__;

static void _print_thread_free_stack(const char* name, void* stack_base) {
 80041f0:	b580      	push	{r7, lr}
 80041f2:	b086      	sub	sp, #24
 80041f4:	af02      	add	r7, sp, #8
 80041f6:	6078      	str	r0, [r7, #4]
 80041f8:	6039      	str	r1, [r7, #0]

    uint8_t* startp = (uint8_t*)stack_base;
 80041fa:	683b      	ldr	r3, [r7, #0]
 80041fc:	60bb      	str	r3, [r7, #8]

    size_t n = 0;
 80041fe:	2300      	movs	r3, #0
 8004200:	60fb      	str	r3, [r7, #12]
    while (true) {
        if (*(startp+n) != CH_DBG_STACK_FILL_VALUE) {
 8004202:	68ba      	ldr	r2, [r7, #8]
 8004204:	68fb      	ldr	r3, [r7, #12]
 8004206:	4413      	add	r3, r2
 8004208:	781b      	ldrb	r3, [r3, #0]
 800420a:	2b55      	cmp	r3, #85	; 0x55
 800420c:	d103      	bne.n	8004216 <_print_thread_free_stack+0x26>
            break;
        }
        n++;
 800420e:	68fb      	ldr	r3, [r7, #12]
 8004210:	3301      	adds	r3, #1
 8004212:	60fb      	str	r3, [r7, #12]
 8004214:	e7f5      	b.n	8004202 <_print_thread_free_stack+0x12>
    }
    uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "%s : %u free", name, n);
 8004216:	68fb      	ldr	r3, [r7, #12]
 8004218:	9300      	str	r3, [sp, #0]
 800421a:	2001      	movs	r0, #1
 800421c:	4903      	ldr	r1, [pc, #12]	; (800422c <_print_thread_free_stack+0x3c>)
 800421e:	4a04      	ldr	r2, [pc, #16]	; (8004230 <_print_thread_free_stack+0x40>)
 8004220:	687b      	ldr	r3, [r7, #4]
 8004222:	f7ff ff7b 	bl	800411c <uavcan_send_debug_msg>
}
 8004226:	3710      	adds	r7, #16
 8004228:	46bd      	mov	sp, r7
 800422a:	bd80      	pop	{r7, pc}
<<<<<<< HEAD
 800422c:	0800e5f8 	.word	0x0800e5f8
 8004230:	0800e5fc 	.word	0x0800e5fc
=======
 800422c:	0800e680 	.word	0x0800e680
 8004230:	0800e684 	.word	0x0800e684
>>>>>>> 752c83b... update binaries

08004234 <print_thread_free_stack>:

static void print_thread_free_stack(thread_t* thread) {
 8004234:	b580      	push	{r7, lr}
 8004236:	b082      	sub	sp, #8
 8004238:	af00      	add	r7, sp, #0
 800423a:	6078      	str	r0, [r7, #4]
    if (!thread->wabase) {
 800423c:	687b      	ldr	r3, [r7, #4]
 800423e:	69db      	ldr	r3, [r3, #28]
 8004240:	2b00      	cmp	r3, #0
 8004242:	d106      	bne.n	8004252 <print_thread_free_stack+0x1e>
        _print_thread_free_stack(thread->name, &__process_stack_base__);
 8004244:	687b      	ldr	r3, [r7, #4]
 8004246:	699b      	ldr	r3, [r3, #24]
 8004248:	4618      	mov	r0, r3
 800424a:	490f      	ldr	r1, [pc, #60]	; (8004288 <print_thread_free_stack+0x54>)
 800424c:	f7ff ffd0 	bl	80041f0 <_print_thread_free_stack>
 8004250:	e016      	b.n	8004280 <print_thread_free_stack+0x4c>
    } else if(thread->wabase == ch_idle_thread_wa) {
 8004252:	687b      	ldr	r3, [r7, #4]
 8004254:	69db      	ldr	r3, [r3, #28]
 8004256:	4a0d      	ldr	r2, [pc, #52]	; (800428c <print_thread_free_stack+0x58>)
 8004258:	4293      	cmp	r3, r2
 800425a:	d108      	bne.n	800426e <print_thread_free_stack+0x3a>
        _print_thread_free_stack(thread->name, thread->wabase);
 800425c:	687b      	ldr	r3, [r7, #4]
 800425e:	699a      	ldr	r2, [r3, #24]
 8004260:	687b      	ldr	r3, [r7, #4]
 8004262:	69db      	ldr	r3, [r3, #28]
 8004264:	4610      	mov	r0, r2
 8004266:	4619      	mov	r1, r3
 8004268:	f7ff ffc2 	bl	80041f0 <_print_thread_free_stack>
 800426c:	e008      	b.n	8004280 <print_thread_free_stack+0x4c>
    } else {
        _print_thread_free_stack(thread->name, (uint8_t*)thread->wabase + sizeof(thread_t));
 800426e:	687b      	ldr	r3, [r7, #4]
 8004270:	699a      	ldr	r2, [r3, #24]
 8004272:	687b      	ldr	r3, [r7, #4]
 8004274:	69db      	ldr	r3, [r3, #28]
 8004276:	3338      	adds	r3, #56	; 0x38
 8004278:	4610      	mov	r0, r2
 800427a:	4619      	mov	r1, r3
 800427c:	f7ff ffb8 	bl	80041f0 <_print_thread_free_stack>
    }
}
 8004280:	3708      	adds	r7, #8
 8004282:	46bd      	mov	sp, r7
 8004284:	bd80      	pop	{r7, pc}
 8004286:	bf00      	nop
 8004288:	20000500 	.word	0x20000500
 800428c:	20001268 	.word	0x20001268

08004290 <print_exception_free_stack>:

static void print_exception_free_stack(void) {
 8004290:	b580      	push	{r7, lr}
 8004292:	af00      	add	r7, sp, #0
    _print_thread_free_stack("exceptions", &__main_stack_base__);
 8004294:	4802      	ldr	r0, [pc, #8]	; (80042a0 <print_exception_free_stack+0x10>)
 8004296:	4903      	ldr	r1, [pc, #12]	; (80042a4 <print_exception_free_stack+0x14>)
 8004298:	f7ff ffaa 	bl	80041f0 <_print_thread_free_stack>
}
 800429c:	bd80      	pop	{r7, pc}
 800429e:	bf00      	nop
<<<<<<< HEAD
 80042a0:	0800e60c 	.word	0x0800e60c
=======
 80042a0:	0800e694 	.word	0x0800e694
>>>>>>> 752c83b... update binaries
 80042a4:	20000000 	.word	0x20000000

080042a8 <stack_print_task_func>:

static void stack_print_task_func(struct worker_thread_timer_task_s* task) {
 80042a8:	b580      	push	{r7, lr}
 80042aa:	b084      	sub	sp, #16
 80042ac:	af00      	add	r7, sp, #0
 80042ae:	6078      	str	r0, [r7, #4]
    (void)task;

    thread_t* thread = chRegFirstThread();
<<<<<<< HEAD
 80042b0:	f006 f960 	bl	800a574 <chRegFirstThread>
=======
 80042b0:	f006 f9a4 	bl	800a5fc <chRegFirstThread>
>>>>>>> 752c83b... update binaries
 80042b4:	60f8      	str	r0, [r7, #12]
 80042b6:	e006      	b.n	80042c6 <stack_print_task_func+0x1e>
    while(thread) {
        print_thread_free_stack(thread);
 80042b8:	68f8      	ldr	r0, [r7, #12]
 80042ba:	f7ff ffbb 	bl	8004234 <print_thread_free_stack>
        thread = chRegNextThread(thread);
 80042be:	68f8      	ldr	r0, [r7, #12]
<<<<<<< HEAD
 80042c0:	f006 f972 	bl	800a5a8 <chRegNextThread>
=======
 80042c0:	f006 f9b6 	bl	800a630 <chRegNextThread>
>>>>>>> 752c83b... update binaries
 80042c4:	60f8      	str	r0, [r7, #12]

static void stack_print_task_func(struct worker_thread_timer_task_s* task) {
    (void)task;

    thread_t* thread = chRegFirstThread();
    while(thread) {
 80042c6:	68fb      	ldr	r3, [r7, #12]
 80042c8:	2b00      	cmp	r3, #0
 80042ca:	d1f5      	bne.n	80042b8 <stack_print_task_func+0x10>
        print_thread_free_stack(thread);
        thread = chRegNextThread(thread);
    }
    print_exception_free_stack();
 80042cc:	f7ff ffe0 	bl	8004290 <print_exception_free_stack>
}
 80042d0:	3710      	adds	r7, #16
 80042d2:	46bd      	mov	sp, r7
 80042d4:	bd80      	pop	{r7, pc}
 80042d6:	bf00      	nop

080042d8 <_local_ctor_14>:
#error Please define REQUIRED_RAM_MARGIN_AFTER_INIT (bytes) in framework_conf.h.
#endif

uint8_t _module_freemem_init_phase = 1;

RUN_AFTER(INIT_END) {
 80042d8:	b580      	push	{r7, lr}
 80042da:	af00      	add	r7, sp, #0
#if REQUIRED_RAM_MARGIN_AFTER_INIT != 0
    if (chCoreGetStatusX() < REQUIRED_RAM_MARGIN_AFTER_INIT) {
<<<<<<< HEAD
 80042dc:	f005 fc00 	bl	8009ae0 <chCoreGetStatusX>
=======
 80042dc:	f005 fc44 	bl	8009b68 <chCoreGetStatusX>
>>>>>>> 752c83b... update binaries
 80042e0:	4603      	mov	r3, r0
 80042e2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80042e6:	d202      	bcs.n	80042ee <_local_ctor_14+0x16>
        chSysHalt(NULL);
 80042e8:	2000      	movs	r0, #0
<<<<<<< HEAD
 80042ea:	f006 fd5b 	bl	800ada4 <chSysHalt>
=======
 80042ea:	f006 fd9f 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
    }
#endif

#ifdef MODULE_UAVCAN_DEBUG_ENABLED
    uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "freemem %u", chCoreGetStatusX());
<<<<<<< HEAD
 80042ee:	f005 fbf7 	bl	8009ae0 <chCoreGetStatusX>
=======
 80042ee:	f005 fc3b 	bl	8009b68 <chCoreGetStatusX>
>>>>>>> 752c83b... update binaries
 80042f2:	4603      	mov	r3, r0
 80042f4:	2001      	movs	r0, #1
 80042f6:	4904      	ldr	r1, [pc, #16]	; (8004308 <_local_ctor_14+0x30>)
 80042f8:	4a04      	ldr	r2, [pc, #16]	; (800430c <_local_ctor_14+0x34>)
 80042fa:	f7ff ff0f 	bl	800411c <uavcan_send_debug_msg>
#endif

    _module_freemem_init_phase = 0;
 80042fe:	4b04      	ldr	r3, [pc, #16]	; (8004310 <_local_ctor_14+0x38>)
 8004300:	2200      	movs	r2, #0
 8004302:	701a      	strb	r2, [r3, #0]
}
 8004304:	bd80      	pop	{r7, pc}
 8004306:	bf00      	nop
<<<<<<< HEAD
 8004308:	0800e5f8 	.word	0x0800e5f8
 800430c:	0800e618 	.word	0x0800e618
=======
 8004308:	0800e680 	.word	0x0800e680
 800430c:	0800e6a0 	.word	0x0800e6a0
>>>>>>> 752c83b... update binaries
 8004310:	20000a18 	.word	0x20000a18

08004314 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8004314:	b580      	push	{r7, lr}
 8004316:	af00      	add	r7, sp, #0
    stm32_clock_init();
<<<<<<< HEAD
 8004318:	f004 ff4e 	bl	80091b8 <stm32_clock_init>
=======
 8004318:	f004 ff90 	bl	800923c <stm32_clock_init>
>>>>>>> 752c83b... update binaries
}
 800431c:	bd80      	pop	{r7, pc}
 800431e:	bf00      	nop

08004320 <board_get_unique_id>:

void board_get_unique_id(uint8_t* buf, uint8_t len) {
 8004320:	b580      	push	{r7, lr}
 8004322:	b086      	sub	sp, #24
 8004324:	af00      	add	r7, sp, #0
 8004326:	6078      	str	r0, [r7, #4]
 8004328:	460b      	mov	r3, r1
 800432a:	70fb      	strb	r3, [r7, #3]
    uint32_t unique_id_uint32[3];
    unique_id_uint32[0] = ((uint32_t*)0x1ffff7e8)[2];
 800432c:	4b12      	ldr	r3, [pc, #72]	; (8004378 <board_get_unique_id+0x58>)
 800432e:	681b      	ldr	r3, [r3, #0]
 8004330:	60fb      	str	r3, [r7, #12]
    unique_id_uint32[1] = ((uint32_t*)0x1ffff7e8)[1];
 8004332:	4b12      	ldr	r3, [pc, #72]	; (800437c <board_get_unique_id+0x5c>)
 8004334:	681b      	ldr	r3, [r3, #0]
 8004336:	613b      	str	r3, [r7, #16]
    unique_id_uint32[2] = ((uint32_t*)0x1ffff7e8)[0];
 8004338:	4b11      	ldr	r3, [pc, #68]	; (8004380 <board_get_unique_id+0x60>)
 800433a:	681b      	ldr	r3, [r3, #0]
 800433c:	617b      	str	r3, [r7, #20]

    if (len>12) {
 800433e:	78fb      	ldrb	r3, [r7, #3]
 8004340:	2b0c      	cmp	r3, #12
 8004342:	d90d      	bls.n	8004360 <board_get_unique_id+0x40>
        memset(buf, 0, len);
 8004344:	78fb      	ldrb	r3, [r7, #3]
 8004346:	6878      	ldr	r0, [r7, #4]
 8004348:	2100      	movs	r1, #0
 800434a:	461a      	mov	r2, r3
<<<<<<< HEAD
 800434c:	f00a f93c 	bl	800e5c8 <memset>
=======
 800434c:	f00a f980 	bl	800e650 <memset>
>>>>>>> 752c83b... update binaries
        memcpy(buf, unique_id_uint32, 12);
 8004350:	f107 030c 	add.w	r3, r7, #12
 8004354:	6878      	ldr	r0, [r7, #4]
 8004356:	4619      	mov	r1, r3
 8004358:	220c      	movs	r2, #12
<<<<<<< HEAD
 800435a:	f00a f90f 	bl	800e57c <memcpy>
=======
 800435a:	f00a f953 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries
 800435e:	e007      	b.n	8004370 <board_get_unique_id+0x50>
    } else {
        memcpy(buf, unique_id_uint32, len);
 8004360:	78fb      	ldrb	r3, [r7, #3]
 8004362:	f107 020c 	add.w	r2, r7, #12
 8004366:	6878      	ldr	r0, [r7, #4]
 8004368:	4611      	mov	r1, r2
 800436a:	461a      	mov	r2, r3
<<<<<<< HEAD
 800436c:	f00a f906 	bl	800e57c <memcpy>
=======
 800436c:	f00a f94a 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries
    }
}
 8004370:	3718      	adds	r7, #24
 8004372:	46bd      	mov	sp, r7
 8004374:	bd80      	pop	{r7, pc}
 8004376:	bf00      	nop
 8004378:	1ffff7f0 	.word	0x1ffff7f0
 800437c:	1ffff7ec 	.word	0x1ffff7ec
 8004380:	1ffff7e8 	.word	0x1ffff7e8

08004384 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8004384:	b480      	push	{r7}
 8004386:	b089      	sub	sp, #36	; 0x24
 8004388:	af00      	add	r7, sp, #0
 800438a:	60f8      	str	r0, [r7, #12]
 800438c:	60b9      	str	r1, [r7, #8]
 800438e:	607a      	str	r2, [r7, #4]
 8004390:	603b      	str	r3, [r7, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 8004392:	68bb      	ldr	r3, [r7, #8]
 8004394:	617b      	str	r3, [r7, #20]
  if (divisor == 0) {
 8004396:	683b      	ldr	r3, [r7, #0]
 8004398:	2b00      	cmp	r3, #0
 800439a:	d102      	bne.n	80043a2 <long_to_string_with_divisor+0x1e>
    ll = num;
 800439c:	68bb      	ldr	r3, [r7, #8]
 800439e:	613b      	str	r3, [r7, #16]
 80043a0:	e001      	b.n	80043a6 <long_to_string_with_divisor+0x22>
  } else {
    ll = divisor;
 80043a2:	683b      	ldr	r3, [r7, #0]
 80043a4:	613b      	str	r3, [r7, #16]
  }

  q = p + MAX_FILLER;
 80043a6:	68fb      	ldr	r3, [r7, #12]
 80043a8:	330b      	adds	r3, #11
 80043aa:	61bb      	str	r3, [r7, #24]
  do {
    i = (int)(l % radix);
 80043ac:	697b      	ldr	r3, [r7, #20]
 80043ae:	687a      	ldr	r2, [r7, #4]
 80043b0:	fbb3 f2f2 	udiv	r2, r3, r2
 80043b4:	6879      	ldr	r1, [r7, #4]
 80043b6:	fb01 f202 	mul.w	r2, r1, r2
 80043ba:	1a9b      	subs	r3, r3, r2
 80043bc:	61fb      	str	r3, [r7, #28]
    i += '0';
 80043be:	69fb      	ldr	r3, [r7, #28]
 80043c0:	3330      	adds	r3, #48	; 0x30
 80043c2:	61fb      	str	r3, [r7, #28]
    if (i > '9')
 80043c4:	69fb      	ldr	r3, [r7, #28]
 80043c6:	2b39      	cmp	r3, #57	; 0x39
 80043c8:	dd02      	ble.n	80043d0 <long_to_string_with_divisor+0x4c>
      i += 'A' - '0' - 10;
 80043ca:	69fb      	ldr	r3, [r7, #28]
 80043cc:	3307      	adds	r3, #7
 80043ce:	61fb      	str	r3, [r7, #28]
    *--q = i;
 80043d0:	69bb      	ldr	r3, [r7, #24]
 80043d2:	3b01      	subs	r3, #1
 80043d4:	61bb      	str	r3, [r7, #24]
 80043d6:	69fb      	ldr	r3, [r7, #28]
 80043d8:	b2da      	uxtb	r2, r3
 80043da:	69bb      	ldr	r3, [r7, #24]
 80043dc:	701a      	strb	r2, [r3, #0]
    l /= radix;
 80043de:	697a      	ldr	r2, [r7, #20]
 80043e0:	687b      	ldr	r3, [r7, #4]
 80043e2:	fbb2 f3f3 	udiv	r3, r2, r3
 80043e6:	617b      	str	r3, [r7, #20]
  } while ((ll /= radix) != 0);
 80043e8:	693a      	ldr	r2, [r7, #16]
 80043ea:	687b      	ldr	r3, [r7, #4]
 80043ec:	fbb2 f3f3 	udiv	r3, r2, r3
 80043f0:	613b      	str	r3, [r7, #16]
 80043f2:	693b      	ldr	r3, [r7, #16]
 80043f4:	2b00      	cmp	r3, #0
 80043f6:	d1d9      	bne.n	80043ac <long_to_string_with_divisor+0x28>

  i = (int)(p + MAX_FILLER - q);
 80043f8:	68fb      	ldr	r3, [r7, #12]
 80043fa:	330b      	adds	r3, #11
 80043fc:	461a      	mov	r2, r3
 80043fe:	69bb      	ldr	r3, [r7, #24]
 8004400:	1ad3      	subs	r3, r2, r3
 8004402:	61fb      	str	r3, [r7, #28]
  do
    *p++ = *q++;
 8004404:	68fb      	ldr	r3, [r7, #12]
 8004406:	1c5a      	adds	r2, r3, #1
 8004408:	60fa      	str	r2, [r7, #12]
 800440a:	69ba      	ldr	r2, [r7, #24]
 800440c:	1c51      	adds	r1, r2, #1
 800440e:	61b9      	str	r1, [r7, #24]
 8004410:	7812      	ldrb	r2, [r2, #0]
 8004412:	701a      	strb	r2, [r3, #0]
  while (--i);
 8004414:	69fb      	ldr	r3, [r7, #28]
 8004416:	3b01      	subs	r3, #1
 8004418:	61fb      	str	r3, [r7, #28]
 800441a:	69fb      	ldr	r3, [r7, #28]
 800441c:	2b00      	cmp	r3, #0
 800441e:	d1f1      	bne.n	8004404 <long_to_string_with_divisor+0x80>

  return p;
 8004420:	68fb      	ldr	r3, [r7, #12]
}
 8004422:	4618      	mov	r0, r3
 8004424:	3724      	adds	r7, #36	; 0x24
 8004426:	46bd      	mov	sp, r7
 8004428:	f85d 7b04 	ldr.w	r7, [sp], #4
 800442c:	4770      	bx	lr
 800442e:	bf00      	nop

08004430 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8004430:	b580      	push	{r7, lr}
 8004432:	b084      	sub	sp, #16
 8004434:	af00      	add	r7, sp, #0
 8004436:	60f8      	str	r0, [r7, #12]
 8004438:	60b9      	str	r1, [r7, #8]
 800443a:	607a      	str	r2, [r7, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 800443c:	68f8      	ldr	r0, [r7, #12]
 800443e:	68b9      	ldr	r1, [r7, #8]
 8004440:	687a      	ldr	r2, [r7, #4]
 8004442:	2300      	movs	r3, #0
 8004444:	f7ff ff9e 	bl	8004384 <long_to_string_with_divisor>
 8004448:	4603      	mov	r3, r0
}
 800444a:	4618      	mov	r0, r3
 800444c:	3710      	adds	r7, #16
 800444e:	46bd      	mov	sp, r7
 8004450:	bd80      	pop	{r7, pc}
 8004452:	bf00      	nop

08004454 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8004454:	b580      	push	{r7, lr}
 8004456:	b090      	sub	sp, #64	; 0x40
 8004458:	af00      	add	r7, sp, #0
 800445a:	60f8      	str	r0, [r7, #12]
 800445c:	60b9      	str	r1, [r7, #8]
 800445e:	607a      	str	r2, [r7, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8004460:	2300      	movs	r3, #0
 8004462:	627b      	str	r3, [r7, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8004464:	68bb      	ldr	r3, [r7, #8]
 8004466:	1c5a      	adds	r2, r3, #1
 8004468:	60ba      	str	r2, [r7, #8]
 800446a:	781b      	ldrb	r3, [r3, #0]
 800446c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    if (c == 0)
 8004470:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004474:	2b00      	cmp	r3, #0
 8004476:	d101      	bne.n	800447c <chvprintf+0x28>
      return n;
 8004478:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800447a:	e20e      	b.n	800489a <chvprintf+0x446>
    if (c != '%') {
 800447c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004480:	2b25      	cmp	r3, #37	; 0x25
 8004482:	d00b      	beq.n	800449c <chvprintf+0x48>
      streamPut(chp, (uint8_t)c);
 8004484:	68fb      	ldr	r3, [r7, #12]
 8004486:	681b      	ldr	r3, [r3, #0]
 8004488:	689b      	ldr	r3, [r3, #8]
 800448a:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800448e:	68f8      	ldr	r0, [r7, #12]
 8004490:	4611      	mov	r1, r2
 8004492:	4798      	blx	r3
      n++;
 8004494:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004496:	3301      	adds	r3, #1
 8004498:	627b      	str	r3, [r7, #36]	; 0x24
 800449a:	e7e3      	b.n	8004464 <chvprintf+0x10>
      continue;
    }
    p = tmpbuf;
 800449c:	f107 0310 	add.w	r3, r7, #16
 80044a0:	63fb      	str	r3, [r7, #60]	; 0x3c
    s = tmpbuf;
 80044a2:	f107 0310 	add.w	r3, r7, #16
 80044a6:	63bb      	str	r3, [r7, #56]	; 0x38
    left_align = FALSE;
 80044a8:	2300      	movs	r3, #0
 80044aa:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    if (*fmt == '-') {
 80044ae:	68bb      	ldr	r3, [r7, #8]
 80044b0:	781b      	ldrb	r3, [r3, #0]
 80044b2:	2b2d      	cmp	r3, #45	; 0x2d
 80044b4:	d105      	bne.n	80044c2 <chvprintf+0x6e>
      fmt++;
 80044b6:	68bb      	ldr	r3, [r7, #8]
 80044b8:	3301      	adds	r3, #1
 80044ba:	60bb      	str	r3, [r7, #8]
      left_align = TRUE;
 80044bc:	2301      	movs	r3, #1
 80044be:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    }
    filler = ' ';
 80044c2:	2320      	movs	r3, #32
 80044c4:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    if (*fmt == '0') {
 80044c8:	68bb      	ldr	r3, [r7, #8]
 80044ca:	781b      	ldrb	r3, [r3, #0]
 80044cc:	2b30      	cmp	r3, #48	; 0x30
 80044ce:	d105      	bne.n	80044dc <chvprintf+0x88>
      fmt++;
 80044d0:	68bb      	ldr	r3, [r7, #8]
 80044d2:	3301      	adds	r3, #1
 80044d4:	60bb      	str	r3, [r7, #8]
      filler = '0';
 80044d6:	2330      	movs	r3, #48	; 0x30
 80044d8:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    }
    width = 0;
 80044dc:	2300      	movs	r3, #0
 80044de:	62bb      	str	r3, [r7, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 80044e0:	68bb      	ldr	r3, [r7, #8]
 80044e2:	1c5a      	adds	r2, r3, #1
 80044e4:	60ba      	str	r2, [r7, #8]
 80044e6:	781b      	ldrb	r3, [r3, #0]
 80044e8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
      if (c >= '0' && c <= '9')
 80044ec:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80044f0:	2b2f      	cmp	r3, #47	; 0x2f
 80044f2:	d909      	bls.n	8004508 <chvprintf+0xb4>
 80044f4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80044f8:	2b39      	cmp	r3, #57	; 0x39
 80044fa:	d805      	bhi.n	8004508 <chvprintf+0xb4>
        c -= '0';
 80044fc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004500:	3b30      	subs	r3, #48	; 0x30
 8004502:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8004506:	e009      	b.n	800451c <chvprintf+0xc8>
      else if (c == '*')
 8004508:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800450c:	2b2a      	cmp	r3, #42	; 0x2a
 800450e:	d110      	bne.n	8004532 <chvprintf+0xde>
        c = va_arg(ap, int);
 8004510:	687b      	ldr	r3, [r7, #4]
 8004512:	1d1a      	adds	r2, r3, #4
 8004514:	607a      	str	r2, [r7, #4]
 8004516:	681b      	ldr	r3, [r3, #0]
 8004518:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 800451c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800451e:	4613      	mov	r3, r2
 8004520:	009b      	lsls	r3, r3, #2
 8004522:	4413      	add	r3, r2
 8004524:	005b      	lsls	r3, r3, #1
 8004526:	461a      	mov	r2, r3
 8004528:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800452c:	4413      	add	r3, r2
 800452e:	62bb      	str	r3, [r7, #40]	; 0x28
 8004530:	e7d6      	b.n	80044e0 <chvprintf+0x8c>
    }
    precision = 0;
 8004532:	2300      	movs	r3, #0
 8004534:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (c == '.') {
 8004536:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800453a:	2b2e      	cmp	r3, #46	; 0x2e
 800453c:	d129      	bne.n	8004592 <chvprintf+0x13e>
      while (TRUE) {
        c = *fmt++;
 800453e:	68bb      	ldr	r3, [r7, #8]
 8004540:	1c5a      	adds	r2, r3, #1
 8004542:	60ba      	str	r2, [r7, #8]
 8004544:	781b      	ldrb	r3, [r3, #0]
 8004546:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if (c >= '0' && c <= '9')
 800454a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800454e:	2b2f      	cmp	r3, #47	; 0x2f
 8004550:	d909      	bls.n	8004566 <chvprintf+0x112>
 8004552:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004556:	2b39      	cmp	r3, #57	; 0x39
 8004558:	d805      	bhi.n	8004566 <chvprintf+0x112>
          c -= '0';
 800455a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800455e:	3b30      	subs	r3, #48	; 0x30
 8004560:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8004564:	e009      	b.n	800457a <chvprintf+0x126>
        else if (c == '*')
 8004566:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800456a:	2b2a      	cmp	r3, #42	; 0x2a
 800456c:	d111      	bne.n	8004592 <chvprintf+0x13e>
          c = va_arg(ap, int);
 800456e:	687b      	ldr	r3, [r7, #4]
 8004570:	1d1a      	adds	r2, r3, #4
 8004572:	607a      	str	r2, [r7, #4]
 8004574:	681b      	ldr	r3, [r3, #0]
 8004576:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        else
          break;
        precision *= 10;
 800457a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800457c:	4613      	mov	r3, r2
 800457e:	009b      	lsls	r3, r3, #2
 8004580:	4413      	add	r3, r2
 8004582:	005b      	lsls	r3, r3, #1
 8004584:	62fb      	str	r3, [r7, #44]	; 0x2c
        precision += c;
 8004586:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800458a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800458c:	4413      	add	r3, r2
 800458e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004590:	e7d5      	b.n	800453e <chvprintf+0xea>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8004592:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8004596:	2b6c      	cmp	r3, #108	; 0x6c
 8004598:	d003      	beq.n	80045a2 <chvprintf+0x14e>
 800459a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800459e:	2b4c      	cmp	r3, #76	; 0x4c
 80045a0:	d10d      	bne.n	80045be <chvprintf+0x16a>
      is_long = TRUE;
 80045a2:	2301      	movs	r3, #1
 80045a4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
      if (*fmt)
 80045a8:	68bb      	ldr	r3, [r7, #8]
 80045aa:	781b      	ldrb	r3, [r3, #0]
 80045ac:	2b00      	cmp	r3, #0
 80045ae:	d01a      	beq.n	80045e6 <chvprintf+0x192>
        c = *fmt++;
 80045b0:	68bb      	ldr	r3, [r7, #8]
 80045b2:	1c5a      	adds	r2, r3, #1
 80045b4:	60ba      	str	r2, [r7, #8]
 80045b6:	781b      	ldrb	r3, [r3, #0]
 80045b8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 80045bc:	e014      	b.n	80045e8 <chvprintf+0x194>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 80045be:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80045c2:	2b40      	cmp	r3, #64	; 0x40
 80045c4:	d905      	bls.n	80045d2 <chvprintf+0x17e>
 80045c6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80045ca:	2b5a      	cmp	r3, #90	; 0x5a
 80045cc:	d801      	bhi.n	80045d2 <chvprintf+0x17e>
 80045ce:	2301      	movs	r3, #1
 80045d0:	e000      	b.n	80045d4 <chvprintf+0x180>
 80045d2:	2300      	movs	r3, #0
 80045d4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80045d8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80045dc:	f003 0301 	and.w	r3, r3, #1
 80045e0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80045e4:	e000      	b.n	80045e8 <chvprintf+0x194>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 80045e6:	bf00      	nop
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80045e8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80045ec:	3b44      	subs	r3, #68	; 0x44
 80045ee:	2b34      	cmp	r3, #52	; 0x34
 80045f0:	f200 80e3 	bhi.w	80047ba <chvprintf+0x366>
 80045f4:	a201      	add	r2, pc, #4	; (adr r2, 80045fc <chvprintf+0x1a8>)
 80045f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80045fa:	bf00      	nop
 80045fc:	08004733 	.word	0x08004733
 8004600:	080047bb 	.word	0x080047bb
 8004604:	080047bb 	.word	0x080047bb
 8004608:	080047bb 	.word	0x080047bb
 800460c:	080047bb 	.word	0x080047bb
 8004610:	08004733 	.word	0x08004733
 8004614:	080047bb 	.word	0x080047bb
 8004618:	080047bb 	.word	0x080047bb
 800461c:	080047bb 	.word	0x080047bb
 8004620:	080047bb 	.word	0x080047bb
 8004624:	080047bb 	.word	0x080047bb
 8004628:	08004785 	.word	0x08004785
 800462c:	080047bb 	.word	0x080047bb
 8004630:	080047bb 	.word	0x080047bb
 8004634:	080047bb 	.word	0x080047bb
 8004638:	080047bb 	.word	0x080047bb
 800463c:	080047bb 	.word	0x080047bb
 8004640:	0800477d 	.word	0x0800477d
 8004644:	080047bb 	.word	0x080047bb
 8004648:	080047bb 	.word	0x080047bb
 800464c:	08004775 	.word	0x08004775
 8004650:	080047bb 	.word	0x080047bb
 8004654:	080047bb 	.word	0x080047bb
 8004658:	080047bb 	.word	0x080047bb
 800465c:	080047bb 	.word	0x080047bb
 8004660:	080047bb 	.word	0x080047bb
 8004664:	080047bb 	.word	0x080047bb
 8004668:	080047bb 	.word	0x080047bb
 800466c:	080047bb 	.word	0x080047bb
 8004670:	080047bb 	.word	0x080047bb
 8004674:	080047bb 	.word	0x080047bb
 8004678:	080046d1 	.word	0x080046d1
 800467c:	08004733 	.word	0x08004733
 8004680:	080047bb 	.word	0x080047bb
 8004684:	080047bb 	.word	0x080047bb
 8004688:	080047bb 	.word	0x080047bb
 800468c:	080047bb 	.word	0x080047bb
 8004690:	08004733 	.word	0x08004733
 8004694:	080047bb 	.word	0x080047bb
 8004698:	080047bb 	.word	0x080047bb
 800469c:	080047bb 	.word	0x080047bb
 80046a0:	080047bb 	.word	0x080047bb
 80046a4:	080047bb 	.word	0x080047bb
 80046a8:	08004785 	.word	0x08004785
 80046ac:	080047bb 	.word	0x080047bb
 80046b0:	080047bb 	.word	0x080047bb
 80046b4:	080047bb 	.word	0x080047bb
 80046b8:	080046eb 	.word	0x080046eb
 80046bc:	080047bb 	.word	0x080047bb
 80046c0:	0800477d 	.word	0x0800477d
 80046c4:	080047bb 	.word	0x080047bb
 80046c8:	080047bb 	.word	0x080047bb
 80046cc:	08004775 	.word	0x08004775
    case 'c':
      filler = ' ';
 80046d0:	2320      	movs	r3, #32
 80046d2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
      *p++ = va_arg(ap, int);
 80046d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80046d8:	1c5a      	adds	r2, r3, #1
 80046da:	63fa      	str	r2, [r7, #60]	; 0x3c
 80046dc:	687a      	ldr	r2, [r7, #4]
 80046de:	1d11      	adds	r1, r2, #4
 80046e0:	6079      	str	r1, [r7, #4]
 80046e2:	6812      	ldr	r2, [r2, #0]
 80046e4:	b2d2      	uxtb	r2, r2
 80046e6:	701a      	strb	r2, [r3, #0]
 80046e8:	e06d      	b.n	80047c6 <chvprintf+0x372>
      break;
    case 's':
      filler = ' ';
 80046ea:	2320      	movs	r3, #32
 80046ec:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 80046f0:	687b      	ldr	r3, [r7, #4]
 80046f2:	1d1a      	adds	r2, r3, #4
 80046f4:	607a      	str	r2, [r7, #4]
 80046f6:	681b      	ldr	r3, [r3, #0]
 80046f8:	63bb      	str	r3, [r7, #56]	; 0x38
 80046fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80046fc:	2b00      	cmp	r3, #0
 80046fe:	d101      	bne.n	8004704 <chvprintf+0x2b0>
        s = "(null)";
 8004700:	4b68      	ldr	r3, [pc, #416]	; (80048a4 <chvprintf+0x450>)
 8004702:	63bb      	str	r3, [r7, #56]	; 0x38
      if (precision == 0)
 8004704:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004706:	2b00      	cmp	r3, #0
 8004708:	d102      	bne.n	8004710 <chvprintf+0x2bc>
        precision = 32767;
 800470a:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800470e:	62fb      	str	r3, [r7, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8004710:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004712:	63fb      	str	r3, [r7, #60]	; 0x3c
 8004714:	e002      	b.n	800471c <chvprintf+0x2c8>
 8004716:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004718:	3301      	adds	r3, #1
 800471a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800471c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800471e:	781b      	ldrb	r3, [r3, #0]
 8004720:	2b00      	cmp	r3, #0
 8004722:	d050      	beq.n	80047c6 <chvprintf+0x372>
 8004724:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004726:	3b01      	subs	r3, #1
 8004728:	62fb      	str	r3, [r7, #44]	; 0x2c
 800472a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800472c:	2b00      	cmp	r3, #0
 800472e:	daf2      	bge.n	8004716 <chvprintf+0x2c2>
 8004730:	e049      	b.n	80047c6 <chvprintf+0x372>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8004732:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8004736:	2b00      	cmp	r3, #0
 8004738:	d005      	beq.n	8004746 <chvprintf+0x2f2>
        l = va_arg(ap, long);
 800473a:	687b      	ldr	r3, [r7, #4]
 800473c:	1d1a      	adds	r2, r3, #4
 800473e:	607a      	str	r2, [r7, #4]
 8004740:	681b      	ldr	r3, [r3, #0]
 8004742:	61fb      	str	r3, [r7, #28]
 8004744:	e004      	b.n	8004750 <chvprintf+0x2fc>
      else
        l = va_arg(ap, int);
 8004746:	687b      	ldr	r3, [r7, #4]
 8004748:	1d1a      	adds	r2, r3, #4
 800474a:	607a      	str	r2, [r7, #4]
 800474c:	681b      	ldr	r3, [r3, #0]
 800474e:	61fb      	str	r3, [r7, #28]
      if (l < 0) {
 8004750:	69fb      	ldr	r3, [r7, #28]
 8004752:	2b00      	cmp	r3, #0
 8004754:	da07      	bge.n	8004766 <chvprintf+0x312>
        *p++ = '-';
 8004756:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004758:	1c5a      	adds	r2, r3, #1
 800475a:	63fa      	str	r2, [r7, #60]	; 0x3c
 800475c:	222d      	movs	r2, #45	; 0x2d
 800475e:	701a      	strb	r2, [r3, #0]
        l = -l;
 8004760:	69fb      	ldr	r3, [r7, #28]
 8004762:	425b      	negs	r3, r3
 8004764:	61fb      	str	r3, [r7, #28]
      }
      p = ch_ltoa(p, l, 10);
 8004766:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004768:	69f9      	ldr	r1, [r7, #28]
 800476a:	220a      	movs	r2, #10
 800476c:	f7ff fe60 	bl	8004430 <ch_ltoa>
 8004770:	63f8      	str	r0, [r7, #60]	; 0x3c
 8004772:	e028      	b.n	80047c6 <chvprintf+0x372>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8004774:	2310      	movs	r3, #16
 8004776:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 800477a:	e006      	b.n	800478a <chvprintf+0x336>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 800477c:	230a      	movs	r3, #10
 800477e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8004782:	e002      	b.n	800478a <chvprintf+0x336>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 8004784:	2308      	movs	r3, #8
 8004786:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
unsigned_common:
      if (is_long)
 800478a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800478e:	2b00      	cmp	r3, #0
 8004790:	d005      	beq.n	800479e <chvprintf+0x34a>
        l = va_arg(ap, unsigned long);
 8004792:	687b      	ldr	r3, [r7, #4]
 8004794:	1d1a      	adds	r2, r3, #4
 8004796:	607a      	str	r2, [r7, #4]
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	61fb      	str	r3, [r7, #28]
 800479c:	e004      	b.n	80047a8 <chvprintf+0x354>
      else
        l = va_arg(ap, unsigned int);
 800479e:	687b      	ldr	r3, [r7, #4]
 80047a0:	1d1a      	adds	r2, r3, #4
 80047a2:	607a      	str	r2, [r7, #4]
 80047a4:	681b      	ldr	r3, [r3, #0]
 80047a6:	61fb      	str	r3, [r7, #28]
      p = ch_ltoa(p, l, c);
 80047a8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80047ac:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80047ae:	69f9      	ldr	r1, [r7, #28]
 80047b0:	461a      	mov	r2, r3
 80047b2:	f7ff fe3d 	bl	8004430 <ch_ltoa>
 80047b6:	63f8      	str	r0, [r7, #60]	; 0x3c
 80047b8:	e005      	b.n	80047c6 <chvprintf+0x372>
      break;
    default:
      *p++ = c;
 80047ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80047bc:	1c5a      	adds	r2, r3, #1
 80047be:	63fa      	str	r2, [r7, #60]	; 0x3c
 80047c0:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 80047c4:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 80047c6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80047c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80047ca:	1ad3      	subs	r3, r2, r3
 80047cc:	633b      	str	r3, [r7, #48]	; 0x30
    if ((width -= i) < 0)
 80047ce:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80047d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80047d2:	1ad3      	subs	r3, r2, r3
 80047d4:	62bb      	str	r3, [r7, #40]	; 0x28
 80047d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047d8:	2b00      	cmp	r3, #0
 80047da:	da01      	bge.n	80047e0 <chvprintf+0x38c>
      width = 0;
 80047dc:	2300      	movs	r3, #0
 80047de:	62bb      	str	r3, [r7, #40]	; 0x28
    if (left_align == FALSE)
 80047e0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 80047e4:	f083 0301 	eor.w	r3, r3, #1
 80047e8:	b2db      	uxtb	r3, r3
 80047ea:	2b00      	cmp	r3, #0
 80047ec:	d002      	beq.n	80047f4 <chvprintf+0x3a0>
      width = -width;
 80047ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047f0:	425b      	negs	r3, r3
 80047f2:	62bb      	str	r3, [r7, #40]	; 0x28
    if (width < 0) {
 80047f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047f6:	2b00      	cmp	r3, #0
 80047f8:	da36      	bge.n	8004868 <chvprintf+0x414>
      if (*s == '-' && filler == '0') {
 80047fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80047fc:	781b      	ldrb	r3, [r3, #0]
 80047fe:	2b2d      	cmp	r3, #45	; 0x2d
 8004800:	d113      	bne.n	800482a <chvprintf+0x3d6>
 8004802:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8004806:	2b30      	cmp	r3, #48	; 0x30
 8004808:	d10f      	bne.n	800482a <chvprintf+0x3d6>
        streamPut(chp, (uint8_t)*s++);
 800480a:	68fb      	ldr	r3, [r7, #12]
 800480c:	681b      	ldr	r3, [r3, #0]
 800480e:	689a      	ldr	r2, [r3, #8]
 8004810:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004812:	1c59      	adds	r1, r3, #1
 8004814:	63b9      	str	r1, [r7, #56]	; 0x38
 8004816:	781b      	ldrb	r3, [r3, #0]
 8004818:	68f8      	ldr	r0, [r7, #12]
 800481a:	4619      	mov	r1, r3
 800481c:	4790      	blx	r2
        n++;
 800481e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004820:	3301      	adds	r3, #1
 8004822:	627b      	str	r3, [r7, #36]	; 0x24
        i--;
 8004824:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004826:	3b01      	subs	r3, #1
 8004828:	633b      	str	r3, [r7, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800482a:	68fb      	ldr	r3, [r7, #12]
 800482c:	681b      	ldr	r3, [r3, #0]
 800482e:	689b      	ldr	r3, [r3, #8]
 8004830:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 8004834:	68f8      	ldr	r0, [r7, #12]
 8004836:	4611      	mov	r1, r2
 8004838:	4798      	blx	r3
        n++;
 800483a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800483c:	3301      	adds	r3, #1
 800483e:	627b      	str	r3, [r7, #36]	; 0x24
      } while (++width != 0);
 8004840:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004842:	3301      	adds	r3, #1
 8004844:	62bb      	str	r3, [r7, #40]	; 0x28
 8004846:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004848:	2b00      	cmp	r3, #0
 800484a:	d1ee      	bne.n	800482a <chvprintf+0x3d6>
 800484c:	e00c      	b.n	8004868 <chvprintf+0x414>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 800484e:	68fb      	ldr	r3, [r7, #12]
 8004850:	681b      	ldr	r3, [r3, #0]
 8004852:	689a      	ldr	r2, [r3, #8]
 8004854:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004856:	1c59      	adds	r1, r3, #1
 8004858:	63b9      	str	r1, [r7, #56]	; 0x38
 800485a:	781b      	ldrb	r3, [r3, #0]
 800485c:	68f8      	ldr	r0, [r7, #12]
 800485e:	4619      	mov	r1, r3
 8004860:	4790      	blx	r2
      n++;
 8004862:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004864:	3301      	adds	r3, #1
 8004866:	627b      	str	r3, [r7, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8004868:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800486a:	3b01      	subs	r3, #1
 800486c:	633b      	str	r3, [r7, #48]	; 0x30
 800486e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004870:	2b00      	cmp	r3, #0
 8004872:	daec      	bge.n	800484e <chvprintf+0x3fa>
 8004874:	e00d      	b.n	8004892 <chvprintf+0x43e>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8004876:	68fb      	ldr	r3, [r7, #12]
 8004878:	681b      	ldr	r3, [r3, #0]
 800487a:	689b      	ldr	r3, [r3, #8]
 800487c:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 8004880:	68f8      	ldr	r0, [r7, #12]
 8004882:	4611      	mov	r1, r2
 8004884:	4798      	blx	r3
      n++;
 8004886:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004888:	3301      	adds	r3, #1
 800488a:	627b      	str	r3, [r7, #36]	; 0x24
      width--;
 800488c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800488e:	3b01      	subs	r3, #1
 8004890:	62bb      	str	r3, [r7, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8004892:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004894:	2b00      	cmp	r3, #0
 8004896:	d1ee      	bne.n	8004876 <chvprintf+0x422>
 8004898:	e5e4      	b.n	8004464 <chvprintf+0x10>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 800489a:	4618      	mov	r0, r3
 800489c:	3740      	adds	r7, #64	; 0x40
 800489e:	46bd      	mov	sp, r7
 80048a0:	bd80      	pop	{r7, pc}
 80048a2:	bf00      	nop
<<<<<<< HEAD
 80048a4:	0800e624 	.word	0x0800e624
=======
 80048a4:	0800e6ac 	.word	0x0800e6ac
>>>>>>> 752c83b... update binaries

080048a8 <_writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t _writes(void *ip, const uint8_t *bp, size_t n) {
 80048a8:	b580      	push	{r7, lr}
 80048aa:	b086      	sub	sp, #24
 80048ac:	af00      	add	r7, sp, #0
 80048ae:	60f8      	str	r0, [r7, #12]
 80048b0:	60b9      	str	r1, [r7, #8]
 80048b2:	607a      	str	r2, [r7, #4]
  MemoryStream *msp = ip;
 80048b4:	68fb      	ldr	r3, [r7, #12]
 80048b6:	617b      	str	r3, [r7, #20]

  if (msp->size - msp->eos < n)
 80048b8:	697b      	ldr	r3, [r7, #20]
 80048ba:	689a      	ldr	r2, [r3, #8]
 80048bc:	697b      	ldr	r3, [r7, #20]
 80048be:	68db      	ldr	r3, [r3, #12]
 80048c0:	1ad2      	subs	r2, r2, r3
 80048c2:	687b      	ldr	r3, [r7, #4]
 80048c4:	429a      	cmp	r2, r3
 80048c6:	d205      	bcs.n	80048d4 <_writes+0x2c>
    n = msp->size - msp->eos;
 80048c8:	697b      	ldr	r3, [r7, #20]
 80048ca:	689a      	ldr	r2, [r3, #8]
 80048cc:	697b      	ldr	r3, [r7, #20]
 80048ce:	68db      	ldr	r3, [r3, #12]
 80048d0:	1ad3      	subs	r3, r2, r3
 80048d2:	607b      	str	r3, [r7, #4]
  memcpy(msp->buffer + msp->eos, bp, n);
 80048d4:	697b      	ldr	r3, [r7, #20]
 80048d6:	685a      	ldr	r2, [r3, #4]
 80048d8:	697b      	ldr	r3, [r7, #20]
 80048da:	68db      	ldr	r3, [r3, #12]
 80048dc:	4413      	add	r3, r2
 80048de:	4618      	mov	r0, r3
 80048e0:	68b9      	ldr	r1, [r7, #8]
 80048e2:	687a      	ldr	r2, [r7, #4]
<<<<<<< HEAD
 80048e4:	f009 fe4a 	bl	800e57c <memcpy>
=======
 80048e4:	f009 fe8e 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries
  msp->eos += n;
 80048e8:	697b      	ldr	r3, [r7, #20]
 80048ea:	68da      	ldr	r2, [r3, #12]
 80048ec:	687b      	ldr	r3, [r7, #4]
 80048ee:	441a      	add	r2, r3
 80048f0:	697b      	ldr	r3, [r7, #20]
 80048f2:	60da      	str	r2, [r3, #12]
  return n;
 80048f4:	687b      	ldr	r3, [r7, #4]
}
 80048f6:	4618      	mov	r0, r3
 80048f8:	3718      	adds	r7, #24
 80048fa:	46bd      	mov	sp, r7
 80048fc:	bd80      	pop	{r7, pc}
 80048fe:	bf00      	nop

08004900 <_reads>:

static size_t _reads(void *ip, uint8_t *bp, size_t n) {
 8004900:	b580      	push	{r7, lr}
 8004902:	b086      	sub	sp, #24
 8004904:	af00      	add	r7, sp, #0
 8004906:	60f8      	str	r0, [r7, #12]
 8004908:	60b9      	str	r1, [r7, #8]
 800490a:	607a      	str	r2, [r7, #4]
  MemoryStream *msp = ip;
 800490c:	68fb      	ldr	r3, [r7, #12]
 800490e:	617b      	str	r3, [r7, #20]

  if (msp->eos - msp->offset < n)
 8004910:	697b      	ldr	r3, [r7, #20]
 8004912:	68da      	ldr	r2, [r3, #12]
 8004914:	697b      	ldr	r3, [r7, #20]
 8004916:	691b      	ldr	r3, [r3, #16]
 8004918:	1ad2      	subs	r2, r2, r3
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	429a      	cmp	r2, r3
 800491e:	d205      	bcs.n	800492c <_reads+0x2c>
    n = msp->eos - msp->offset;
 8004920:	697b      	ldr	r3, [r7, #20]
 8004922:	68da      	ldr	r2, [r3, #12]
 8004924:	697b      	ldr	r3, [r7, #20]
 8004926:	691b      	ldr	r3, [r3, #16]
 8004928:	1ad3      	subs	r3, r2, r3
 800492a:	607b      	str	r3, [r7, #4]
  memcpy(bp, msp->buffer + msp->offset, n);
 800492c:	697b      	ldr	r3, [r7, #20]
 800492e:	685a      	ldr	r2, [r3, #4]
 8004930:	697b      	ldr	r3, [r7, #20]
 8004932:	691b      	ldr	r3, [r3, #16]
 8004934:	4413      	add	r3, r2
 8004936:	68b8      	ldr	r0, [r7, #8]
 8004938:	4619      	mov	r1, r3
 800493a:	687a      	ldr	r2, [r7, #4]
<<<<<<< HEAD
 800493c:	f009 fe1e 	bl	800e57c <memcpy>
=======
 800493c:	f009 fe62 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries
  msp->offset += n;
 8004940:	697b      	ldr	r3, [r7, #20]
 8004942:	691a      	ldr	r2, [r3, #16]
 8004944:	687b      	ldr	r3, [r7, #4]
 8004946:	441a      	add	r2, r3
 8004948:	697b      	ldr	r3, [r7, #20]
 800494a:	611a      	str	r2, [r3, #16]
  return n;
 800494c:	687b      	ldr	r3, [r7, #4]
}
 800494e:	4618      	mov	r0, r3
 8004950:	3718      	adds	r7, #24
 8004952:	46bd      	mov	sp, r7
 8004954:	bd80      	pop	{r7, pc}
 8004956:	bf00      	nop

08004958 <_put.lto_priv.6>:

static msg_t _put(void *ip, uint8_t b) {
 8004958:	b480      	push	{r7}
 800495a:	b085      	sub	sp, #20
 800495c:	af00      	add	r7, sp, #0
 800495e:	6078      	str	r0, [r7, #4]
 8004960:	460b      	mov	r3, r1
 8004962:	70fb      	strb	r3, [r7, #3]
  MemoryStream *msp = ip;
 8004964:	687b      	ldr	r3, [r7, #4]
 8004966:	60fb      	str	r3, [r7, #12]

  if (msp->size - msp->eos <= 0)
 8004968:	68fb      	ldr	r3, [r7, #12]
 800496a:	689a      	ldr	r2, [r3, #8]
 800496c:	68fb      	ldr	r3, [r7, #12]
 800496e:	68db      	ldr	r3, [r3, #12]
 8004970:	429a      	cmp	r2, r3
 8004972:	d102      	bne.n	800497a <_put.lto_priv.6+0x22>
    return MSG_RESET;
 8004974:	f06f 0301 	mvn.w	r3, #1
 8004978:	e00c      	b.n	8004994 <_put.lto_priv.6+0x3c>
  *(msp->buffer + msp->eos) = b;
 800497a:	68fb      	ldr	r3, [r7, #12]
 800497c:	685a      	ldr	r2, [r3, #4]
 800497e:	68fb      	ldr	r3, [r7, #12]
 8004980:	68db      	ldr	r3, [r3, #12]
 8004982:	4413      	add	r3, r2
 8004984:	78fa      	ldrb	r2, [r7, #3]
 8004986:	701a      	strb	r2, [r3, #0]
  msp->eos += 1;
 8004988:	68fb      	ldr	r3, [r7, #12]
 800498a:	68db      	ldr	r3, [r3, #12]
 800498c:	1c5a      	adds	r2, r3, #1
 800498e:	68fb      	ldr	r3, [r7, #12]
 8004990:	60da      	str	r2, [r3, #12]
  return MSG_OK;
 8004992:	2300      	movs	r3, #0
}
 8004994:	4618      	mov	r0, r3
 8004996:	3714      	adds	r7, #20
 8004998:	46bd      	mov	sp, r7
 800499a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800499e:	4770      	bx	lr

080049a0 <_get.lto_priv.4>:

static msg_t _get(void *ip) {
 80049a0:	b480      	push	{r7}
 80049a2:	b085      	sub	sp, #20
 80049a4:	af00      	add	r7, sp, #0
 80049a6:	6078      	str	r0, [r7, #4]
  uint8_t b;
  MemoryStream *msp = ip;
 80049a8:	687b      	ldr	r3, [r7, #4]
 80049aa:	60fb      	str	r3, [r7, #12]

  if (msp->eos - msp->offset <= 0)
 80049ac:	68fb      	ldr	r3, [r7, #12]
 80049ae:	68da      	ldr	r2, [r3, #12]
 80049b0:	68fb      	ldr	r3, [r7, #12]
 80049b2:	691b      	ldr	r3, [r3, #16]
 80049b4:	429a      	cmp	r2, r3
 80049b6:	d102      	bne.n	80049be <_get.lto_priv.4+0x1e>
    return MSG_RESET;
 80049b8:	f06f 0301 	mvn.w	r3, #1
 80049bc:	e00c      	b.n	80049d8 <_get.lto_priv.4+0x38>
  b = *(msp->buffer + msp->offset);
 80049be:	68fb      	ldr	r3, [r7, #12]
 80049c0:	685a      	ldr	r2, [r3, #4]
 80049c2:	68fb      	ldr	r3, [r7, #12]
 80049c4:	691b      	ldr	r3, [r3, #16]
 80049c6:	4413      	add	r3, r2
 80049c8:	781b      	ldrb	r3, [r3, #0]
 80049ca:	72fb      	strb	r3, [r7, #11]
  msp->offset += 1;
 80049cc:	68fb      	ldr	r3, [r7, #12]
 80049ce:	691b      	ldr	r3, [r3, #16]
 80049d0:	1c5a      	adds	r2, r3, #1
 80049d2:	68fb      	ldr	r3, [r7, #12]
 80049d4:	611a      	str	r2, [r3, #16]
  return b;
 80049d6:	7afb      	ldrb	r3, [r7, #11]
}
 80049d8:	4618      	mov	r0, r3
 80049da:	3714      	adds	r7, #20
 80049dc:	46bd      	mov	sp, r7
 80049de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049e2:	4770      	bx	lr

080049e4 <msObjectInit>:
 * @param[in] eos       initial End Of Stream offset. Normally you need to
 *                      put this to zero for RAM buffers or equal to @p size
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {
 80049e4:	b480      	push	{r7}
 80049e6:	b085      	sub	sp, #20
 80049e8:	af00      	add	r7, sp, #0
 80049ea:	60f8      	str	r0, [r7, #12]
 80049ec:	60b9      	str	r1, [r7, #8]
 80049ee:	607a      	str	r2, [r7, #4]
 80049f0:	603b      	str	r3, [r7, #0]

  msp->vmt    = &vmt;
 80049f2:	68fb      	ldr	r3, [r7, #12]
 80049f4:	4a09      	ldr	r2, [pc, #36]	; (8004a1c <msObjectInit+0x38>)
 80049f6:	601a      	str	r2, [r3, #0]
  msp->buffer = buffer;
 80049f8:	68fb      	ldr	r3, [r7, #12]
 80049fa:	68ba      	ldr	r2, [r7, #8]
 80049fc:	605a      	str	r2, [r3, #4]
  msp->size   = size;
 80049fe:	68fb      	ldr	r3, [r7, #12]
 8004a00:	687a      	ldr	r2, [r7, #4]
 8004a02:	609a      	str	r2, [r3, #8]
  msp->eos    = eos;
 8004a04:	68fb      	ldr	r3, [r7, #12]
 8004a06:	683a      	ldr	r2, [r7, #0]
 8004a08:	60da      	str	r2, [r3, #12]
  msp->offset = 0;
 8004a0a:	68fb      	ldr	r3, [r7, #12]
 8004a0c:	2200      	movs	r2, #0
 8004a0e:	611a      	str	r2, [r3, #16]
}
 8004a10:	3714      	adds	r7, #20
 8004a12:	46bd      	mov	sp, r7
 8004a14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004a18:	4770      	bx	lr
 8004a1a:	bf00      	nop
 8004a1c:	0800edc0 	.word	0x0800edc0

08004a20 <_uavcan_set_node_id.lto_priv.97>:

uint8_t uavcan_get_node_id(uint8_t uavcan_idx) {
    return _uavcan_get_node_id(uavcan_get_instance(uavcan_idx));
}

static void _uavcan_set_node_id(struct uavcan_instance_s* instance, uint8_t node_id) {
 8004a20:	b580      	push	{r7, lr}
 8004a22:	b082      	sub	sp, #8
 8004a24:	af00      	add	r7, sp, #0
 8004a26:	6078      	str	r0, [r7, #4]
 8004a28:	460b      	mov	r3, r1
 8004a2a:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8004a2c:	687b      	ldr	r3, [r7, #4]
 8004a2e:	2b00      	cmp	r3, #0
 8004a30:	d017      	beq.n	8004a62 <_uavcan_set_node_id.lto_priv.97+0x42>
        return;
    }

    can_set_auto_retransmit_mode(instance->can_instance, node_id != 0);
 8004a32:	687b      	ldr	r3, [r7, #4]
 8004a34:	685a      	ldr	r2, [r3, #4]
 8004a36:	78fb      	ldrb	r3, [r7, #3]
 8004a38:	2b00      	cmp	r3, #0
 8004a3a:	bf14      	ite	ne
 8004a3c:	2301      	movne	r3, #1
 8004a3e:	2300      	moveq	r3, #0
 8004a40:	b2db      	uxtb	r3, r3
 8004a42:	4610      	mov	r0, r2
 8004a44:	4619      	mov	r1, r3
 8004a46:	f003 f829 	bl	8007a9c <can_set_auto_retransmit_mode>
    chSysLock();
 8004a4a:	f001 fc8f 	bl	800636c <chSysLock.lto_priv.77>
    canardSetLocalNodeID(&instance->canard, node_id);
 8004a4e:	687b      	ldr	r3, [r7, #4]
 8004a50:	f103 0208 	add.w	r2, r3, #8
 8004a54:	78fb      	ldrb	r3, [r7, #3]
 8004a56:	4610      	mov	r0, r2
 8004a58:	4619      	mov	r1, r3
<<<<<<< HEAD
 8004a5a:	f008 f81b 	bl	800ca94 <canardSetLocalNodeID>
=======
 8004a5a:	f008 f85f 	bl	800cb1c <canardSetLocalNodeID>
>>>>>>> 752c83b... update binaries
    chSysUnlock();
 8004a5e:	f001 fc8d 	bl	800637c <chSysUnlock.lto_priv.76>
}
 8004a62:	3708      	adds	r7, #8
 8004a64:	46bd      	mov	sp, r7
 8004a66:	bd80      	pop	{r7, pc}

08004a68 <uavcan_set_node_id>:

void uavcan_set_node_id(uint8_t uavcan_idx, uint8_t node_id) {
 8004a68:	b580      	push	{r7, lr}
 8004a6a:	b082      	sub	sp, #8
 8004a6c:	af00      	add	r7, sp, #0
 8004a6e:	4603      	mov	r3, r0
 8004a70:	460a      	mov	r2, r1
 8004a72:	71fb      	strb	r3, [r7, #7]
 8004a74:	4613      	mov	r3, r2
 8004a76:	71bb      	strb	r3, [r7, #6]
    return _uavcan_set_node_id(uavcan_get_instance(uavcan_idx), node_id);
 8004a78:	79fb      	ldrb	r3, [r7, #7]
 8004a7a:	4618      	mov	r0, r3
 8004a7c:	f000 fb20 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8004a80:	4602      	mov	r2, r0
 8004a82:	79bb      	ldrb	r3, [r7, #6]
 8004a84:	4610      	mov	r0, r2
 8004a86:	4619      	mov	r1, r3
 8004a88:	f7ff ffca 	bl	8004a20 <_uavcan_set_node_id.lto_priv.97>
}
 8004a8c:	3708      	adds	r7, #8
 8004a8e:	46bd      	mov	sp, r7
 8004a90:	bd80      	pop	{r7, pc}
 8004a92:	bf00      	nop

08004a94 <copy_bit_array>:

/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
 8004a94:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
    // Normalizing inputs
    src += src_offset / 8;
    dst += dst_offset / 8;

    src_offset %= 8;
 8004a98:	f001 0607 	and.w	r6, r1, #7

/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
 8004a9c:	9c08      	ldr	r4, [sp, #32]
    dst += dst_offset / 8;

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
 8004a9e:	4432      	add	r2, r6
    while (last_bit - src_offset)
 8004aa0:	4296      	cmp	r6, r2
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */

static void __attribute__((optimize("O3"))) copy_bit_array(const uint8_t* src, uint32_t src_offset, uint32_t src_len, uint8_t* dst, uint32_t dst_offset) {
    // Normalizing inputs
    src += src_offset / 8;
 8004aa2:	ea4f 01d1 	mov.w	r1, r1, lsr #3
    dst += dst_offset / 8;
 8004aa6:	ea4f 09d4 	mov.w	r9, r4, lsr #3

    src_offset %= 8;
    dst_offset %= 8;
 8004aaa:	f004 0c07 	and.w	ip, r4, #7

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 8004aae:	d02d      	beq.n	8004b0c <copy_bit_array+0x78>
 8004ab0:	4408      	add	r0, r1
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 8004ab2:	f44f 417f 	mov.w	r1, #65280	; 0xff00
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
    {
        const uint8_t src_bit_offset = (uint8_t)(src_offset % 8U);
 8004ab6:	f006 0b07 	and.w	fp, r6, #7
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);
 8004aba:	f00c 0507 	and.w	r5, ip, #7

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);
 8004abe:	455d      	cmp	r5, fp
 8004ac0:	462c      	mov	r4, r5
 8004ac2:	bf38      	it	cc
 8004ac4:	465c      	movcc	r4, fp
 8004ac6:	ebc6 0e02 	rsb	lr, r6, r2
 8004aca:	f1c4 0408 	rsb	r4, r4, #8
 8004ace:	45a6      	cmp	lr, r4
 8004ad0:	bf28      	it	cs
 8004ad2:	46a6      	movcs	lr, r4

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8004ad4:	08f4      	lsrs	r4, r6, #3
 8004ad6:	f810 a004 	ldrb.w	sl, [r0, r4]
 8004ada:	eb09 08dc 	add.w	r8, r9, ip, lsr #3
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 8004ade:	fa21 f40e 	lsr.w	r4, r1, lr
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8004ae2:	fa0a fa0b 	lsl.w	sl, sl, fp
 8004ae6:	b2e4      	uxtb	r4, r4

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004ae8:	f813 b008 	ldrb.w	fp, [r3, r8]

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 8004aec:	fa4a fa05 	asr.w	sl, sl, r5
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 8004af0:	fa44 f505 	asr.w	r5, r4, r5
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004af4:	ea05 0a0a 	and.w	sl, r5, sl
 8004af8:	ea2b 0405 	bic.w	r4, fp, r5

        src_offset += copy_bits;
 8004afc:	4476      	add	r6, lr
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004afe:	ea4a 0404 	orr.w	r4, sl, r4

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 8004b02:	42b2      	cmp	r2, r6
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));

        src_offset += copy_bits;
        dst_offset += copy_bits;
 8004b04:	44f4      	add	ip, lr
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 8004b06:	f803 4008 	strb.w	r4, [r3, r8]

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
 8004b0a:	d1d4      	bne.n	8004ab6 <copy_bit_array+0x22>
 8004b0c:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}

08004b10 <uavcan_transmit_chunk_handler>:
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
    struct uavcan_transmit_state_s* tx_state = ctx;

    if (tx_state->failed || bitlen == 0) {
 8004b10:	7813      	ldrb	r3, [r2, #0]
 8004b12:	2b00      	cmp	r3, #0
 8004b14:	d146      	bne.n	8004ba4 <uavcan_transmit_chunk_handler+0x94>
 8004b16:	2900      	cmp	r1, #0
 8004b18:	d044      	beq.n	8004ba4 <uavcan_transmit_chunk_handler+0x94>
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8004b1a:	e92d 4f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}

    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
 8004b1e:	68d4      	ldr	r4, [r2, #12]
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8004b20:	b082      	sub	sp, #8
 8004b22:	460e      	mov	r6, r1
 8004b24:	4680      	mov	r8, r0
 8004b26:	4615      	mov	r5, r2

    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
 8004b28:	2c00      	cmp	r4, #0
 8004b2a:	d050      	beq.n	8004bce <uavcan_transmit_chunk_handler+0xbe>
        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}

static void __attribute__((optimize("O3"))) uavcan_transmit_chunk_handler(uint8_t* chunk, size_t bitlen, void* ctx) {
 8004b2c:	f04f 0b00 	mov.w	fp, #0

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004b30:	f105 0a08 	add.w	sl, r5, #8
 8004b34:	e017      	b.n	8004b66 <uavcan_transmit_chunk_handler+0x56>
 8004b36:	686a      	ldr	r2, [r5, #4]
    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
 8004b38:	68ab      	ldr	r3, [r5, #8]
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004b3a:	6850      	ldr	r0, [r2, #4]
 8004b3c:	4651      	mov	r1, sl
    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
        if (frame_copy_bits == 0) {
            bool make_room_for_crc = tx_state->frame_list_head->next == NULL;
 8004b3e:	f8d3 9018 	ldr.w	r9, [r3, #24]
            tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004b42:	f000 ff43 	bl	80059cc <can_allocate_tx_frame_and_append>
 8004b46:	60e8      	str	r0, [r5, #12]
            if (!tx_state->frame_list_tail) {
 8004b48:	b368      	cbz	r0, 8004ba6 <uavcan_transmit_chunk_handler+0x96>
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
 8004b4a:	7204      	strb	r4, [r0, #8]
 8004b4c:	7244      	strb	r4, [r0, #9]
 8004b4e:	7284      	strb	r4, [r0, #10]
 8004b50:	72c4      	strb	r4, [r0, #11]
 8004b52:	7304      	strb	r4, [r0, #12]
 8004b54:	7344      	strb	r4, [r0, #13]
 8004b56:	7384      	strb	r4, [r0, #14]
 8004b58:	73c4      	strb	r4, [r0, #15]
            if (make_room_for_crc) {
 8004b5a:	f1b9 0f00 	cmp.w	r9, #0
 8004b5e:	d027      	beq.n	8004bb0 <uavcan_transmit_chunk_handler+0xa0>
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
                tx_state->frame_bit_ofs = 16;
            } else {
                tx_state->frame_bit_ofs = 0;
 8004b60:	612c      	str	r4, [r5, #16]
        memset(tx_state->frame_list_tail->content.data, 0, 8);
    }

    size_t chunk_bit_ofs = 0;

    while (chunk_bit_ofs < bitlen) {
 8004b62:	455e      	cmp	r6, fp
 8004b64:	d921      	bls.n	8004baa <uavcan_transmit_chunk_handler+0x9a>
        size_t frame_copy_bits = MIN(bitlen-chunk_bit_ofs, 7*8-tx_state->frame_bit_ofs);
 8004b66:	692a      	ldr	r2, [r5, #16]
 8004b68:	ebcb 0406 	rsb	r4, fp, r6
 8004b6c:	f1c2 0338 	rsb	r3, r2, #56	; 0x38
 8004b70:	429c      	cmp	r4, r3
 8004b72:	bf28      	it	cs
 8004b74:	461c      	movcs	r4, r3
        if (frame_copy_bits == 0) {
 8004b76:	2c00      	cmp	r4, #0
 8004b78:	d0dd      	beq.n	8004b36 <uavcan_transmit_chunk_handler+0x26>
                tx_state->frame_bit_ofs = 0;
            }
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
 8004b7a:	68eb      	ldr	r3, [r5, #12]
 8004b7c:	4659      	mov	r1, fp
 8004b7e:	9200      	str	r2, [sp, #0]
 8004b80:	3308      	adds	r3, #8
 8004b82:	4622      	mov	r2, r4
 8004b84:	4640      	mov	r0, r8
 8004b86:	f7ff ff85 	bl	8004a94 <copy_bit_array>
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
 8004b8a:	692b      	ldr	r3, [r5, #16]
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 8004b8c:	68ea      	ldr	r2, [r5, #12]
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
 8004b8e:	4423      	add	r3, r4
 8004b90:	612b      	str	r3, [r5, #16]
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 8004b92:	3307      	adds	r3, #7
 8004b94:	7811      	ldrb	r1, [r2, #0]
 8004b96:	08db      	lsrs	r3, r3, #3
 8004b98:	3301      	adds	r3, #1
 8004b9a:	f363 0185 	bfi	r1, r3, #2, #4
            }
            continue;
        }

        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
 8004b9e:	44a3      	add	fp, r4
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
 8004ba0:	7011      	strb	r1, [r2, #0]
 8004ba2:	e7de      	b.n	8004b62 <uavcan_transmit_chunk_handler+0x52>
 8004ba4:	4770      	bx	lr
    }

    if (!tx_state->frame_list_tail) {
        tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
        if (!tx_state->frame_list_tail) {
            tx_state->failed = true;
 8004ba6:	2301      	movs	r3, #1
 8004ba8:	702b      	strb	r3, [r5, #0]
        copy_bit_array(chunk, chunk_bit_ofs, frame_copy_bits, tx_state->frame_list_tail->content.data, tx_state->frame_bit_ofs);
        chunk_bit_ofs += frame_copy_bits;
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
    }
}
 8004baa:	b002      	add	sp, #8
 8004bac:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
            if (make_room_for_crc) {
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
 8004bb0:	68aa      	ldr	r2, [r5, #8]
 8004bb2:	68eb      	ldr	r3, [r5, #12]
 8004bb4:	f8b2 100d 	ldrh.w	r1, [r2, #13]
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
 8004bb8:	2205      	movs	r2, #5
                tx_state->failed = true;
                return;
            }
            memset(tx_state->frame_list_tail->content.data, 0, 8);
            if (make_room_for_crc) {
                memcpy(tx_state->frame_list_tail->content.data, &tx_state->frame_list_head->content.data[5], 2);
 8004bba:	8119      	strh	r1, [r3, #8]
                memmove(&tx_state->frame_list_head->content.data[2], tx_state->frame_list_head->content.data, 5);
 8004bbc:	68a9      	ldr	r1, [r5, #8]
 8004bbe:	f101 000a 	add.w	r0, r1, #10
 8004bc2:	3108      	adds	r1, #8
<<<<<<< HEAD
 8004bc4:	f009 fce5 	bl	800e592 <memmove>
=======
 8004bc4:	f009 fd29 	bl	800e61a <memmove>
>>>>>>> 752c83b... update binaries
                tx_state->frame_bit_ofs = 16;
 8004bc8:	2310      	movs	r3, #16
 8004bca:	612b      	str	r3, [r5, #16]
 8004bcc:	e7c9      	b.n	8004b62 <uavcan_transmit_chunk_handler+0x52>
    if (tx_state->failed || bitlen == 0) {
        return;
    }

    if (!tx_state->frame_list_tail) {
        tx_state->frame_list_tail = can_allocate_tx_frame_and_append(tx_state->instance->can_instance, &tx_state->frame_list_head);
 8004bce:	6853      	ldr	r3, [r2, #4]
 8004bd0:	f102 0108 	add.w	r1, r2, #8
 8004bd4:	6858      	ldr	r0, [r3, #4]
 8004bd6:	f000 fef9 	bl	80059cc <can_allocate_tx_frame_and_append>
 8004bda:	60e8      	str	r0, [r5, #12]
        if (!tx_state->frame_list_tail) {
 8004bdc:	2800      	cmp	r0, #0
 8004bde:	d0e2      	beq.n	8004ba6 <uavcan_transmit_chunk_handler+0x96>
            tx_state->failed = true;
            return;
        }
        memset(tx_state->frame_list_tail->content.data, 0, 8);
 8004be0:	7204      	strb	r4, [r0, #8]
 8004be2:	7244      	strb	r4, [r0, #9]
 8004be4:	7284      	strb	r4, [r0, #10]
 8004be6:	72c4      	strb	r4, [r0, #11]
 8004be8:	7304      	strb	r4, [r0, #12]
 8004bea:	7344      	strb	r4, [r0, #13]
 8004bec:	7384      	strb	r4, [r0, #14]
 8004bee:	73c4      	strb	r4, [r0, #15]
 8004bf0:	e79c      	b.n	8004b2c <uavcan_transmit_chunk_handler+0x1c>
 8004bf2:	bf00      	nop

08004bf4 <_uavcan_send>:
        tx_state->frame_bit_ofs += frame_copy_bits;
        tx_state->frame_list_tail->content.DLC = (tx_state->frame_bit_ofs+7)/8 + 1;
    }
}

static bool _uavcan_send(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* const msg_descriptor, uint16_t data_type_id, uint8_t priority, uint8_t transfer_id, uint8_t dest_node_id, void* msg_data) {
 8004bf4:	b580      	push	{r7, lr}
 8004bf6:	b08e      	sub	sp, #56	; 0x38
 8004bf8:	af00      	add	r7, sp, #0
 8004bfa:	60f8      	str	r0, [r7, #12]
 8004bfc:	60b9      	str	r1, [r7, #8]
 8004bfe:	4611      	mov	r1, r2
 8004c00:	461a      	mov	r2, r3
 8004c02:	460b      	mov	r3, r1
 8004c04:	80fb      	strh	r3, [r7, #6]
 8004c06:	4613      	mov	r3, r2
 8004c08:	717b      	strb	r3, [r7, #5]
    if (!instance || !msg_descriptor || !msg_descriptor->serializer_func || !msg_data) {
 8004c0a:	68fb      	ldr	r3, [r7, #12]
 8004c0c:	2b00      	cmp	r3, #0
 8004c0e:	d009      	beq.n	8004c24 <_uavcan_send+0x30>
 8004c10:	68bb      	ldr	r3, [r7, #8]
 8004c12:	2b00      	cmp	r3, #0
 8004c14:	d006      	beq.n	8004c24 <_uavcan_send+0x30>
 8004c16:	68bb      	ldr	r3, [r7, #8]
 8004c18:	695b      	ldr	r3, [r3, #20]
 8004c1a:	2b00      	cmp	r3, #0
 8004c1c:	d002      	beq.n	8004c24 <_uavcan_send+0x30>
 8004c1e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004c20:	2b00      	cmp	r3, #0
 8004c22:	d101      	bne.n	8004c28 <_uavcan_send+0x34>
        return false;
 8004c24:	2300      	movs	r3, #0
 8004c26:	e183      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    if (_uavcan_get_node_id(instance) == 0 && (data_type_id > 0b11 || msg_descriptor->transfer_type != CanardTransferTypeBroadcast)) {
 8004c28:	68f8      	ldr	r0, [r7, #12]
 8004c2a:	f001 fdb7 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004c2e:	4603      	mov	r3, r0
 8004c30:	2b00      	cmp	r3, #0
 8004c32:	d108      	bne.n	8004c46 <_uavcan_send+0x52>
 8004c34:	88fb      	ldrh	r3, [r7, #6]
 8004c36:	2b03      	cmp	r3, #3
 8004c38:	d803      	bhi.n	8004c42 <_uavcan_send+0x4e>
 8004c3a:	68bb      	ldr	r3, [r7, #8]
 8004c3c:	7a9b      	ldrb	r3, [r3, #10]
 8004c3e:	2b02      	cmp	r3, #2
 8004c40:	d001      	beq.n	8004c46 <_uavcan_send+0x52>
        return false;
 8004c42:	2300      	movs	r3, #0
 8004c44:	e174      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    if (msg_descriptor->transfer_type != CanardTransferTypeBroadcast && data_type_id > 0xff) {
 8004c46:	68bb      	ldr	r3, [r7, #8]
 8004c48:	7a9b      	ldrb	r3, [r3, #10]
 8004c4a:	2b02      	cmp	r3, #2
 8004c4c:	d004      	beq.n	8004c58 <_uavcan_send+0x64>
 8004c4e:	88fb      	ldrh	r3, [r7, #6]
 8004c50:	2bff      	cmp	r3, #255	; 0xff
 8004c52:	d901      	bls.n	8004c58 <_uavcan_send+0x64>
        return false;
 8004c54:	2300      	movs	r3, #0
 8004c56:	e16b      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    if (_uavcan_get_node_id(instance) > 127) {
 8004c58:	68f8      	ldr	r0, [r7, #12]
 8004c5a:	f001 fd9f 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004c5e:	4603      	mov	r3, r0
 8004c60:	b2db      	uxtb	r3, r3
 8004c62:	b25b      	sxtb	r3, r3
 8004c64:	2b00      	cmp	r3, #0
 8004c66:	da01      	bge.n	8004c6c <_uavcan_send+0x78>
        return false;
 8004c68:	2300      	movs	r3, #0
 8004c6a:	e161      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    struct uavcan_transmit_state_s tx_state = {
 8004c6c:	2300      	movs	r3, #0
 8004c6e:	763b      	strb	r3, [r7, #24]
 8004c70:	68fb      	ldr	r3, [r7, #12]
 8004c72:	61fb      	str	r3, [r7, #28]
 8004c74:	2300      	movs	r3, #0
 8004c76:	623b      	str	r3, [r7, #32]
 8004c78:	2300      	movs	r3, #0
 8004c7a:	627b      	str	r3, [r7, #36]	; 0x24
 8004c7c:	2300      	movs	r3, #0
 8004c7e:	62bb      	str	r3, [r7, #40]	; 0x28
        false, instance, NULL, NULL, 0
    };

    msg_descriptor->serializer_func(msg_data, uavcan_transmit_chunk_handler, &tx_state);
 8004c80:	68bb      	ldr	r3, [r7, #8]
 8004c82:	695b      	ldr	r3, [r3, #20]
 8004c84:	f107 0218 	add.w	r2, r7, #24
 8004c88:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8004c8a:	49ab      	ldr	r1, [pc, #684]	; (8004f38 <_uavcan_send+0x344>)
 8004c8c:	4798      	blx	r3
    if (tx_state.failed || !tx_state.frame_list_head) {
 8004c8e:	7e3b      	ldrb	r3, [r7, #24]
 8004c90:	2b00      	cmp	r3, #0
 8004c92:	d102      	bne.n	8004c9a <_uavcan_send+0xa6>
 8004c94:	6a3b      	ldr	r3, [r7, #32]
 8004c96:	2b00      	cmp	r3, #0
 8004c98:	d10a      	bne.n	8004cb0 <_uavcan_send+0xbc>
        can_free_tx_frames(instance->can_instance, &tx_state.frame_list_head);
 8004c9a:	68fb      	ldr	r3, [r7, #12]
 8004c9c:	685a      	ldr	r2, [r3, #4]
 8004c9e:	f107 0318 	add.w	r3, r7, #24
 8004ca2:	3308      	adds	r3, #8
 8004ca4:	4610      	mov	r0, r2
 8004ca6:	4619      	mov	r1, r3
 8004ca8:	f000 fee2 	bl	8005a70 <can_free_tx_frames>
        return false;
 8004cac:	2300      	movs	r3, #0
 8004cae:	e13f      	b.n	8004f30 <_uavcan_send+0x33c>
    }

    /* debug message */
    LED_ON;
 8004cb0:	4ba2      	ldr	r3, [pc, #648]	; (8004f3c <_uavcan_send+0x348>)
 8004cb2:	2202      	movs	r2, #2
 8004cb4:	611a      	str	r2, [r3, #16]
    chnWrite(&SD1, (const uint8_t *)"snd\n", 5);
 8004cb6:	4ba2      	ldr	r3, [pc, #648]	; (8004f40 <_uavcan_send+0x34c>)
 8004cb8:	681b      	ldr	r3, [r3, #0]
 8004cba:	681b      	ldr	r3, [r3, #0]
 8004cbc:	48a0      	ldr	r0, [pc, #640]	; (8004f40 <_uavcan_send+0x34c>)
 8004cbe:	49a1      	ldr	r1, [pc, #644]	; (8004f44 <_uavcan_send+0x350>)
 8004cc0:	2205      	movs	r2, #5
 8004cc2:	4798      	blx	r3

    uint32_t can_id = 0;
 8004cc4:	2300      	movs	r3, #0
 8004cc6:	637b      	str	r3, [r7, #52]	; 0x34
    can_id |= (uint32_t)(priority&0x1f) << 24;
 8004cc8:	797b      	ldrb	r3, [r7, #5]
 8004cca:	f003 031f 	and.w	r3, r3, #31
 8004cce:	061b      	lsls	r3, r3, #24
 8004cd0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004cd2:	4313      	orrs	r3, r2
 8004cd4:	637b      	str	r3, [r7, #52]	; 0x34
    if (msg_descriptor->transfer_type == CanardTransferTypeBroadcast) {
 8004cd6:	68bb      	ldr	r3, [r7, #8]
 8004cd8:	7a9b      	ldrb	r3, [r3, #10]
 8004cda:	2b02      	cmp	r3, #2
 8004cdc:	d105      	bne.n	8004cea <_uavcan_send+0xf6>
        can_id |= (uint32_t)(data_type_id) << 8;
 8004cde:	88fb      	ldrh	r3, [r7, #6]
 8004ce0:	021b      	lsls	r3, r3, #8
 8004ce2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004ce4:	4313      	orrs	r3, r2
 8004ce6:	637b      	str	r3, [r7, #52]	; 0x34
 8004ce8:	e018      	b.n	8004d1c <_uavcan_send+0x128>
    } else {
        can_id |= data_type_id<<16;
 8004cea:	88fb      	ldrh	r3, [r7, #6]
 8004cec:	041b      	lsls	r3, r3, #16
 8004cee:	461a      	mov	r2, r3
 8004cf0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004cf2:	4313      	orrs	r3, r2
 8004cf4:	637b      	str	r3, [r7, #52]	; 0x34
        if (msg_descriptor->transfer_type == CanardTransferTypeRequest) {
 8004cf6:	68bb      	ldr	r3, [r7, #8]
 8004cf8:	7a9b      	ldrb	r3, [r3, #10]
 8004cfa:	2b01      	cmp	r3, #1
 8004cfc:	d103      	bne.n	8004d06 <_uavcan_send+0x112>
            can_id |= 1<<15;
 8004cfe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d00:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004d04:	637b      	str	r3, [r7, #52]	; 0x34
        }
        can_id |= dest_node_id<<8;
 8004d06:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8004d0a:	021b      	lsls	r3, r3, #8
 8004d0c:	461a      	mov	r2, r3
 8004d0e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d10:	4313      	orrs	r3, r2
 8004d12:	637b      	str	r3, [r7, #52]	; 0x34
        can_id |= 1<<7;
 8004d14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d16:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004d1a:	637b      	str	r3, [r7, #52]	; 0x34
    }

    if (_uavcan_get_node_id(instance) == 0) {
 8004d1c:	68f8      	ldr	r0, [r7, #12]
 8004d1e:	f001 fd3d 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004d22:	4603      	mov	r3, r0
 8004d24:	2b00      	cmp	r3, #0
 8004d26:	d110      	bne.n	8004d4a <_uavcan_send+0x156>
        can_id |= (uint32_t)(crc16_ccitt(tx_state.frame_list_head->content.data, 7, 0xffff) & 0xfffc)<<8;
 8004d28:	6a3b      	ldr	r3, [r7, #32]
 8004d2a:	3308      	adds	r3, #8
 8004d2c:	4618      	mov	r0, r3
 8004d2e:	2107      	movs	r1, #7
 8004d30:	f64f 72ff 	movw	r2, #65535	; 0xffff
<<<<<<< HEAD
 8004d34:	f002 ff32 	bl	8007b9c <crc16_ccitt>
=======
 8004d34:	f002 ff40 	bl	8007bb8 <crc16_ccitt>
>>>>>>> 752c83b... update binaries
 8004d38:	4603      	mov	r3, r0
 8004d3a:	461a      	mov	r2, r3
 8004d3c:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8004d40:	4013      	ands	r3, r2
 8004d42:	021b      	lsls	r3, r3, #8
 8004d44:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004d46:	4313      	orrs	r3, r2
 8004d48:	637b      	str	r3, [r7, #52]	; 0x34
    }

    can_id |= _uavcan_get_node_id(instance);
 8004d4a:	68f8      	ldr	r0, [r7, #12]
 8004d4c:	f001 fd26 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 8004d50:	4603      	mov	r3, r0
 8004d52:	461a      	mov	r2, r3
 8004d54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d56:	4313      	orrs	r3, r2
 8004d58:	637b      	str	r3, [r7, #52]	; 0x34

    uint8_t toggle = 0;
 8004d5a:	2300      	movs	r3, #0
 8004d5c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    struct can_tx_frame_s* frame = tx_state.frame_list_head;
 8004d60:	6a3b      	ldr	r3, [r7, #32]
 8004d62:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004d64:	e088      	b.n	8004e78 <_uavcan_send+0x284>
    while (frame != NULL) {
        frame->content.IDE = 1;
 8004d66:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004d68:	7813      	ldrb	r3, [r2, #0]
 8004d6a:	f043 0302 	orr.w	r3, r3, #2
 8004d6e:	7013      	strb	r3, [r2, #0]
        frame->content.RTR = 0;
 8004d70:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004d72:	7813      	ldrb	r3, [r2, #0]
 8004d74:	f36f 0300 	bfc	r3, #0, #1
 8004d78:	7013      	strb	r3, [r2, #0]
        frame->content.EID = can_id;
 8004d7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004d7c:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8004d80:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004d82:	6853      	ldr	r3, [r2, #4]
 8004d84:	f361 031c 	bfi	r3, r1, #0, #29
 8004d88:	6053      	str	r3, [r2, #4]
        if (frame == tx_state.frame_list_head) {
 8004d8a:	6a3a      	ldr	r2, [r7, #32]
 8004d8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004d8e:	429a      	cmp	r2, r3
 8004d90:	d115      	bne.n	8004dbe <_uavcan_send+0x1ca>
            frame->content.data[frame->content.DLC-1] |= 1<<7;
 8004d92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004d94:	781b      	ldrb	r3, [r3, #0]
 8004d96:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004d9a:	b2db      	uxtb	r3, r3
 8004d9c:	3b01      	subs	r3, #1
 8004d9e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004da0:	7812      	ldrb	r2, [r2, #0]
 8004da2:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004da6:	b2d2      	uxtb	r2, r2
 8004da8:	3a01      	subs	r2, #1
 8004daa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004dac:	440a      	add	r2, r1
 8004dae:	7a12      	ldrb	r2, [r2, #8]
 8004db0:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8004db4:	b2d1      	uxtb	r1, r2
 8004db6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004db8:	4413      	add	r3, r2
 8004dba:	460a      	mov	r2, r1
 8004dbc:	721a      	strb	r2, [r3, #8]
        }
        if (frame == tx_state.frame_list_tail) {
 8004dbe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004dc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004dc2:	429a      	cmp	r2, r3
 8004dc4:	d115      	bne.n	8004df2 <_uavcan_send+0x1fe>
            frame->content.data[frame->content.DLC-1] |= 1<<6;
 8004dc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004dc8:	781b      	ldrb	r3, [r3, #0]
 8004dca:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004dce:	b2db      	uxtb	r3, r3
 8004dd0:	3b01      	subs	r3, #1
 8004dd2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004dd4:	7812      	ldrb	r2, [r2, #0]
 8004dd6:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004dda:	b2d2      	uxtb	r2, r2
 8004ddc:	3a01      	subs	r2, #1
 8004dde:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004de0:	440a      	add	r2, r1
 8004de2:	7a12      	ldrb	r2, [r2, #8]
 8004de4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004de8:	b2d1      	uxtb	r1, r2
 8004dea:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004dec:	4413      	add	r3, r2
 8004dee:	460a      	mov	r2, r1
 8004df0:	721a      	strb	r2, [r3, #8]
        }
        frame->content.data[frame->content.DLC-1] |= toggle << 5;
 8004df2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004df4:	781b      	ldrb	r3, [r3, #0]
 8004df6:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004dfa:	b2db      	uxtb	r3, r3
 8004dfc:	3b01      	subs	r3, #1
 8004dfe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e00:	7812      	ldrb	r2, [r2, #0]
 8004e02:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004e06:	b2d2      	uxtb	r2, r2
 8004e08:	3a01      	subs	r2, #1
 8004e0a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004e0c:	440a      	add	r2, r1
 8004e0e:	7a12      	ldrb	r2, [r2, #8]
 8004e10:	b2d1      	uxtb	r1, r2
 8004e12:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 8004e16:	0152      	lsls	r2, r2, #5
 8004e18:	b2d2      	uxtb	r2, r2
 8004e1a:	430a      	orrs	r2, r1
 8004e1c:	b2d2      	uxtb	r2, r2
 8004e1e:	b2d1      	uxtb	r1, r2
 8004e20:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e22:	4413      	add	r3, r2
 8004e24:	460a      	mov	r2, r1
 8004e26:	721a      	strb	r2, [r3, #8]
        frame->content.data[frame->content.DLC-1] |= transfer_id&0x1f;
 8004e28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e2a:	781b      	ldrb	r3, [r3, #0]
 8004e2c:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004e30:	b2db      	uxtb	r3, r3
 8004e32:	3b01      	subs	r3, #1
 8004e34:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e36:	7812      	ldrb	r2, [r2, #0]
 8004e38:	f3c2 0283 	ubfx	r2, r2, #2, #4
 8004e3c:	b2d2      	uxtb	r2, r2
 8004e3e:	3a01      	subs	r2, #1
 8004e40:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004e42:	440a      	add	r2, r1
 8004e44:	7a12      	ldrb	r2, [r2, #8]
 8004e46:	b2d1      	uxtb	r1, r2
 8004e48:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8004e4c:	f002 021f 	and.w	r2, r2, #31
 8004e50:	b2d2      	uxtb	r2, r2
 8004e52:	430a      	orrs	r2, r1
 8004e54:	b2d2      	uxtb	r2, r2
 8004e56:	b2d1      	uxtb	r1, r2
 8004e58:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004e5a:	4413      	add	r3, r2
 8004e5c:	460a      	mov	r2, r1
 8004e5e:	721a      	strb	r2, [r3, #8]

        toggle = toggle?0:1;
 8004e60:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8004e64:	2b00      	cmp	r3, #0
 8004e66:	bf0c      	ite	eq
 8004e68:	2301      	moveq	r3, #1
 8004e6a:	2300      	movne	r3, #0
 8004e6c:	b2db      	uxtb	r3, r3
 8004e6e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

        frame = frame->next;
 8004e72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e74:	699b      	ldr	r3, [r3, #24]
 8004e76:	62fb      	str	r3, [r7, #44]	; 0x2c

    can_id |= _uavcan_get_node_id(instance);

    uint8_t toggle = 0;
    struct can_tx_frame_s* frame = tx_state.frame_list_head;
    while (frame != NULL) {
 8004e78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004e7a:	2b00      	cmp	r3, #0
 8004e7c:	f47f af73 	bne.w	8004d66 <_uavcan_send+0x172>
        toggle = toggle?0:1;

        frame = frame->next;
    }

    if (tx_state.frame_list_head != tx_state.frame_list_tail) {
 8004e80:	6a3a      	ldr	r2, [r7, #32]
 8004e82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004e84:	429a      	cmp	r2, r3
 8004e86:	d046      	beq.n	8004f16 <_uavcan_send+0x322>
        uint16_t crc16 = crc16_ccitt((void*)&msg_descriptor->data_type_signature, 8, 0xffff);
 8004e88:	68bb      	ldr	r3, [r7, #8]
 8004e8a:	4618      	mov	r0, r3
 8004e8c:	2108      	movs	r1, #8
 8004e8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
<<<<<<< HEAD
 8004e92:	f002 fe83 	bl	8007b9c <crc16_ccitt>
=======
 8004e92:	f002 fe91 	bl	8007bb8 <crc16_ccitt>
>>>>>>> 752c83b... update binaries
 8004e96:	4603      	mov	r3, r0
 8004e98:	82fb      	strh	r3, [r7, #22]

        frame = tx_state.frame_list_head;
 8004e9a:	6a3b      	ldr	r3, [r7, #32]
 8004e9c:	62fb      	str	r3, [r7, #44]	; 0x2c
        crc16 = crc16_ccitt(&frame->content.data[2], 5, crc16);
 8004e9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ea0:	f103 020a 	add.w	r2, r3, #10
 8004ea4:	8afb      	ldrh	r3, [r7, #22]
 8004ea6:	4610      	mov	r0, r2
 8004ea8:	2105      	movs	r1, #5
 8004eaa:	461a      	mov	r2, r3
<<<<<<< HEAD
 8004eac:	f002 fe76 	bl	8007b9c <crc16_ccitt>
=======
 8004eac:	f002 fe84 	bl	8007bb8 <crc16_ccitt>
>>>>>>> 752c83b... update binaries
 8004eb0:	4603      	mov	r3, r0
 8004eb2:	82fb      	strh	r3, [r7, #22]
        frame = frame->next;
 8004eb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004eb6:	699b      	ldr	r3, [r3, #24]
 8004eb8:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004eba:	e00d      	b.n	8004ed8 <_uavcan_send+0x2e4>

        while (frame->next != NULL) {
            crc16 = crc16_ccitt(&frame->content.data[0], 7, crc16);
 8004ebc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ebe:	f103 0208 	add.w	r2, r3, #8
 8004ec2:	8afb      	ldrh	r3, [r7, #22]
 8004ec4:	4610      	mov	r0, r2
 8004ec6:	2107      	movs	r1, #7
 8004ec8:	461a      	mov	r2, r3
<<<<<<< HEAD
 8004eca:	f002 fe67 	bl	8007b9c <crc16_ccitt>
=======
 8004eca:	f002 fe75 	bl	8007bb8 <crc16_ccitt>
>>>>>>> 752c83b... update binaries
 8004ece:	4603      	mov	r3, r0
 8004ed0:	82fb      	strh	r3, [r7, #22]
            frame = frame->next;
 8004ed2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ed4:	699b      	ldr	r3, [r3, #24]
 8004ed6:	62fb      	str	r3, [r7, #44]	; 0x2c

        frame = tx_state.frame_list_head;
        crc16 = crc16_ccitt(&frame->content.data[2], 5, crc16);
        frame = frame->next;

        while (frame->next != NULL) {
 8004ed8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004eda:	699b      	ldr	r3, [r3, #24]
 8004edc:	2b00      	cmp	r3, #0
 8004ede:	d1ed      	bne.n	8004ebc <_uavcan_send+0x2c8>
            crc16 = crc16_ccitt(&frame->content.data[0], 7, crc16);
            frame = frame->next;
        }
        crc16 = crc16_ccitt(&frame->content.data[0], frame->content.DLC-1, crc16);
 8004ee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ee2:	f103 0208 	add.w	r2, r3, #8
 8004ee6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ee8:	781b      	ldrb	r3, [r3, #0]
 8004eea:	f3c3 0383 	ubfx	r3, r3, #2, #4
 8004eee:	b2db      	uxtb	r3, r3
 8004ef0:	3b01      	subs	r3, #1
 8004ef2:	4619      	mov	r1, r3
 8004ef4:	8afb      	ldrh	r3, [r7, #22]
 8004ef6:	4610      	mov	r0, r2
 8004ef8:	461a      	mov	r2, r3
<<<<<<< HEAD
 8004efa:	f002 fe4f 	bl	8007b9c <crc16_ccitt>
=======
 8004efa:	f002 fe5d 	bl	8007bb8 <crc16_ccitt>
>>>>>>> 752c83b... update binaries
 8004efe:	4603      	mov	r3, r0
 8004f00:	82fb      	strh	r3, [r7, #22]
        memcpy(tx_state.frame_list_head->content.data, &crc16, 2);
 8004f02:	6a3b      	ldr	r3, [r7, #32]
 8004f04:	f103 0208 	add.w	r2, r3, #8
 8004f08:	f107 0316 	add.w	r3, r7, #22
 8004f0c:	4610      	mov	r0, r2
 8004f0e:	4619      	mov	r1, r3
 8004f10:	2202      	movs	r2, #2
<<<<<<< HEAD
 8004f12:	f009 fb33 	bl	800e57c <memcpy>
=======
 8004f12:	f009 fb77 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries
    }

    can_enqueue_tx_frames(instance->can_instance, &tx_state.frame_list_head, TIME_INFINITE, NULL);
 8004f16:	68fb      	ldr	r3, [r7, #12]
 8004f18:	685a      	ldr	r2, [r3, #4]
 8004f1a:	f107 0318 	add.w	r3, r7, #24
 8004f1e:	3308      	adds	r3, #8
 8004f20:	4610      	mov	r0, r2
 8004f22:	4619      	mov	r1, r3
 8004f24:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8004f28:	2300      	movs	r3, #0
 8004f2a:	f000 fd63 	bl	80059f4 <can_enqueue_tx_frames>

    return true;
 8004f2e:	2301      	movs	r3, #1
}
 8004f30:	4618      	mov	r0, r3
 8004f32:	3738      	adds	r7, #56	; 0x38
 8004f34:	46bd      	mov	sp, r7
 8004f36:	bd80      	pop	{r7, pc}
 8004f38:	08004b11 	.word	0x08004b11
 8004f3c:	40010c00 	.word	0x40010c00
 8004f40:	200013ac 	.word	0x200013ac
<<<<<<< HEAD
 8004f44:	0800e62c 	.word	0x0800e62c
=======
 8004f44:	0800e6b4 	.word	0x0800e6b4
>>>>>>> 752c83b... update binaries

08004f48 <uavcan_broadcast>:

bool uavcan_broadcast(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* const msg_descriptor, uint8_t priority, void* msg_data) {
 8004f48:	b590      	push	{r4, r7, lr}
 8004f4a:	b08d      	sub	sp, #52	; 0x34
 8004f4c:	af04      	add	r7, sp, #16
 8004f4e:	60b9      	str	r1, [r7, #8]
 8004f50:	607b      	str	r3, [r7, #4]
 8004f52:	4603      	mov	r3, r0
 8004f54:	73fb      	strb	r3, [r7, #15]
 8004f56:	4613      	mov	r3, r2
 8004f58:	73bb      	strb	r3, [r7, #14]
    struct uavcan_instance_s* instance = uavcan_get_instance(uavcan_idx);
 8004f5a:	7bfb      	ldrb	r3, [r7, #15]
 8004f5c:	4618      	mov	r0, r3
 8004f5e:	f000 f8af 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8004f62:	61f8      	str	r0, [r7, #28]
    if (!instance) {
 8004f64:	69fb      	ldr	r3, [r7, #28]
 8004f66:	2b00      	cmp	r3, #0
 8004f68:	d101      	bne.n	8004f6e <uavcan_broadcast+0x26>
        return false;
 8004f6a:	2300      	movs	r3, #0
 8004f6c:	e02b      	b.n	8004fc6 <uavcan_broadcast+0x7e>
    }

    uint16_t data_type_id = msg_descriptor->default_data_type_id;
 8004f6e:	68bb      	ldr	r3, [r7, #8]
 8004f70:	891b      	ldrh	r3, [r3, #8]
 8004f72:	837b      	strh	r3, [r7, #26]
    chSysLock();
 8004f74:	f001 f9fa 	bl	800636c <chSysLock.lto_priv.77>
    uint8_t* transfer_id = uavcan_transfer_id_map_retrieve(&instance->transfer_id_map, false, data_type_id, 0);
 8004f78:	69fb      	ldr	r3, [r7, #28]
 8004f7a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8004f7e:	8b7b      	ldrh	r3, [r7, #26]
 8004f80:	4610      	mov	r0, r2
 8004f82:	2100      	movs	r1, #0
 8004f84:	461a      	mov	r2, r3
 8004f86:	2300      	movs	r3, #0
 8004f88:	f000 fa22 	bl	80053d0 <uavcan_transfer_id_map_retrieve>
 8004f8c:	6178      	str	r0, [r7, #20]
    chSysUnlock();
 8004f8e:	f001 f9f5 	bl	800637c <chSysUnlock.lto_priv.76>
    if(_uavcan_send(instance, msg_descriptor, data_type_id, priority, *transfer_id, 0, msg_data)) {
 8004f92:	697b      	ldr	r3, [r7, #20]
 8004f94:	781b      	ldrb	r3, [r3, #0]
 8004f96:	8b7a      	ldrh	r2, [r7, #26]
 8004f98:	7bbc      	ldrb	r4, [r7, #14]
 8004f9a:	9300      	str	r3, [sp, #0]
 8004f9c:	2300      	movs	r3, #0
 8004f9e:	9301      	str	r3, [sp, #4]
 8004fa0:	687b      	ldr	r3, [r7, #4]
 8004fa2:	9302      	str	r3, [sp, #8]
 8004fa4:	69f8      	ldr	r0, [r7, #28]
 8004fa6:	68b9      	ldr	r1, [r7, #8]
 8004fa8:	4623      	mov	r3, r4
 8004faa:	f7ff fe23 	bl	8004bf4 <_uavcan_send>
 8004fae:	4603      	mov	r3, r0
 8004fb0:	2b00      	cmp	r3, #0
 8004fb2:	d007      	beq.n	8004fc4 <uavcan_broadcast+0x7c>
        (*transfer_id)++;
 8004fb4:	697b      	ldr	r3, [r7, #20]
 8004fb6:	781b      	ldrb	r3, [r3, #0]
 8004fb8:	3301      	adds	r3, #1
 8004fba:	b2da      	uxtb	r2, r3
 8004fbc:	697b      	ldr	r3, [r7, #20]
 8004fbe:	701a      	strb	r2, [r3, #0]
        return true;
 8004fc0:	2301      	movs	r3, #1
 8004fc2:	e000      	b.n	8004fc6 <uavcan_broadcast+0x7e>
    } else {
        return false;
 8004fc4:	2300      	movs	r3, #0
    }
}
 8004fc6:	4618      	mov	r0, r3
 8004fc8:	3724      	adds	r7, #36	; 0x24
 8004fca:	46bd      	mov	sp, r7
 8004fcc:	bd90      	pop	{r4, r7, pc}
 8004fce:	bf00      	nop

08004fd0 <uavcan_respond>:
    } else {
        return false;
    }
}

bool uavcan_respond(uint8_t uavcan_idx, const struct uavcan_deserialized_message_s* const req_msg, void* msg_data) {
 8004fd0:	b590      	push	{r4, r7, lr}
 8004fd2:	b08d      	sub	sp, #52	; 0x34
 8004fd4:	af04      	add	r7, sp, #16
 8004fd6:	4603      	mov	r3, r0
 8004fd8:	60b9      	str	r1, [r7, #8]
 8004fda:	607a      	str	r2, [r7, #4]
 8004fdc:	73fb      	strb	r3, [r7, #15]
    struct uavcan_instance_s* instance = uavcan_get_instance(uavcan_idx);
 8004fde:	7bfb      	ldrb	r3, [r7, #15]
 8004fe0:	4618      	mov	r0, r3
 8004fe2:	f000 f86d 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8004fe6:	61f8      	str	r0, [r7, #28]
    if (!instance) {
 8004fe8:	69fb      	ldr	r3, [r7, #28]
 8004fea:	2b00      	cmp	r3, #0
 8004fec:	d101      	bne.n	8004ff2 <uavcan_respond+0x22>
        return false;
 8004fee:	2300      	movs	r3, #0
 8004ff0:	e01d      	b.n	800502e <uavcan_respond+0x5e>
    }

    const struct uavcan_message_descriptor_s* msg_descriptor = req_msg->descriptor->resp_descriptor;
 8004ff2:	68bb      	ldr	r3, [r7, #8]
 8004ff4:	685b      	ldr	r3, [r3, #4]
 8004ff6:	69db      	ldr	r3, [r3, #28]
 8004ff8:	61bb      	str	r3, [r7, #24]
    uint8_t priority = req_msg->priority;
 8004ffa:	68bb      	ldr	r3, [r7, #8]
 8004ffc:	7adb      	ldrb	r3, [r3, #11]
 8004ffe:	75fb      	strb	r3, [r7, #23]
    uint8_t transfer_id = req_msg->transfer_id;
 8005000:	68bb      	ldr	r3, [r7, #8]
 8005002:	7a9b      	ldrb	r3, [r3, #10]
 8005004:	75bb      	strb	r3, [r7, #22]
    uint8_t dest_node_id = req_msg->source_node_id;
 8005006:	68bb      	ldr	r3, [r7, #8]
 8005008:	7b1b      	ldrb	r3, [r3, #12]
 800500a:	757b      	strb	r3, [r7, #21]
    uint16_t data_type_id = msg_descriptor->default_data_type_id;
 800500c:	69bb      	ldr	r3, [r7, #24]
 800500e:	891b      	ldrh	r3, [r3, #8]
 8005010:	827b      	strh	r3, [r7, #18]
    return _uavcan_send(instance, msg_descriptor, data_type_id, priority, transfer_id, dest_node_id, msg_data);
 8005012:	8a7a      	ldrh	r2, [r7, #18]
 8005014:	7dfc      	ldrb	r4, [r7, #23]
 8005016:	7dbb      	ldrb	r3, [r7, #22]
 8005018:	9300      	str	r3, [sp, #0]
 800501a:	7d7b      	ldrb	r3, [r7, #21]
 800501c:	9301      	str	r3, [sp, #4]
 800501e:	687b      	ldr	r3, [r7, #4]
 8005020:	9302      	str	r3, [sp, #8]
 8005022:	69f8      	ldr	r0, [r7, #28]
 8005024:	69b9      	ldr	r1, [r7, #24]
 8005026:	4623      	mov	r3, r4
 8005028:	f7ff fde4 	bl	8004bf4 <_uavcan_send>
 800502c:	4603      	mov	r3, r0
}
 800502e:	4618      	mov	r0, r3
 8005030:	3724      	adds	r7, #36	; 0x24
 8005032:	46bd      	mov	sp, r7
 8005034:	bd90      	pop	{r4, r7, pc}
 8005036:	bf00      	nop

08005038 <uavcan_can_rx_handler.lto_priv.81>:

static void uavcan_can_rx_handler(size_t msg_size, const void* msg, void* ctx) {
 8005038:	b580      	push	{r7, lr}
 800503a:	b08c      	sub	sp, #48	; 0x30
 800503c:	af00      	add	r7, sp, #0
 800503e:	60f8      	str	r0, [r7, #12]
 8005040:	60b9      	str	r1, [r7, #8]
 8005042:	607a      	str	r2, [r7, #4]
    (void) msg_size;
    struct uavcan_instance_s* instance = ctx;
 8005044:	687b      	ldr	r3, [r7, #4]
 8005046:	62fb      	str	r3, [r7, #44]	; 0x2c

    const struct can_rx_frame_s* frame = msg;
 8005048:	68bb      	ldr	r3, [r7, #8]
 800504a:	62bb      	str	r3, [r7, #40]	; 0x28

    CanardCANFrame canard_frame = convert_can_frame_to_CanardCANFrame(&frame->content);
 800504c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800504e:	f107 0210 	add.w	r2, r7, #16
 8005052:	4610      	mov	r0, r2
 8005054:	4619      	mov	r1, r3
 8005056:	f000 f893 	bl	8005180 <convert_can_frame_to_CanardCANFrame>

    uint64_t timestamp = micros64();
<<<<<<< HEAD
 800505a:	f002 fe51 	bl	8007d00 <micros64>
=======
 800505a:	f002 fe85 	bl	8007d68 <micros64>
>>>>>>> 752c83b... update binaries
 800505e:	e9c7 0108 	strd	r0, r1, [r7, #32]
    canardHandleRxFrame(&instance->canard, &canard_frame, timestamp);
 8005062:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005064:	f103 0208 	add.w	r2, r3, #8
 8005068:	f107 0310 	add.w	r3, r7, #16
 800506c:	4610      	mov	r0, r2
 800506e:	4619      	mov	r1, r3
 8005070:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
<<<<<<< HEAD
 8005074:	f007 fd34 	bl	800cae0 <canardHandleRxFrame>
=======
 8005074:	f007 fd78 	bl	800cb68 <canardHandleRxFrame>
>>>>>>> 752c83b... update binaries

    /* debug message */
    LED_OFF;
 8005078:	4b02      	ldr	r3, [pc, #8]	; (8005084 <uavcan_can_rx_handler.lto_priv.81+0x4c>)
 800507a:	2202      	movs	r2, #2
 800507c:	615a      	str	r2, [r3, #20]
//    chnWrite(&SD1, (const uint8_t *)"rcv\n", 5);
}
 800507e:	3730      	adds	r7, #48	; 0x30
 8005080:	46bd      	mov	sp, r7
 8005082:	bd80      	pop	{r7, pc}
 8005084:	40010c00 	.word	0x40010c00

08005088 <stale_transfer_cleanup_task_func.lto_priv.83>:

static void stale_transfer_cleanup_task_func(struct worker_thread_timer_task_s* task) {
 8005088:	b590      	push	{r4, r7, lr}
 800508a:	b085      	sub	sp, #20
 800508c:	af00      	add	r7, sp, #0
 800508e:	6078      	str	r0, [r7, #4]
    (void)task;
    struct uavcan_instance_s* instance = NULL;
 8005090:	2300      	movs	r3, #0
 8005092:	60fb      	str	r3, [r7, #12]
 8005094:	e009      	b.n	80050aa <stale_transfer_cleanup_task_func.lto_priv.83+0x22>

    while (uavcan_iterate_instances(&instance)) {
        canardCleanupStaleTransfers(&instance->canard, micros64());
 8005096:	68fb      	ldr	r3, [r7, #12]
 8005098:	f103 0408 	add.w	r4, r3, #8
<<<<<<< HEAD
 800509c:	f002 fe30 	bl	8007d00 <micros64>
 80050a0:	4602      	mov	r2, r0
 80050a2:	460b      	mov	r3, r1
 80050a4:	4620      	mov	r0, r4
 80050a6:	f008 f849 	bl	800d13c <canardCleanupStaleTransfers>
=======
 800509c:	f002 fe64 	bl	8007d68 <micros64>
 80050a0:	4602      	mov	r2, r0
 80050a2:	460b      	mov	r3, r1
 80050a4:	4620      	mov	r0, r4
 80050a6:	f008 f88d 	bl	800d1c4 <canardCleanupStaleTransfers>
>>>>>>> 752c83b... update binaries

static void stale_transfer_cleanup_task_func(struct worker_thread_timer_task_s* task) {
    (void)task;
    struct uavcan_instance_s* instance = NULL;

    while (uavcan_iterate_instances(&instance)) {
 80050aa:	f107 030c 	add.w	r3, r7, #12
 80050ae:	4618      	mov	r0, r3
 80050b0:	f001 fad4 	bl	800665c <uavcan_iterate_instances.lto_priv.75>
 80050b4:	4603      	mov	r3, r0
 80050b6:	2b00      	cmp	r3, #0
 80050b8:	d1ed      	bne.n	8005096 <stale_transfer_cleanup_task_func.lto_priv.83+0xe>
        canardCleanupStaleTransfers(&instance->canard, micros64());
    }
}
 80050ba:	3714      	adds	r7, #20
 80050bc:	46bd      	mov	sp, r7
 80050be:	bd90      	pop	{r4, r7, pc}

080050c0 <uavcan_get_instance.lto_priv.96>:

static struct uavcan_instance_s* uavcan_get_instance(uint8_t idx) {
 80050c0:	b480      	push	{r7}
 80050c2:	b085      	sub	sp, #20
 80050c4:	af00      	add	r7, sp, #0
 80050c6:	4603      	mov	r3, r0
 80050c8:	71fb      	strb	r3, [r7, #7]
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 80050ca:	4b0e      	ldr	r3, [pc, #56]	; (8005104 <uavcan_get_instance.lto_priv.96+0x44>)
 80050cc:	681b      	ldr	r3, [r3, #0]
 80050ce:	60fb      	str	r3, [r7, #12]
 80050d0:	e005      	b.n	80050de <uavcan_get_instance.lto_priv.96+0x1e>
    while (instance && idx != 0) {
        idx--;
 80050d2:	79fb      	ldrb	r3, [r7, #7]
 80050d4:	3b01      	subs	r3, #1
 80050d6:	71fb      	strb	r3, [r7, #7]
        instance = instance->next;
 80050d8:	68fb      	ldr	r3, [r7, #12]
 80050da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80050dc:	60fb      	str	r3, [r7, #12]
    }
}

static struct uavcan_instance_s* uavcan_get_instance(uint8_t idx) {
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    while (instance && idx != 0) {
 80050de:	68fb      	ldr	r3, [r7, #12]
 80050e0:	2b00      	cmp	r3, #0
 80050e2:	d002      	beq.n	80050ea <uavcan_get_instance.lto_priv.96+0x2a>
 80050e4:	79fb      	ldrb	r3, [r7, #7]
 80050e6:	2b00      	cmp	r3, #0
 80050e8:	d1f3      	bne.n	80050d2 <uavcan_get_instance.lto_priv.96+0x12>
        idx--;
        instance = instance->next;
    }

    if (idx != 0) {
 80050ea:	79fb      	ldrb	r3, [r7, #7]
 80050ec:	2b00      	cmp	r3, #0
 80050ee:	d001      	beq.n	80050f4 <uavcan_get_instance.lto_priv.96+0x34>
        return NULL;
 80050f0:	2300      	movs	r3, #0
 80050f2:	e000      	b.n	80050f6 <uavcan_get_instance.lto_priv.96+0x36>
    } else {
        return instance;
 80050f4:	68fb      	ldr	r3, [r7, #12]
    }
}
 80050f6:	4618      	mov	r0, r3
 80050f8:	3714      	adds	r7, #20
 80050fa:	46bd      	mov	sp, r7
 80050fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005100:	4770      	bx	lr
 8005102:	bf00      	nop
 8005104:	200014a8 	.word	0x200014a8

08005108 <uavcan_get_num_instances>:

uint8_t uavcan_get_num_instances(void) {
 8005108:	b480      	push	{r7}
 800510a:	b083      	sub	sp, #12
 800510c:	af00      	add	r7, sp, #0
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 800510e:	4b0b      	ldr	r3, [pc, #44]	; (800513c <uavcan_get_num_instances+0x34>)
 8005110:	681b      	ldr	r3, [r3, #0]
 8005112:	607b      	str	r3, [r7, #4]
    uint8_t count = 0;
 8005114:	2300      	movs	r3, #0
 8005116:	70fb      	strb	r3, [r7, #3]
 8005118:	e005      	b.n	8005126 <uavcan_get_num_instances+0x1e>
    while (instance) {
        count++;
 800511a:	78fb      	ldrb	r3, [r7, #3]
 800511c:	3301      	adds	r3, #1
 800511e:	70fb      	strb	r3, [r7, #3]
        instance = instance->next;
 8005120:	687b      	ldr	r3, [r7, #4]
 8005122:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005124:	607b      	str	r3, [r7, #4]
}

uint8_t uavcan_get_num_instances(void) {
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    uint8_t count = 0;
    while (instance) {
 8005126:	687b      	ldr	r3, [r7, #4]
 8005128:	2b00      	cmp	r3, #0
 800512a:	d1f6      	bne.n	800511a <uavcan_get_num_instances+0x12>
        count++;
        instance = instance->next;
    }
    return count;
 800512c:	78fb      	ldrb	r3, [r7, #3]
}
 800512e:	4618      	mov	r0, r3
 8005130:	370c      	adds	r7, #12
 8005132:	46bd      	mov	sp, r7
 8005134:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005138:	4770      	bx	lr
 800513a:	bf00      	nop
 800513c:	200014a8 	.word	0x200014a8

08005140 <uavcan_get_idx.lto_priv.98>:

static uint8_t uavcan_get_idx(struct uavcan_instance_s* instance_arg) {
 8005140:	b480      	push	{r7}
 8005142:	b085      	sub	sp, #20
 8005144:	af00      	add	r7, sp, #0
 8005146:	6078      	str	r0, [r7, #4]
    uint8_t idx = 0;
 8005148:	2300      	movs	r3, #0
 800514a:	73fb      	strb	r3, [r7, #15]
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
 800514c:	4b0b      	ldr	r3, [pc, #44]	; (800517c <uavcan_get_idx.lto_priv.98+0x3c>)
 800514e:	681b      	ldr	r3, [r3, #0]
 8005150:	60bb      	str	r3, [r7, #8]
 8005152:	e005      	b.n	8005160 <uavcan_get_idx.lto_priv.98+0x20>
    while (instance && instance != instance_arg) {
        idx++;
 8005154:	7bfb      	ldrb	r3, [r7, #15]
 8005156:	3301      	adds	r3, #1
 8005158:	73fb      	strb	r3, [r7, #15]
        instance = instance->next;
 800515a:	68bb      	ldr	r3, [r7, #8]
 800515c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800515e:	60bb      	str	r3, [r7, #8]
}

static uint8_t uavcan_get_idx(struct uavcan_instance_s* instance_arg) {
    uint8_t idx = 0;
    struct uavcan_instance_s* instance = uavcan_instance_list_head;
    while (instance && instance != instance_arg) {
 8005160:	68bb      	ldr	r3, [r7, #8]
 8005162:	2b00      	cmp	r3, #0
 8005164:	d003      	beq.n	800516e <uavcan_get_idx.lto_priv.98+0x2e>
 8005166:	68ba      	ldr	r2, [r7, #8]
 8005168:	687b      	ldr	r3, [r7, #4]
 800516a:	429a      	cmp	r2, r3
 800516c:	d1f2      	bne.n	8005154 <uavcan_get_idx.lto_priv.98+0x14>
        idx++;
        instance = instance->next;
    }
    return idx;
 800516e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005170:	4618      	mov	r0, r3
 8005172:	3714      	adds	r7, #20
 8005174:	46bd      	mov	sp, r7
 8005176:	f85d 7b04 	ldr.w	r7, [sp], #4
 800517a:	4770      	bx	lr
 800517c:	200014a8 	.word	0x200014a8

08005180 <convert_can_frame_to_CanardCANFrame>:

static CanardCANFrame convert_can_frame_to_CanardCANFrame(const struct can_frame_s* frame) {
 8005180:	b590      	push	{r4, r7, lr}
 8005182:	b087      	sub	sp, #28
 8005184:	af00      	add	r7, sp, #0
 8005186:	6078      	str	r0, [r7, #4]
 8005188:	6039      	str	r1, [r7, #0]
    CanardCANFrame ret;
    if (frame->IDE) {
 800518a:	683b      	ldr	r3, [r7, #0]
 800518c:	781b      	ldrb	r3, [r3, #0]
 800518e:	f003 0302 	and.w	r3, r3, #2
 8005192:	b2db      	uxtb	r3, r3
 8005194:	2b00      	cmp	r3, #0
 8005196:	d007      	beq.n	80051a8 <convert_can_frame_to_CanardCANFrame+0x28>
        ret.id = frame->EID | CANARD_CAN_FRAME_EFF;
 8005198:	683b      	ldr	r3, [r7, #0]
 800519a:	685b      	ldr	r3, [r3, #4]
 800519c:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80051a0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80051a4:	60bb      	str	r3, [r7, #8]
 80051a6:	e005      	b.n	80051b4 <convert_can_frame_to_CanardCANFrame+0x34>
    } else {
        ret.id = frame->SID;
 80051a8:	683b      	ldr	r3, [r7, #0]
 80051aa:	889b      	ldrh	r3, [r3, #4]
 80051ac:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80051b0:	b29b      	uxth	r3, r3
 80051b2:	60bb      	str	r3, [r7, #8]
    }

    if (frame->RTR) {
 80051b4:	683b      	ldr	r3, [r7, #0]
 80051b6:	781b      	ldrb	r3, [r3, #0]
 80051b8:	f003 0301 	and.w	r3, r3, #1
 80051bc:	b2db      	uxtb	r3, r3
 80051be:	2b00      	cmp	r3, #0
 80051c0:	d003      	beq.n	80051ca <convert_can_frame_to_CanardCANFrame+0x4a>
        ret.id |= CANARD_CAN_FRAME_RTR;
 80051c2:	68bb      	ldr	r3, [r7, #8]
 80051c4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80051c8:	60bb      	str	r3, [r7, #8]
    }

    ret.data_len = frame->DLC;
 80051ca:	683b      	ldr	r3, [r7, #0]
 80051cc:	781b      	ldrb	r3, [r3, #0]
 80051ce:	f3c3 0383 	ubfx	r3, r3, #2, #4
 80051d2:	b2db      	uxtb	r3, r3
 80051d4:	753b      	strb	r3, [r7, #20]
    memcpy(ret.data, frame->data, ret.data_len);
 80051d6:	683b      	ldr	r3, [r7, #0]
 80051d8:	f103 0208 	add.w	r2, r3, #8
 80051dc:	7d3b      	ldrb	r3, [r7, #20]
 80051de:	461c      	mov	r4, r3
 80051e0:	f107 0308 	add.w	r3, r7, #8
 80051e4:	3304      	adds	r3, #4
 80051e6:	4618      	mov	r0, r3
 80051e8:	4611      	mov	r1, r2
 80051ea:	4622      	mov	r2, r4
<<<<<<< HEAD
 80051ec:	f009 f9c6 	bl	800e57c <memcpy>
=======
 80051ec:	f009 fa0a 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries
    return ret;
 80051f0:	687b      	ldr	r3, [r7, #4]
 80051f2:	461c      	mov	r4, r3
 80051f4:	f107 0308 	add.w	r3, r7, #8
 80051f8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80051fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 80051fe:	6878      	ldr	r0, [r7, #4]
 8005200:	371c      	adds	r7, #28
 8005202:	46bd      	mov	sp, r7
 8005204:	bd90      	pop	{r4, r7, pc}
 8005206:	bf00      	nop

08005208 <uavcan_message_writer_func>:
    uint8_t uavcan_idx;
    CanardRxTransfer* transfer;
    const struct uavcan_message_descriptor_s* const descriptor;
};

static void uavcan_message_writer_func(size_t msg_size, void* write_buf, void* ctx) {
 8005208:	b580      	push	{r7, lr}
 800520a:	b086      	sub	sp, #24
 800520c:	af00      	add	r7, sp, #0
 800520e:	60f8      	str	r0, [r7, #12]
 8005210:	60b9      	str	r1, [r7, #8]
 8005212:	607a      	str	r2, [r7, #4]
    (void)msg_size;
    struct uavcan_message_writer_func_args* args = ctx;
 8005214:	687b      	ldr	r3, [r7, #4]
 8005216:	617b      	str	r3, [r7, #20]
    struct uavcan_deserialized_message_s* deserialized_message = write_buf;
 8005218:	68bb      	ldr	r3, [r7, #8]
 800521a:	613b      	str	r3, [r7, #16]
    deserialized_message->uavcan_idx = args->uavcan_idx;
 800521c:	697b      	ldr	r3, [r7, #20]
 800521e:	781a      	ldrb	r2, [r3, #0]
 8005220:	693b      	ldr	r3, [r7, #16]
 8005222:	701a      	strb	r2, [r3, #0]
    deserialized_message->descriptor = args->descriptor;
 8005224:	697b      	ldr	r3, [r7, #20]
 8005226:	689a      	ldr	r2, [r3, #8]
 8005228:	693b      	ldr	r3, [r7, #16]
 800522a:	605a      	str	r2, [r3, #4]
    deserialized_message->data_type_id = args->transfer->data_type_id;
 800522c:	697b      	ldr	r3, [r7, #20]
 800522e:	685b      	ldr	r3, [r3, #4]
 8005230:	8ada      	ldrh	r2, [r3, #22]
 8005232:	693b      	ldr	r3, [r7, #16]
 8005234:	811a      	strh	r2, [r3, #8]
    deserialized_message->transfer_id = args->transfer->transfer_id;
 8005236:	697b      	ldr	r3, [r7, #20]
 8005238:	685b      	ldr	r3, [r3, #4]
 800523a:	7e5a      	ldrb	r2, [r3, #25]
 800523c:	693b      	ldr	r3, [r7, #16]
 800523e:	729a      	strb	r2, [r3, #10]
    deserialized_message->priority = args->transfer->priority;
 8005240:	697b      	ldr	r3, [r7, #20]
 8005242:	685b      	ldr	r3, [r3, #4]
 8005244:	7e9a      	ldrb	r2, [r3, #26]
 8005246:	693b      	ldr	r3, [r7, #16]
 8005248:	72da      	strb	r2, [r3, #11]
    deserialized_message->source_node_id = args->transfer->source_node_id;
 800524a:	697b      	ldr	r3, [r7, #20]
 800524c:	685b      	ldr	r3, [r3, #4]
 800524e:	7eda      	ldrb	r2, [r3, #27]
 8005250:	693b      	ldr	r3, [r7, #16]
 8005252:	731a      	strb	r2, [r3, #12]
    args->descriptor->deserializer_func(args->transfer, deserialized_message->msg);
 8005254:	697b      	ldr	r3, [r7, #20]
 8005256:	689b      	ldr	r3, [r3, #8]
 8005258:	699b      	ldr	r3, [r3, #24]
 800525a:	697a      	ldr	r2, [r7, #20]
 800525c:	6851      	ldr	r1, [r2, #4]
 800525e:	693a      	ldr	r2, [r7, #16]
 8005260:	3210      	adds	r2, #16
 8005262:	4608      	mov	r0, r1
 8005264:	4611      	mov	r1, r2
 8005266:	4798      	blx	r3
}
 8005268:	3718      	adds	r7, #24
 800526a:	46bd      	mov	sp, r7
 800526c:	bd80      	pop	{r7, pc}
 800526e:	bf00      	nop

08005270 <uavcan_on_transfer_rx.lto_priv.79>:

static void uavcan_on_transfer_rx(CanardInstance* canard, CanardRxTransfer* transfer) {
 8005270:	b580      	push	{r7, lr}
 8005272:	b088      	sub	sp, #32
 8005274:	af00      	add	r7, sp, #0
 8005276:	6078      	str	r0, [r7, #4]
 8005278:	6039      	str	r1, [r7, #0]
    if (!canard || !transfer) {
 800527a:	687b      	ldr	r3, [r7, #4]
 800527c:	2b00      	cmp	r3, #0
 800527e:	d03c      	beq.n	80052fa <uavcan_on_transfer_rx.lto_priv.79+0x8a>
 8005280:	683b      	ldr	r3, [r7, #0]
 8005282:	2b00      	cmp	r3, #0
 8005284:	d039      	beq.n	80052fa <uavcan_on_transfer_rx.lto_priv.79+0x8a>
        return;
    }

    struct uavcan_instance_s* instance = canardGetUserReference(canard);
 8005286:	6878      	ldr	r0, [r7, #4]
<<<<<<< HEAD
 8005288:	f007 fbf8 	bl	800ca7c <canardGetUserReference>
=======
 8005288:	f007 fc3c 	bl	800cb04 <canardGetUserReference>
>>>>>>> 752c83b... update binaries
 800528c:	61b8      	str	r0, [r7, #24]
    if (!instance) {
 800528e:	69bb      	ldr	r3, [r7, #24]
 8005290:	2b00      	cmp	r3, #0
 8005292:	d032      	beq.n	80052fa <uavcan_on_transfer_rx.lto_priv.79+0x8a>
        return;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 8005294:	69bb      	ldr	r3, [r7, #24]
 8005296:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005298:	61fb      	str	r3, [r7, #28]
 800529a:	e02b      	b.n	80052f4 <uavcan_on_transfer_rx.lto_priv.79+0x84>
    while (rx_list_item) {
        if (rx_list_item->msg_descriptor->transfer_type == transfer->transfer_type && _uavcan_get_message_data_type_id(instance, rx_list_item->msg_descriptor) == transfer->data_type_id) {
 800529c:	69fb      	ldr	r3, [r7, #28]
 800529e:	681b      	ldr	r3, [r3, #0]
 80052a0:	7a9a      	ldrb	r2, [r3, #10]
 80052a2:	683b      	ldr	r3, [r7, #0]
 80052a4:	7e1b      	ldrb	r3, [r3, #24]
 80052a6:	429a      	cmp	r2, r3
 80052a8:	d121      	bne.n	80052ee <uavcan_on_transfer_rx.lto_priv.79+0x7e>
 80052aa:	69fb      	ldr	r3, [r7, #28]
 80052ac:	681b      	ldr	r3, [r3, #0]
 80052ae:	69b8      	ldr	r0, [r7, #24]
 80052b0:	4619      	mov	r1, r3
 80052b2:	f001 fa61 	bl	8006778 <_uavcan_get_message_data_type_id.lto_priv.74>
 80052b6:	4603      	mov	r3, r0
 80052b8:	461a      	mov	r2, r3
 80052ba:	683b      	ldr	r3, [r7, #0]
 80052bc:	8adb      	ldrh	r3, [r3, #22]
 80052be:	429a      	cmp	r2, r3
 80052c0:	d115      	bne.n	80052ee <uavcan_on_transfer_rx.lto_priv.79+0x7e>
            struct uavcan_message_writer_func_args writer_args = { instance->idx, transfer, rx_list_item->msg_descriptor };
 80052c2:	69bb      	ldr	r3, [r7, #24]
 80052c4:	781b      	ldrb	r3, [r3, #0]
 80052c6:	733b      	strb	r3, [r7, #12]
 80052c8:	683b      	ldr	r3, [r7, #0]
 80052ca:	613b      	str	r3, [r7, #16]
 80052cc:	69fb      	ldr	r3, [r7, #28]
 80052ce:	681b      	ldr	r3, [r3, #0]
 80052d0:	617b      	str	r3, [r7, #20]
            pubsub_publish_message(&rx_list_item->topic, rx_list_item->msg_descriptor->deserialized_size+sizeof(struct uavcan_deserialized_message_s), uavcan_message_writer_func, &writer_args);
 80052d2:	69fb      	ldr	r3, [r7, #28]
 80052d4:	1d19      	adds	r1, r3, #4
 80052d6:	69fb      	ldr	r3, [r7, #28]
 80052d8:	681b      	ldr	r3, [r3, #0]
 80052da:	68db      	ldr	r3, [r3, #12]
 80052dc:	f103 0210 	add.w	r2, r3, #16
 80052e0:	f107 030c 	add.w	r3, r7, #12
 80052e4:	4608      	mov	r0, r1
 80052e6:	4611      	mov	r1, r2
 80052e8:	4a05      	ldr	r2, [pc, #20]	; (8005300 <uavcan_on_transfer_rx.lto_priv.79+0x90>)
<<<<<<< HEAD
 80052ea:	f003 f825 	bl	8008338 <pubsub_publish_message>
=======
 80052ea:	f003 f84d 	bl	8008388 <pubsub_publish_message>
>>>>>>> 752c83b... update binaries
        }

        rx_list_item = rx_list_item->next;
 80052ee:	69fb      	ldr	r3, [r7, #28]
 80052f0:	691b      	ldr	r3, [r3, #16]
 80052f2:	61fb      	str	r3, [r7, #28]
    if (!instance) {
        return;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item) {
 80052f4:	69fb      	ldr	r3, [r7, #28]
 80052f6:	2b00      	cmp	r3, #0
 80052f8:	d1d0      	bne.n	800529c <uavcan_on_transfer_rx.lto_priv.79+0x2c>
            pubsub_publish_message(&rx_list_item->topic, rx_list_item->msg_descriptor->deserialized_size+sizeof(struct uavcan_deserialized_message_s), uavcan_message_writer_func, &writer_args);
        }

        rx_list_item = rx_list_item->next;
    }
}
 80052fa:	3720      	adds	r7, #32
 80052fc:	46bd      	mov	sp, r7
 80052fe:	bd80      	pop	{r7, pc}
 8005300:	08005209 	.word	0x08005209

08005304 <uavcan_should_accept_transfer.lto_priv.80>:

static bool uavcan_should_accept_transfer(const CanardInstance* canard, uint64_t* out_data_type_signature, uint16_t data_type_id, CanardTransferType transfer_type, uint8_t source_node_id) {
 8005304:	b580      	push	{r7, lr}
 8005306:	b086      	sub	sp, #24
 8005308:	af00      	add	r7, sp, #0
 800530a:	60f8      	str	r0, [r7, #12]
 800530c:	60b9      	str	r1, [r7, #8]
 800530e:	4611      	mov	r1, r2
 8005310:	461a      	mov	r2, r3
 8005312:	460b      	mov	r3, r1
 8005314:	80fb      	strh	r3, [r7, #6]
 8005316:	4613      	mov	r3, r2
 8005318:	717b      	strb	r3, [r7, #5]
    (void)source_node_id;
    if (!canard || !out_data_type_signature) {
 800531a:	68fb      	ldr	r3, [r7, #12]
 800531c:	2b00      	cmp	r3, #0
 800531e:	d002      	beq.n	8005326 <uavcan_should_accept_transfer.lto_priv.80+0x22>
 8005320:	68bb      	ldr	r3, [r7, #8]
 8005322:	2b00      	cmp	r3, #0
 8005324:	d101      	bne.n	800532a <uavcan_should_accept_transfer.lto_priv.80+0x26>
        return false;
 8005326:	2300      	movs	r3, #0
 8005328:	e02d      	b.n	8005386 <uavcan_should_accept_transfer.lto_priv.80+0x82>
    }

    struct uavcan_instance_s* instance = canardGetUserReference((CanardInstance*)canard);
 800532a:	68f8      	ldr	r0, [r7, #12]
<<<<<<< HEAD
 800532c:	f007 fba6 	bl	800ca7c <canardGetUserReference>
=======
 800532c:	f007 fbea 	bl	800cb04 <canardGetUserReference>
>>>>>>> 752c83b... update binaries
 8005330:	6138      	str	r0, [r7, #16]
    if (!instance) {
 8005332:	693b      	ldr	r3, [r7, #16]
 8005334:	2b00      	cmp	r3, #0
 8005336:	d101      	bne.n	800533c <uavcan_should_accept_transfer.lto_priv.80+0x38>
        return false;
 8005338:	2300      	movs	r3, #0
 800533a:	e024      	b.n	8005386 <uavcan_should_accept_transfer.lto_priv.80+0x82>
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 800533c:	693b      	ldr	r3, [r7, #16]
 800533e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005340:	617b      	str	r3, [r7, #20]
 8005342:	e01c      	b.n	800537e <uavcan_should_accept_transfer.lto_priv.80+0x7a>
    while (rx_list_item) {
        if (transfer_type == rx_list_item->msg_descriptor->transfer_type && data_type_id == _uavcan_get_message_data_type_id(instance, rx_list_item->msg_descriptor)) {
 8005344:	697b      	ldr	r3, [r7, #20]
 8005346:	681b      	ldr	r3, [r3, #0]
 8005348:	7a9b      	ldrb	r3, [r3, #10]
 800534a:	797a      	ldrb	r2, [r7, #5]
 800534c:	429a      	cmp	r2, r3
 800534e:	d113      	bne.n	8005378 <uavcan_should_accept_transfer.lto_priv.80+0x74>
 8005350:	697b      	ldr	r3, [r7, #20]
 8005352:	681b      	ldr	r3, [r3, #0]
 8005354:	6938      	ldr	r0, [r7, #16]
 8005356:	4619      	mov	r1, r3
 8005358:	f001 fa0e 	bl	8006778 <_uavcan_get_message_data_type_id.lto_priv.74>
 800535c:	4603      	mov	r3, r0
 800535e:	461a      	mov	r2, r3
 8005360:	88fb      	ldrh	r3, [r7, #6]
 8005362:	4293      	cmp	r3, r2
 8005364:	d108      	bne.n	8005378 <uavcan_should_accept_transfer.lto_priv.80+0x74>
            *out_data_type_signature = rx_list_item->msg_descriptor->data_type_signature;
 8005366:	697b      	ldr	r3, [r7, #20]
 8005368:	681b      	ldr	r3, [r3, #0]
 800536a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800536e:	68b9      	ldr	r1, [r7, #8]
 8005370:	e9c1 2300 	strd	r2, r3, [r1]
            return true;
 8005374:	2301      	movs	r3, #1
 8005376:	e006      	b.n	8005386 <uavcan_should_accept_transfer.lto_priv.80+0x82>
        }

        rx_list_item = rx_list_item->next;
 8005378:	697b      	ldr	r3, [r7, #20]
 800537a:	691b      	ldr	r3, [r3, #16]
 800537c:	617b      	str	r3, [r7, #20]
    if (!instance) {
        return false;
    }

    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item) {
 800537e:	697b      	ldr	r3, [r7, #20]
 8005380:	2b00      	cmp	r3, #0
 8005382:	d1df      	bne.n	8005344 <uavcan_should_accept_transfer.lto_priv.80+0x40>
        }

        rx_list_item = rx_list_item->next;
    }

    return false;
 8005384:	2300      	movs	r3, #0
}
 8005386:	4618      	mov	r0, r3
 8005388:	3718      	adds	r7, #24
 800538a:	46bd      	mov	sp, r7
 800538c:	bd80      	pop	{r7, pc}
 800538e:	bf00      	nop

08005390 <uavcan_transfer_id_map_init.lto_priv.99>:

#define UAVCAN_TRANSFER_ID_MAP_MAX_LEN ((1<<7)-1)

static void uavcan_transfer_id_map_init(struct transfer_id_map_s* map, size_t map_mem_size, void* map_mem) {
 8005390:	b480      	push	{r7}
 8005392:	b085      	sub	sp, #20
 8005394:	af00      	add	r7, sp, #0
 8005396:	60f8      	str	r0, [r7, #12]
 8005398:	60b9      	str	r1, [r7, #8]
 800539a:	607a      	str	r2, [r7, #4]
    if (!map) {
 800539c:	68fb      	ldr	r3, [r7, #12]
 800539e:	2b00      	cmp	r3, #0
 80053a0:	d011      	beq.n	80053c6 <uavcan_transfer_id_map_init.lto_priv.99+0x36>
        return;
    }
    map->entries = map_mem;
 80053a2:	68fb      	ldr	r3, [r7, #12]
 80053a4:	687a      	ldr	r2, [r7, #4]
 80053a6:	601a      	str	r2, [r3, #0]
    map->size = map_mem_size/sizeof(struct map_entry_s);
 80053a8:	68bb      	ldr	r3, [r7, #8]
 80053aa:	089b      	lsrs	r3, r3, #2
 80053ac:	b29a      	uxth	r2, r3
 80053ae:	68fb      	ldr	r3, [r7, #12]
 80053b0:	809a      	strh	r2, [r3, #4]
    if (map->size > UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 80053b2:	68fb      	ldr	r3, [r7, #12]
 80053b4:	889b      	ldrh	r3, [r3, #4]
 80053b6:	2b7f      	cmp	r3, #127	; 0x7f
 80053b8:	d902      	bls.n	80053c0 <uavcan_transfer_id_map_init.lto_priv.99+0x30>
        map->size = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80053ba:	68fb      	ldr	r3, [r7, #12]
 80053bc:	227f      	movs	r2, #127	; 0x7f
 80053be:	809a      	strh	r2, [r3, #4]
    }
    map->head = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80053c0:	68fb      	ldr	r3, [r7, #12]
 80053c2:	227f      	movs	r2, #127	; 0x7f
 80053c4:	80da      	strh	r2, [r3, #6]
}
 80053c6:	3714      	adds	r7, #20
 80053c8:	46bd      	mov	sp, r7
 80053ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053ce:	4770      	bx	lr

080053d0 <uavcan_transfer_id_map_retrieve>:

static uint8_t* uavcan_transfer_id_map_retrieve(struct transfer_id_map_s* map, bool service_not_message, uint16_t data_type_id, uint8_t dest_node_id) {
 80053d0:	b480      	push	{r7}
 80053d2:	b087      	sub	sp, #28
 80053d4:	af00      	add	r7, sp, #0
 80053d6:	6078      	str	r0, [r7, #4]
 80053d8:	4608      	mov	r0, r1
 80053da:	4611      	mov	r1, r2
 80053dc:	461a      	mov	r2, r3
 80053de:	4603      	mov	r3, r0
 80053e0:	70fb      	strb	r3, [r7, #3]
 80053e2:	460b      	mov	r3, r1
 80053e4:	803b      	strh	r3, [r7, #0]
 80053e6:	4613      	mov	r3, r2
 80053e8:	70bb      	strb	r3, [r7, #2]
    if (!map || !map->entries) {
 80053ea:	687b      	ldr	r3, [r7, #4]
 80053ec:	2b00      	cmp	r3, #0
 80053ee:	d003      	beq.n	80053f8 <uavcan_transfer_id_map_retrieve+0x28>
 80053f0:	687b      	ldr	r3, [r7, #4]
 80053f2:	681b      	ldr	r3, [r3, #0]
 80053f4:	2b00      	cmp	r3, #0
 80053f6:	d101      	bne.n	80053fc <uavcan_transfer_id_map_retrieve+0x2c>
        return 0;
 80053f8:	2300      	movs	r3, #0
 80053fa:	e0a6      	b.n	800554a <uavcan_transfer_id_map_retrieve+0x17a>
    }

    uint32_t key;
    if (service_not_message) {
 80053fc:	78fb      	ldrb	r3, [r7, #3]
 80053fe:	2b00      	cmp	r3, #0
 8005400:	d008      	beq.n	8005414 <uavcan_transfer_id_map_retrieve+0x44>
        key = (1<<16) | ((data_type_id << 8) & 0xFF00) | ((dest_node_id << 0) & 0x00FF);
 8005402:	883b      	ldrh	r3, [r7, #0]
 8005404:	021b      	lsls	r3, r3, #8
 8005406:	b29b      	uxth	r3, r3
 8005408:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 800540c:	78bb      	ldrb	r3, [r7, #2]
 800540e:	4313      	orrs	r3, r2
 8005410:	617b      	str	r3, [r7, #20]
 8005412:	e001      	b.n	8005418 <uavcan_transfer_id_map_retrieve+0x48>
    } else {
        key = data_type_id;
 8005414:	883b      	ldrh	r3, [r7, #0]
 8005416:	617b      	str	r3, [r7, #20]
    }

    uint16_t count = 0;
 8005418:	2300      	movs	r3, #0
 800541a:	827b      	strh	r3, [r7, #18]
    uint16_t entry = map->head;
 800541c:	687b      	ldr	r3, [r7, #4]
 800541e:	88db      	ldrh	r3, [r3, #6]
 8005420:	823b      	strh	r3, [r7, #16]
    uint16_t entry_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 8005422:	237f      	movs	r3, #127	; 0x7f
 8005424:	81fb      	strh	r3, [r7, #14]
    uint16_t entry_prev_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 8005426:	237f      	movs	r3, #127	; 0x7f
 8005428:	81bb      	strh	r3, [r7, #12]
 800542a:	e010      	b.n	800544e <uavcan_transfer_id_map_retrieve+0x7e>

    while (entry != UAVCAN_TRANSFER_ID_MAP_MAX_LEN && map->entries[entry].key != key) {
        count++;
 800542c:	8a7b      	ldrh	r3, [r7, #18]
 800542e:	3301      	adds	r3, #1
 8005430:	827b      	strh	r3, [r7, #18]
        entry_prev_prev = entry_prev;
 8005432:	89fb      	ldrh	r3, [r7, #14]
 8005434:	81bb      	strh	r3, [r7, #12]
        entry_prev = entry;
 8005436:	8a3b      	ldrh	r3, [r7, #16]
 8005438:	81fb      	strh	r3, [r7, #14]
        entry = map->entries[entry].next;
 800543a:	687b      	ldr	r3, [r7, #4]
 800543c:	681a      	ldr	r2, [r3, #0]
 800543e:	8a3b      	ldrh	r3, [r7, #16]
 8005440:	009b      	lsls	r3, r3, #2
 8005442:	4413      	add	r3, r2
 8005444:	789b      	ldrb	r3, [r3, #2]
 8005446:	f3c3 0346 	ubfx	r3, r3, #1, #7
 800544a:	b2db      	uxtb	r3, r3
 800544c:	823b      	strh	r3, [r7, #16]
    uint16_t count = 0;
    uint16_t entry = map->head;
    uint16_t entry_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
    uint16_t entry_prev_prev = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;

    while (entry != UAVCAN_TRANSFER_ID_MAP_MAX_LEN && map->entries[entry].key != key) {
 800544e:	8a3b      	ldrh	r3, [r7, #16]
 8005450:	2b7f      	cmp	r3, #127	; 0x7f
 8005452:	d011      	beq.n	8005478 <uavcan_transfer_id_map_retrieve+0xa8>
 8005454:	687b      	ldr	r3, [r7, #4]
 8005456:	681a      	ldr	r2, [r3, #0]
 8005458:	8a3b      	ldrh	r3, [r7, #16]
 800545a:	009b      	lsls	r3, r3, #2
 800545c:	4413      	add	r3, r2
 800545e:	781a      	ldrb	r2, [r3, #0]
 8005460:	7859      	ldrb	r1, [r3, #1]
 8005462:	0209      	lsls	r1, r1, #8
 8005464:	430a      	orrs	r2, r1
 8005466:	789b      	ldrb	r3, [r3, #2]
 8005468:	f003 0301 	and.w	r3, r3, #1
 800546c:	041b      	lsls	r3, r3, #16
 800546e:	4313      	orrs	r3, r2
 8005470:	461a      	mov	r2, r3
 8005472:	697b      	ldr	r3, [r7, #20]
 8005474:	429a      	cmp	r2, r3
 8005476:	d1d9      	bne.n	800542c <uavcan_transfer_id_map_retrieve+0x5c>
        entry_prev_prev = entry_prev;
        entry_prev = entry;
        entry = map->entries[entry].next;
    }

    if (entry == UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 8005478:	8a3b      	ldrh	r3, [r7, #16]
 800547a:	2b7f      	cmp	r3, #127	; 0x7f
 800547c:	d138      	bne.n	80054f0 <uavcan_transfer_id_map_retrieve+0x120>
        // Not found. Allocate an entry.
        if (count >= map->size) {
 800547e:	687b      	ldr	r3, [r7, #4]
 8005480:	889b      	ldrh	r3, [r3, #4]
 8005482:	8a7a      	ldrh	r2, [r7, #18]
 8005484:	429a      	cmp	r2, r3
 8005486:	d304      	bcc.n	8005492 <uavcan_transfer_id_map_retrieve+0xc2>
            // list is full - entry_prev is the LRU entry
            entry = entry_prev;
 8005488:	89fb      	ldrh	r3, [r7, #14]
 800548a:	823b      	strh	r3, [r7, #16]
            entry_prev = entry_prev_prev;
 800548c:	89bb      	ldrh	r3, [r7, #12]
 800548e:	81fb      	strh	r3, [r7, #14]
 8005490:	e001      	b.n	8005496 <uavcan_transfer_id_map_retrieve+0xc6>
        } else {
            // list is not full - allocate next available element
            entry = count;
 8005492:	8a7b      	ldrh	r3, [r7, #18]
 8005494:	823b      	strh	r3, [r7, #16]
        }

        // Populate the allocated entry
        map->entries[entry].key = key;
 8005496:	687b      	ldr	r3, [r7, #4]
 8005498:	681a      	ldr	r2, [r3, #0]
 800549a:	8a3b      	ldrh	r3, [r7, #16]
 800549c:	009b      	lsls	r3, r3, #2
 800549e:	4413      	add	r3, r2
 80054a0:	697a      	ldr	r2, [r7, #20]
 80054a2:	f3c2 0210 	ubfx	r2, r2, #0, #17
 80054a6:	b2d1      	uxtb	r1, r2
 80054a8:	2000      	movs	r0, #0
 80054aa:	4301      	orrs	r1, r0
 80054ac:	7019      	strb	r1, [r3, #0]
 80054ae:	0a11      	lsrs	r1, r2, #8
 80054b0:	b2c9      	uxtb	r1, r1
 80054b2:	2000      	movs	r0, #0
 80054b4:	4301      	orrs	r1, r0
 80054b6:	7059      	strb	r1, [r3, #1]
 80054b8:	0c12      	lsrs	r2, r2, #16
 80054ba:	f002 0201 	and.w	r2, r2, #1
 80054be:	f002 0001 	and.w	r0, r2, #1
 80054c2:	789a      	ldrb	r2, [r3, #2]
 80054c4:	f022 0201 	bic.w	r2, r2, #1
 80054c8:	4611      	mov	r1, r2
 80054ca:	4602      	mov	r2, r0
 80054cc:	430a      	orrs	r2, r1
 80054ce:	709a      	strb	r2, [r3, #2]
        map->entries[entry].transfer_id = 0;
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	681a      	ldr	r2, [r3, #0]
 80054d4:	8a3b      	ldrh	r3, [r7, #16]
 80054d6:	009b      	lsls	r3, r3, #2
 80054d8:	4413      	add	r3, r2
 80054da:	2200      	movs	r2, #0
 80054dc:	70da      	strb	r2, [r3, #3]
        map->entries[entry].next = UAVCAN_TRANSFER_ID_MAP_MAX_LEN;
 80054de:	687b      	ldr	r3, [r7, #4]
 80054e0:	681a      	ldr	r2, [r3, #0]
 80054e2:	8a3b      	ldrh	r3, [r7, #16]
 80054e4:	009b      	lsls	r3, r3, #2
 80054e6:	441a      	add	r2, r3
 80054e8:	7893      	ldrb	r3, [r2, #2]
 80054ea:	f043 03fe 	orr.w	r3, r3, #254	; 0xfe
 80054ee:	7093      	strb	r3, [r2, #2]
    }

    // Move to front
    if (entry_prev != UAVCAN_TRANSFER_ID_MAP_MAX_LEN) {
 80054f0:	89fb      	ldrh	r3, [r7, #14]
 80054f2:	2b7f      	cmp	r3, #127	; 0x7f
 80054f4:	d020      	beq.n	8005538 <uavcan_transfer_id_map_retrieve+0x168>
        map->entries[entry_prev].next = map->entries[entry].next;
 80054f6:	687b      	ldr	r3, [r7, #4]
 80054f8:	681a      	ldr	r2, [r3, #0]
 80054fa:	89fb      	ldrh	r3, [r7, #14]
 80054fc:	009b      	lsls	r3, r3, #2
 80054fe:	441a      	add	r2, r3
 8005500:	687b      	ldr	r3, [r7, #4]
 8005502:	6819      	ldr	r1, [r3, #0]
 8005504:	8a3b      	ldrh	r3, [r7, #16]
 8005506:	009b      	lsls	r3, r3, #2
 8005508:	440b      	add	r3, r1
 800550a:	789b      	ldrb	r3, [r3, #2]
 800550c:	f3c3 0346 	ubfx	r3, r3, #1, #7
 8005510:	b2d9      	uxtb	r1, r3
 8005512:	7893      	ldrb	r3, [r2, #2]
 8005514:	f361 0347 	bfi	r3, r1, #1, #7
 8005518:	7093      	strb	r3, [r2, #2]
        map->entries[entry].next = map->head;
 800551a:	687b      	ldr	r3, [r7, #4]
 800551c:	681a      	ldr	r2, [r3, #0]
 800551e:	8a3b      	ldrh	r3, [r7, #16]
 8005520:	009b      	lsls	r3, r3, #2
 8005522:	441a      	add	r2, r3
 8005524:	687b      	ldr	r3, [r7, #4]
 8005526:	88db      	ldrh	r3, [r3, #6]
 8005528:	b2db      	uxtb	r3, r3
 800552a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800552e:	b2d9      	uxtb	r1, r3
 8005530:	7893      	ldrb	r3, [r2, #2]
 8005532:	f361 0347 	bfi	r3, r1, #1, #7
 8005536:	7093      	strb	r3, [r2, #2]
    }
    map->head = entry;
 8005538:	687b      	ldr	r3, [r7, #4]
 800553a:	8a3a      	ldrh	r2, [r7, #16]
 800553c:	80da      	strh	r2, [r3, #6]

    return &map->entries[entry].transfer_id;
 800553e:	687b      	ldr	r3, [r7, #4]
 8005540:	681a      	ldr	r2, [r3, #0]
 8005542:	8a3b      	ldrh	r3, [r7, #16]
 8005544:	009b      	lsls	r3, r3, #2
 8005546:	4413      	add	r3, r2
 8005548:	3303      	adds	r3, #3
}
 800554a:	4618      	mov	r0, r3
 800554c:	371c      	adds	r7, #28
 800554e:	46bd      	mov	sp, r7
 8005550:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005554:	4770      	bx	lr
 8005556:	bf00      	nop

08005558 <uavcan_nodestatus_publisher_get_nodestatus_message>:

static void node_status_publisher_task_func(struct worker_thread_timer_task_s* task);

// TODO mechanism to change node status

const struct uavcan_protocol_NodeStatus_s* uavcan_nodestatus_publisher_get_nodestatus_message(void) {
 8005558:	b480      	push	{r7}
 800555a:	af00      	add	r7, sp, #0
    return &node_status;
 800555c:	4b02      	ldr	r3, [pc, #8]	; (8005568 <uavcan_nodestatus_publisher_get_nodestatus_message+0x10>)
}
 800555e:	4618      	mov	r0, r3
 8005560:	46bd      	mov	sp, r7
 8005562:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005566:	4770      	bx	lr
 8005568:	200014ac 	.word	0x200014ac

0800556c <_local_ctor_24>:

RUN_AFTER(UAVCAN_INIT) {
 800556c:	b580      	push	{r7, lr}
 800556e:	b082      	sub	sp, #8
 8005570:	af02      	add	r7, sp, #8
    node_status.uptime_sec = 0;
 8005572:	4b0e      	ldr	r3, [pc, #56]	; (80055ac <_local_ctor_24+0x40>)
 8005574:	2200      	movs	r2, #0
 8005576:	601a      	str	r2, [r3, #0]
    node_status.health = UAVCAN_PROTOCOL_NODESTATUS_HEALTH_OK;
 8005578:	4b0c      	ldr	r3, [pc, #48]	; (80055ac <_local_ctor_24+0x40>)
 800557a:	2200      	movs	r2, #0
 800557c:	711a      	strb	r2, [r3, #4]
    node_status.mode = UAVCAN_PROTOCOL_NODESTATUS_MODE_OPERATIONAL;
 800557e:	4b0b      	ldr	r3, [pc, #44]	; (80055ac <_local_ctor_24+0x40>)
 8005580:	2200      	movs	r2, #0
 8005582:	715a      	strb	r2, [r3, #5]
    node_status.sub_mode = 0;
 8005584:	4b09      	ldr	r3, [pc, #36]	; (80055ac <_local_ctor_24+0x40>)
 8005586:	2200      	movs	r2, #0
 8005588:	719a      	strb	r2, [r3, #6]
    node_status.vendor_specific_status_code = 0;
 800558a:	4b08      	ldr	r3, [pc, #32]	; (80055ac <_local_ctor_24+0x40>)
 800558c:	2200      	movs	r2, #0
 800558e:	811a      	strh	r2, [r3, #8]

    worker_thread_add_timer_task(&WT, &node_status_publisher_task, node_status_publisher_task_func, NULL, S2ST(1), true);
 8005590:	f242 7310 	movw	r3, #10000	; 0x2710
 8005594:	9300      	str	r3, [sp, #0]
 8005596:	2301      	movs	r3, #1
 8005598:	9301      	str	r3, [sp, #4]
 800559a:	4805      	ldr	r0, [pc, #20]	; (80055b0 <_local_ctor_24+0x44>)
 800559c:	4905      	ldr	r1, [pc, #20]	; (80055b4 <_local_ctor_24+0x48>)
 800559e:	4a06      	ldr	r2, [pc, #24]	; (80055b8 <_local_ctor_24+0x4c>)
 80055a0:	2300      	movs	r3, #0
<<<<<<< HEAD
 80055a2:	f003 f985 	bl	80088b0 <worker_thread_add_timer_task>
=======
 80055a2:	f003 f991 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries
}
 80055a6:	46bd      	mov	sp, r7
 80055a8:	bd80      	pop	{r7, pc}
 80055aa:	bf00      	nop
 80055ac:	200014ac 	.word	0x200014ac
 80055b0:	20000a20 	.word	0x20000a20
 80055b4:	200014b8 	.word	0x200014b8
 80055b8:	080055bd 	.word	0x080055bd

080055bc <node_status_publisher_task_func>:
void set_node_mode(uint8_t mode) {
    node_status.mode = mode;
}


static void node_status_publisher_task_func(struct worker_thread_timer_task_s* task) {
 80055bc:	b580      	push	{r7, lr}
 80055be:	b082      	sub	sp, #8
 80055c0:	af00      	add	r7, sp, #0
 80055c2:	6078      	str	r0, [r7, #4]
    (void)task;

    chnWrite(&SD1, (const uint8_t *)"sts\n", 5);
 80055c4:	4b0a      	ldr	r3, [pc, #40]	; (80055f0 <node_status_publisher_task_func+0x34>)
 80055c6:	681b      	ldr	r3, [r3, #0]
 80055c8:	681b      	ldr	r3, [r3, #0]
 80055ca:	4809      	ldr	r0, [pc, #36]	; (80055f0 <node_status_publisher_task_func+0x34>)
 80055cc:	4909      	ldr	r1, [pc, #36]	; (80055f4 <node_status_publisher_task_func+0x38>)
 80055ce:	2205      	movs	r2, #5
 80055d0:	4798      	blx	r3

    node_status.uptime_sec++;
 80055d2:	4b09      	ldr	r3, [pc, #36]	; (80055f8 <node_status_publisher_task_func+0x3c>)
 80055d4:	681b      	ldr	r3, [r3, #0]
 80055d6:	3301      	adds	r3, #1
 80055d8:	4a07      	ldr	r2, [pc, #28]	; (80055f8 <node_status_publisher_task_func+0x3c>)
 80055da:	6013      	str	r3, [r2, #0]
    uavcan_broadcast(0, &uavcan_protocol_NodeStatus_descriptor, CANARD_TRANSFER_PRIORITY_LOW, &node_status);
 80055dc:	2000      	movs	r0, #0
 80055de:	4907      	ldr	r1, [pc, #28]	; (80055fc <node_status_publisher_task_func+0x40>)
 80055e0:	2218      	movs	r2, #24
 80055e2:	4b05      	ldr	r3, [pc, #20]	; (80055f8 <node_status_publisher_task_func+0x3c>)
 80055e4:	f7ff fcb0 	bl	8004f48 <uavcan_broadcast>
}
 80055e8:	3708      	adds	r7, #8
 80055ea:	46bd      	mov	sp, r7
 80055ec:	bd80      	pop	{r7, pc}
 80055ee:	bf00      	nop
 80055f0:	200013ac 	.word	0x200013ac
<<<<<<< HEAD
 80055f4:	0800e634 	.word	0x0800e634
 80055f8:	200014a0 	.word	0x200014a0
 80055fc:	0800e6f8 	.word	0x0800e6f8
=======
 80055f4:	0800e6bc 	.word	0x0800e6bc
 80055f8:	200014ac 	.word	0x200014ac
 80055fc:	0800e7d0 	.word	0x0800e7d0
>>>>>>> 752c83b... update binaries

08005600 <_local_ctor_26>:
#include <uavcan.protocol.GetNodeInfo.h>

static struct worker_thread_listener_task_s getnodeinfo_req_listener_task;
static void getnodeinfo_req_handler(size_t msg_size, const void* buf, void* ctx);

RUN_AFTER(UAVCAN_INIT) {
 8005600:	b580      	push	{r7, lr}
 8005602:	b084      	sub	sp, #16
 8005604:	af02      	add	r7, sp, #8
    struct pubsub_topic_s* getnodeinfo_req_topic = uavcan_get_message_topic(0, &uavcan_protocol_GetNodeInfo_req_descriptor);
 8005606:	2000      	movs	r0, #0
 8005608:	4907      	ldr	r1, [pc, #28]	; (8005628 <_local_ctor_26+0x28>)
 800560a:	f001 f8a1 	bl	8006750 <uavcan_get_message_topic>
 800560e:	6078      	str	r0, [r7, #4]
    worker_thread_add_listener_task(&WT, &getnodeinfo_req_listener_task, getnodeinfo_req_topic, getnodeinfo_req_handler, NULL);
 8005610:	2300      	movs	r3, #0
 8005612:	9300      	str	r3, [sp, #0]
 8005614:	4805      	ldr	r0, [pc, #20]	; (800562c <_local_ctor_26+0x2c>)
 8005616:	4906      	ldr	r1, [pc, #24]	; (8005630 <_local_ctor_26+0x30>)
 8005618:	687a      	ldr	r2, [r7, #4]
 800561a:	4b06      	ldr	r3, [pc, #24]	; (8005634 <_local_ctor_26+0x34>)
<<<<<<< HEAD
 800561c:	f003 f9f6 	bl	8008a0c <worker_thread_add_listener_task>
=======
 800561c:	f003 fa0e 	bl	8008a3c <worker_thread_add_listener_task>
>>>>>>> 752c83b... update binaries
}
 8005620:	3708      	adds	r7, #8
 8005622:	46bd      	mov	sp, r7
 8005624:	bd80      	pop	{r7, pc}
 8005626:	bf00      	nop
 8005628:	0800e890 	.word	0x0800e890
 800562c:	20000a20 	.word	0x20000a20
 8005630:	200014d0 	.word	0x200014d0
 8005634:	08005639 	.word	0x08005639

08005638 <getnodeinfo_req_handler>:

static void getnodeinfo_req_handler(size_t msg_size, const void* buf, void* ctx) {
 8005638:	b580      	push	{r7, lr}
 800563a:	b0e8      	sub	sp, #416	; 0x1a0
 800563c:	af00      	add	r7, sp, #0
 800563e:	f107 030c 	add.w	r3, r7, #12
 8005642:	6018      	str	r0, [r3, #0]
 8005644:	f107 0308 	add.w	r3, r7, #8
 8005648:	6019      	str	r1, [r3, #0]
 800564a:	1d3b      	adds	r3, r7, #4
 800564c:	601a      	str	r2, [r3, #0]
    (void)msg_size;
    (void)ctx;

    const struct uavcan_deserialized_message_s* msg_wrapper = buf;
 800564e:	f107 0308 	add.w	r3, r7, #8
 8005652:	681b      	ldr	r3, [r3, #0]
 8005654:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c

    struct uavcan_protocol_GetNodeInfo_res_s res;
    memset(&res, 0, sizeof(struct uavcan_protocol_GetNodeInfo_res_s));
 8005658:	f107 0310 	add.w	r3, r7, #16
 800565c:	4618      	mov	r0, r3
 800565e:	2100      	movs	r1, #0
 8005660:	f44f 72c4 	mov.w	r2, #392	; 0x188
<<<<<<< HEAD
 8005664:	f008 ffb0 	bl	800e5c8 <memset>
=======
 8005664:	f008 fff4 	bl	800e650 <memset>
>>>>>>> 752c83b... update binaries

    res.status = *uavcan_nodestatus_publisher_get_nodestatus_message();
 8005668:	f7ff ff76 	bl	8005558 <uavcan_nodestatus_publisher_get_nodestatus_message>
 800566c:	4602      	mov	r2, r0
 800566e:	f107 0310 	add.w	r3, r7, #16
 8005672:	ca07      	ldmia	r2, {r0, r1, r2}
 8005674:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    board_get_unique_id(res.hardware_version.unique_id, sizeof(res.hardware_version.unique_id));
 8005678:	f107 0310 	add.w	r3, r7, #16
 800567c:	3322      	adds	r3, #34	; 0x22
 800567e:	4618      	mov	r0, r3
 8005680:	2110      	movs	r1, #16
 8005682:	f7fe fe4d 	bl	8004320 <board_get_unique_id>
        res.hardware_version.minor = boot_msg.boot_info_msg.hw_info->hw_minor_version;
    }
#endif

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    res.software_version.major = shared_app_descriptor.major_version;
 8005686:	4b14      	ldr	r3, [pc, #80]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 8005688:	7e1a      	ldrb	r2, [r3, #24]
 800568a:	f107 0310 	add.w	r3, r7, #16
 800568e:	741a      	strb	r2, [r3, #16]
    res.software_version.minor = shared_app_descriptor.minor_version;
 8005690:	4b11      	ldr	r3, [pc, #68]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 8005692:	7e5a      	ldrb	r2, [r3, #25]
 8005694:	f107 0310 	add.w	r3, r7, #16
 8005698:	745a      	strb	r2, [r3, #17]
    res.software_version.optional_field_flags = UAVCAN_PROTOCOL_SOFTWAREVERSION_OPTIONAL_FIELD_FLAG_VCS_COMMIT |
 800569a:	f107 0310 	add.w	r3, r7, #16
 800569e:	2203      	movs	r2, #3
 80056a0:	749a      	strb	r2, [r3, #18]
                                                UAVCAN_PROTOCOL_SOFTWAREVERSION_OPTIONAL_FIELD_FLAG_IMAGE_CRC;
    res.software_version.vcs_commit = shared_app_descriptor.vcs_commit;
 80056a2:	4b0d      	ldr	r3, [pc, #52]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 80056a4:	695a      	ldr	r2, [r3, #20]
 80056a6:	f107 0310 	add.w	r3, r7, #16
 80056aa:	615a      	str	r2, [r3, #20]
    res.software_version.image_crc = *(volatile uint64_t*)&shared_app_descriptor.image_crc;
 80056ac:	4b0a      	ldr	r3, [pc, #40]	; (80056d8 <getnodeinfo_req_handler+0xa0>)
 80056ae:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80056b2:	f107 0110 	add.w	r1, r7, #16
 80056b6:	e9c1 2306 	strd	r2, r3, [r1, #24]
#endif

    uavcan_respond(msg_wrapper->uavcan_idx, msg_wrapper, &res);
 80056ba:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 80056be:	781a      	ldrb	r2, [r3, #0]
 80056c0:	f107 0310 	add.w	r3, r7, #16
 80056c4:	4610      	mov	r0, r2
 80056c6:	f8d7 119c 	ldr.w	r1, [r7, #412]	; 0x19c
 80056ca:	461a      	mov	r2, r3
 80056cc:	f7ff fc80 	bl	8004fd0 <uavcan_respond>
}
 80056d0:	f507 77d0 	add.w	r7, r7, #416	; 0x1a0
 80056d4:	46bd      	mov	sp, r7
 80056d6:	bd80      	pop	{r7, pc}
 80056d8:	08003160 	.word	0x08003160

080056dc <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 80056dc:	b580      	push	{r7, lr}
 80056de:	b082      	sub	sp, #8
 80056e0:	af00      	add	r7, sp, #0
 80056e2:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 80056e4:	6878      	ldr	r0, [r7, #4]
 80056e6:	2104      	movs	r1, #4
 80056e8:	2200      	movs	r2, #0
<<<<<<< HEAD
 80056ea:	f004 f9e3 	bl	8009ab4 <chCoreAllocAlignedWithOffset>
=======
 80056ea:	f004 fa27 	bl	8009b3c <chCoreAllocAlignedWithOffset>
>>>>>>> 752c83b... update binaries
 80056ee:	4603      	mov	r3, r0
}
 80056f0:	4618      	mov	r0, r3
 80056f2:	3708      	adds	r7, #8
 80056f4:	46bd      	mov	sp, r7
 80056f6:	bd80      	pop	{r7, pc}

080056f8 <_local_ctor_34>:
    struct worker_thread_timer_task_s request_transmit_task;
    struct worker_thread_listener_task_s allocation_listener_task;
};


RUN_AFTER(UAVCAN_INIT) {
 80056f8:	b580      	push	{r7, lr}
 80056fa:	b086      	sub	sp, #24
 80056fc:	af02      	add	r7, sp, #8
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
 80056fe:	2300      	movs	r3, #0
 8005700:	73fb      	strb	r3, [r7, #15]
 8005702:	e034      	b.n	800576e <_local_ctor_34+0x76>
        if (uavcan_get_node_id(i) != 0) {
 8005704:	7bfb      	ldrb	r3, [r7, #15]
 8005706:	4618      	mov	r0, r3
 8005708:	f001 f862 	bl	80067d0 <uavcan_get_node_id>
 800570c:	4603      	mov	r3, r0
 800570e:	2b00      	cmp	r3, #0
 8005710:	d127      	bne.n	8005762 <_local_ctor_34+0x6a>
            continue;
        }

        struct allocatee_instance_s* instance = chCoreAlloc(sizeof(struct allocatee_instance_s));
 8005712:	2054      	movs	r0, #84	; 0x54
 8005714:	f7ff ffe2 	bl	80056dc <chCoreAlloc>
 8005718:	60b8      	str	r0, [r7, #8]

        chDbgCheck(instance != NULL);
 800571a:	68bb      	ldr	r3, [r7, #8]
 800571c:	2b00      	cmp	r3, #0
 800571e:	d102      	bne.n	8005726 <_local_ctor_34+0x2e>
 8005720:	4818      	ldr	r0, [pc, #96]	; (8005784 <_local_ctor_34+0x8c>)
<<<<<<< HEAD
 8005722:	f005 fb3f 	bl	800ada4 <chSysHalt>
=======
 8005722:	f005 fb83 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
        if (!instance) {
 8005726:	68bb      	ldr	r3, [r7, #8]
 8005728:	2b00      	cmp	r3, #0
 800572a:	d01c      	beq.n	8005766 <_local_ctor_34+0x6e>
            continue;
        }

        struct pubsub_topic_s* allocation_topic = uavcan_get_message_topic(i, &uavcan_protocol_dynamic_node_id_Allocation_descriptor);
 800572c:	7bfb      	ldrb	r3, [r7, #15]
 800572e:	4618      	mov	r0, r3
 8005730:	4915      	ldr	r1, [pc, #84]	; (8005788 <_local_ctor_34+0x90>)
 8005732:	f001 f80d 	bl	8006750 <uavcan_get_message_topic>
 8005736:	6078      	str	r0, [r7, #4]

        instance->uavcan_idx = i;
 8005738:	68bb      	ldr	r3, [r7, #8]
 800573a:	7bfa      	ldrb	r2, [r7, #15]
 800573c:	701a      	strb	r2, [r3, #0]
        instance->unique_id_offset = 0;
 800573e:	68bb      	ldr	r3, [r7, #8]
 8005740:	2200      	movs	r2, #0
 8005742:	605a      	str	r2, [r3, #4]
        worker_thread_add_listener_task(&WT, &instance->allocation_listener_task, allocation_topic, allocation_message_handler, instance);
 8005744:	68bb      	ldr	r3, [r7, #8]
 8005746:	f103 0220 	add.w	r2, r3, #32
 800574a:	68bb      	ldr	r3, [r7, #8]
 800574c:	9300      	str	r3, [sp, #0]
 800574e:	480f      	ldr	r0, [pc, #60]	; (800578c <_local_ctor_34+0x94>)
 8005750:	4611      	mov	r1, r2
 8005752:	687a      	ldr	r2, [r7, #4]
 8005754:	4b0e      	ldr	r3, [pc, #56]	; (8005790 <_local_ctor_34+0x98>)
<<<<<<< HEAD
 8005756:	f003 f959 	bl	8008a0c <worker_thread_add_listener_task>
=======
 8005756:	f003 f971 	bl	8008a3c <worker_thread_add_listener_task>
>>>>>>> 752c83b... update binaries
        allocation_start_request_timer(instance);
 800575a:	68b8      	ldr	r0, [r7, #8]
 800575c:	f7fe fb12 	bl	8003d84 <allocation_start_request_timer.lto_priv.72>
 8005760:	e002      	b.n	8005768 <_local_ctor_34+0x70>


RUN_AFTER(UAVCAN_INIT) {
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
        if (uavcan_get_node_id(i) != 0) {
            continue;
 8005762:	bf00      	nop
 8005764:	e000      	b.n	8005768 <_local_ctor_34+0x70>

        struct allocatee_instance_s* instance = chCoreAlloc(sizeof(struct allocatee_instance_s));

        chDbgCheck(instance != NULL);
        if (!instance) {
            continue;
 8005766:	bf00      	nop
    struct worker_thread_listener_task_s allocation_listener_task;
};


RUN_AFTER(UAVCAN_INIT) {
     for (uint8_t i=0; i<uavcan_get_num_instances(); i++) {
 8005768:	7bfb      	ldrb	r3, [r7, #15]
 800576a:	3301      	adds	r3, #1
 800576c:	73fb      	strb	r3, [r7, #15]
 800576e:	f7ff fccb 	bl	8005108 <uavcan_get_num_instances>
 8005772:	4603      	mov	r3, r0
 8005774:	461a      	mov	r2, r3
 8005776:	7bfb      	ldrb	r3, [r7, #15]
 8005778:	4293      	cmp	r3, r2
 800577a:	d3c3      	bcc.n	8005704 <_local_ctor_34+0xc>
        instance->uavcan_idx = i;
        instance->unique_id_offset = 0;
        worker_thread_add_listener_task(&WT, &instance->allocation_listener_task, allocation_topic, allocation_message_handler, instance);
        allocation_start_request_timer(instance);
    }
}
 800577c:	3710      	adds	r7, #16
 800577e:	46bd      	mov	sp, r7
 8005780:	bd80      	pop	{r7, pc}
 8005782:	bf00      	nop
 8005784:	0800eda4 	.word	0x0800eda4
 8005788:	0800e830 	.word	0x0800e830
 800578c:	20000a20 	.word	0x20000a20
 8005790:	08005865 	.word	0x08005865

08005794 <allocation_stop_and_cleanup.lto_priv.64>:

static void allocation_stop_and_cleanup(struct allocatee_instance_s* instance) {
 8005794:	b580      	push	{r7, lr}
 8005796:	b082      	sub	sp, #8
 8005798:	af00      	add	r7, sp, #0
 800579a:	6078      	str	r0, [r7, #4]
    worker_thread_remove_timer_task(&WT, &instance->request_transmit_task);
 800579c:	687b      	ldr	r3, [r7, #4]
 800579e:	3308      	adds	r3, #8
 80057a0:	4806      	ldr	r0, [pc, #24]	; (80057bc <allocation_stop_and_cleanup.lto_priv.64+0x28>)
 80057a2:	4619      	mov	r1, r3
<<<<<<< HEAD
 80057a4:	f003 f910 	bl	80089c8 <worker_thread_remove_timer_task>
=======
 80057a4:	f003 f928 	bl	80089f8 <worker_thread_remove_timer_task>
>>>>>>> 752c83b... update binaries
    worker_thread_remove_listener_task(&WT, &instance->allocation_listener_task);
 80057a8:	687b      	ldr	r3, [r7, #4]
 80057aa:	3320      	adds	r3, #32
 80057ac:	4803      	ldr	r0, [pc, #12]	; (80057bc <allocation_stop_and_cleanup.lto_priv.64+0x28>)
 80057ae:	4619      	mov	r1, r3
 80057b0:	f003 f982 	bl	8008ab8 <worker_thread_remove_listener_task>
}
 80057b4:	3708      	adds	r7, #8
 80057b6:	46bd      	mov	sp, r7
 80057b8:	bd80      	pop	{r7, pc}
 80057ba:	bf00      	nop
 80057bc:	20000a20 	.word	0x20000a20

080057c0 <allocation_timer_expired.lto_priv.7>:

static void allocation_timer_expired(struct worker_thread_timer_task_s* task) {
 80057c0:	b590      	push	{r4, r7, lr}
 80057c2:	b08d      	sub	sp, #52	; 0x34
 80057c4:	af00      	add	r7, sp, #0
 80057c6:	6078      	str	r0, [r7, #4]
    struct allocatee_instance_s* instance = worker_thread_task_get_user_context(task);
 80057c8:	6878      	ldr	r0, [r7, #4]
<<<<<<< HEAD
 80057ca:	f003 f90d 	bl	80089e8 <worker_thread_task_get_user_context>
=======
 80057ca:	f003 f925 	bl	8008a18 <worker_thread_task_get_user_context>
>>>>>>> 752c83b... update binaries
 80057ce:	62f8      	str	r0, [r7, #44]	; 0x2c

    if (!allocation_running(instance)) {
 80057d0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80057d2:	f7fe fb6b 	bl	8003eac <allocation_running.lto_priv.73>
 80057d6:	4603      	mov	r3, r0
 80057d8:	f083 0301 	eor.w	r3, r3, #1
 80057dc:	b2db      	uxtb	r3, r3
 80057de:	2b00      	cmp	r3, #0
 80057e0:	d003      	beq.n	80057ea <allocation_timer_expired.lto_priv.7+0x2a>
        allocation_stop_and_cleanup(instance);
 80057e2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80057e4:	f7ff ffd6 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 80057e8:	e036      	b.n	8005858 <allocation_timer_expired.lto_priv.7+0x98>
        return;
    }

    // Start allocation request timer
    allocation_start_request_timer(instance);
 80057ea:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80057ec:	f7fe faca 	bl	8003d84 <allocation_start_request_timer.lto_priv.72>

    // Send allocation message
    struct uavcan_protocol_dynamic_node_id_Allocation_s msg;

    uint8_t my_unique_id[16];
    board_get_unique_id(my_unique_id, sizeof(my_unique_id));
 80057f0:	f107 0308 	add.w	r3, r7, #8
 80057f4:	4618      	mov	r0, r3
 80057f6:	2110      	movs	r1, #16
 80057f8:	f7fe fd92 	bl	8004320 <board_get_unique_id>

    msg.node_id = 0;
 80057fc:	2300      	movs	r3, #0
 80057fe:	763b      	strb	r3, [r7, #24]
    msg.first_part_of_unique_id = (instance->unique_id_offset == 0);
 8005800:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005802:	685b      	ldr	r3, [r3, #4]
 8005804:	2b00      	cmp	r3, #0
 8005806:	bf0c      	ite	eq
 8005808:	2301      	moveq	r3, #1
 800580a:	2300      	movne	r3, #0
 800580c:	b2db      	uxtb	r3, r3
 800580e:	767b      	strb	r3, [r7, #25]
    msg.unique_id_len = MIN(16-instance->unique_id_offset, UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST);
 8005810:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005812:	685b      	ldr	r3, [r3, #4]
 8005814:	f1c3 0310 	rsb	r3, r3, #16
 8005818:	2b06      	cmp	r3, #6
 800581a:	bf28      	it	cs
 800581c:	2306      	movcs	r3, #6
 800581e:	b2db      	uxtb	r3, r3
 8005820:	76bb      	strb	r3, [r7, #26]
    memcpy(&msg.unique_id, &my_unique_id[instance->unique_id_offset], msg.unique_id_len);
 8005822:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005824:	685b      	ldr	r3, [r3, #4]
 8005826:	f107 0208 	add.w	r2, r7, #8
 800582a:	441a      	add	r2, r3
 800582c:	7ebb      	ldrb	r3, [r7, #26]
 800582e:	461c      	mov	r4, r3
 8005830:	f107 0318 	add.w	r3, r7, #24
 8005834:	3303      	adds	r3, #3
 8005836:	4618      	mov	r0, r3
 8005838:	4611      	mov	r1, r2
 800583a:	4622      	mov	r2, r4
<<<<<<< HEAD
 800583c:	f008 fe9e 	bl	800e57c <memcpy>
=======
 800583c:	f008 fee2 	bl	800e604 <memcpy>
>>>>>>> 752c83b... update binaries
    uavcan_broadcast(instance->uavcan_idx, &uavcan_protocol_dynamic_node_id_Allocation_descriptor, CANARD_TRANSFER_PRIORITY_LOW, &msg);
 8005840:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005842:	781a      	ldrb	r2, [r3, #0]
 8005844:	f107 0318 	add.w	r3, r7, #24
 8005848:	4610      	mov	r0, r2
 800584a:	4905      	ldr	r1, [pc, #20]	; (8005860 <allocation_timer_expired.lto_priv.7+0xa0>)
 800584c:	2218      	movs	r2, #24
 800584e:	f7ff fb7b 	bl	8004f48 <uavcan_broadcast>
    instance->unique_id_offset = 0;
 8005852:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005854:	2200      	movs	r2, #0
 8005856:	605a      	str	r2, [r3, #4]
}
 8005858:	3734      	adds	r7, #52	; 0x34
 800585a:	46bd      	mov	sp, r7
 800585c:	bd90      	pop	{r4, r7, pc}
 800585e:	bf00      	nop
 8005860:	0800e830 	.word	0x0800e830

08005864 <allocation_message_handler>:

static void allocation_message_handler(size_t msg_size, const void* buf, void* ctx) {
 8005864:	b590      	push	{r4, r7, lr}
 8005866:	b08d      	sub	sp, #52	; 0x34
 8005868:	af00      	add	r7, sp, #0
 800586a:	60f8      	str	r0, [r7, #12]
 800586c:	60b9      	str	r1, [r7, #8]
 800586e:	607a      	str	r2, [r7, #4]
    (void)msg_size;

    const struct uavcan_deserialized_message_s* wrapper = buf;
 8005870:	68bb      	ldr	r3, [r7, #8]
 8005872:	62fb      	str	r3, [r7, #44]	; 0x2c
    const struct uavcan_protocol_dynamic_node_id_Allocation_s* msg = (const struct uavcan_protocol_dynamic_node_id_Allocation_s*)wrapper->msg;
 8005874:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005876:	3310      	adds	r3, #16
 8005878:	62bb      	str	r3, [r7, #40]	; 0x28

    struct allocatee_instance_s* instance = ctx;
 800587a:	687b      	ldr	r3, [r7, #4]
 800587c:	627b      	str	r3, [r7, #36]	; 0x24

    if (!allocation_running(instance)) {
 800587e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005880:	f7fe fb14 	bl	8003eac <allocation_running.lto_priv.73>
 8005884:	4603      	mov	r3, r0
 8005886:	f083 0301 	eor.w	r3, r3, #1
 800588a:	b2db      	uxtb	r3, r3
 800588c:	2b00      	cmp	r3, #0
 800588e:	d003      	beq.n	8005898 <allocation_message_handler+0x34>
        allocation_stop_and_cleanup(instance);
 8005890:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005892:	f7ff ff7f 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
 8005896:	e036      	b.n	8005906 <allocation_message_handler+0xa2>
        return;
    }

    allocation_start_request_timer(instance);
 8005898:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800589a:	f7fe fa73 	bl	8003d84 <allocation_start_request_timer.lto_priv.72>
    instance->unique_id_offset = 0;
 800589e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058a0:	2200      	movs	r2, #0
 80058a2:	605a      	str	r2, [r3, #4]

    if (wrapper->source_node_id == 0) {
 80058a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80058a6:	7b1b      	ldrb	r3, [r3, #12]
 80058a8:	2b00      	cmp	r3, #0
 80058aa:	d02c      	beq.n	8005906 <allocation_message_handler+0xa2>
        return;
    }

    uint8_t my_unique_id[16];
    board_get_unique_id(my_unique_id, sizeof(my_unique_id));
 80058ac:	f107 0314 	add.w	r3, r7, #20
 80058b0:	4618      	mov	r0, r3
 80058b2:	2110      	movs	r1, #16
 80058b4:	f7fe fd34 	bl	8004320 <board_get_unique_id>

    if (memcmp(my_unique_id, msg->unique_id, msg->unique_id_len) != 0) {
 80058b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058ba:	1cda      	adds	r2, r3, #3
 80058bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058be:	789b      	ldrb	r3, [r3, #2]
 80058c0:	461c      	mov	r4, r3
 80058c2:	f107 0314 	add.w	r3, r7, #20
 80058c6:	4618      	mov	r0, r3
 80058c8:	4611      	mov	r1, r2
 80058ca:	4622      	mov	r2, r4
<<<<<<< HEAD
 80058cc:	f008 fe46 	bl	800e55c <memcmp>
=======
 80058cc:	f008 fe8a 	bl	800e5e4 <memcmp>
>>>>>>> 752c83b... update binaries
 80058d0:	4603      	mov	r3, r0
 80058d2:	2b00      	cmp	r3, #0
 80058d4:	d117      	bne.n	8005906 <allocation_message_handler+0xa2>
        // If unique ID does not match, return
        return;
    }

    if (msg->unique_id_len < 16) {
 80058d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058d8:	789b      	ldrb	r3, [r3, #2]
 80058da:	2b0f      	cmp	r3, #15
 80058dc:	d808      	bhi.n	80058f0 <allocation_message_handler+0x8c>
        // Unique ID partially matches - set the UID offset and start the followup timer
        instance->unique_id_offset = msg->unique_id_len;
 80058de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058e0:	789b      	ldrb	r3, [r3, #2]
 80058e2:	461a      	mov	r2, r3
 80058e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058e6:	605a      	str	r2, [r3, #4]
        allocation_start_followup_timer(instance);
 80058e8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80058ea:	f7fe fa99 	bl	8003e20 <allocation_start_followup_timer.lto_priv.71>
 80058ee:	e00a      	b.n	8005906 <allocation_message_handler+0xa2>
    } else {
        // Complete match received
        uavcan_set_node_id(instance->uavcan_idx, msg->node_id);
 80058f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80058f2:	781a      	ldrb	r2, [r3, #0]
 80058f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058f6:	781b      	ldrb	r3, [r3, #0]
 80058f8:	4610      	mov	r0, r2
 80058fa:	4619      	mov	r1, r3
 80058fc:	f7ff f8b4 	bl	8004a68 <uavcan_set_node_id>
        allocation_stop_and_cleanup(instance);
 8005900:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005902:	f7ff ff47 	bl	8005794 <allocation_stop_and_cleanup.lto_priv.64>
    }
}
 8005906:	3734      	adds	r7, #52	; 0x34
 8005908:	46bd      	mov	sp, r7
 800590a:	bd90      	pop	{r4, r7, pc}

0800590c <can_start>:
        instance->baudrate_confirmed = false;
    }
    instance->baudrate = baudrate;
}

void can_start(struct can_instance_s* instance, bool silent, bool auto_retransmit, uint32_t baudrate) {
 800590c:	b580      	push	{r7, lr}
 800590e:	b084      	sub	sp, #16
 8005910:	af00      	add	r7, sp, #0
 8005912:	60f8      	str	r0, [r7, #12]
 8005914:	607b      	str	r3, [r7, #4]
 8005916:	460b      	mov	r3, r1
 8005918:	72fb      	strb	r3, [r7, #11]
 800591a:	4613      	mov	r3, r2
 800591c:	72bb      	strb	r3, [r7, #10]
    chSysLock();
 800591e:	f001 fff1 	bl	8007904 <chSysLock.lto_priv.102>
    can_start_I(instance, silent, auto_retransmit, baudrate);
 8005922:	7afa      	ldrb	r2, [r7, #11]
 8005924:	7abb      	ldrb	r3, [r7, #10]
 8005926:	68f8      	ldr	r0, [r7, #12]
 8005928:	4611      	mov	r1, r2
 800592a:	461a      	mov	r2, r3
 800592c:	687b      	ldr	r3, [r7, #4]
 800592e:	f002 f90b 	bl	8007b48 <can_start_I>
    chSysUnlock();
 8005932:	f001 ffef 	bl	8007914 <chSysUnlock.lto_priv.101>
}
 8005936:	3710      	adds	r7, #16
 8005938:	46bd      	mov	sp, r7
 800593a:	bd80      	pop	{r7, pc}

0800593c <can_stop_I>:

void can_stop_I(struct can_instance_s* instance) {
 800593c:	b580      	push	{r7, lr}
 800593e:	b082      	sub	sp, #8
 8005940:	af00      	add	r7, sp, #0
 8005942:	6078      	str	r0, [r7, #4]
    if (!instance) {
 8005944:	687b      	ldr	r3, [r7, #4]
 8005946:	2b00      	cmp	r3, #0
 8005948:	d00d      	beq.n	8005966 <can_stop_I+0x2a>
        return;
    }

    if (instance->started) {
 800594a:	687b      	ldr	r3, [r7, #4]
 800594c:	785b      	ldrb	r3, [r3, #1]
 800594e:	2b00      	cmp	r3, #0
 8005950:	d009      	beq.n	8005966 <can_stop_I+0x2a>
        instance->driver_iface->stop(instance->driver_ctx);
 8005952:	687b      	ldr	r3, [r7, #4]
 8005954:	691b      	ldr	r3, [r3, #16]
 8005956:	685b      	ldr	r3, [r3, #4]
 8005958:	687a      	ldr	r2, [r7, #4]
 800595a:	68d2      	ldr	r2, [r2, #12]
 800595c:	4610      	mov	r0, r2
 800595e:	4798      	blx	r3
        instance->started = true;
 8005960:	687b      	ldr	r3, [r7, #4]
 8005962:	2201      	movs	r2, #1
 8005964:	705a      	strb	r2, [r3, #1]
    }
}
 8005966:	3708      	adds	r7, #8
 8005968:	46bd      	mov	sp, r7
 800596a:	bd80      	pop	{r7, pc}

0800596c <can_allocate_tx_frame_and_append_I>:
    chSysLock();
    can_stop_I(instance);
    chSysUnlock();
}

struct can_tx_frame_s* can_allocate_tx_frame_and_append_I(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 800596c:	b580      	push	{r7, lr}
 800596e:	b084      	sub	sp, #16
 8005970:	af00      	add	r7, sp, #0
 8005972:	6078      	str	r0, [r7, #4]
 8005974:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8005976:	f005 faf3 	bl	800af60 <chDbgCheckClassI>
=======
 8005976:	f005 fb37 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
    
    if (!instance || !frame_list) {
 800597a:	687b      	ldr	r3, [r7, #4]
 800597c:	2b00      	cmp	r3, #0
 800597e:	d002      	beq.n	8005986 <can_allocate_tx_frame_and_append_I+0x1a>
 8005980:	683b      	ldr	r3, [r7, #0]
 8005982:	2b00      	cmp	r3, #0
 8005984:	d101      	bne.n	800598a <can_allocate_tx_frame_and_append_I+0x1e>
        return NULL;
 8005986:	2300      	movs	r3, #0
 8005988:	e01c      	b.n	80059c4 <can_allocate_tx_frame_and_append_I+0x58>
    }
    
    struct can_tx_frame_s* new_frame = chPoolAllocI(&instance->frame_pool);
 800598a:	687b      	ldr	r3, [r7, #4]
 800598c:	3330      	adds	r3, #48	; 0x30
 800598e:	4618      	mov	r0, r3
<<<<<<< HEAD
 8005990:	f004 f944 	bl	8009c1c <chPoolAllocI>
=======
 8005990:	f004 f988 	bl	8009ca4 <chPoolAllocI>
>>>>>>> 752c83b... update binaries
 8005994:	60b8      	str	r0, [r7, #8]
    if (!new_frame) {
 8005996:	68bb      	ldr	r3, [r7, #8]
 8005998:	2b00      	cmp	r3, #0
 800599a:	d101      	bne.n	80059a0 <can_allocate_tx_frame_and_append_I+0x34>
        return NULL;
 800599c:	2300      	movs	r3, #0
 800599e:	e011      	b.n	80059c4 <can_allocate_tx_frame_and_append_I+0x58>
    }
    
    LINKED_LIST_APPEND(struct can_tx_frame_s, *frame_list, new_frame);
 80059a0:	68bb      	ldr	r3, [r7, #8]
 80059a2:	2200      	movs	r2, #0
 80059a4:	619a      	str	r2, [r3, #24]
 80059a6:	683b      	ldr	r3, [r7, #0]
 80059a8:	60fb      	str	r3, [r7, #12]
 80059aa:	e003      	b.n	80059b4 <can_allocate_tx_frame_and_append_I+0x48>
 80059ac:	68fb      	ldr	r3, [r7, #12]
 80059ae:	681b      	ldr	r3, [r3, #0]
 80059b0:	3318      	adds	r3, #24
 80059b2:	60fb      	str	r3, [r7, #12]
 80059b4:	68fb      	ldr	r3, [r7, #12]
 80059b6:	681b      	ldr	r3, [r3, #0]
 80059b8:	2b00      	cmp	r3, #0
 80059ba:	d1f7      	bne.n	80059ac <can_allocate_tx_frame_and_append_I+0x40>
 80059bc:	68fb      	ldr	r3, [r7, #12]
 80059be:	68ba      	ldr	r2, [r7, #8]
 80059c0:	601a      	str	r2, [r3, #0]

    return new_frame;
 80059c2:	68bb      	ldr	r3, [r7, #8]
}
 80059c4:	4618      	mov	r0, r3
 80059c6:	3710      	adds	r7, #16
 80059c8:	46bd      	mov	sp, r7
 80059ca:	bd80      	pop	{r7, pc}

080059cc <can_allocate_tx_frame_and_append>:

struct can_tx_frame_s* can_allocate_tx_frame_and_append(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 80059cc:	b580      	push	{r7, lr}
 80059ce:	b084      	sub	sp, #16
 80059d0:	af00      	add	r7, sp, #0
 80059d2:	6078      	str	r0, [r7, #4]
 80059d4:	6039      	str	r1, [r7, #0]
    chSysLock();
 80059d6:	f001 ff95 	bl	8007904 <chSysLock.lto_priv.102>
    struct can_tx_frame_s* ret = can_allocate_tx_frame_and_append_I(instance, frame_list);
 80059da:	6878      	ldr	r0, [r7, #4]
 80059dc:	6839      	ldr	r1, [r7, #0]
 80059de:	f7ff ffc5 	bl	800596c <can_allocate_tx_frame_and_append_I>
 80059e2:	60f8      	str	r0, [r7, #12]
    chSysUnlock();
 80059e4:	f001 ff96 	bl	8007914 <chSysUnlock.lto_priv.101>
    return ret;
 80059e8:	68fb      	ldr	r3, [r7, #12]
}
 80059ea:	4618      	mov	r0, r3
 80059ec:	3710      	adds	r7, #16
 80059ee:	46bd      	mov	sp, r7
 80059f0:	bd80      	pop	{r7, pc}
 80059f2:	bf00      	nop

080059f4 <can_enqueue_tx_frames>:
        }
    }
    return ret;
}

void can_enqueue_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list, systime_t tx_timeout, struct pubsub_topic_s* completion_topic) {
 80059f4:	b580      	push	{r7, lr}
 80059f6:	b088      	sub	sp, #32
 80059f8:	af00      	add	r7, sp, #0
 80059fa:	60f8      	str	r0, [r7, #12]
 80059fc:	60b9      	str	r1, [r7, #8]
 80059fe:	603b      	str	r3, [r7, #0]
 8005a00:	4613      	mov	r3, r2
 8005a02:	80fb      	strh	r3, [r7, #6]
    if (!instance) {
 8005a04:	68fb      	ldr	r3, [r7, #12]
 8005a06:	2b00      	cmp	r3, #0
 8005a08:	d02f      	beq.n	8005a6a <can_enqueue_tx_frames+0x76>
        return;
    }
    
    systime_t t_now = chVTGetSystemTimeX();
 8005a0a:	f001 ff9f 	bl	800794c <chVTGetSystemTimeX.lto_priv.100>
 8005a0e:	4603      	mov	r3, r0
 8005a10:	837b      	strh	r3, [r7, #26]

    struct can_tx_frame_s* frame = *frame_list;
 8005a12:	68bb      	ldr	r3, [r7, #8]
 8005a14:	681b      	ldr	r3, [r3, #0]
 8005a16:	61fb      	str	r3, [r7, #28]
 8005a18:	e01b      	b.n	8005a52 <can_enqueue_tx_frames+0x5e>
    while (frame != NULL) {
        struct can_tx_frame_s* next_frame = frame->next;
 8005a1a:	69fb      	ldr	r3, [r7, #28]
 8005a1c:	699b      	ldr	r3, [r3, #24]
 8005a1e:	617b      	str	r3, [r7, #20]

        frame->creation_systime = t_now;
 8005a20:	69fb      	ldr	r3, [r7, #28]
 8005a22:	8b7a      	ldrh	r2, [r7, #26]
 8005a24:	821a      	strh	r2, [r3, #16]
        frame->tx_timeout = tx_timeout;
 8005a26:	69fb      	ldr	r3, [r7, #28]
 8005a28:	88fa      	ldrh	r2, [r7, #6]
 8005a2a:	825a      	strh	r2, [r3, #18]
        if (!frame->next) {
 8005a2c:	69fb      	ldr	r3, [r7, #28]
 8005a2e:	699b      	ldr	r3, [r3, #24]
 8005a30:	2b00      	cmp	r3, #0
 8005a32:	d103      	bne.n	8005a3c <can_enqueue_tx_frames+0x48>
            frame->completion_topic = completion_topic;
 8005a34:	69fb      	ldr	r3, [r7, #28]
 8005a36:	683a      	ldr	r2, [r7, #0]
 8005a38:	615a      	str	r2, [r3, #20]
 8005a3a:	e002      	b.n	8005a42 <can_enqueue_tx_frames+0x4e>
        } else {
            frame->completion_topic = NULL;
 8005a3c:	69fb      	ldr	r3, [r7, #28]
 8005a3e:	2200      	movs	r2, #0
 8005a40:	615a      	str	r2, [r3, #20]
        }
        can_tx_queue_push(&instance->tx_queue, frame);
 8005a42:	68fb      	ldr	r3, [r7, #12]
 8005a44:	333c      	adds	r3, #60	; 0x3c
 8005a46:	4618      	mov	r0, r3
 8005a48:	69f9      	ldr	r1, [r7, #28]
 8005a4a:	f001 fdbb 	bl	80075c4 <can_tx_queue_push>

        frame = next_frame;
 8005a4e:	697b      	ldr	r3, [r7, #20]
 8005a50:	61fb      	str	r3, [r7, #28]
    }
    
    systime_t t_now = chVTGetSystemTimeX();

    struct can_tx_frame_s* frame = *frame_list;
    while (frame != NULL) {
 8005a52:	69fb      	ldr	r3, [r7, #28]
 8005a54:	2b00      	cmp	r3, #0
 8005a56:	d1e0      	bne.n	8005a1a <can_enqueue_tx_frames+0x26>
        can_tx_queue_push(&instance->tx_queue, frame);

        frame = next_frame;
    }

    *frame_list = NULL;
 8005a58:	68bb      	ldr	r3, [r7, #8]
 8005a5a:	2200      	movs	r2, #0
 8005a5c:	601a      	str	r2, [r3, #0]

    can_try_enqueue_waiting_frame(instance);
 8005a5e:	68f8      	ldr	r0, [r7, #12]
 8005a60:	f000 f960 	bl	8005d24 <can_try_enqueue_waiting_frame>
    can_reschedule_expire_timer(instance);
 8005a64:	68f8      	ldr	r0, [r7, #12]
 8005a66:	f000 f9cb 	bl	8005e00 <can_reschedule_expire_timer>
}
 8005a6a:	3720      	adds	r7, #32
 8005a6c:	46bd      	mov	sp, r7
 8005a6e:	bd80      	pop	{r7, pc}

08005a70 <can_free_tx_frames>:

void can_free_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
 8005a70:	b580      	push	{r7, lr}
 8005a72:	b084      	sub	sp, #16
 8005a74:	af00      	add	r7, sp, #0
 8005a76:	6078      	str	r0, [r7, #4]
 8005a78:	6039      	str	r1, [r7, #0]
    if (!instance) {
 8005a7a:	687b      	ldr	r3, [r7, #4]
 8005a7c:	2b00      	cmp	r3, #0
 8005a7e:	d012      	beq.n	8005aa6 <can_free_tx_frames+0x36>
        return;
    }
    
    for (struct can_tx_frame_s* frame = *frame_list; frame != NULL; frame = frame->next) {
 8005a80:	683b      	ldr	r3, [r7, #0]
 8005a82:	681b      	ldr	r3, [r3, #0]
 8005a84:	60fb      	str	r3, [r7, #12]
 8005a86:	e008      	b.n	8005a9a <can_free_tx_frames+0x2a>
        chPoolFree(&instance->frame_pool, frame);
 8005a88:	687b      	ldr	r3, [r7, #4]
 8005a8a:	3330      	adds	r3, #48	; 0x30
 8005a8c:	4618      	mov	r0, r3
 8005a8e:	68f9      	ldr	r1, [r7, #12]
<<<<<<< HEAD
 8005a90:	f004 f920 	bl	8009cd4 <chPoolFree>
=======
 8005a90:	f004 f964 	bl	8009d5c <chPoolFree>
>>>>>>> 752c83b... update binaries
void can_free_tx_frames(struct can_instance_s* instance, struct can_tx_frame_s** frame_list) {
    if (!instance) {
        return;
    }
    
    for (struct can_tx_frame_s* frame = *frame_list; frame != NULL; frame = frame->next) {
 8005a94:	68fb      	ldr	r3, [r7, #12]
 8005a96:	699b      	ldr	r3, [r3, #24]
 8005a98:	60fb      	str	r3, [r7, #12]
 8005a9a:	68fb      	ldr	r3, [r7, #12]
 8005a9c:	2b00      	cmp	r3, #0
 8005a9e:	d1f3      	bne.n	8005a88 <can_free_tx_frames+0x18>
        chPoolFree(&instance->frame_pool, frame);
    }
    
    *frame_list = NULL;
 8005aa0:	683b      	ldr	r3, [r7, #0]
 8005aa2:	2200      	movs	r2, #0
 8005aa4:	601a      	str	r2, [r3, #0]
}
 8005aa6:	3710      	adds	r7, #16
 8005aa8:	46bd      	mov	sp, r7
 8005aaa:	bd80      	pop	{r7, pc}

08005aac <can_driver_register>:

struct can_instance_s* can_driver_register(uint8_t can_idx, void* driver_ctx, const struct can_driver_iface_s* driver_iface, uint8_t num_tx_mailboxes, uint8_t num_rx_mailboxes, uint8_t rx_fifo_depth) {
 8005aac:	b580      	push	{r7, lr}
 8005aae:	b08a      	sub	sp, #40	; 0x28
 8005ab0:	af02      	add	r7, sp, #8
 8005ab2:	60b9      	str	r1, [r7, #8]
 8005ab4:	607a      	str	r2, [r7, #4]
 8005ab6:	461a      	mov	r2, r3
 8005ab8:	4603      	mov	r3, r0
 8005aba:	73fb      	strb	r3, [r7, #15]
 8005abc:	4613      	mov	r3, r2
 8005abe:	73bb      	strb	r3, [r7, #14]
    if (can_get_instance(can_idx) != NULL) {
 8005ac0:	7bfb      	ldrb	r3, [r7, #15]
 8005ac2:	4618      	mov	r0, r3
 8005ac4:	f001 ff90 	bl	80079e8 <can_get_instance>
 8005ac8:	4603      	mov	r3, r0
 8005aca:	2b00      	cmp	r3, #0
 8005acc:	d001      	beq.n	8005ad2 <can_driver_register+0x26>
        return NULL;
 8005ace:	2300      	movs	r3, #0
 8005ad0:	e093      	b.n	8005bfa <can_driver_register+0x14e>
    }

    struct can_instance_s* instance = chPoolAlloc(&can_instance_pool);
 8005ad2:	484c      	ldr	r0, [pc, #304]	; (8005c04 <can_driver_register+0x158>)
<<<<<<< HEAD
 8005ad4:	f004 f8ce 	bl	8009c74 <chPoolAlloc>
=======
 8005ad4:	f004 f912 	bl	8009cfc <chPoolAlloc>
>>>>>>> 752c83b... update binaries
 8005ad8:	6178      	str	r0, [r7, #20]

    if (!instance) {
 8005ada:	697b      	ldr	r3, [r7, #20]
 8005adc:	2b00      	cmp	r3, #0
 8005ade:	d101      	bne.n	8005ae4 <can_driver_register+0x38>
        return NULL;
 8005ae0:	2300      	movs	r3, #0
 8005ae2:	e08a      	b.n	8005bfa <can_driver_register+0x14e>
    }
    
    void* tx_queue_mem = chCoreAlloc(CAN_TX_QUEUE_LEN*sizeof(struct can_tx_frame_s));
 8005ae4:	f44f 60e0 	mov.w	r0, #1792	; 0x700
 8005ae8:	f001 ff48 	bl	800797c <chCoreAlloc.lto_priv.84>
 8005aec:	6138      	str	r0, [r7, #16]
    
    if (!tx_queue_mem) {
 8005aee:	693b      	ldr	r3, [r7, #16]
 8005af0:	2b00      	cmp	r3, #0
 8005af2:	d101      	bne.n	8005af8 <can_driver_register+0x4c>
        return NULL;
 8005af4:	2300      	movs	r3, #0
 8005af6:	e080      	b.n	8005bfa <can_driver_register+0x14e>
    }

    if (num_tx_mailboxes > MAX_NUM_TX_MAILBOXES) {
 8005af8:	7bbb      	ldrb	r3, [r7, #14]
 8005afa:	2b03      	cmp	r3, #3
 8005afc:	d901      	bls.n	8005b02 <can_driver_register+0x56>
        num_tx_mailboxes = MAX_NUM_TX_MAILBOXES;
 8005afe:	2303      	movs	r3, #3
 8005b00:	73bb      	strb	r3, [r7, #14]
    }

    instance->idx = can_idx;
 8005b02:	697b      	ldr	r3, [r7, #20]
 8005b04:	7bfa      	ldrb	r2, [r7, #15]
 8005b06:	701a      	strb	r2, [r3, #0]

    instance->started = false;
 8005b08:	697b      	ldr	r3, [r7, #20]
 8005b0a:	2200      	movs	r2, #0
 8005b0c:	705a      	strb	r2, [r3, #1]
    instance->silent = false;
 8005b0e:	697b      	ldr	r3, [r7, #20]
 8005b10:	2200      	movs	r2, #0
 8005b12:	709a      	strb	r2, [r3, #2]
    instance->auto_retransmit = false;
 8005b14:	697b      	ldr	r3, [r7, #20]
 8005b16:	2200      	movs	r2, #0
 8005b18:	70da      	strb	r2, [r3, #3]
    instance->baudrate = 0;
 8005b1a:	697b      	ldr	r3, [r7, #20]
 8005b1c:	2200      	movs	r2, #0
 8005b1e:	605a      	str	r2, [r3, #4]
    instance->baudrate_confirmed = false;
 8005b20:	697b      	ldr	r3, [r7, #20]
 8005b22:	2200      	movs	r2, #0
 8005b24:	721a      	strb	r2, [r3, #8]

    instance->driver_ctx = driver_ctx;
 8005b26:	697b      	ldr	r3, [r7, #20]
 8005b28:	68ba      	ldr	r2, [r7, #8]
 8005b2a:	60da      	str	r2, [r3, #12]
    instance->driver_iface = driver_iface;
 8005b2c:	697b      	ldr	r3, [r7, #20]
 8005b2e:	687a      	ldr	r2, [r7, #4]
 8005b30:	611a      	str	r2, [r3, #16]

    for (uint8_t i=0; i<MAX_NUM_TX_MAILBOXES; i++) {
 8005b32:	2300      	movs	r3, #0
 8005b34:	77fb      	strb	r3, [r7, #31]
 8005b36:	e009      	b.n	8005b4c <can_driver_register+0xa0>
        instance->tx_mailbox[i].state = CAN_TX_MAILBOX_EMPTY;
 8005b38:	7ffb      	ldrb	r3, [r7, #31]
 8005b3a:	697a      	ldr	r2, [r7, #20]
 8005b3c:	3302      	adds	r3, #2
 8005b3e:	00db      	lsls	r3, r3, #3
 8005b40:	4413      	add	r3, r2
 8005b42:	2200      	movs	r2, #0
 8005b44:	721a      	strb	r2, [r3, #8]
    instance->baudrate_confirmed = false;

    instance->driver_ctx = driver_ctx;
    instance->driver_iface = driver_iface;

    for (uint8_t i=0; i<MAX_NUM_TX_MAILBOXES; i++) {
 8005b46:	7ffb      	ldrb	r3, [r7, #31]
 8005b48:	3301      	adds	r3, #1
 8005b4a:	77fb      	strb	r3, [r7, #31]
 8005b4c:	7ffb      	ldrb	r3, [r7, #31]
 8005b4e:	2b02      	cmp	r3, #2
 8005b50:	d9f2      	bls.n	8005b38 <can_driver_register+0x8c>
        instance->tx_mailbox[i].state = CAN_TX_MAILBOX_EMPTY;
    }
    instance->num_tx_mailboxes = num_tx_mailboxes;
 8005b52:	697b      	ldr	r3, [r7, #20]
 8005b54:	7bba      	ldrb	r2, [r7, #14]
 8005b56:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    
    chPoolObjectInit(&instance->frame_pool, sizeof(struct can_tx_frame_s), NULL);
 8005b5a:	697b      	ldr	r3, [r7, #20]
 8005b5c:	3330      	adds	r3, #48	; 0x30
 8005b5e:	4618      	mov	r0, r3
 8005b60:	211c      	movs	r1, #28
 8005b62:	2200      	movs	r2, #0
<<<<<<< HEAD
 8005b64:	f004 f818 	bl	8009b98 <chPoolObjectInit>
=======
 8005b64:	f004 f85c 	bl	8009c20 <chPoolObjectInit>
>>>>>>> 752c83b... update binaries
    chPoolLoadArray(&instance->frame_pool, tx_queue_mem, CAN_TX_QUEUE_LEN);
 8005b68:	697b      	ldr	r3, [r7, #20]
 8005b6a:	3330      	adds	r3, #48	; 0x30
 8005b6c:	4618      	mov	r0, r3
 8005b6e:	6939      	ldr	r1, [r7, #16]
 8005b70:	2240      	movs	r2, #64	; 0x40
<<<<<<< HEAD
 8005b72:	f004 f82f 	bl	8009bd4 <chPoolLoadArray>
=======
 8005b72:	f004 f873 	bl	8009c5c <chPoolLoadArray>
>>>>>>> 752c83b... update binaries

    can_tx_queue_init(&instance->tx_queue);
 8005b76:	697b      	ldr	r3, [r7, #20]
 8005b78:	333c      	adds	r3, #60	; 0x3c
 8005b7a:	4618      	mov	r0, r3
 8005b7c:	f001 fcde 	bl	800753c <can_tx_queue_init>

    pubsub_init_topic(&instance->rx_topic, NULL); // TODO specific/configurable topic group
 8005b80:	697b      	ldr	r3, [r7, #20]
 8005b82:	3340      	adds	r3, #64	; 0x40
 8005b84:	4618      	mov	r0, r3
 8005b86:	2100      	movs	r1, #0
<<<<<<< HEAD
 8005b88:	f002 faf0 	bl	800816c <pubsub_init_topic>
=======
 8005b88:	f002 fb18 	bl	80081bc <pubsub_init_topic>
>>>>>>> 752c83b... update binaries
    worker_thread_add_publisher_task(&WT_TRX, &instance->rx_publisher_task, sizeof(struct can_rx_frame_s), num_rx_mailboxes*rx_fifo_depth);
 8005b8c:	697b      	ldr	r3, [r7, #20]
 8005b8e:	f103 014c 	add.w	r1, r3, #76	; 0x4c
 8005b92:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8005b96:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8005b9a:	fb02 f303 	mul.w	r3, r2, r3
 8005b9e:	481a      	ldr	r0, [pc, #104]	; (8005c08 <can_driver_register+0x15c>)
 8005ba0:	2214      	movs	r2, #20
 8005ba2:	f000 fe85 	bl	80068b0 <worker_thread_add_publisher_task>

    worker_thread_add_publisher_task(&WT_TRX, &instance->tx_publisher_task, sizeof(struct can_transmit_completion_msg_s), num_tx_mailboxes);
 8005ba6:	697b      	ldr	r3, [r7, #20]
 8005ba8:	f103 028c 	add.w	r2, r3, #140	; 0x8c
 8005bac:	7bbb      	ldrb	r3, [r7, #14]
 8005bae:	4816      	ldr	r0, [pc, #88]	; (8005c08 <can_driver_register+0x15c>)
 8005bb0:	4611      	mov	r1, r2
 8005bb2:	2204      	movs	r2, #4
 8005bb4:	f000 fe7c 	bl	80068b0 <worker_thread_add_publisher_task>

    worker_thread_add_timer_task(&WT_EXPIRE, &instance->expire_timer_task, can_expire_handler, instance, TIME_INFINITE, false);
 8005bb8:	697b      	ldr	r3, [r7, #20]
 8005bba:	f103 02cc 	add.w	r2, r3, #204	; 0xcc
 8005bbe:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005bc2:	9300      	str	r3, [sp, #0]
 8005bc4:	2300      	movs	r3, #0
 8005bc6:	9301      	str	r3, [sp, #4]
 8005bc8:	480f      	ldr	r0, [pc, #60]	; (8005c08 <can_driver_register+0x15c>)
 8005bca:	4611      	mov	r1, r2
 8005bcc:	4a0f      	ldr	r2, [pc, #60]	; (8005c0c <can_driver_register+0x160>)
 8005bce:	697b      	ldr	r3, [r7, #20]
<<<<<<< HEAD
 8005bd0:	f002 fe6e 	bl	80088b0 <worker_thread_add_timer_task>
=======
 8005bd0:	f002 fe7a 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries

    LINKED_LIST_APPEND(struct can_instance_s, can_instance_list_head, instance);
 8005bd4:	697b      	ldr	r3, [r7, #20]
 8005bd6:	2200      	movs	r2, #0
 8005bd8:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
 8005bdc:	4b0c      	ldr	r3, [pc, #48]	; (8005c10 <can_driver_register+0x164>)
 8005bde:	61bb      	str	r3, [r7, #24]
 8005be0:	e003      	b.n	8005bea <can_driver_register+0x13e>
 8005be2:	69bb      	ldr	r3, [r7, #24]
 8005be4:	681b      	ldr	r3, [r3, #0]
 8005be6:	33e4      	adds	r3, #228	; 0xe4
 8005be8:	61bb      	str	r3, [r7, #24]
 8005bea:	69bb      	ldr	r3, [r7, #24]
 8005bec:	681b      	ldr	r3, [r3, #0]
 8005bee:	2b00      	cmp	r3, #0
 8005bf0:	d1f7      	bne.n	8005be2 <can_driver_register+0x136>
 8005bf2:	69bb      	ldr	r3, [r7, #24]
 8005bf4:	697a      	ldr	r2, [r7, #20]
 8005bf6:	601a      	str	r2, [r3, #0]

    return instance;
 8005bf8:	697b      	ldr	r3, [r7, #20]
}
 8005bfa:	4618      	mov	r0, r3
 8005bfc:	3720      	adds	r7, #32
 8005bfe:	46bd      	mov	sp, r7
 8005c00:	bd80      	pop	{r7, pc}
 8005c02:	bf00      	nop
 8005c04:	20000a00 	.word	0x20000a00
 8005c08:	20000a3c 	.word	0x20000a3c
 8005c0c:	08005ee5 	.word	0x08005ee5
 8005c10:	20001470 	.word	0x20001470

08005c14 <can_try_enqueue_waiting_frame_I>:

static void can_try_enqueue_waiting_frame_I(struct can_instance_s* instance) {
 8005c14:	b580      	push	{r7, lr}
 8005c16:	b088      	sub	sp, #32
 8005c18:	af00      	add	r7, sp, #0
 8005c1a:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8005c1c:	f005 f9a0 	bl	800af60 <chDbgCheckClassI>
=======
 8005c1c:	f005 f9e4 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
    
    // Enqueue the next frame if it will be the highest priority
    bool have_empty_mailbox = false;
 8005c20:	2300      	movs	r3, #0
 8005c22:	77fb      	strb	r3, [r7, #31]
    uint8_t empty_mailbox_idx;
    bool have_pending_mailbox = false;
 8005c24:	2300      	movs	r3, #0
 8005c26:	777b      	strb	r3, [r7, #29]
    can_frame_priority_t highest_prio_pending = 0;
 8005c28:	2300      	movs	r3, #0
 8005c2a:	61bb      	str	r3, [r7, #24]
    
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005c2c:	2300      	movs	r3, #0
 8005c2e:	75fb      	strb	r3, [r7, #23]
 8005c30:	e037      	b.n	8005ca2 <can_try_enqueue_waiting_frame_I+0x8e>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_EMPTY) {
 8005c32:	7dfb      	ldrb	r3, [r7, #23]
 8005c34:	687a      	ldr	r2, [r7, #4]
 8005c36:	3302      	adds	r3, #2
 8005c38:	00db      	lsls	r3, r3, #3
 8005c3a:	4413      	add	r3, r2
 8005c3c:	7a1b      	ldrb	r3, [r3, #8]
 8005c3e:	2b00      	cmp	r3, #0
 8005c40:	d104      	bne.n	8005c4c <can_try_enqueue_waiting_frame_I+0x38>
            have_empty_mailbox = true;
 8005c42:	2301      	movs	r3, #1
 8005c44:	77fb      	strb	r3, [r7, #31]
            empty_mailbox_idx = i;
 8005c46:	7dfb      	ldrb	r3, [r7, #23]
 8005c48:	77bb      	strb	r3, [r7, #30]
 8005c4a:	e027      	b.n	8005c9c <can_try_enqueue_waiting_frame_I+0x88>
        } else if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING || instance->tx_mailbox[i].state == CAN_TX_MAILBOX_ABORTING) {
 8005c4c:	7dfb      	ldrb	r3, [r7, #23]
 8005c4e:	687a      	ldr	r2, [r7, #4]
 8005c50:	3302      	adds	r3, #2
 8005c52:	00db      	lsls	r3, r3, #3
 8005c54:	4413      	add	r3, r2
 8005c56:	7a1b      	ldrb	r3, [r3, #8]
 8005c58:	2b01      	cmp	r3, #1
 8005c5a:	d007      	beq.n	8005c6c <can_try_enqueue_waiting_frame_I+0x58>
 8005c5c:	7dfb      	ldrb	r3, [r7, #23]
 8005c5e:	687a      	ldr	r2, [r7, #4]
 8005c60:	3302      	adds	r3, #2
 8005c62:	00db      	lsls	r3, r3, #3
 8005c64:	4413      	add	r3, r2
 8005c66:	7a1b      	ldrb	r3, [r3, #8]
 8005c68:	2b02      	cmp	r3, #2
 8005c6a:	d117      	bne.n	8005c9c <can_try_enqueue_waiting_frame_I+0x88>
            can_frame_priority_t prio = can_get_tx_frame_priority_X(instance->tx_mailbox[i].frame);
 8005c6c:	7dfb      	ldrb	r3, [r7, #23]
 8005c6e:	687a      	ldr	r2, [r7, #4]
 8005c70:	3302      	adds	r3, #2
 8005c72:	00db      	lsls	r3, r3, #3
 8005c74:	4413      	add	r3, r2
 8005c76:	685b      	ldr	r3, [r3, #4]
 8005c78:	4618      	mov	r0, r3
 8005c7a:	f001 fe05 	bl	8007888 <can_get_tx_frame_priority_X>
 8005c7e:	6138      	str	r0, [r7, #16]
            if (!have_pending_mailbox || prio > highest_prio_pending) {
 8005c80:	7f7b      	ldrb	r3, [r7, #29]
 8005c82:	f083 0301 	eor.w	r3, r3, #1
 8005c86:	b2db      	uxtb	r3, r3
 8005c88:	2b00      	cmp	r3, #0
 8005c8a:	d103      	bne.n	8005c94 <can_try_enqueue_waiting_frame_I+0x80>
 8005c8c:	693a      	ldr	r2, [r7, #16]
 8005c8e:	69bb      	ldr	r3, [r7, #24]
 8005c90:	429a      	cmp	r2, r3
 8005c92:	d901      	bls.n	8005c98 <can_try_enqueue_waiting_frame_I+0x84>
                highest_prio_pending = prio;
 8005c94:	693b      	ldr	r3, [r7, #16]
 8005c96:	61bb      	str	r3, [r7, #24]
            }
            have_pending_mailbox = true;
 8005c98:	2301      	movs	r3, #1
 8005c9a:	777b      	strb	r3, [r7, #29]
    bool have_empty_mailbox = false;
    uint8_t empty_mailbox_idx;
    bool have_pending_mailbox = false;
    can_frame_priority_t highest_prio_pending = 0;
    
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005c9c:	7dfb      	ldrb	r3, [r7, #23]
 8005c9e:	3301      	adds	r3, #1
 8005ca0:	75fb      	strb	r3, [r7, #23]
 8005ca2:	687b      	ldr	r3, [r7, #4]
 8005ca4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005ca8:	7dfa      	ldrb	r2, [r7, #23]
 8005caa:	429a      	cmp	r2, r3
 8005cac:	d3c1      	bcc.n	8005c32 <can_try_enqueue_waiting_frame_I+0x1e>
            }
            have_pending_mailbox = true;
        }
    }
    
    if (!have_empty_mailbox) {
 8005cae:	7ffb      	ldrb	r3, [r7, #31]
 8005cb0:	f083 0301 	eor.w	r3, r3, #1
 8005cb4:	b2db      	uxtb	r3, r3
 8005cb6:	2b00      	cmp	r3, #0
 8005cb8:	d130      	bne.n	8005d1c <can_try_enqueue_waiting_frame_I+0x108>
        return;
    }
    
    struct can_tx_frame_s* frame = can_tx_queue_peek_I(&instance->tx_queue);
 8005cba:	687b      	ldr	r3, [r7, #4]
 8005cbc:	333c      	adds	r3, #60	; 0x3c
 8005cbe:	4618      	mov	r0, r3
 8005cc0:	f001 fcbe 	bl	8007640 <can_tx_queue_peek_I>
 8005cc4:	60f8      	str	r0, [r7, #12]
    if (frame && (!have_pending_mailbox || can_get_tx_frame_priority_X(frame) > highest_prio_pending)) {
 8005cc6:	68fb      	ldr	r3, [r7, #12]
 8005cc8:	2b00      	cmp	r3, #0
 8005cca:	d027      	beq.n	8005d1c <can_try_enqueue_waiting_frame_I+0x108>
 8005ccc:	7f7b      	ldrb	r3, [r7, #29]
 8005cce:	f083 0301 	eor.w	r3, r3, #1
 8005cd2:	b2db      	uxtb	r3, r3
 8005cd4:	2b00      	cmp	r3, #0
 8005cd6:	d106      	bne.n	8005ce6 <can_try_enqueue_waiting_frame_I+0xd2>
 8005cd8:	68f8      	ldr	r0, [r7, #12]
 8005cda:	f001 fdd5 	bl	8007888 <can_get_tx_frame_priority_X>
 8005cde:	4602      	mov	r2, r0
 8005ce0:	69bb      	ldr	r3, [r7, #24]
 8005ce2:	429a      	cmp	r2, r3
 8005ce4:	d91a      	bls.n	8005d1c <can_try_enqueue_waiting_frame_I+0x108>
        can_tx_queue_pop_I(&instance->tx_queue);
 8005ce6:	687b      	ldr	r3, [r7, #4]
 8005ce8:	333c      	adds	r3, #60	; 0x3c
 8005cea:	4618      	mov	r0, r3
 8005cec:	f001 fcb4 	bl	8007658 <can_tx_queue_pop_I>
        instance->tx_mailbox[empty_mailbox_idx].frame = frame;
 8005cf0:	7fbb      	ldrb	r3, [r7, #30]
 8005cf2:	687a      	ldr	r2, [r7, #4]
 8005cf4:	3302      	adds	r3, #2
 8005cf6:	00db      	lsls	r3, r3, #3
 8005cf8:	4413      	add	r3, r2
 8005cfa:	68fa      	ldr	r2, [r7, #12]
 8005cfc:	605a      	str	r2, [r3, #4]
        instance->tx_mailbox[empty_mailbox_idx].state = CAN_TX_MAILBOX_PENDING;
 8005cfe:	7fbb      	ldrb	r3, [r7, #30]
 8005d00:	687a      	ldr	r2, [r7, #4]
 8005d02:	3302      	adds	r3, #2
 8005d04:	00db      	lsls	r3, r3, #3
 8005d06:	4413      	add	r3, r2
 8005d08:	2201      	movs	r2, #1
 8005d0a:	721a      	strb	r2, [r3, #8]
        instance->driver_iface->load_tx_mailbox_I(instance->driver_ctx, empty_mailbox_idx, &frame->content);
 8005d0c:	687b      	ldr	r3, [r7, #4]
 8005d0e:	691b      	ldr	r3, [r3, #16]
 8005d10:	68db      	ldr	r3, [r3, #12]
 8005d12:	687a      	ldr	r2, [r7, #4]
 8005d14:	68d0      	ldr	r0, [r2, #12]
 8005d16:	68fa      	ldr	r2, [r7, #12]
 8005d18:	7fb9      	ldrb	r1, [r7, #30]
 8005d1a:	4798      	blx	r3
    }
}
 8005d1c:	3720      	adds	r7, #32
 8005d1e:	46bd      	mov	sp, r7
 8005d20:	bd80      	pop	{r7, pc}
 8005d22:	bf00      	nop

08005d24 <can_try_enqueue_waiting_frame>:

static void can_try_enqueue_waiting_frame(struct can_instance_s* instance) {
 8005d24:	b580      	push	{r7, lr}
 8005d26:	b082      	sub	sp, #8
 8005d28:	af00      	add	r7, sp, #0
 8005d2a:	6078      	str	r0, [r7, #4]
    chSysLock();
 8005d2c:	f001 fdea 	bl	8007904 <chSysLock.lto_priv.102>
    can_try_enqueue_waiting_frame_I(instance);
 8005d30:	6878      	ldr	r0, [r7, #4]
 8005d32:	f7ff ff6f 	bl	8005c14 <can_try_enqueue_waiting_frame_I>
    chSysUnlock();
 8005d36:	f001 fded 	bl	8007914 <chSysUnlock.lto_priv.101>
}
 8005d3a:	3708      	adds	r7, #8
 8005d3c:	46bd      	mov	sp, r7
 8005d3e:	bd80      	pop	{r7, pc}

08005d40 <can_reschedule_expire_timer_I>:

static void can_reschedule_expire_timer_I(struct can_instance_s* instance) {
 8005d40:	b580      	push	{r7, lr}
 8005d42:	b086      	sub	sp, #24
 8005d44:	af00      	add	r7, sp, #0
 8005d46:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8005d48:	f005 f90a 	bl	800af60 <chDbgCheckClassI>
=======
 8005d48:	f005 f94e 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    // Find frame that expires soonest in mailboxes and queue, schedule expire handler for that time
    systime_t t_now = chVTGetSystemTimeX();
 8005d4c:	f001 fdfe 	bl	800794c <chVTGetSystemTimeX.lto_priv.100>
 8005d50:	4603      	mov	r3, r0
 8005d52:	827b      	strh	r3, [r7, #18]
    systime_t min_ticks_to_expire = TIME_INFINITE;
 8005d54:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005d58:	82fb      	strh	r3, [r7, #22]

    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005d5a:	2300      	movs	r3, #0
 8005d5c:	757b      	strb	r3, [r7, #21]
 8005d5e:	e01d      	b.n	8005d9c <can_reschedule_expire_timer_I+0x5c>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING) {
 8005d60:	7d7b      	ldrb	r3, [r7, #21]
 8005d62:	687a      	ldr	r2, [r7, #4]
 8005d64:	3302      	adds	r3, #2
 8005d66:	00db      	lsls	r3, r3, #3
 8005d68:	4413      	add	r3, r2
 8005d6a:	7a1b      	ldrb	r3, [r3, #8]
 8005d6c:	2b01      	cmp	r3, #1
 8005d6e:	d112      	bne.n	8005d96 <can_reschedule_expire_timer_I+0x56>
            systime_t ticks_to_expire = can_tx_frame_time_until_expire_X(instance->tx_mailbox[i].frame, t_now);
 8005d70:	7d7b      	ldrb	r3, [r7, #21]
 8005d72:	687a      	ldr	r2, [r7, #4]
 8005d74:	3302      	adds	r3, #2
 8005d76:	00db      	lsls	r3, r3, #3
 8005d78:	4413      	add	r3, r2
 8005d7a:	685a      	ldr	r2, [r3, #4]
 8005d7c:	8a7b      	ldrh	r3, [r7, #18]
 8005d7e:	4610      	mov	r0, r2
 8005d80:	4619      	mov	r1, r3
 8005d82:	f001 fd0b 	bl	800779c <can_tx_frame_time_until_expire_X>
 8005d86:	4603      	mov	r3, r0
 8005d88:	823b      	strh	r3, [r7, #16]
            if (ticks_to_expire < min_ticks_to_expire) {
 8005d8a:	8a3a      	ldrh	r2, [r7, #16]
 8005d8c:	8afb      	ldrh	r3, [r7, #22]
 8005d8e:	429a      	cmp	r2, r3
 8005d90:	d201      	bcs.n	8005d96 <can_reschedule_expire_timer_I+0x56>
                min_ticks_to_expire = ticks_to_expire;
 8005d92:	8a3b      	ldrh	r3, [r7, #16]
 8005d94:	82fb      	strh	r3, [r7, #22]

    // Find frame that expires soonest in mailboxes and queue, schedule expire handler for that time
    systime_t t_now = chVTGetSystemTimeX();
    systime_t min_ticks_to_expire = TIME_INFINITE;

    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005d96:	7d7b      	ldrb	r3, [r7, #21]
 8005d98:	3301      	adds	r3, #1
 8005d9a:	757b      	strb	r3, [r7, #21]
 8005d9c:	687b      	ldr	r3, [r7, #4]
 8005d9e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005da2:	7d7a      	ldrb	r2, [r7, #21]
 8005da4:	429a      	cmp	r2, r3
 8005da6:	d3db      	bcc.n	8005d60 <can_reschedule_expire_timer_I+0x20>
                min_ticks_to_expire = ticks_to_expire;
            }
        }
    }

    struct can_tx_frame_s* frame = NULL;
 8005da8:	2300      	movs	r3, #0
 8005daa:	60bb      	str	r3, [r7, #8]
 8005dac:	e00d      	b.n	8005dca <can_reschedule_expire_timer_I+0x8a>
    while (can_tx_queue_iterate_I(&instance->tx_queue, &frame)) {
        systime_t ticks_to_expire = can_tx_frame_time_until_expire_X(frame, t_now);
 8005dae:	68ba      	ldr	r2, [r7, #8]
 8005db0:	8a7b      	ldrh	r3, [r7, #18]
 8005db2:	4610      	mov	r0, r2
 8005db4:	4619      	mov	r1, r3
 8005db6:	f001 fcf1 	bl	800779c <can_tx_frame_time_until_expire_X>
 8005dba:	4603      	mov	r3, r0
 8005dbc:	81fb      	strh	r3, [r7, #14]
        if (ticks_to_expire < min_ticks_to_expire) {
 8005dbe:	89fa      	ldrh	r2, [r7, #14]
 8005dc0:	8afb      	ldrh	r3, [r7, #22]
 8005dc2:	429a      	cmp	r2, r3
 8005dc4:	d201      	bcs.n	8005dca <can_reschedule_expire_timer_I+0x8a>
            min_ticks_to_expire = ticks_to_expire;
 8005dc6:	89fb      	ldrh	r3, [r7, #14]
 8005dc8:	82fb      	strh	r3, [r7, #22]
            }
        }
    }

    struct can_tx_frame_s* frame = NULL;
    while (can_tx_queue_iterate_I(&instance->tx_queue, &frame)) {
 8005dca:	687b      	ldr	r3, [r7, #4]
 8005dcc:	f103 023c 	add.w	r2, r3, #60	; 0x3c
 8005dd0:	f107 0308 	add.w	r3, r7, #8
 8005dd4:	4610      	mov	r0, r2
 8005dd6:	4619      	mov	r1, r3
 8005dd8:	f001 fc04 	bl	80075e4 <can_tx_queue_iterate_I>
 8005ddc:	4603      	mov	r3, r0
 8005dde:	2b00      	cmp	r3, #0
 8005de0:	d1e5      	bne.n	8005dae <can_reschedule_expire_timer_I+0x6e>
        if (ticks_to_expire < min_ticks_to_expire) {
            min_ticks_to_expire = ticks_to_expire;
        }
    }

    worker_thread_timer_task_reschedule_I(&WT_EXPIRE, &instance->expire_timer_task, min_ticks_to_expire);
 8005de2:	687b      	ldr	r3, [r7, #4]
 8005de4:	f103 02cc 	add.w	r2, r3, #204	; 0xcc
 8005de8:	8afb      	ldrh	r3, [r7, #22]
 8005dea:	4804      	ldr	r0, [pc, #16]	; (8005dfc <can_reschedule_expire_timer_I+0xbc>)
 8005dec:	4611      	mov	r1, r2
 8005dee:	461a      	mov	r2, r3
<<<<<<< HEAD
 8005df0:	f002 fd98 	bl	8008924 <worker_thread_timer_task_reschedule_I>
=======
 8005df0:	f002 fdb4 	bl	800895c <worker_thread_timer_task_reschedule_I>
>>>>>>> 752c83b... update binaries
}
 8005df4:	3718      	adds	r7, #24
 8005df6:	46bd      	mov	sp, r7
 8005df8:	bd80      	pop	{r7, pc}
 8005dfa:	bf00      	nop
 8005dfc:	20000a3c 	.word	0x20000a3c

08005e00 <can_reschedule_expire_timer>:

static void can_reschedule_expire_timer(struct can_instance_s* instance) {
 8005e00:	b580      	push	{r7, lr}
 8005e02:	b082      	sub	sp, #8
 8005e04:	af00      	add	r7, sp, #0
 8005e06:	6078      	str	r0, [r7, #4]
    chSysLock();
 8005e08:	f001 fd7c 	bl	8007904 <chSysLock.lto_priv.102>
    can_reschedule_expire_timer_I(instance);
 8005e0c:	6878      	ldr	r0, [r7, #4]
 8005e0e:	f7ff ff97 	bl	8005d40 <can_reschedule_expire_timer_I>
    chSchRescheduleS();
<<<<<<< HEAD
 8005e12:	f005 fca7 	bl	800b764 <chSchRescheduleS>
=======
 8005e12:	f005 fceb 	bl	800b7ec <chSchRescheduleS>
>>>>>>> 752c83b... update binaries
    chSysUnlock();
 8005e16:	f001 fd7d 	bl	8007914 <chSysUnlock.lto_priv.101>
}
 8005e1a:	3708      	adds	r7, #8
 8005e1c:	46bd      	mov	sp, r7
 8005e1e:	bd80      	pop	{r7, pc}

08005e20 <can_tx_frame_completed_I>:

static void can_tx_frame_completed_I(struct can_instance_s* instance, struct can_tx_frame_s* frame, bool success, systime_t completion_systime) {
 8005e20:	b580      	push	{r7, lr}
 8005e22:	b088      	sub	sp, #32
 8005e24:	af02      	add	r7, sp, #8
 8005e26:	60f8      	str	r0, [r7, #12]
 8005e28:	60b9      	str	r1, [r7, #8]
 8005e2a:	4611      	mov	r1, r2
 8005e2c:	461a      	mov	r2, r3
 8005e2e:	460b      	mov	r3, r1
 8005e30:	71fb      	strb	r3, [r7, #7]
 8005e32:	4613      	mov	r3, r2
 8005e34:	80bb      	strh	r3, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8005e36:	f005 f893 	bl	800af60 <chDbgCheckClassI>
=======
 8005e36:	f005 f8d7 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    if (frame->completion_topic) {
 8005e3a:	68bb      	ldr	r3, [r7, #8]
 8005e3c:	695b      	ldr	r3, [r3, #20]
 8005e3e:	2b00      	cmp	r3, #0
 8005e40:	d017      	beq.n	8005e72 <can_tx_frame_completed_I+0x52>
        struct can_transmit_completion_msg_s msg = { success, completion_systime };
 8005e42:	79fb      	ldrb	r3, [r7, #7]
 8005e44:	b29b      	uxth	r3, r3
 8005e46:	82bb      	strh	r3, [r7, #20]
 8005e48:	88bb      	ldrh	r3, [r7, #4]
 8005e4a:	2b00      	cmp	r3, #0
 8005e4c:	bf14      	ite	ne
 8005e4e:	2301      	movne	r3, #1
 8005e50:	2300      	moveq	r3, #0
 8005e52:	b2db      	uxtb	r3, r3
 8005e54:	75bb      	strb	r3, [r7, #22]
        worker_thread_publisher_task_publish_I(&instance->tx_publisher_task, frame->completion_topic, sizeof(struct can_transmit_completion_msg_s), pubsub_copy_writer_func, &msg);
 8005e56:	68fb      	ldr	r3, [r7, #12]
 8005e58:	f103 018c 	add.w	r1, r3, #140	; 0x8c
 8005e5c:	68bb      	ldr	r3, [r7, #8]
 8005e5e:	695a      	ldr	r2, [r3, #20]
 8005e60:	f107 0314 	add.w	r3, r7, #20
 8005e64:	9300      	str	r3, [sp, #0]
 8005e66:	4608      	mov	r0, r1
 8005e68:	4611      	mov	r1, r2
 8005e6a:	2204      	movs	r2, #4
 8005e6c:	4b05      	ldr	r3, [pc, #20]	; (8005e84 <can_tx_frame_completed_I+0x64>)
 8005e6e:	f000 fd33 	bl	80068d8 <worker_thread_publisher_task_publish_I>
    }
    chPoolFreeI(&instance->frame_pool, frame);
 8005e72:	68fb      	ldr	r3, [r7, #12]
 8005e74:	3330      	adds	r3, #48	; 0x30
 8005e76:	4618      	mov	r0, r3
 8005e78:	68b9      	ldr	r1, [r7, #8]
<<<<<<< HEAD
 8005e7a:	f003 ff0d 	bl	8009c98 <chPoolFreeI>
=======
 8005e7a:	f003 ff51 	bl	8009d20 <chPoolFreeI>
>>>>>>> 752c83b... update binaries
}
 8005e7e:	3718      	adds	r7, #24
 8005e80:	46bd      	mov	sp, r7
 8005e82:	bd80      	pop	{r7, pc}
<<<<<<< HEAD
 8005e84:	080082a9 	.word	0x080082a9
=======
 8005e84:	080082f9 	.word	0x080082f9
>>>>>>> 752c83b... update binaries

08005e88 <can_tx_frame_completed>:

static void can_tx_frame_completed(struct can_instance_s* instance, struct can_tx_frame_s* frame, bool success, systime_t completion_systime) {
 8005e88:	b580      	push	{r7, lr}
 8005e8a:	b086      	sub	sp, #24
 8005e8c:	af00      	add	r7, sp, #0
 8005e8e:	60f8      	str	r0, [r7, #12]
 8005e90:	60b9      	str	r1, [r7, #8]
 8005e92:	4611      	mov	r1, r2
 8005e94:	461a      	mov	r2, r3
 8005e96:	460b      	mov	r3, r1
 8005e98:	71fb      	strb	r3, [r7, #7]
 8005e9a:	4613      	mov	r3, r2
 8005e9c:	80bb      	strh	r3, [r7, #4]
    if (frame->completion_topic) {
 8005e9e:	68bb      	ldr	r3, [r7, #8]
 8005ea0:	695b      	ldr	r3, [r3, #20]
 8005ea2:	2b00      	cmp	r3, #0
 8005ea4:	d012      	beq.n	8005ecc <can_tx_frame_completed+0x44>
        struct can_transmit_completion_msg_s msg = { success, completion_systime };
 8005ea6:	79fb      	ldrb	r3, [r7, #7]
 8005ea8:	b29b      	uxth	r3, r3
 8005eaa:	82bb      	strh	r3, [r7, #20]
 8005eac:	88bb      	ldrh	r3, [r7, #4]
 8005eae:	2b00      	cmp	r3, #0
 8005eb0:	bf14      	ite	ne
 8005eb2:	2301      	movne	r3, #1
 8005eb4:	2300      	moveq	r3, #0
 8005eb6:	b2db      	uxtb	r3, r3
 8005eb8:	75bb      	strb	r3, [r7, #22]
        pubsub_publish_message(frame->completion_topic, sizeof(struct can_transmit_completion_msg_s), pubsub_copy_writer_func, &msg);
 8005eba:	68bb      	ldr	r3, [r7, #8]
 8005ebc:	695a      	ldr	r2, [r3, #20]
 8005ebe:	f107 0314 	add.w	r3, r7, #20
 8005ec2:	4610      	mov	r0, r2
 8005ec4:	2104      	movs	r1, #4
 8005ec6:	4a06      	ldr	r2, [pc, #24]	; (8005ee0 <can_tx_frame_completed+0x58>)
<<<<<<< HEAD
 8005ec8:	f002 fa36 	bl	8008338 <pubsub_publish_message>
=======
 8005ec8:	f002 fa5e 	bl	8008388 <pubsub_publish_message>
>>>>>>> 752c83b... update binaries
    }
    chPoolFree(&instance->frame_pool, frame);
 8005ecc:	68fb      	ldr	r3, [r7, #12]
 8005ece:	3330      	adds	r3, #48	; 0x30
 8005ed0:	4618      	mov	r0, r3
 8005ed2:	68b9      	ldr	r1, [r7, #8]
<<<<<<< HEAD
 8005ed4:	f003 fefe 	bl	8009cd4 <chPoolFree>
=======
 8005ed4:	f003 ff42 	bl	8009d5c <chPoolFree>
>>>>>>> 752c83b... update binaries
}
 8005ed8:	3718      	adds	r7, #24
 8005eda:	46bd      	mov	sp, r7
 8005edc:	bd80      	pop	{r7, pc}
 8005ede:	bf00      	nop
<<<<<<< HEAD
 8005ee0:	080082a9 	.word	0x080082a9
=======
 8005ee0:	080082f9 	.word	0x080082f9
>>>>>>> 752c83b... update binaries

08005ee4 <can_expire_handler>:

static void can_expire_handler(struct worker_thread_timer_task_s* task) {
 8005ee4:	b580      	push	{r7, lr}
 8005ee6:	b086      	sub	sp, #24
 8005ee8:	af00      	add	r7, sp, #0
 8005eea:	6078      	str	r0, [r7, #4]
    struct can_instance_s* instance = worker_thread_task_get_user_context(task);
 8005eec:	6878      	ldr	r0, [r7, #4]
<<<<<<< HEAD
 8005eee:	f002 fd7b 	bl	80089e8 <worker_thread_task_get_user_context>
=======
 8005eee:	f002 fd93 	bl	8008a18 <worker_thread_task_get_user_context>
>>>>>>> 752c83b... update binaries
 8005ef2:	6138      	str	r0, [r7, #16]

    // Abort expired mailboxes
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005ef4:	2300      	movs	r3, #0
 8005ef6:	75fb      	strb	r3, [r7, #23]
 8005ef8:	e02d      	b.n	8005f56 <can_expire_handler+0x72>
        chSysLock();
 8005efa:	f001 fd03 	bl	8007904 <chSysLock.lto_priv.102>
        if (instance->tx_mailbox[i].state == CAN_TX_MAILBOX_PENDING && can_tx_frame_expired_X(instance->tx_mailbox[i].frame)) {
 8005efe:	7dfb      	ldrb	r3, [r7, #23]
 8005f00:	693a      	ldr	r2, [r7, #16]
 8005f02:	3302      	adds	r3, #2
 8005f04:	00db      	lsls	r3, r3, #3
 8005f06:	4413      	add	r3, r2
 8005f08:	7a1b      	ldrb	r3, [r3, #8]
 8005f0a:	2b01      	cmp	r3, #1
 8005f0c:	d11e      	bne.n	8005f4c <can_expire_handler+0x68>
 8005f0e:	7dfb      	ldrb	r3, [r7, #23]
 8005f10:	693a      	ldr	r2, [r7, #16]
 8005f12:	3302      	adds	r3, #2
 8005f14:	00db      	lsls	r3, r3, #3
 8005f16:	4413      	add	r3, r2
 8005f18:	685b      	ldr	r3, [r3, #4]
 8005f1a:	4618      	mov	r0, r3
 8005f1c:	f001 fc28 	bl	8007770 <can_tx_frame_expired_X>
 8005f20:	4603      	mov	r3, r0
 8005f22:	2b00      	cmp	r3, #0
 8005f24:	d012      	beq.n	8005f4c <can_expire_handler+0x68>
            if (instance->driver_iface->abort_tx_mailbox_I(instance->driver_ctx, i)) {
 8005f26:	693b      	ldr	r3, [r7, #16]
 8005f28:	691b      	ldr	r3, [r3, #16]
 8005f2a:	689b      	ldr	r3, [r3, #8]
 8005f2c:	693a      	ldr	r2, [r7, #16]
 8005f2e:	68d1      	ldr	r1, [r2, #12]
 8005f30:	7dfa      	ldrb	r2, [r7, #23]
 8005f32:	4608      	mov	r0, r1
 8005f34:	4611      	mov	r1, r2
 8005f36:	4798      	blx	r3
 8005f38:	4603      	mov	r3, r0
 8005f3a:	2b00      	cmp	r3, #0
 8005f3c:	d006      	beq.n	8005f4c <can_expire_handler+0x68>
                instance->tx_mailbox[i].state = CAN_TX_MAILBOX_ABORTING;
 8005f3e:	7dfb      	ldrb	r3, [r7, #23]
 8005f40:	693a      	ldr	r2, [r7, #16]
 8005f42:	3302      	adds	r3, #2
 8005f44:	00db      	lsls	r3, r3, #3
 8005f46:	4413      	add	r3, r2
 8005f48:	2202      	movs	r2, #2
 8005f4a:	721a      	strb	r2, [r3, #8]
            }
        }
        chSysUnlock();
 8005f4c:	f001 fce2 	bl	8007914 <chSysUnlock.lto_priv.101>

static void can_expire_handler(struct worker_thread_timer_task_s* task) {
    struct can_instance_s* instance = worker_thread_task_get_user_context(task);

    // Abort expired mailboxes
    for (uint8_t i=0; i < instance->num_tx_mailboxes; i++) {
 8005f50:	7dfb      	ldrb	r3, [r7, #23]
 8005f52:	3301      	adds	r3, #1
 8005f54:	75fb      	strb	r3, [r7, #23]
 8005f56:	693b      	ldr	r3, [r7, #16]
 8005f58:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8005f5c:	7dfa      	ldrb	r2, [r7, #23]
 8005f5e:	429a      	cmp	r2, r3
 8005f60:	d3cb      	bcc.n	8005efa <can_expire_handler+0x16>
 8005f62:	e007      	b.n	8005f74 <can_expire_handler+0x90>
    }

    // Abort expired queue items
    struct can_tx_frame_s* frame;
    while ((frame = can_tx_queue_pop_expired(&instance->tx_queue)) != NULL) {
        can_tx_frame_completed(instance, frame, false, chVTGetSystemTimeX());
 8005f64:	f001 fcf2 	bl	800794c <chVTGetSystemTimeX.lto_priv.100>
 8005f68:	4603      	mov	r3, r0
 8005f6a:	6938      	ldr	r0, [r7, #16]
 8005f6c:	68f9      	ldr	r1, [r7, #12]
 8005f6e:	2200      	movs	r2, #0
 8005f70:	f7ff ff8a 	bl	8005e88 <can_tx_frame_completed>
        chSysUnlock();
    }

    // Abort expired queue items
    struct can_tx_frame_s* frame;
    while ((frame = can_tx_queue_pop_expired(&instance->tx_queue)) != NULL) {
 8005f74:	693b      	ldr	r3, [r7, #16]
 8005f76:	333c      	adds	r3, #60	; 0x3c
 8005f78:	4618      	mov	r0, r3
 8005f7a:	f001 fbaf 	bl	80076dc <can_tx_queue_pop_expired>
 8005f7e:	60f8      	str	r0, [r7, #12]
 8005f80:	68fb      	ldr	r3, [r7, #12]
 8005f82:	2b00      	cmp	r3, #0
 8005f84:	d1ee      	bne.n	8005f64 <can_expire_handler+0x80>
        can_tx_frame_completed(instance, frame, false, chVTGetSystemTimeX());
    }

    can_try_enqueue_waiting_frame(instance);
 8005f86:	6938      	ldr	r0, [r7, #16]
 8005f88:	f7ff fecc 	bl	8005d24 <can_try_enqueue_waiting_frame>

    can_reschedule_expire_timer(instance);
 8005f8c:	6938      	ldr	r0, [r7, #16]
 8005f8e:	f7ff ff37 	bl	8005e00 <can_reschedule_expire_timer>
}
 8005f92:	3718      	adds	r7, #24
 8005f94:	46bd      	mov	sp, r7
 8005f96:	bd80      	pop	{r7, pc}

08005f98 <can_driver_tx_request_complete_I>:

void can_driver_tx_request_complete_I(struct can_instance_s* instance, uint8_t mb_idx, bool transmit_success, systime_t completion_systime) {
 8005f98:	b580      	push	{r7, lr}
 8005f9a:	b082      	sub	sp, #8
 8005f9c:	af00      	add	r7, sp, #0
 8005f9e:	6078      	str	r0, [r7, #4]
 8005fa0:	4608      	mov	r0, r1
 8005fa2:	4611      	mov	r1, r2
 8005fa4:	461a      	mov	r2, r3
 8005fa6:	4603      	mov	r3, r0
 8005fa8:	70fb      	strb	r3, [r7, #3]
 8005faa:	460b      	mov	r3, r1
 8005fac:	70bb      	strb	r3, [r7, #2]
 8005fae:	4613      	mov	r3, r2
 8005fb0:	803b      	strh	r3, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8005fb2:	f004 ffd5 	bl	800af60 <chDbgCheckClassI>
=======
 8005fb2:	f005 f819 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
    chDbgCheck(instance->tx_mailbox[mb_idx].state == CAN_TX_MAILBOX_PENDING || instance->tx_mailbox[mb_idx].state == CAN_TX_MAILBOX_ABORTING);
 8005fb6:	78fb      	ldrb	r3, [r7, #3]
 8005fb8:	687a      	ldr	r2, [r7, #4]
 8005fba:	3302      	adds	r3, #2
 8005fbc:	00db      	lsls	r3, r3, #3
 8005fbe:	4413      	add	r3, r2
 8005fc0:	7a1b      	ldrb	r3, [r3, #8]
 8005fc2:	2b01      	cmp	r3, #1
 8005fc4:	d00a      	beq.n	8005fdc <can_driver_tx_request_complete_I+0x44>
 8005fc6:	78fb      	ldrb	r3, [r7, #3]
 8005fc8:	687a      	ldr	r2, [r7, #4]
 8005fca:	3302      	adds	r3, #2
 8005fcc:	00db      	lsls	r3, r3, #3
 8005fce:	4413      	add	r3, r2
 8005fd0:	7a1b      	ldrb	r3, [r3, #8]
 8005fd2:	2b02      	cmp	r3, #2
 8005fd4:	d002      	beq.n	8005fdc <can_driver_tx_request_complete_I+0x44>
 8005fd6:	480d      	ldr	r0, [pc, #52]	; (800600c <can_driver_tx_request_complete_I+0x74>)
<<<<<<< HEAD
 8005fd8:	f004 fee4 	bl	800ada4 <chSysHalt>
=======
 8005fd8:	f004 ff28 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

    can_tx_frame_completed_I(instance, instance->tx_mailbox[mb_idx].frame, transmit_success, completion_systime);
 8005fdc:	78fb      	ldrb	r3, [r7, #3]
 8005fde:	687a      	ldr	r2, [r7, #4]
 8005fe0:	3302      	adds	r3, #2
 8005fe2:	00db      	lsls	r3, r3, #3
 8005fe4:	4413      	add	r3, r2
 8005fe6:	6859      	ldr	r1, [r3, #4]
 8005fe8:	78ba      	ldrb	r2, [r7, #2]
 8005fea:	883b      	ldrh	r3, [r7, #0]
 8005fec:	6878      	ldr	r0, [r7, #4]
 8005fee:	f7ff ff17 	bl	8005e20 <can_tx_frame_completed_I>
    instance->tx_mailbox[mb_idx].state = CAN_TX_MAILBOX_EMPTY;
 8005ff2:	78fb      	ldrb	r3, [r7, #3]
 8005ff4:	687a      	ldr	r2, [r7, #4]
 8005ff6:	3302      	adds	r3, #2
 8005ff8:	00db      	lsls	r3, r3, #3
 8005ffa:	4413      	add	r3, r2
 8005ffc:	2200      	movs	r2, #0
 8005ffe:	721a      	strb	r2, [r3, #8]

    can_try_enqueue_waiting_frame_I(instance);
 8006000:	6878      	ldr	r0, [r7, #4]
 8006002:	f7ff fe07 	bl	8005c14 <can_try_enqueue_waiting_frame_I>
}
 8006006:	3708      	adds	r7, #8
 8006008:	46bd      	mov	sp, r7
 800600a:	bd80      	pop	{r7, pc}
 800600c:	0800ed4c 	.word	0x0800ed4c

08006010 <can_fill_rx_frame_I>:
struct can_fill_rx_frame_params_s {
    systime_t rx_systime;
    struct can_frame_s* frame;
};

static void can_fill_rx_frame_I(size_t msg_size, void* msg, void* ctx) {
 8006010:	b590      	push	{r4, r7, lr}
 8006012:	b087      	sub	sp, #28
 8006014:	af00      	add	r7, sp, #0
 8006016:	60f8      	str	r0, [r7, #12]
 8006018:	60b9      	str	r1, [r7, #8]
 800601a:	607a      	str	r2, [r7, #4]
    (void)msg_size;

    chDbgCheckClassI();
<<<<<<< HEAD
 800601c:	f004 ffa0 	bl	800af60 <chDbgCheckClassI>
=======
 800601c:	f004 ffe4 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    struct can_fill_rx_frame_params_s* params = ctx;
 8006020:	687b      	ldr	r3, [r7, #4]
 8006022:	617b      	str	r3, [r7, #20]
    struct can_rx_frame_s* frame = msg;
 8006024:	68bb      	ldr	r3, [r7, #8]
 8006026:	613b      	str	r3, [r7, #16]

    frame->content = *params->frame;
 8006028:	697b      	ldr	r3, [r7, #20]
 800602a:	685b      	ldr	r3, [r3, #4]
 800602c:	693a      	ldr	r2, [r7, #16]
 800602e:	4614      	mov	r4, r2
 8006030:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8006032:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    frame->rx_systime = params->rx_systime;
 8006036:	697b      	ldr	r3, [r7, #20]
 8006038:	881a      	ldrh	r2, [r3, #0]
 800603a:	693b      	ldr	r3, [r7, #16]
 800603c:	821a      	strh	r2, [r3, #16]
}
 800603e:	371c      	adds	r7, #28
 8006040:	46bd      	mov	sp, r7
 8006042:	bd90      	pop	{r4, r7, pc}

08006044 <can_driver_rx_frame_received_I>:

void can_driver_rx_frame_received_I(struct can_instance_s* instance, uint8_t mb_idx, systime_t rx_systime, struct can_frame_s* frame) {
 8006044:	b580      	push	{r7, lr}
 8006046:	b088      	sub	sp, #32
 8006048:	af02      	add	r7, sp, #8
 800604a:	60f8      	str	r0, [r7, #12]
 800604c:	607b      	str	r3, [r7, #4]
 800604e:	460b      	mov	r3, r1
 8006050:	72fb      	strb	r3, [r7, #11]
 8006052:	4613      	mov	r3, r2
 8006054:	813b      	strh	r3, [r7, #8]
    (void)mb_idx;

    chDbgCheckClassI();
<<<<<<< HEAD
 8006056:	f004 ff83 	bl	800af60 <chDbgCheckClassI>
=======
 8006056:	f004 ffc7 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    struct can_fill_rx_frame_params_s can_fill_rx_frame_params = {rx_systime, frame};
 800605a:	893b      	ldrh	r3, [r7, #8]
 800605c:	823b      	strh	r3, [r7, #16]
 800605e:	687b      	ldr	r3, [r7, #4]
 8006060:	617b      	str	r3, [r7, #20]
    worker_thread_publisher_task_publish_I(&instance->rx_publisher_task, &instance->rx_topic, sizeof(struct can_rx_frame_s), can_fill_rx_frame_I, &can_fill_rx_frame_params);
 8006062:	68fb      	ldr	r3, [r7, #12]
 8006064:	f103 014c 	add.w	r1, r3, #76	; 0x4c
 8006068:	68fb      	ldr	r3, [r7, #12]
 800606a:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800606e:	f107 0310 	add.w	r3, r7, #16
 8006072:	9300      	str	r3, [sp, #0]
 8006074:	4608      	mov	r0, r1
 8006076:	4611      	mov	r1, r2
 8006078:	2214      	movs	r2, #20
 800607a:	4b04      	ldr	r3, [pc, #16]	; (800608c <can_driver_rx_frame_received_I+0x48>)
 800607c:	f000 fc2c 	bl	80068d8 <worker_thread_publisher_task_publish_I>
    instance->baudrate_confirmed = true;
 8006080:	68fb      	ldr	r3, [r7, #12]
 8006082:	2201      	movs	r2, #1
 8006084:	721a      	strb	r2, [r3, #8]
}
 8006086:	3718      	adds	r7, #24
 8006088:	46bd      	mov	sp, r7
 800608a:	bd80      	pop	{r7, pc}
 800608c:	08006011 	.word	0x08006011

08006090 <LL_US2ST.lto_priv.86>:
 * @param[in] usec      number of microseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_US2ST(unsigned int usec) {
 8006090:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8006094:	b086      	sub	sp, #24
 8006096:	af00      	add	r7, sp, #0
 8006098:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)usec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999999ULL)
 800609a:	68f9      	ldr	r1, [r7, #12]
 800609c:	460c      	mov	r4, r1
 800609e:	f04f 0500 	mov.w	r5, #0
 80060a2:	4620      	mov	r0, r4
 80060a4:	4629      	mov	r1, r5
 80060a6:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 80060aa:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 80060ae:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 80060b2:	4650      	mov	r0, sl
 80060b4:	4659      	mov	r1, fp
 80060b6:	014b      	lsls	r3, r1, #5
 80060b8:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 80060bc:	0142      	lsls	r2, r0, #5
 80060be:	1a12      	subs	r2, r2, r0
 80060c0:	eb63 0301 	sbc.w	r3, r3, r1
 80060c4:	18a4      	adds	r4, r4, r2
 80060c6:	eb45 0503 	adc.w	r5, r5, r3
 80060ca:	4622      	mov	r2, r4
 80060cc:	462b      	mov	r3, r5
 80060ce:	0099      	lsls	r1, r3, #2
 80060d0:	6079      	str	r1, [r7, #4]
 80060d2:	6879      	ldr	r1, [r7, #4]
 80060d4:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 80060d8:	6079      	str	r1, [r7, #4]
 80060da:	0091      	lsls	r1, r2, #2
 80060dc:	6039      	str	r1, [r7, #0]
 80060de:	e9d7 0100 	ldrd	r0, r1, [r7]
 80060e2:	1880      	adds	r0, r0, r2
 80060e4:	eb41 0103 	adc.w	r1, r1, r3
 80060e8:	4602      	mov	r2, r0
 80060ea:	460b      	mov	r3, r1
 80060ec:	ea4f 1903 	mov.w	r9, r3, lsl #4
 80060f0:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 80060f4:	ea4f 1802 	mov.w	r8, r2, lsl #4
 80060f8:	4642      	mov	r2, r8
 80060fa:	464b      	mov	r3, r9
 80060fc:	4610      	mov	r0, r2
 80060fe:	4619      	mov	r1, r3
 8006100:	4a11      	ldr	r2, [pc, #68]	; (8006148 <LL_US2ST.lto_priv.86+0xb8>)
 8006102:	f04f 0300 	mov.w	r3, #0
 8006106:	1812      	adds	r2, r2, r0
 8006108:	eb43 0301 	adc.w	r3, r3, r1
 800610c:	4610      	mov	r0, r2
 800610e:	4619      	mov	r1, r3
 8006110:	4a0e      	ldr	r2, [pc, #56]	; (800614c <LL_US2ST.lto_priv.86+0xbc>)
 8006112:	f04f 0300 	mov.w	r3, #0
 8006116:	f7fd f8ff 	bl	8003318 <__aeabi_uldivmod>
 800611a:	4602      	mov	r2, r0
 800611c:	460b      	mov	r3, r1
 800611e:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 8006122:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8006126:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 800612a:	f04f 0100 	mov.w	r1, #0
 800612e:	4299      	cmp	r1, r3
 8006130:	bf08      	it	eq
 8006132:	4290      	cmpeq	r0, r2
 8006134:	d202      	bcs.n	800613c <LL_US2ST.lto_priv.86+0xac>
 8006136:	4806      	ldr	r0, [pc, #24]	; (8006150 <LL_US2ST.lto_priv.86+0xc0>)
<<<<<<< HEAD
 8006138:	f004 fe34 	bl	800ada4 <chSysHalt>
=======
 8006138:	f004 fe78 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

  return (systime_t)ticks;
 800613c:	8a3b      	ldrh	r3, [r7, #16]
}
 800613e:	4618      	mov	r0, r3
 8006140:	3718      	adds	r7, #24
 8006142:	46bd      	mov	sp, r7
 8006144:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8006148:	000f423f 	.word	0x000f423f
 800614c:	000f4240 	.word	0x000f4240
 8006150:	0800ed80 	.word	0x0800ed80

08006154 <is_baudrate_valid>:

static uint8_t baudrate_idx = 0;
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task);
static struct worker_thread_timer_task_s autobaud_timer_task;

static bool is_baudrate_valid(uint32_t baudrate) {
 8006154:	b480      	push	{r7}
 8006156:	b085      	sub	sp, #20
 8006158:	af00      	add	r7, sp, #0
 800615a:	6078      	str	r0, [r7, #4]
    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 800615c:	2300      	movs	r3, #0
 800615e:	73fb      	strb	r3, [r7, #15]
 8006160:	e00b      	b.n	800617a <is_baudrate_valid+0x26>
        if (baudrate == valid_baudrates[i]) {
 8006162:	7bfb      	ldrb	r3, [r7, #15]
 8006164:	4a0a      	ldr	r2, [pc, #40]	; (8006190 <is_baudrate_valid+0x3c>)
 8006166:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800616a:	687b      	ldr	r3, [r7, #4]
 800616c:	429a      	cmp	r2, r3
 800616e:	d101      	bne.n	8006174 <is_baudrate_valid+0x20>
            return true;
 8006170:	2301      	movs	r3, #1
 8006172:	e006      	b.n	8006182 <is_baudrate_valid+0x2e>
static uint8_t baudrate_idx = 0;
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task);
static struct worker_thread_timer_task_s autobaud_timer_task;

static bool is_baudrate_valid(uint32_t baudrate) {
    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 8006174:	7bfb      	ldrb	r3, [r7, #15]
 8006176:	3301      	adds	r3, #1
 8006178:	73fb      	strb	r3, [r7, #15]
 800617a:	7bfb      	ldrb	r3, [r7, #15]
 800617c:	2b03      	cmp	r3, #3
 800617e:	d9f0      	bls.n	8006162 <is_baudrate_valid+0xe>
        if (baudrate == valid_baudrates[i]) {
            return true;
        }
    }
    return false;
 8006180:	2300      	movs	r3, #0
}
 8006182:	4618      	mov	r0, r3
 8006184:	3714      	adds	r7, #20
 8006186:	46bd      	mov	sp, r7
 8006188:	f85d 7b04 	ldr.w	r7, [sp], #4
 800618c:	4770      	bx	lr
 800618e:	bf00      	nop
 8006190:	0800ed70 	.word	0x0800ed70

08006194 <_local_ctor_37>:

RUN_AFTER(CAN_INIT) {
 8006194:	b580      	push	{r7, lr}
 8006196:	b086      	sub	sp, #24
 8006198:	af02      	add	r7, sp, #8
    uint32_t canbus_baud = 1000000;
 800619a:	4b38      	ldr	r3, [pc, #224]	; (800627c <_local_ctor_37+0xe8>)
 800619c:	60fb      	str	r3, [r7, #12]
    bool canbus_autobaud_enable = true;
 800619e:	2301      	movs	r3, #1
 80061a0:	72fb      	strb	r3, [r7, #11]

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    if (is_baudrate_valid(shared_get_parameters(&shared_app_descriptor)->canbus_baudrate)) {
 80061a2:	4837      	ldr	r0, [pc, #220]	; (8006280 <_local_ctor_37+0xec>)
<<<<<<< HEAD
 80061a4:	f003 fb5c 	bl	8009860 <shared_get_parameters>
=======
 80061a4:	f003 fb9e 	bl	80098e4 <shared_get_parameters>
>>>>>>> 752c83b... update binaries
 80061a8:	4603      	mov	r3, r0
 80061aa:	789a      	ldrb	r2, [r3, #2]
 80061ac:	0852      	lsrs	r2, r2, #1
 80061ae:	b2d2      	uxtb	r2, r2
 80061b0:	78d9      	ldrb	r1, [r3, #3]
 80061b2:	01c9      	lsls	r1, r1, #7
 80061b4:	430a      	orrs	r2, r1
 80061b6:	7919      	ldrb	r1, [r3, #4]
 80061b8:	03c9      	lsls	r1, r1, #15
 80061ba:	430a      	orrs	r2, r1
 80061bc:	795b      	ldrb	r3, [r3, #5]
 80061be:	05db      	lsls	r3, r3, #23
 80061c0:	4313      	orrs	r3, r2
 80061c2:	4618      	mov	r0, r3
 80061c4:	f7ff ffc6 	bl	8006154 <is_baudrate_valid>
 80061c8:	4603      	mov	r3, r0
 80061ca:	2b00      	cmp	r3, #0
 80061cc:	d010      	beq.n	80061f0 <_local_ctor_37+0x5c>
        canbus_baud = shared_get_parameters(&shared_app_descriptor)->canbus_baudrate;
 80061ce:	482c      	ldr	r0, [pc, #176]	; (8006280 <_local_ctor_37+0xec>)
<<<<<<< HEAD
 80061d0:	f003 fb46 	bl	8009860 <shared_get_parameters>
=======
 80061d0:	f003 fb88 	bl	80098e4 <shared_get_parameters>
>>>>>>> 752c83b... update binaries
 80061d4:	4603      	mov	r3, r0
 80061d6:	789a      	ldrb	r2, [r3, #2]
 80061d8:	0852      	lsrs	r2, r2, #1
 80061da:	b2d2      	uxtb	r2, r2
 80061dc:	78d9      	ldrb	r1, [r3, #3]
 80061de:	01c9      	lsls	r1, r1, #7
 80061e0:	430a      	orrs	r2, r1
 80061e2:	7919      	ldrb	r1, [r3, #4]
 80061e4:	03c9      	lsls	r1, r1, #15
 80061e6:	430a      	orrs	r2, r1
 80061e8:	795b      	ldrb	r3, [r3, #5]
 80061ea:	05db      	lsls	r3, r3, #23
 80061ec:	4313      	orrs	r3, r2
 80061ee:	60fb      	str	r3, [r7, #12]
    }

    if (shared_get_parameters(&shared_app_descriptor)->canbus_disable_auto_baud) {
 80061f0:	4823      	ldr	r0, [pc, #140]	; (8006280 <_local_ctor_37+0xec>)
<<<<<<< HEAD
 80061f2:	f003 fb35 	bl	8009860 <shared_get_parameters>
=======
 80061f2:	f003 fb77 	bl	80098e4 <shared_get_parameters>
>>>>>>> 752c83b... update binaries
 80061f6:	4603      	mov	r3, r0
 80061f8:	789b      	ldrb	r3, [r3, #2]
 80061fa:	f003 0301 	and.w	r3, r3, #1
 80061fe:	b2db      	uxtb	r3, r3
 8006200:	2b00      	cmp	r3, #0
 8006202:	d001      	beq.n	8006208 <_local_ctor_37+0x74>
        canbus_autobaud_enable = false;
 8006204:	2300      	movs	r3, #0
 8006206:	72fb      	strb	r3, [r7, #11]
        canbus_baud = boot_msg.canbus_info.baudrate;
        canbus_autobaud_enable = false;
    }
#endif

    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 8006208:	2300      	movs	r3, #0
 800620a:	72bb      	strb	r3, [r7, #10]
 800620c:	e00d      	b.n	800622a <_local_ctor_37+0x96>
        if (canbus_baud == valid_baudrates[i]) {
 800620e:	7abb      	ldrb	r3, [r7, #10]
 8006210:	4a1c      	ldr	r2, [pc, #112]	; (8006284 <_local_ctor_37+0xf0>)
 8006212:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8006216:	68fb      	ldr	r3, [r7, #12]
 8006218:	429a      	cmp	r2, r3
 800621a:	d103      	bne.n	8006224 <_local_ctor_37+0x90>
            baudrate_idx = i;
 800621c:	4a1a      	ldr	r2, [pc, #104]	; (8006288 <_local_ctor_37+0xf4>)
 800621e:	7abb      	ldrb	r3, [r7, #10]
 8006220:	7013      	strb	r3, [r2, #0]
 8006222:	e005      	b.n	8006230 <_local_ctor_37+0x9c>
        canbus_baud = boot_msg.canbus_info.baudrate;
        canbus_autobaud_enable = false;
    }
#endif

    for (uint8_t i=0; i<LEN(valid_baudrates); i++) {
 8006224:	7abb      	ldrb	r3, [r7, #10]
 8006226:	3301      	adds	r3, #1
 8006228:	72bb      	strb	r3, [r7, #10]
 800622a:	7abb      	ldrb	r3, [r7, #10]
 800622c:	2b03      	cmp	r3, #3
 800622e:	d9ee      	bls.n	800620e <_local_ctor_37+0x7a>
            baudrate_idx = i;
            break;
        }
    }

    struct can_instance_s* can_instance = NULL;
 8006230:	2300      	movs	r3, #0
 8006232:	607b      	str	r3, [r7, #4]
 8006234:	e007      	b.n	8006246 <_local_ctor_37+0xb2>
    while (can_iterate_instances(&can_instance)) {
        can_start(can_instance, canbus_autobaud_enable, true, canbus_baud);
 8006236:	687a      	ldr	r2, [r7, #4]
 8006238:	7afb      	ldrb	r3, [r7, #11]
 800623a:	4610      	mov	r0, r2
 800623c:	4619      	mov	r1, r3
 800623e:	2201      	movs	r2, #1
 8006240:	68fb      	ldr	r3, [r7, #12]
 8006242:	f7ff fb63 	bl	800590c <can_start>
            break;
        }
    }

    struct can_instance_s* can_instance = NULL;
    while (can_iterate_instances(&can_instance)) {
 8006246:	1d3b      	adds	r3, r7, #4
 8006248:	4618      	mov	r0, r3
 800624a:	f001 fba5 	bl	8007998 <can_iterate_instances>
 800624e:	4603      	mov	r3, r0
 8006250:	2b00      	cmp	r3, #0
 8006252:	d1f0      	bne.n	8006236 <_local_ctor_37+0xa2>
        can_start(can_instance, canbus_autobaud_enable, true, canbus_baud);
    }

    if (canbus_autobaud_enable) {
 8006254:	7afb      	ldrb	r3, [r7, #11]
 8006256:	2b00      	cmp	r3, #0
 8006258:	d00c      	beq.n	8006274 <_local_ctor_37+0xe0>
        worker_thread_add_timer_task(&WT, &autobaud_timer_task, autobaud_timer_task_func, NULL, LL_US2ST(CAN_AUTOBAUD_SWITCH_INTERVAL_US), false);
 800625a:	4808      	ldr	r0, [pc, #32]	; (800627c <_local_ctor_37+0xe8>)
 800625c:	f7ff ff18 	bl	8006090 <LL_US2ST.lto_priv.86>
 8006260:	4603      	mov	r3, r0
 8006262:	9300      	str	r3, [sp, #0]
 8006264:	2300      	movs	r3, #0
 8006266:	9301      	str	r3, [sp, #4]
 8006268:	4808      	ldr	r0, [pc, #32]	; (800628c <_local_ctor_37+0xf8>)
 800626a:	4909      	ldr	r1, [pc, #36]	; (8006290 <_local_ctor_37+0xfc>)
 800626c:	4a09      	ldr	r2, [pc, #36]	; (8006294 <_local_ctor_37+0x100>)
 800626e:	2300      	movs	r3, #0
<<<<<<< HEAD
 8006270:	f002 fb1e 	bl	80088b0 <worker_thread_add_timer_task>
=======
 8006270:	f002 fb2a 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries
    }
}
 8006274:	3710      	adds	r7, #16
 8006276:	46bd      	mov	sp, r7
 8006278:	bd80      	pop	{r7, pc}
 800627a:	bf00      	nop
 800627c:	000f4240 	.word	0x000f4240
 8006280:	08003160 	.word	0x08003160
 8006284:	0800ed70 	.word	0x0800ed70
 8006288:	20001474 	.word	0x20001474
 800628c:	20000a20 	.word	0x20000a20
 8006290:	20001478 	.word	0x20001478
 8006294:	08006299 	.word	0x08006299

08006298 <autobaud_timer_task_func>:

static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task) {
 8006298:	b580      	push	{r7, lr}
 800629a:	b084      	sub	sp, #16
 800629c:	af00      	add	r7, sp, #0
 800629e:	6078      	str	r0, [r7, #4]
    baudrate_idx = (baudrate_idx + 1) % LEN(valid_baudrates);
 80062a0:	4b20      	ldr	r3, [pc, #128]	; (8006324 <autobaud_timer_task_func+0x8c>)
 80062a2:	781b      	ldrb	r3, [r3, #0]
 80062a4:	3301      	adds	r3, #1
 80062a6:	b2db      	uxtb	r3, r3
 80062a8:	f003 0303 	and.w	r3, r3, #3
 80062ac:	b2da      	uxtb	r2, r3
 80062ae:	4b1d      	ldr	r3, [pc, #116]	; (8006324 <autobaud_timer_task_func+0x8c>)
 80062b0:	701a      	strb	r2, [r3, #0]

    bool autobaud_complete = true;
 80062b2:	2301      	movs	r3, #1
 80062b4:	73fb      	strb	r3, [r7, #15]
    struct can_instance_s* can_instance = NULL;
 80062b6:	2300      	movs	r3, #0
 80062b8:	60bb      	str	r3, [r7, #8]
 80062ba:	e019      	b.n	80062f0 <autobaud_timer_task_func+0x58>
    while (can_iterate_instances(&can_instance)) {
        if (can_get_baudrate_confirmed(can_instance)) {
 80062bc:	68bb      	ldr	r3, [r7, #8]
 80062be:	4618      	mov	r0, r3
 80062c0:	f001 fc30 	bl	8007b24 <can_get_baudrate_confirmed>
 80062c4:	4603      	mov	r3, r0
 80062c6:	2b00      	cmp	r3, #0
 80062c8:	d005      	beq.n	80062d6 <autobaud_timer_task_func+0x3e>
            can_set_silent_mode(can_instance, false);
 80062ca:	68bb      	ldr	r3, [r7, #8]
 80062cc:	4618      	mov	r0, r3
 80062ce:	2100      	movs	r1, #0
 80062d0:	f001 fbc2 	bl	8007a58 <can_set_silent_mode>
 80062d4:	e00c      	b.n	80062f0 <autobaud_timer_task_func+0x58>
        } else {
            can_set_baudrate(can_instance, valid_baudrates[baudrate_idx]);
 80062d6:	68ba      	ldr	r2, [r7, #8]
 80062d8:	4b12      	ldr	r3, [pc, #72]	; (8006324 <autobaud_timer_task_func+0x8c>)
 80062da:	781b      	ldrb	r3, [r3, #0]
 80062dc:	4619      	mov	r1, r3
 80062de:	4b12      	ldr	r3, [pc, #72]	; (8006328 <autobaud_timer_task_func+0x90>)
 80062e0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80062e4:	4610      	mov	r0, r2
 80062e6:	4619      	mov	r1, r3
 80062e8:	f001 fbfa 	bl	8007ae0 <can_set_baudrate>
            autobaud_complete = false;
 80062ec:	2300      	movs	r3, #0
 80062ee:	73fb      	strb	r3, [r7, #15]
static void autobaud_timer_task_func(struct worker_thread_timer_task_s* task) {
    baudrate_idx = (baudrate_idx + 1) % LEN(valid_baudrates);

    bool autobaud_complete = true;
    struct can_instance_s* can_instance = NULL;
    while (can_iterate_instances(&can_instance)) {
 80062f0:	f107 0308 	add.w	r3, r7, #8
 80062f4:	4618      	mov	r0, r3
 80062f6:	f001 fb4f 	bl	8007998 <can_iterate_instances>
 80062fa:	4603      	mov	r3, r0
 80062fc:	2b00      	cmp	r3, #0
 80062fe:	d1dd      	bne.n	80062bc <autobaud_timer_task_func+0x24>
            can_set_baudrate(can_instance, valid_baudrates[baudrate_idx]);
            autobaud_complete = false;
        }
    }

    if (!autobaud_complete) {
 8006300:	7bfb      	ldrb	r3, [r7, #15]
 8006302:	f083 0301 	eor.w	r3, r3, #1
 8006306:	b2db      	uxtb	r3, r3
 8006308:	2b00      	cmp	r3, #0
 800630a:	d008      	beq.n	800631e <autobaud_timer_task_func+0x86>
        worker_thread_timer_task_reschedule(&WT, task, LL_US2ST(CAN_AUTOBAUD_SWITCH_INTERVAL_US));
 800630c:	4807      	ldr	r0, [pc, #28]	; (800632c <autobaud_timer_task_func+0x94>)
 800630e:	f7ff febf 	bl	8006090 <LL_US2ST.lto_priv.86>
 8006312:	4603      	mov	r3, r0
 8006314:	4806      	ldr	r0, [pc, #24]	; (8006330 <autobaud_timer_task_func+0x98>)
 8006316:	6879      	ldr	r1, [r7, #4]
 8006318:	461a      	mov	r2, r3
<<<<<<< HEAD
 800631a:	f002 fb19 	bl	8008950 <worker_thread_timer_task_reschedule>
=======
 800631a:	f002 fb33 	bl	8008984 <worker_thread_timer_task_reschedule>
>>>>>>> 752c83b... update binaries
    }
}
 800631e:	3710      	adds	r7, #16
 8006320:	46bd      	mov	sp, r7
 8006322:	bd80      	pop	{r7, pc}
 8006324:	20001474 	.word	0x20001474
 8006328:	0800ed70 	.word	0x0800ed70
 800632c:	000f4240 	.word	0x000f4240
 8006330:	20000a20 	.word	0x20000a20

08006334 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006334:	b480      	push	{r7}
 8006336:	b083      	sub	sp, #12
 8006338:	af00      	add	r7, sp, #0
 800633a:	2320      	movs	r3, #32
 800633c:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800633e:	687b      	ldr	r3, [r7, #4]
 8006340:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006344:	370c      	adds	r7, #12
 8006346:	46bd      	mov	sp, r7
 8006348:	f85d 7b04 	ldr.w	r7, [sp], #4
 800634c:	4770      	bx	lr
 800634e:	bf00      	nop

08006350 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006350:	b480      	push	{r7}
 8006352:	b083      	sub	sp, #12
 8006354:	af00      	add	r7, sp, #0
 8006356:	2300      	movs	r3, #0
 8006358:	607b      	str	r3, [r7, #4]
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006360:	370c      	adds	r7, #12
 8006362:	46bd      	mov	sp, r7
 8006364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006368:	4770      	bx	lr
 800636a:	bf00      	nop

0800636c <chSysLock.lto_priv.77>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800636c:	b580      	push	{r7, lr}
 800636e:	af00      	add	r7, sp, #0

  port_lock();
 8006370:	f7ff ffe0 	bl	8006334 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
<<<<<<< HEAD
 8006374:	f004 fd64 	bl	800ae40 <_dbg_check_lock>
=======
 8006374:	f004 fda8 	bl	800aec8 <_dbg_check_lock>
>>>>>>> 752c83b... update binaries
}
 8006378:	bd80      	pop	{r7, pc}
 800637a:	bf00      	nop

0800637c <chSysUnlock.lto_priv.76>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800637c:	b580      	push	{r7, lr}
 800637e:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
<<<<<<< HEAD
 8006380:	f004 fd74 	bl	800ae6c <_dbg_check_unlock>
=======
 8006380:	f004 fdb8 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006384:	4b09      	ldr	r3, [pc, #36]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 8006386:	681b      	ldr	r3, [r3, #0]
 8006388:	4a08      	ldr	r2, [pc, #32]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 800638a:	4293      	cmp	r3, r2
 800638c:	d00a      	beq.n	80063a4 <chSysUnlock.lto_priv.76+0x28>
 800638e:	4b07      	ldr	r3, [pc, #28]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 8006390:	699b      	ldr	r3, [r3, #24]
 8006392:	689a      	ldr	r2, [r3, #8]
 8006394:	4b05      	ldr	r3, [pc, #20]	; (80063ac <chSysUnlock.lto_priv.76+0x30>)
 8006396:	681b      	ldr	r3, [r3, #0]
 8006398:	689b      	ldr	r3, [r3, #8]
 800639a:	429a      	cmp	r2, r3
 800639c:	d202      	bcs.n	80063a4 <chSysUnlock.lto_priv.76+0x28>
 800639e:	4804      	ldr	r0, [pc, #16]	; (80063b0 <chSysUnlock.lto_priv.76+0x34>)
<<<<<<< HEAD
 80063a0:	f004 fd00 	bl	800ada4 <chSysHalt>
=======
 80063a0:	f004 fd44 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80063a4:	f7ff ffd4 	bl	8006350 <port_unlock>
}
 80063a8:	bd80      	pop	{r7, pc}
 80063aa:	bf00      	nop
 80063ac:	20001338 	.word	0x20001338
 80063b0:	0800ed98 	.word	0x0800ed98

080063b4 <LL_US2ST.lto_priv.87>:
 * @param[in] usec      number of microseconds
 * @return              The number of ticks.
 *
 * @api
 */
static inline systime_t LL_US2ST(unsigned int usec) {
 80063b4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80063b8:	b086      	sub	sp, #24
 80063ba:	af00      	add	r7, sp, #0
 80063bc:	60f8      	str	r0, [r7, #12]
  uint64_t ticks = (((uint64_t)usec * (uint64_t)CH_CFG_ST_FREQUENCY) + 999999ULL)
 80063be:	68f9      	ldr	r1, [r7, #12]
 80063c0:	460c      	mov	r4, r1
 80063c2:	f04f 0500 	mov.w	r5, #0
 80063c6:	4620      	mov	r0, r4
 80063c8:	4629      	mov	r1, r5
 80063ca:	ea4f 0b81 	mov.w	fp, r1, lsl #2
 80063ce:	ea4b 7b90 	orr.w	fp, fp, r0, lsr #30
 80063d2:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 80063d6:	4650      	mov	r0, sl
 80063d8:	4659      	mov	r1, fp
 80063da:	014b      	lsls	r3, r1, #5
 80063dc:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 80063e0:	0142      	lsls	r2, r0, #5
 80063e2:	1a12      	subs	r2, r2, r0
 80063e4:	eb63 0301 	sbc.w	r3, r3, r1
 80063e8:	18a4      	adds	r4, r4, r2
 80063ea:	eb45 0503 	adc.w	r5, r5, r3
 80063ee:	4622      	mov	r2, r4
 80063f0:	462b      	mov	r3, r5
 80063f2:	0099      	lsls	r1, r3, #2
 80063f4:	6079      	str	r1, [r7, #4]
 80063f6:	6879      	ldr	r1, [r7, #4]
 80063f8:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 80063fc:	6079      	str	r1, [r7, #4]
 80063fe:	0091      	lsls	r1, r2, #2
 8006400:	6039      	str	r1, [r7, #0]
 8006402:	e9d7 0100 	ldrd	r0, r1, [r7]
 8006406:	1880      	adds	r0, r0, r2
 8006408:	eb41 0103 	adc.w	r1, r1, r3
 800640c:	4602      	mov	r2, r0
 800640e:	460b      	mov	r3, r1
 8006410:	ea4f 1903 	mov.w	r9, r3, lsl #4
 8006414:	ea49 7912 	orr.w	r9, r9, r2, lsr #28
 8006418:	ea4f 1802 	mov.w	r8, r2, lsl #4
 800641c:	4642      	mov	r2, r8
 800641e:	464b      	mov	r3, r9
 8006420:	4610      	mov	r0, r2
 8006422:	4619      	mov	r1, r3
 8006424:	4a11      	ldr	r2, [pc, #68]	; (800646c <LL_US2ST.lto_priv.87+0xb8>)
 8006426:	f04f 0300 	mov.w	r3, #0
 800642a:	1812      	adds	r2, r2, r0
 800642c:	eb43 0301 	adc.w	r3, r3, r1
 8006430:	4610      	mov	r0, r2
 8006432:	4619      	mov	r1, r3
 8006434:	4a0e      	ldr	r2, [pc, #56]	; (8006470 <LL_US2ST.lto_priv.87+0xbc>)
 8006436:	f04f 0300 	mov.w	r3, #0
 800643a:	f7fc ff6d 	bl	8003318 <__aeabi_uldivmod>
 800643e:	4602      	mov	r2, r0
 8006440:	460b      	mov	r3, r1
 8006442:	e9c7 2304 	strd	r2, r3, [r7, #16]
                   / 1000000ULL;

  chDbgAssert(ticks <= (uint64_t)TIME_MAXIMUM, "conversion overflow");
 8006446:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800644a:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 800644e:	f04f 0100 	mov.w	r1, #0
 8006452:	4299      	cmp	r1, r3
 8006454:	bf08      	it	eq
 8006456:	4290      	cmpeq	r0, r2
 8006458:	d202      	bcs.n	8006460 <LL_US2ST.lto_priv.87+0xac>
 800645a:	4806      	ldr	r0, [pc, #24]	; (8006474 <LL_US2ST.lto_priv.87+0xc0>)
<<<<<<< HEAD
 800645c:	f004 fca2 	bl	800ada4 <chSysHalt>
=======
 800645c:	f004 fce6 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

  return (systime_t)ticks;
 8006460:	8a3b      	ldrh	r3, [r7, #16]
}
 8006462:	4618      	mov	r0, r3
 8006464:	3718      	adds	r7, #24
 8006466:	46bd      	mov	sp, r7
 8006468:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800646c:	000f423f 	.word	0x000f423f
 8006470:	000f4240 	.word	0x000f4240
 8006474:	0800ed8c 	.word	0x0800ed8c

08006478 <chCoreAllocAlignedI.lto_priv.9>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8006478:	b580      	push	{r7, lr}
 800647a:	b082      	sub	sp, #8
 800647c:	af00      	add	r7, sp, #0
 800647e:	6078      	str	r0, [r7, #4]
 8006480:	6039      	str	r1, [r7, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8006482:	6878      	ldr	r0, [r7, #4]
 8006484:	6839      	ldr	r1, [r7, #0]
 8006486:	2200      	movs	r2, #0
<<<<<<< HEAD
 8006488:	f003 fad0 	bl	8009a2c <chCoreAllocAlignedWithOffsetI>
=======
 8006488:	f003 fb14 	bl	8009ab4 <chCoreAllocAlignedWithOffsetI>
>>>>>>> 752c83b... update binaries
 800648c:	4603      	mov	r3, r0
}
 800648e:	4618      	mov	r0, r3
 8006490:	3708      	adds	r7, #8
 8006492:	46bd      	mov	sp, r7
 8006494:	bd80      	pop	{r7, pc}
 8006496:	bf00      	nop

08006498 <chCoreAlloc.lto_priv.85>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 8006498:	b580      	push	{r7, lr}
 800649a:	b082      	sub	sp, #8
 800649c:	af00      	add	r7, sp, #0
 800649e:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 80064a0:	6878      	ldr	r0, [r7, #4]
 80064a2:	2104      	movs	r1, #4
 80064a4:	2200      	movs	r2, #0
<<<<<<< HEAD
 80064a6:	f003 fb05 	bl	8009ab4 <chCoreAllocAlignedWithOffset>
=======
 80064a6:	f003 fb49 	bl	8009b3c <chCoreAllocAlignedWithOffset>
>>>>>>> 752c83b... update binaries
 80064aa:	4603      	mov	r3, r0
}
 80064ac:	4618      	mov	r0, r3
 80064ae:	3708      	adds	r7, #8
 80064b0:	46bd      	mov	sp, r7
 80064b2:	bd80      	pop	{r7, pc}

080064b4 <_local_ctor_100>:
#ifdef MODULE_PARAM_ENABLED
#include <modules/param/param.h>
PARAM_DEFINE_UINT8_PARAM_STATIC(node_id_param, "uavcan.node_id", 0, 0, 125)
#endif

RUN_ON(UAVCAN_INIT) {
 80064b4:	b580      	push	{r7, lr}
 80064b6:	b082      	sub	sp, #8
 80064b8:	af02      	add	r7, sp, #8
    uavcan_init(0);
 80064ba:	2000      	movs	r0, #0
 80064bc:	f000 f818 	bl	80064f0 <uavcan_init>

    worker_thread_add_timer_task(&WT_RX, &stale_transfer_cleanup_task, stale_transfer_cleanup_task_func, NULL, LL_US2ST(CANARD_RECOMMENDED_STALE_TRANSFER_CLEANUP_INTERVAL_USEC), true);
 80064c0:	4807      	ldr	r0, [pc, #28]	; (80064e0 <_local_ctor_100+0x2c>)
 80064c2:	f7ff ff77 	bl	80063b4 <LL_US2ST.lto_priv.87>
 80064c6:	4603      	mov	r3, r0
 80064c8:	9300      	str	r3, [sp, #0]
 80064ca:	2301      	movs	r3, #1
 80064cc:	9301      	str	r3, [sp, #4]
 80064ce:	4805      	ldr	r0, [pc, #20]	; (80064e4 <_local_ctor_100+0x30>)
 80064d0:	4905      	ldr	r1, [pc, #20]	; (80064e8 <_local_ctor_100+0x34>)
 80064d2:	4a06      	ldr	r2, [pc, #24]	; (80064ec <_local_ctor_100+0x38>)
 80064d4:	2300      	movs	r3, #0
<<<<<<< HEAD
 80064d6:	f002 f9eb 	bl	80088b0 <worker_thread_add_timer_task>
=======
 80064d6:	f002 f9f7 	bl	80088c8 <worker_thread_add_timer_task>
>>>>>>> 752c83b... update binaries
}
 80064da:	46bd      	mov	sp, r7
 80064dc:	bd80      	pop	{r7, pc}
 80064de:	bf00      	nop
 80064e0:	000f4240 	.word	0x000f4240
 80064e4:	20000a3c 	.word	0x20000a3c
 80064e8:	20001490 	.word	0x20001490
 80064ec:	08005089 	.word	0x08005089

080064f0 <uavcan_init>:

static void uavcan_init(uint8_t can_dev_idx) {
 80064f0:	b580      	push	{r7, lr}
 80064f2:	b08c      	sub	sp, #48	; 0x30
 80064f4:	af02      	add	r7, sp, #8
 80064f6:	4603      	mov	r3, r0
 80064f8:	71fb      	strb	r3, [r7, #7]
    struct uavcan_instance_s* instance;
    struct can_instance_s* can_instance;
    void* transfer_id_map_working_area;

    if (!(can_instance = can_get_instance(can_dev_idx))) { goto fail; }
 80064fa:	79fb      	ldrb	r3, [r7, #7]
 80064fc:	4618      	mov	r0, r3
 80064fe:	f001 fa73 	bl	80079e8 <can_get_instance>
 8006502:	61f8      	str	r0, [r7, #28]
 8006504:	69fb      	ldr	r3, [r7, #28]
 8006506:	2b00      	cmp	r3, #0
 8006508:	f000 8091 	beq.w	800662e <uavcan_init+0x13e>
    if (!(instance = chCoreAlloc(sizeof(struct uavcan_instance_s)))) { goto fail; }
 800650c:	2074      	movs	r0, #116	; 0x74
 800650e:	f7ff ffc3 	bl	8006498 <chCoreAlloc.lto_priv.85>
 8006512:	61b8      	str	r0, [r7, #24]
 8006514:	69bb      	ldr	r3, [r7, #24]
 8006516:	2b00      	cmp	r3, #0
 8006518:	f000 8089 	beq.w	800662e <uavcan_init+0x13e>
    memset(instance, 0, sizeof(struct uavcan_instance_s));
 800651c:	69b8      	ldr	r0, [r7, #24]
 800651e:	2100      	movs	r1, #0
 8006520:	2274      	movs	r2, #116	; 0x74
<<<<<<< HEAD
 8006522:	f008 f851 	bl	800e5c8 <memset>
=======
 8006522:	f008 f895 	bl	800e650 <memset>
>>>>>>> 752c83b... update binaries
    instance->can_instance = can_instance;
 8006526:	69bb      	ldr	r3, [r7, #24]
 8006528:	69fa      	ldr	r2, [r7, #28]
 800652a:	605a      	str	r2, [r3, #4]
    if (!(transfer_id_map_working_area = chCoreAlloc(UAVCAN_TRANSFER_ID_MAP_WORKING_AREA_SIZE))) { goto fail; }
 800652c:	2080      	movs	r0, #128	; 0x80
 800652e:	f7ff ffb3 	bl	8006498 <chCoreAlloc.lto_priv.85>
 8006532:	6178      	str	r0, [r7, #20]
 8006534:	697b      	ldr	r3, [r7, #20]
 8006536:	2b00      	cmp	r3, #0
 8006538:	d079      	beq.n	800662e <uavcan_init+0x13e>
    uavcan_transfer_id_map_init(&instance->transfer_id_map, UAVCAN_TRANSFER_ID_MAP_WORKING_AREA_SIZE, transfer_id_map_working_area);
 800653a:	69bb      	ldr	r3, [r7, #24]
 800653c:	3330      	adds	r3, #48	; 0x30
 800653e:	4618      	mov	r0, r3
 8006540:	2180      	movs	r1, #128	; 0x80
 8006542:	697a      	ldr	r2, [r7, #20]
 8006544:	f7fe ff24 	bl	8005390 <uavcan_transfer_id_map_init.lto_priv.99>
    if(!(instance->canard_memory_pool = chCoreAlloc(UAVCAN_CANARD_MEMORY_POOL_SIZE))) { goto fail; }
 8006548:	f44f 7040 	mov.w	r0, #768	; 0x300
 800654c:	f7ff ffa4 	bl	8006498 <chCoreAlloc.lto_priv.85>
 8006550:	4602      	mov	r2, r0
 8006552:	69bb      	ldr	r3, [r7, #24]
 8006554:	62da      	str	r2, [r3, #44]	; 0x2c
 8006556:	69bb      	ldr	r3, [r7, #24]
 8006558:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800655a:	2b00      	cmp	r3, #0
 800655c:	d067      	beq.n	800662e <uavcan_init+0x13e>
    canardInit(&instance->canard, instance->canard_memory_pool, UAVCAN_CANARD_MEMORY_POOL_SIZE, uavcan_on_transfer_rx, uavcan_should_accept_transfer, instance);
 800655e:	69bb      	ldr	r3, [r7, #24]
 8006560:	f103 0108 	add.w	r1, r3, #8
 8006564:	69bb      	ldr	r3, [r7, #24]
 8006566:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006568:	4b34      	ldr	r3, [pc, #208]	; (800663c <uavcan_init+0x14c>)
 800656a:	9300      	str	r3, [sp, #0]
 800656c:	69bb      	ldr	r3, [r7, #24]
 800656e:	9301      	str	r3, [sp, #4]
 8006570:	4608      	mov	r0, r1
 8006572:	4611      	mov	r1, r2
 8006574:	f44f 7240 	mov.w	r2, #768	; 0x300
 8006578:	4b31      	ldr	r3, [pc, #196]	; (8006640 <uavcan_init+0x150>)
<<<<<<< HEAD
 800657a:	f006 fa49 	bl	800ca10 <canardInit>
=======
 800657a:	f006 fa8d 	bl	800ca98 <canardInit>
>>>>>>> 752c83b... update binaries
    struct pubsub_topic_s* can_rx_topic = can_get_rx_topic(instance->can_instance);
 800657e:	69bb      	ldr	r3, [r7, #24]
 8006580:	685b      	ldr	r3, [r3, #4]
 8006582:	4618      	mov	r0, r3
 8006584:	f001 fa50 	bl	8007a28 <can_get_rx_topic>
 8006588:	6138      	str	r0, [r7, #16]
    if (!can_rx_topic) { goto fail; }
 800658a:	693b      	ldr	r3, [r7, #16]
 800658c:	2b00      	cmp	r3, #0
 800658e:	d04e      	beq.n	800662e <uavcan_init+0x13e>
    worker_thread_add_listener_task(&WT_RX, &instance->rx_listener_task, can_rx_topic, uavcan_can_rx_handler, instance); // TODO configurable thread
 8006590:	69bb      	ldr	r3, [r7, #24]
 8006592:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8006596:	69bb      	ldr	r3, [r7, #24]
 8006598:	9300      	str	r3, [sp, #0]
 800659a:	482a      	ldr	r0, [pc, #168]	; (8006644 <uavcan_init+0x154>)
 800659c:	4611      	mov	r1, r2
 800659e:	693a      	ldr	r2, [r7, #16]
 80065a0:	4b29      	ldr	r3, [pc, #164]	; (8006648 <uavcan_init+0x158>)
<<<<<<< HEAD
 80065a2:	f002 fa33 	bl	8008a0c <worker_thread_add_listener_task>
=======
 80065a2:	f002 fa4b 	bl	8008a3c <worker_thread_add_listener_task>
>>>>>>> 752c83b... update binaries

    can_set_auto_retransmit_mode(instance->can_instance, false);
 80065a6:	69bb      	ldr	r3, [r7, #24]
 80065a8:	685b      	ldr	r3, [r3, #4]
 80065aa:	4618      	mov	r0, r3
 80065ac:	2100      	movs	r1, #0
 80065ae:	f001 fa75 	bl	8007a9c <can_set_auto_retransmit_mode>

    LINKED_LIST_APPEND(struct uavcan_instance_s, uavcan_instance_list_head, instance);
 80065b2:	69bb      	ldr	r3, [r7, #24]
 80065b4:	2200      	movs	r2, #0
 80065b6:	671a      	str	r2, [r3, #112]	; 0x70
 80065b8:	4b24      	ldr	r3, [pc, #144]	; (800664c <uavcan_init+0x15c>)
 80065ba:	627b      	str	r3, [r7, #36]	; 0x24
 80065bc:	e003      	b.n	80065c6 <uavcan_init+0xd6>
 80065be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80065c0:	681b      	ldr	r3, [r3, #0]
 80065c2:	3370      	adds	r3, #112	; 0x70
 80065c4:	627b      	str	r3, [r7, #36]	; 0x24
 80065c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80065c8:	681b      	ldr	r3, [r3, #0]
 80065ca:	2b00      	cmp	r3, #0
 80065cc:	d1f7      	bne.n	80065be <uavcan_init+0xce>
 80065ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80065d0:	69ba      	ldr	r2, [r7, #24]
 80065d2:	601a      	str	r2, [r3, #0]

    instance->idx = uavcan_get_idx(instance);
 80065d4:	69b8      	ldr	r0, [r7, #24]
 80065d6:	f7fe fdb3 	bl	8005140 <uavcan_get_idx.lto_priv.98>
 80065da:	4603      	mov	r3, r0
 80065dc:	461a      	mov	r2, r3
 80065de:	69bb      	ldr	r3, [r7, #24]
 80065e0:	701a      	strb	r2, [r3, #0]

    uint8_t node_id = 0;
 80065e2:	2300      	movs	r3, #0
 80065e4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

#ifdef MODULE_APP_DESCRIPTOR_ENABLED
    {
        const struct shared_app_parameters_s* shared_parameters = shared_get_parameters(&shared_app_descriptor);
 80065e8:	4819      	ldr	r0, [pc, #100]	; (8006650 <uavcan_init+0x160>)
<<<<<<< HEAD
 80065ea:	f003 f939 	bl	8009860 <shared_get_parameters>
=======
 80065ea:	f003 f97b 	bl	80098e4 <shared_get_parameters>
>>>>>>> 752c83b... update binaries
 80065ee:	60f8      	str	r0, [r7, #12]
        if (shared_parameters && shared_parameters->canbus_local_node_id > 0 && shared_parameters->canbus_local_node_id <= 127) {
 80065f0:	68fb      	ldr	r3, [r7, #12]
 80065f2:	2b00      	cmp	r3, #0
 80065f4:	d00d      	beq.n	8006612 <uavcan_init+0x122>
 80065f6:	68fb      	ldr	r3, [r7, #12]
 80065f8:	799b      	ldrb	r3, [r3, #6]
 80065fa:	2b00      	cmp	r3, #0
 80065fc:	d009      	beq.n	8006612 <uavcan_init+0x122>
 80065fe:	68fb      	ldr	r3, [r7, #12]
 8006600:	799b      	ldrb	r3, [r3, #6]
 8006602:	b2db      	uxtb	r3, r3
 8006604:	b25b      	sxtb	r3, r3
 8006606:	2b00      	cmp	r3, #0
 8006608:	db03      	blt.n	8006612 <uavcan_init+0x122>
            node_id = shared_parameters->canbus_local_node_id;
 800660a:	68fb      	ldr	r3, [r7, #12]
 800660c:	799b      	ldrb	r3, [r3, #6]
 800660e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (node_id_param != 0) {
        node_id = node_id_param;
    }
#endif

    _uavcan_set_node_id(instance, node_id);
 8006612:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8006616:	69b8      	ldr	r0, [r7, #24]
 8006618:	4619      	mov	r1, r3
 800661a:	f7fe fa01 	bl	8004a20 <_uavcan_set_node_id.lto_priv.97>

    /* debug message */
    chnWrite(&SD1, (const uint8_t *)"uavcan_init complete\n", 24);
 800661e:	4b0d      	ldr	r3, [pc, #52]	; (8006654 <uavcan_init+0x164>)
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	681b      	ldr	r3, [r3, #0]
 8006624:	480b      	ldr	r0, [pc, #44]	; (8006654 <uavcan_init+0x164>)
 8006626:	490c      	ldr	r1, [pc, #48]	; (8006658 <uavcan_init+0x168>)
 8006628:	2218      	movs	r2, #24
 800662a:	4798      	blx	r3
 800662c:	e002      	b.n	8006634 <uavcan_init+0x144>

    return;

fail:
    chSysHalt(NULL);
 800662e:	2000      	movs	r0, #0
<<<<<<< HEAD
 8006630:	f004 fbb8 	bl	800ada4 <chSysHalt>
=======
 8006630:	f004 fbfc 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
}
 8006634:	3728      	adds	r7, #40	; 0x28
 8006636:	46bd      	mov	sp, r7
 8006638:	bd80      	pop	{r7, pc}
 800663a:	bf00      	nop
 800663c:	08005305 	.word	0x08005305
 8006640:	08005271 	.word	0x08005271
 8006644:	20000a3c 	.word	0x20000a3c
 8006648:	08005039 	.word	0x08005039
 800664c:	200014a8 	.word	0x200014a8
 8006650:	08003160 	.word	0x08003160
 8006654:	200013ac 	.word	0x200013ac
<<<<<<< HEAD
 8006658:	0800e63c 	.word	0x0800e63c
=======
 8006658:	0800e6c4 	.word	0x0800e6c4
>>>>>>> 752c83b... update binaries

0800665c <uavcan_iterate_instances.lto_priv.75>:

static bool uavcan_iterate_instances(struct uavcan_instance_s** instance_ptr) {
 800665c:	b480      	push	{r7}
 800665e:	b083      	sub	sp, #12
 8006660:	af00      	add	r7, sp, #0
 8006662:	6078      	str	r0, [r7, #4]
    if (!instance_ptr) {
 8006664:	687b      	ldr	r3, [r7, #4]
 8006666:	2b00      	cmp	r3, #0
 8006668:	d101      	bne.n	800666e <uavcan_iterate_instances.lto_priv.75+0x12>
        return false;
 800666a:	2300      	movs	r3, #0
 800666c:	e014      	b.n	8006698 <uavcan_iterate_instances.lto_priv.75+0x3c>
    }

    if (!(*instance_ptr)) {
 800666e:	687b      	ldr	r3, [r7, #4]
 8006670:	681b      	ldr	r3, [r3, #0]
 8006672:	2b00      	cmp	r3, #0
 8006674:	d104      	bne.n	8006680 <uavcan_iterate_instances.lto_priv.75+0x24>
        *instance_ptr = uavcan_instance_list_head;
 8006676:	4b0b      	ldr	r3, [pc, #44]	; (80066a4 <uavcan_iterate_instances.lto_priv.75+0x48>)
 8006678:	681a      	ldr	r2, [r3, #0]
 800667a:	687b      	ldr	r3, [r7, #4]
 800667c:	601a      	str	r2, [r3, #0]
 800667e:	e004      	b.n	800668a <uavcan_iterate_instances.lto_priv.75+0x2e>
    } else {
        *instance_ptr = (*instance_ptr)->next;
 8006680:	687b      	ldr	r3, [r7, #4]
 8006682:	681b      	ldr	r3, [r3, #0]
 8006684:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8006686:	687b      	ldr	r3, [r7, #4]
 8006688:	601a      	str	r2, [r3, #0]
    }

    return *instance_ptr != NULL;
 800668a:	687b      	ldr	r3, [r7, #4]
 800668c:	681b      	ldr	r3, [r3, #0]
 800668e:	2b00      	cmp	r3, #0
 8006690:	bf14      	ite	ne
 8006692:	2301      	movne	r3, #1
 8006694:	2300      	moveq	r3, #0
 8006696:	b2db      	uxtb	r3, r3
}
 8006698:	4618      	mov	r0, r3
 800669a:	370c      	adds	r7, #12
 800669c:	46bd      	mov	sp, r7
 800669e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80066a2:	4770      	bx	lr
 80066a4:	200014a8 	.word	0x200014a8

080066a8 <_uavcan_get_message_topic>:

static struct pubsub_topic_s* _uavcan_get_message_topic(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* msg_descriptor) {
 80066a8:	b580      	push	{r7, lr}
 80066aa:	b084      	sub	sp, #16
 80066ac:	af00      	add	r7, sp, #0
 80066ae:	6078      	str	r0, [r7, #4]
 80066b0:	6039      	str	r1, [r7, #0]
    if (!instance) {
 80066b2:	687b      	ldr	r3, [r7, #4]
 80066b4:	2b00      	cmp	r3, #0
 80066b6:	d101      	bne.n	80066bc <_uavcan_get_message_topic+0x14>
        return NULL;
 80066b8:	2300      	movs	r3, #0
 80066ba:	e042      	b.n	8006742 <_uavcan_get_message_topic+0x9a>
    }

    chSysLock();
 80066bc:	f7ff fe56 	bl	800636c <chSysLock.lto_priv.77>

    // attempt to find existing item in receive list
    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
 80066c0:	687b      	ldr	r3, [r7, #4]
 80066c2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80066c4:	60fb      	str	r3, [r7, #12]
 80066c6:	e002      	b.n	80066ce <_uavcan_get_message_topic+0x26>
    while (rx_list_item && rx_list_item->msg_descriptor != msg_descriptor) {
        rx_list_item = rx_list_item->next;
 80066c8:	68fb      	ldr	r3, [r7, #12]
 80066ca:	691b      	ldr	r3, [r3, #16]
 80066cc:	60fb      	str	r3, [r7, #12]

    chSysLock();

    // attempt to find existing item in receive list
    struct uavcan_rx_list_item_s* rx_list_item = instance->rx_list_head;
    while (rx_list_item && rx_list_item->msg_descriptor != msg_descriptor) {
 80066ce:	68fb      	ldr	r3, [r7, #12]
 80066d0:	2b00      	cmp	r3, #0
 80066d2:	d004      	beq.n	80066de <_uavcan_get_message_topic+0x36>
 80066d4:	68fb      	ldr	r3, [r7, #12]
 80066d6:	681a      	ldr	r2, [r3, #0]
 80066d8:	683b      	ldr	r3, [r7, #0]
 80066da:	429a      	cmp	r2, r3
 80066dc:	d1f4      	bne.n	80066c8 <_uavcan_get_message_topic+0x20>
        rx_list_item = rx_list_item->next;
    }

    if (rx_list_item) {
 80066de:	68fb      	ldr	r3, [r7, #12]
 80066e0:	2b00      	cmp	r3, #0
 80066e2:	d004      	beq.n	80066ee <_uavcan_get_message_topic+0x46>
        chSysUnlock();
 80066e4:	f7ff fe4a 	bl	800637c <chSysUnlock.lto_priv.76>
        return &rx_list_item->topic;
 80066e8:	68fb      	ldr	r3, [r7, #12]
 80066ea:	3304      	adds	r3, #4
 80066ec:	e029      	b.n	8006742 <_uavcan_get_message_topic+0x9a>
    }

    // create new item in receive list
    rx_list_item = chPoolAllocI(&rx_list_pool);
 80066ee:	4817      	ldr	r0, [pc, #92]	; (800674c <_uavcan_get_message_topic+0xa4>)
<<<<<<< HEAD
 80066f0:	f003 fa94 	bl	8009c1c <chPoolAllocI>
=======
 80066f0:	f003 fad8 	bl	8009ca4 <chPoolAllocI>
>>>>>>> 752c83b... update binaries
 80066f4:	60f8      	str	r0, [r7, #12]
    if (!rx_list_item) {
 80066f6:	68fb      	ldr	r3, [r7, #12]
 80066f8:	2b00      	cmp	r3, #0
 80066fa:	d103      	bne.n	8006704 <_uavcan_get_message_topic+0x5c>
        chSysUnlock();
 80066fc:	f7ff fe3e 	bl	800637c <chSysUnlock.lto_priv.76>
        return NULL;
 8006700:	2300      	movs	r3, #0
 8006702:	e01e      	b.n	8006742 <_uavcan_get_message_topic+0x9a>
    }

    // populate it
    rx_list_item->msg_descriptor = msg_descriptor;
 8006704:	68fb      	ldr	r3, [r7, #12]
 8006706:	683a      	ldr	r2, [r7, #0]
 8006708:	601a      	str	r2, [r3, #0]
    pubsub_init_topic(&rx_list_item->topic, NULL);
 800670a:	68fb      	ldr	r3, [r7, #12]
 800670c:	3304      	adds	r3, #4
 800670e:	4618      	mov	r0, r3
 8006710:	2100      	movs	r1, #0
<<<<<<< HEAD
 8006712:	f001 fd2b 	bl	800816c <pubsub_init_topic>
=======
 8006712:	f001 fd53 	bl	80081bc <pubsub_init_topic>
>>>>>>> 752c83b... update binaries

    // append it
    LINKED_LIST_APPEND(struct uavcan_rx_list_item_s, instance->rx_list_head, rx_list_item);
 8006716:	68fb      	ldr	r3, [r7, #12]
 8006718:	2200      	movs	r2, #0
 800671a:	611a      	str	r2, [r3, #16]
 800671c:	687b      	ldr	r3, [r7, #4]
 800671e:	336c      	adds	r3, #108	; 0x6c
 8006720:	60bb      	str	r3, [r7, #8]
 8006722:	e003      	b.n	800672c <_uavcan_get_message_topic+0x84>
 8006724:	68bb      	ldr	r3, [r7, #8]
 8006726:	681b      	ldr	r3, [r3, #0]
 8006728:	3310      	adds	r3, #16
 800672a:	60bb      	str	r3, [r7, #8]
 800672c:	68bb      	ldr	r3, [r7, #8]
 800672e:	681b      	ldr	r3, [r3, #0]
 8006730:	2b00      	cmp	r3, #0
 8006732:	d1f7      	bne.n	8006724 <_uavcan_get_message_topic+0x7c>
 8006734:	68bb      	ldr	r3, [r7, #8]
 8006736:	68fa      	ldr	r2, [r7, #12]
 8006738:	601a      	str	r2, [r3, #0]

    chSysUnlock();
 800673a:	f7ff fe1f 	bl	800637c <chSysUnlock.lto_priv.76>

    return &rx_list_item->topic;
 800673e:	68fb      	ldr	r3, [r7, #12]
 8006740:	3304      	adds	r3, #4
}
 8006742:	4618      	mov	r0, r3
 8006744:	3710      	adds	r7, #16
 8006746:	46bd      	mov	sp, r7
 8006748:	bd80      	pop	{r7, pc}
 800674a:	bf00      	nop
 800674c:	20000a0c 	.word	0x20000a0c

08006750 <uavcan_get_message_topic>:

struct pubsub_topic_s* uavcan_get_message_topic(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* msg_descriptor) {
 8006750:	b580      	push	{r7, lr}
 8006752:	b082      	sub	sp, #8
 8006754:	af00      	add	r7, sp, #0
 8006756:	4603      	mov	r3, r0
 8006758:	6039      	str	r1, [r7, #0]
 800675a:	71fb      	strb	r3, [r7, #7]
    return _uavcan_get_message_topic(uavcan_get_instance(uavcan_idx), msg_descriptor);
 800675c:	79fb      	ldrb	r3, [r7, #7]
 800675e:	4618      	mov	r0, r3
 8006760:	f7fe fcae 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 8006764:	4603      	mov	r3, r0
 8006766:	4618      	mov	r0, r3
 8006768:	6839      	ldr	r1, [r7, #0]
 800676a:	f7ff ff9d 	bl	80066a8 <_uavcan_get_message_topic>
 800676e:	4603      	mov	r3, r0
}
 8006770:	4618      	mov	r0, r3
 8006772:	3708      	adds	r7, #8
 8006774:	46bd      	mov	sp, r7
 8006776:	bd80      	pop	{r7, pc}

08006778 <_uavcan_get_message_data_type_id.lto_priv.74>:

static uint16_t _uavcan_get_message_data_type_id(struct uavcan_instance_s* instance, const struct uavcan_message_descriptor_s* msg_descriptor) {
 8006778:	b480      	push	{r7}
 800677a:	b083      	sub	sp, #12
 800677c:	af00      	add	r7, sp, #0
 800677e:	6078      	str	r0, [r7, #4]
 8006780:	6039      	str	r1, [r7, #0]
    (void)instance;

    if (msg_descriptor) {
 8006782:	683b      	ldr	r3, [r7, #0]
 8006784:	2b00      	cmp	r3, #0
 8006786:	d002      	beq.n	800678e <_uavcan_get_message_data_type_id.lto_priv.74+0x16>
        return msg_descriptor->default_data_type_id;
 8006788:	683b      	ldr	r3, [r7, #0]
 800678a:	891b      	ldrh	r3, [r3, #8]
 800678c:	e000      	b.n	8006790 <_uavcan_get_message_data_type_id.lto_priv.74+0x18>
    } else {
        return 0;
 800678e:	2300      	movs	r3, #0
    }
}
 8006790:	4618      	mov	r0, r3
 8006792:	370c      	adds	r7, #12
 8006794:	46bd      	mov	sp, r7
 8006796:	f85d 7b04 	ldr.w	r7, [sp], #4
 800679a:	4770      	bx	lr

0800679c <_uavcan_get_node_id.lto_priv.78>:

uint16_t uavcan_get_message_data_type_id(uint8_t uavcan_idx, const struct uavcan_message_descriptor_s* msg_descriptor) {
    return _uavcan_get_message_data_type_id(uavcan_get_instance(uavcan_idx), msg_descriptor);
}

static uint8_t _uavcan_get_node_id(struct uavcan_instance_s* instance) {
 800679c:	b580      	push	{r7, lr}
 800679e:	b084      	sub	sp, #16
 80067a0:	af00      	add	r7, sp, #0
 80067a2:	6078      	str	r0, [r7, #4]
    if (!instance) {
 80067a4:	687b      	ldr	r3, [r7, #4]
 80067a6:	2b00      	cmp	r3, #0
 80067a8:	d101      	bne.n	80067ae <_uavcan_get_node_id.lto_priv.78+0x12>
        return 0;
 80067aa:	2300      	movs	r3, #0
 80067ac:	e00b      	b.n	80067c6 <_uavcan_get_node_id.lto_priv.78+0x2a>
    }

    chSysLock();
 80067ae:	f7ff fddd 	bl	800636c <chSysLock.lto_priv.77>
    uint8_t ret = canardGetLocalNodeID(&instance->canard);
 80067b2:	687b      	ldr	r3, [r7, #4]
 80067b4:	3308      	adds	r3, #8
 80067b6:	4618      	mov	r0, r3
<<<<<<< HEAD
 80067b8:	f006 f986 	bl	800cac8 <canardGetLocalNodeID>
=======
 80067b8:	f006 f9ca 	bl	800cb50 <canardGetLocalNodeID>
>>>>>>> 752c83b... update binaries
 80067bc:	4603      	mov	r3, r0
 80067be:	73fb      	strb	r3, [r7, #15]
    chSysUnlock();
 80067c0:	f7ff fddc 	bl	800637c <chSysUnlock.lto_priv.76>
    return ret;
 80067c4:	7bfb      	ldrb	r3, [r7, #15]
}
 80067c6:	4618      	mov	r0, r3
 80067c8:	3710      	adds	r7, #16
 80067ca:	46bd      	mov	sp, r7
 80067cc:	bd80      	pop	{r7, pc}
 80067ce:	bf00      	nop

080067d0 <uavcan_get_node_id>:

uint8_t uavcan_get_node_id(uint8_t uavcan_idx) {
 80067d0:	b580      	push	{r7, lr}
 80067d2:	b082      	sub	sp, #8
 80067d4:	af00      	add	r7, sp, #0
 80067d6:	4603      	mov	r3, r0
 80067d8:	71fb      	strb	r3, [r7, #7]
    return _uavcan_get_node_id(uavcan_get_instance(uavcan_idx));
 80067da:	79fb      	ldrb	r3, [r7, #7]
 80067dc:	4618      	mov	r0, r3
 80067de:	f7fe fc6f 	bl	80050c0 <uavcan_get_instance.lto_priv.96>
 80067e2:	4603      	mov	r3, r0
 80067e4:	4618      	mov	r0, r3
 80067e6:	f7ff ffd9 	bl	800679c <_uavcan_get_node_id.lto_priv.78>
 80067ea:	4603      	mov	r3, r0
}
 80067ec:	4618      	mov	r0, r3
 80067ee:	3708      	adds	r7, #8
 80067f0:	46bd      	mov	sp, r7
 80067f2:	bd80      	pop	{r7, pc}

<<<<<<< HEAD
080067f4 <worker_thread_remove_listener_task>:

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
}

void worker_thread_remove_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task) {
 80067f4:	b580      	push	{r7, lr}
 80067f6:	b084      	sub	sp, #16
 80067f8:	af00      	add	r7, sp, #0
 80067fa:	6078      	str	r0, [r7, #4]
 80067fc:	6039      	str	r1, [r7, #0]
    pubsub_listener_unregister(&task->listener);
 80067fe:	683b      	ldr	r3, [r7, #0]
 8006800:	4618      	mov	r0, r3
 8006802:	f001 fd15 	bl	8008230 <pubsub_listener_unregister>

    chSysLock();
 8006806:	f001 ff4b 	bl	80086a0 <chSysLock.lto_priv.125>
=======
080067f4 <worker_thread_add_publisher_task_I>:
    chSysLock();
>>>>>>> 752c83b... update binaries
    LINKED_LIST_REMOVE(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
    chSysUnlock();
<<<<<<< HEAD
 800683e:	f001 ff37 	bl	80086b0 <chSysUnlock.lto_priv.123>
=======
>>>>>>> 752c83b... update binaries
}

void worker_thread_add_publisher_task_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* task, size_t msg_max_size, size_t msg_queue_depth) {
 80067f4:	b590      	push	{r4, r7, lr}
 80067f6:	b089      	sub	sp, #36	; 0x24
 80067f8:	af00      	add	r7, sp, #0
 80067fa:	60f8      	str	r0, [r7, #12]
 80067fc:	60b9      	str	r1, [r7, #8]
 80067fe:	607a      	str	r2, [r7, #4]
 8006800:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006856:	f004 fb83 	bl	800af60 <chDbgCheckClassI>
    chDbgCheck(!worker_thread_publisher_task_is_registered_I(worker_thread, task));
 800685a:	68f8      	ldr	r0, [r7, #12]
 800685c:	68b9      	ldr	r1, [r7, #8]
 800685e:	f000 fa33 	bl	8006cc8 <worker_thread_publisher_task_is_registered_I>
 8006862:	4603      	mov	r3, r0
 8006864:	2b00      	cmp	r3, #0
 8006866:	d002      	beq.n	800686e <worker_thread_add_publisher_task_I+0x26>
 8006868:	4825      	ldr	r0, [pc, #148]	; (8006900 <worker_thread_add_publisher_task_I+0xb8>)
 800686a:	f004 fa9b 	bl	800ada4 <chSysHalt>
=======
 8006802:	f004 fbf1 	bl	800afe8 <chDbgCheckClassI>
    chDbgCheck(!worker_thread_publisher_task_is_registered_I(worker_thread, task));
 8006806:	68f8      	ldr	r0, [r7, #12]
 8006808:	68b9      	ldr	r1, [r7, #8]
 800680a:	f000 fa6b 	bl	8006ce4 <worker_thread_publisher_task_is_registered_I>
 800680e:	4603      	mov	r3, r0
 8006810:	2b00      	cmp	r3, #0
 8006812:	d002      	beq.n	800681a <worker_thread_add_publisher_task_I+0x26>
 8006814:	4825      	ldr	r0, [pc, #148]	; (80068ac <worker_thread_add_publisher_task_I+0xb8>)
 8006816:	f004 fb09 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

    size_t mem_block_size = sizeof(struct worker_thread_publisher_msg_s)+msg_max_size;
 800681a:	687b      	ldr	r3, [r7, #4]
 800681c:	3308      	adds	r3, #8
 800681e:	617b      	str	r3, [r7, #20]

    task->msg_max_size = msg_max_size;
 8006820:	68bb      	ldr	r3, [r7, #8]
 8006822:	687a      	ldr	r2, [r7, #4]
 8006824:	601a      	str	r2, [r3, #0]
    chPoolObjectInit(&task->pool, mem_block_size, NULL);
<<<<<<< HEAD
 800687a:	68bb      	ldr	r3, [r7, #8]
 800687c:	3304      	adds	r3, #4
 800687e:	4618      	mov	r0, r3
 8006880:	6979      	ldr	r1, [r7, #20]
 8006882:	2200      	movs	r2, #0
 8006884:	f003 f988 	bl	8009b98 <chPoolObjectInit>
    chMBObjectInit(&task->mailbox, chCoreAllocI(sizeof(msg_t)*msg_queue_depth), msg_queue_depth);
 8006888:	68bb      	ldr	r3, [r7, #8]
 800688a:	f103 0410 	add.w	r4, r3, #16
 800688e:	683b      	ldr	r3, [r7, #0]
 8006890:	009b      	lsls	r3, r3, #2
 8006892:	4618      	mov	r0, r3
 8006894:	f001 ff6c 	bl	8008770 <chCoreAllocI.lto_priv.135>
 8006898:	4602      	mov	r2, r0
 800689a:	683b      	ldr	r3, [r7, #0]
 800689c:	4620      	mov	r0, r4
 800689e:	4611      	mov	r1, r2
 80068a0:	461a      	mov	r2, r3
 80068a2:	f004 f981 	bl	800aba8 <chMBObjectInit>
=======
 8006826:	68bb      	ldr	r3, [r7, #8]
 8006828:	3304      	adds	r3, #4
 800682a:	4618      	mov	r0, r3
 800682c:	6979      	ldr	r1, [r7, #20]
 800682e:	2200      	movs	r2, #0
 8006830:	f003 f9f6 	bl	8009c20 <chPoolObjectInit>
    chMBObjectInit(&task->mailbox, chCoreAllocI(sizeof(msg_t)*msg_queue_depth), msg_queue_depth);
 8006834:	68bb      	ldr	r3, [r7, #8]
 8006836:	f103 0410 	add.w	r4, r3, #16
 800683a:	683b      	ldr	r3, [r7, #0]
 800683c:	009b      	lsls	r3, r3, #2
 800683e:	4618      	mov	r0, r3
 8006840:	f001 ffa2 	bl	8008788 <chCoreAllocI.lto_priv.134>
 8006844:	4602      	mov	r2, r0
 8006846:	683b      	ldr	r3, [r7, #0]
 8006848:	4620      	mov	r0, r4
 800684a:	4611      	mov	r1, r2
 800684c:	461a      	mov	r2, r3
 800684e:	f004 f9ef 	bl	800ac30 <chMBObjectInit>
>>>>>>> 752c83b... update binaries
    task->worker_thread = worker_thread;
 8006852:	68bb      	ldr	r3, [r7, #8]
 8006854:	68fa      	ldr	r2, [r7, #12]
 8006856:	639a      	str	r2, [r3, #56]	; 0x38

    for (size_t i = 0; i < msg_queue_depth; i++) {
 8006858:	2300      	movs	r3, #0
 800685a:	61fb      	str	r3, [r7, #28]
 800685c:	e00c      	b.n	8006878 <worker_thread_add_publisher_task_I+0x84>
        chPoolAddI(&task->pool, chCoreAllocI(mem_block_size));
<<<<<<< HEAD
 80068b2:	68bb      	ldr	r3, [r7, #8]
 80068b4:	1d1c      	adds	r4, r3, #4
 80068b6:	6978      	ldr	r0, [r7, #20]
 80068b8:	f001 ff5a 	bl	8008770 <chCoreAllocI.lto_priv.135>
 80068bc:	4603      	mov	r3, r0
 80068be:	4620      	mov	r0, r4
 80068c0:	4619      	mov	r1, r3
 80068c2:	f001 ff63 	bl	800878c <chPoolAddI.lto_priv.134>
=======
 800685e:	68bb      	ldr	r3, [r7, #8]
 8006860:	1d1c      	adds	r4, r3, #4
 8006862:	6978      	ldr	r0, [r7, #20]
 8006864:	f001 ff90 	bl	8008788 <chCoreAllocI.lto_priv.134>
 8006868:	4603      	mov	r3, r0
 800686a:	4620      	mov	r0, r4
 800686c:	4619      	mov	r1, r3
 800686e:	f001 ff99 	bl	80087a4 <chPoolAddI.lto_priv.133>
>>>>>>> 752c83b... update binaries
    task->msg_max_size = msg_max_size;
    chPoolObjectInit(&task->pool, mem_block_size, NULL);
    chMBObjectInit(&task->mailbox, chCoreAllocI(sizeof(msg_t)*msg_queue_depth), msg_queue_depth);
    task->worker_thread = worker_thread;

    for (size_t i = 0; i < msg_queue_depth; i++) {
 8006872:	69fb      	ldr	r3, [r7, #28]
 8006874:	3301      	adds	r3, #1
 8006876:	61fb      	str	r3, [r7, #28]
 8006878:	69fa      	ldr	r2, [r7, #28]
 800687a:	683b      	ldr	r3, [r7, #0]
 800687c:	429a      	cmp	r2, r3
 800687e:	d3ee      	bcc.n	800685e <worker_thread_add_publisher_task_I+0x6a>
        chPoolAddI(&task->pool, chCoreAllocI(mem_block_size));
    }

    LINKED_LIST_APPEND(struct worker_thread_publisher_task_s, worker_thread->publisher_task_list_head, task);
 8006880:	68bb      	ldr	r3, [r7, #8]
 8006882:	2200      	movs	r2, #0
 8006884:	63da      	str	r2, [r3, #60]	; 0x3c
 8006886:	68fb      	ldr	r3, [r7, #12]
 8006888:	3318      	adds	r3, #24
 800688a:	61bb      	str	r3, [r7, #24]
 800688c:	e003      	b.n	8006896 <worker_thread_add_publisher_task_I+0xa2>
 800688e:	69bb      	ldr	r3, [r7, #24]
 8006890:	681b      	ldr	r3, [r3, #0]
 8006892:	333c      	adds	r3, #60	; 0x3c
 8006894:	61bb      	str	r3, [r7, #24]
 8006896:	69bb      	ldr	r3, [r7, #24]
 8006898:	681b      	ldr	r3, [r3, #0]
 800689a:	2b00      	cmp	r3, #0
 800689c:	d1f7      	bne.n	800688e <worker_thread_add_publisher_task_I+0x9a>
 800689e:	69bb      	ldr	r3, [r7, #24]
 80068a0:	68ba      	ldr	r2, [r7, #8]
 80068a2:	601a      	str	r2, [r3, #0]
}
 80068a4:	3724      	adds	r7, #36	; 0x24
 80068a6:	46bd      	mov	sp, r7
 80068a8:	bd90      	pop	{r4, r7, pc}
 80068aa:	bf00      	nop
 80068ac:	0800ec9c 	.word	0x0800ec9c

080068b0 <worker_thread_add_publisher_task>:

void worker_thread_add_publisher_task(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* task, size_t msg_max_size, size_t msg_queue_depth) {
 80068b0:	b580      	push	{r7, lr}
 80068b2:	b084      	sub	sp, #16
 80068b4:	af00      	add	r7, sp, #0
 80068b6:	60f8      	str	r0, [r7, #12]
 80068b8:	60b9      	str	r1, [r7, #8]
 80068ba:	607a      	str	r2, [r7, #4]
 80068bc:	603b      	str	r3, [r7, #0]
    chSysLock();
<<<<<<< HEAD
 8006912:	f001 fec5 	bl	80086a0 <chSysLock.lto_priv.125>
=======
 80068be:	f001 ff03 	bl	80086c8 <chSysLock.lto_priv.124>
>>>>>>> 752c83b... update binaries
    worker_thread_add_publisher_task_I(worker_thread, task, msg_max_size, msg_queue_depth);
 80068c2:	68f8      	ldr	r0, [r7, #12]
 80068c4:	68b9      	ldr	r1, [r7, #8]
 80068c6:	687a      	ldr	r2, [r7, #4]
 80068c8:	683b      	ldr	r3, [r7, #0]
 80068ca:	f7ff ff93 	bl	80067f4 <worker_thread_add_publisher_task_I>
    chSysUnlock();
<<<<<<< HEAD
 8006922:	f001 fec5 	bl	80086b0 <chSysUnlock.lto_priv.123>
=======
 80068ce:	f001 ff03 	bl	80086d8 <chSysUnlock.lto_priv.122>
>>>>>>> 752c83b... update binaries
}
 80068d2:	3710      	adds	r7, #16
 80068d4:	46bd      	mov	sp, r7
 80068d6:	bd80      	pop	{r7, pc}

080068d8 <worker_thread_publisher_task_publish_I>:
    chSysLock();
    LINKED_LIST_REMOVE(struct worker_thread_publisher_task_s, worker_thread->publisher_task_list_head, task);
    chSysUnlock();
}

bool worker_thread_publisher_task_publish_I(struct worker_thread_publisher_task_s* task, struct pubsub_topic_s* topic, size_t size, pubsub_message_writer_func_ptr writer_cb, void* ctx) {
 80068d8:	b580      	push	{r7, lr}
 80068da:	b086      	sub	sp, #24
 80068dc:	af00      	add	r7, sp, #0
 80068de:	60f8      	str	r0, [r7, #12]
 80068e0:	60b9      	str	r1, [r7, #8]
 80068e2:	607a      	str	r2, [r7, #4]
 80068e4:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 800693a:	f004 fb11 	bl	800af60 <chDbgCheckClassI>
=======
 80068e6:	f004 fb7f 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    if (size > task->msg_max_size) {
 80068ea:	68fb      	ldr	r3, [r7, #12]
 80068ec:	681a      	ldr	r2, [r3, #0]
 80068ee:	687b      	ldr	r3, [r7, #4]
 80068f0:	429a      	cmp	r2, r3
 80068f2:	d201      	bcs.n	80068f8 <worker_thread_publisher_task_publish_I+0x20>
        return false;
 80068f4:	2300      	movs	r3, #0
 80068f6:	e02c      	b.n	8006952 <worker_thread_publisher_task_publish_I+0x7a>
    }

    struct worker_thread_publisher_msg_s* msg = chPoolAllocI(&task->pool);
<<<<<<< HEAD
 800694c:	68fb      	ldr	r3, [r7, #12]
 800694e:	3304      	adds	r3, #4
 8006950:	4618      	mov	r0, r3
 8006952:	f003 f963 	bl	8009c1c <chPoolAllocI>
 8006956:	6178      	str	r0, [r7, #20]
=======
 80068f8:	68fb      	ldr	r3, [r7, #12]
 80068fa:	3304      	adds	r3, #4
 80068fc:	4618      	mov	r0, r3
 80068fe:	f003 f9d1 	bl	8009ca4 <chPoolAllocI>
 8006902:	6178      	str	r0, [r7, #20]
>>>>>>> 752c83b... update binaries

    if (!msg || !topic) {
 8006904:	697b      	ldr	r3, [r7, #20]
 8006906:	2b00      	cmp	r3, #0
 8006908:	d002      	beq.n	8006910 <worker_thread_publisher_task_publish_I+0x38>
 800690a:	68bb      	ldr	r3, [r7, #8]
 800690c:	2b00      	cmp	r3, #0
 800690e:	d101      	bne.n	8006914 <worker_thread_publisher_task_publish_I+0x3c>
        return false;
 8006910:	2300      	movs	r3, #0
 8006912:	e01e      	b.n	8006952 <worker_thread_publisher_task_publish_I+0x7a>
    }

    msg->topic = topic;
 8006914:	697b      	ldr	r3, [r7, #20]
 8006916:	68ba      	ldr	r2, [r7, #8]
 8006918:	601a      	str	r2, [r3, #0]
    msg->size = size;
 800691a:	697b      	ldr	r3, [r7, #20]
 800691c:	687a      	ldr	r2, [r7, #4]
 800691e:	605a      	str	r2, [r3, #4]

    if (writer_cb) {
 8006920:	683b      	ldr	r3, [r7, #0]
 8006922:	2b00      	cmp	r3, #0
 8006924:	d007      	beq.n	8006936 <worker_thread_publisher_task_publish_I+0x5e>
        writer_cb(size, msg->data, ctx);
 8006926:	697b      	ldr	r3, [r7, #20]
 8006928:	f103 0208 	add.w	r2, r3, #8
 800692c:	683b      	ldr	r3, [r7, #0]
 800692e:	6878      	ldr	r0, [r7, #4]
 8006930:	4611      	mov	r1, r2
 8006932:	6a3a      	ldr	r2, [r7, #32]
 8006934:	4798      	blx	r3
    }

    chMBPostI(&task->mailbox, (msg_t)msg);
<<<<<<< HEAD
 800698a:	68fb      	ldr	r3, [r7, #12]
 800698c:	f103 0210 	add.w	r2, r3, #16
 8006990:	697b      	ldr	r3, [r7, #20]
 8006992:	4610      	mov	r0, r2
 8006994:	4619      	mov	r1, r3
 8006996:	f004 f93d 	bl	800ac14 <chMBPostI>
=======
 8006936:	68fb      	ldr	r3, [r7, #12]
 8006938:	f103 0210 	add.w	r2, r3, #16
 800693c:	697b      	ldr	r3, [r7, #20]
 800693e:	4610      	mov	r0, r2
 8006940:	4619      	mov	r1, r3
 8006942:	f004 f9ab 	bl	800ac9c <chMBPostI>
>>>>>>> 752c83b... update binaries

    worker_thread_wake_I(task->worker_thread);
 8006946:	68fb      	ldr	r3, [r7, #12]
 8006948:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800694a:	4618      	mov	r0, r3
 800694c:	f000 f910 	bl	8006b70 <worker_thread_wake_I.lto_priv.159>
    return true;
 8006950:	2301      	movs	r3, #1
}
 8006952:	4618      	mov	r0, r3
 8006954:	3718      	adds	r7, #24
 8006956:	46bd      	mov	sp, r7
 8006958:	bd80      	pop	{r7, pc}
 800695a:	bf00      	nop

0800695c <worker_thread_takeover>:
#endif

void worker_thread_takeover(struct worker_thread_s* worker_thread) {
 800695c:	b590      	push	{r4, r7, lr}
 800695e:	b091      	sub	sp, #68	; 0x44
 8006960:	af04      	add	r7, sp, #16
 8006962:	6078      	str	r0, [r7, #4]
    chRegSetThreadName(worker_thread->name);
<<<<<<< HEAD
 80069b8:	687b      	ldr	r3, [r7, #4]
 80069ba:	681b      	ldr	r3, [r3, #0]
 80069bc:	4618      	mov	r0, r3
 80069be:	f001 fea7 	bl	8008710 <chRegSetThreadName.lto_priv.133>
    chThdSetPriority(worker_thread->priority);
 80069c2:	687b      	ldr	r3, [r7, #4]
 80069c4:	685b      	ldr	r3, [r3, #4]
 80069c6:	4618      	mov	r0, r3
 80069c8:	f003 fcaa 	bl	800a320 <chThdSetPriority>
    worker_thread->thread = chThdGetSelfX();
 80069cc:	f001 fe94 	bl	80086f8 <chThdGetSelfX.lto_priv.132>
 80069d0:	4602      	mov	r2, r0
 80069d2:	687b      	ldr	r3, [r7, #4]
 80069d4:	609a      	str	r2, [r3, #8]
=======
 8006964:	687b      	ldr	r3, [r7, #4]
 8006966:	681b      	ldr	r3, [r3, #0]
 8006968:	4618      	mov	r0, r3
 800696a:	f001 fedd 	bl	8008728 <chRegSetThreadName.lto_priv.132>
    chThdSetPriority(worker_thread->priority);
 800696e:	687b      	ldr	r3, [r7, #4]
 8006970:	685b      	ldr	r3, [r3, #4]
 8006972:	4618      	mov	r0, r3
 8006974:	f003 fd18 	bl	800a3a8 <chThdSetPriority>
    worker_thread->thread = chThdGetSelfX();
 8006978:	f001 feca 	bl	8008710 <chThdGetSelfX.lto_priv.131>
 800697c:	4602      	mov	r2, r0
 800697e:	687b      	ldr	r3, [r7, #4]
 8006980:	609a      	str	r2, [r3, #8]
>>>>>>> 752c83b... update binaries

    while (true) {
#ifdef MODULE_PUBSUB_ENABLED
        // Handle publisher tasks
        {
            chSysLock();
<<<<<<< HEAD
 80069d6:	f001 fe63 	bl	80086a0 <chSysLock.lto_priv.125>
=======
 8006982:	f001 fea1 	bl	80086c8 <chSysLock.lto_priv.124>
>>>>>>> 752c83b... update binaries
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 8006986:	687b      	ldr	r3, [r7, #4]
 8006988:	699b      	ldr	r3, [r3, #24]
 800698a:	62fb      	str	r3, [r7, #44]	; 0x2c
            chSysUnlock();
<<<<<<< HEAD
 80069e0:	f001 fe66 	bl	80086b0 <chSysUnlock.lto_priv.123>
 80069e4:	e025      	b.n	8006a32 <worker_thread_takeover+0x82>
=======
 800698c:	f001 fea4 	bl	80086d8 <chSysUnlock.lto_priv.122>
 8006990:	e025      	b.n	80069de <worker_thread_takeover+0x82>
>>>>>>> 752c83b... update binaries
            while (task) {
                struct worker_thread_publisher_msg_s* msg;
                while (chMBFetch(&task->mailbox, (msg_t*)&msg, TIME_IMMEDIATE) == MSG_OK) {
                    pubsub_publish_message(msg->topic, msg->size, pubsub_copy_writer_func, msg->data);
<<<<<<< HEAD
 80069e6:	68fb      	ldr	r3, [r7, #12]
 80069e8:	6819      	ldr	r1, [r3, #0]
 80069ea:	68fb      	ldr	r3, [r7, #12]
 80069ec:	685a      	ldr	r2, [r3, #4]
 80069ee:	68fb      	ldr	r3, [r7, #12]
 80069f0:	3308      	adds	r3, #8
 80069f2:	4608      	mov	r0, r1
 80069f4:	4611      	mov	r1, r2
 80069f6:	4a48      	ldr	r2, [pc, #288]	; (8006b18 <worker_thread_takeover+0x168>)
 80069f8:	f001 fc9e 	bl	8008338 <pubsub_publish_message>
                    chPoolFree(&task->pool, msg);
 80069fc:	69fb      	ldr	r3, [r7, #28]
 80069fe:	1d1a      	adds	r2, r3, #4
 8006a00:	68fb      	ldr	r3, [r7, #12]
 8006a02:	4610      	mov	r0, r2
 8006a04:	4619      	mov	r1, r3
 8006a06:	f003 f965 	bl	8009cd4 <chPoolFree>
=======
 8006992:	68fb      	ldr	r3, [r7, #12]
 8006994:	6819      	ldr	r1, [r3, #0]
 8006996:	68fb      	ldr	r3, [r7, #12]
 8006998:	685a      	ldr	r2, [r3, #4]
 800699a:	68fb      	ldr	r3, [r7, #12]
 800699c:	3308      	adds	r3, #8
 800699e:	4608      	mov	r0, r1
 80069a0:	4611      	mov	r1, r2
 80069a2:	4a68      	ldr	r2, [pc, #416]	; (8006b44 <worker_thread_takeover+0x1e8>)
 80069a4:	f001 fcf0 	bl	8008388 <pubsub_publish_message>
                    chPoolFree(&task->pool, msg);
 80069a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069aa:	1d1a      	adds	r2, r3, #4
 80069ac:	68fb      	ldr	r3, [r7, #12]
 80069ae:	4610      	mov	r0, r2
 80069b0:	4619      	mov	r1, r3
 80069b2:	f003 f9d3 	bl	8009d5c <chPoolFree>
>>>>>>> 752c83b... update binaries
            chSysLock();
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
            chSysUnlock();
            while (task) {
                struct worker_thread_publisher_msg_s* msg;
                while (chMBFetch(&task->mailbox, (msg_t*)&msg, TIME_IMMEDIATE) == MSG_OK) {
<<<<<<< HEAD
 8006a0a:	69fb      	ldr	r3, [r7, #28]
 8006a0c:	f103 0210 	add.w	r2, r3, #16
 8006a10:	f107 030c 	add.w	r3, r7, #12
 8006a14:	4610      	mov	r0, r2
 8006a16:	4619      	mov	r1, r3
 8006a18:	2200      	movs	r2, #0
 8006a1a:	f004 f93b 	bl	800ac94 <chMBFetch>
 8006a1e:	4603      	mov	r3, r0
 8006a20:	2b00      	cmp	r3, #0
 8006a22:	d0e0      	beq.n	80069e6 <worker_thread_takeover+0x36>
=======
 80069b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069b8:	f103 0210 	add.w	r2, r3, #16
 80069bc:	f107 030c 	add.w	r3, r7, #12
 80069c0:	4610      	mov	r0, r2
 80069c2:	4619      	mov	r1, r3
 80069c4:	2200      	movs	r2, #0
 80069c6:	f004 f9a9 	bl	800ad1c <chMBFetch>
 80069ca:	4603      	mov	r3, r0
 80069cc:	2b00      	cmp	r3, #0
 80069ce:	d0e0      	beq.n	8006992 <worker_thread_takeover+0x36>
>>>>>>> 752c83b... update binaries
                    pubsub_publish_message(msg->topic, msg->size, pubsub_copy_writer_func, msg->data);
                    chPoolFree(&task->pool, msg);
                }
                chSysLock();
<<<<<<< HEAD
 8006a24:	f001 fe3c 	bl	80086a0 <chSysLock.lto_priv.125>
=======
 80069d0:	f001 fe7a 	bl	80086c8 <chSysLock.lto_priv.124>
>>>>>>> 752c83b... update binaries
                task = task->next;
 80069d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80069d8:	62fb      	str	r3, [r7, #44]	; 0x2c
                chSysUnlock();
<<<<<<< HEAD
 8006a2e:	f001 fe3f 	bl	80086b0 <chSysUnlock.lto_priv.123>
=======
 80069da:	f001 fe7d 	bl	80086d8 <chSysUnlock.lto_priv.122>
>>>>>>> 752c83b... update binaries
        // Handle publisher tasks
        {
            chSysLock();
            struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
            chSysUnlock();
            while (task) {
 80069de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069e0:	2b00      	cmp	r3, #0
 80069e2:	d1e8      	bne.n	80069b6 <worker_thread_takeover+0x5a>
            }
        }

        // Check for immediately available messages on listener tasks, handle one
        {
            chSysLock();
<<<<<<< HEAD
 8006a38:	f001 fe32 	bl	80086a0 <chSysLock.lto_priv.125>
=======
 80069e4:	f001 fe70 	bl	80086c8 <chSysLock.lto_priv.124>
>>>>>>> 752c83b... update binaries
            struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
 80069e8:	687b      	ldr	r3, [r7, #4]
 80069ea:	695b      	ldr	r3, [r3, #20]
 80069ec:	62bb      	str	r3, [r7, #40]	; 0x28
            chSysUnlock();
<<<<<<< HEAD
 8006a42:	f001 fe35 	bl	80086b0 <chSysUnlock.lto_priv.123>
 8006a46:	e00e      	b.n	8006a66 <worker_thread_takeover+0xb6>
            while (listener_task) {
                if (pubsub_listener_handle_one_timeout(&listener_task->listener, TIME_IMMEDIATE)) {
 8006a48:	69bb      	ldr	r3, [r7, #24]
 8006a4a:	4618      	mov	r0, r3
 8006a4c:	2100      	movs	r1, #0
 8006a4e:	f001 fcff 	bl	8008450 <pubsub_listener_handle_one_timeout>
 8006a52:	4603      	mov	r3, r0
 8006a54:	2b00      	cmp	r3, #0
 8006a56:	d109      	bne.n	8006a6c <worker_thread_takeover+0xbc>
                    break;
                }
                chSysLock();
 8006a58:	f001 fe22 	bl	80086a0 <chSysLock.lto_priv.125>
=======
 80069ee:	f001 fe73 	bl	80086d8 <chSysUnlock.lto_priv.122>
 80069f2:	e00e      	b.n	8006a12 <worker_thread_takeover+0xb6>
            while (listener_task) {
                if (pubsub_listener_handle_one_timeout(&listener_task->listener, TIME_IMMEDIATE)) {
 80069f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80069f6:	4618      	mov	r0, r3
 80069f8:	2100      	movs	r1, #0
 80069fa:	f001 fd51 	bl	80084a0 <pubsub_listener_handle_one_timeout>
 80069fe:	4603      	mov	r3, r0
 8006a00:	2b00      	cmp	r3, #0
 8006a02:	d109      	bne.n	8006a18 <worker_thread_takeover+0xbc>
                    break;
                }
                chSysLock();
 8006a04:	f001 fe60 	bl	80086c8 <chSysLock.lto_priv.124>
>>>>>>> 752c83b... update binaries
                listener_task = listener_task->next;
 8006a08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006a0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006a0c:	62bb      	str	r3, [r7, #40]	; 0x28
                chSysUnlock();
<<<<<<< HEAD
 8006a62:	f001 fe25 	bl	80086b0 <chSysUnlock.lto_priv.123>
=======
 8006a0e:	f001 fe63 	bl	80086d8 <chSysUnlock.lto_priv.122>
>>>>>>> 752c83b... update binaries
        // Check for immediately available messages on listener tasks, handle one
        {
            chSysLock();
            struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
            chSysUnlock();
            while (listener_task) {
 8006a12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006a14:	2b00      	cmp	r3, #0
 8006a16:	d1ed      	bne.n	80069f4 <worker_thread_takeover+0x98>
                listener_task = listener_task->next;
                chSysUnlock();
            }
        }
#endif
        chSysLock();
<<<<<<< HEAD
 8006a6c:	f001 fe18 	bl	80086a0 <chSysLock.lto_priv.125>
        systime_t tnow_ticks = chVTGetSystemTimeX();
 8006a70:	f001 fe3a 	bl	80086e8 <chVTGetSystemTimeX.lto_priv.116>
 8006a74:	4603      	mov	r3, r0
 8006a76:	82fb      	strh	r3, [r7, #22]
        systime_t ticks_to_next_timer_task = worker_thread_get_ticks_to_timer_task_I(worker_thread->timer_task_list_head, tnow_ticks);
 8006a78:	687b      	ldr	r3, [r7, #4]
 8006a7a:	691a      	ldr	r2, [r3, #16]
 8006a7c:	8afb      	ldrh	r3, [r7, #22]
 8006a7e:	4610      	mov	r0, r2
 8006a80:	4619      	mov	r1, r3
 8006a82:	f000 f8f7 	bl	8006c74 <worker_thread_get_ticks_to_timer_task_I>
 8006a86:	4603      	mov	r3, r0
 8006a88:	82bb      	strh	r3, [r7, #20]

        chSysUnlock();
 8006a8a:	f001 fe11 	bl	80086b0 <chSysUnlock.lto_priv.123>
        uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "rem_ticks: %u", ticks_to_next_timer_task);
 8006a8e:	8abb      	ldrh	r3, [r7, #20]
 8006a90:	2001      	movs	r0, #1
 8006a92:	4922      	ldr	r1, [pc, #136]	; (8006b1c <worker_thread_takeover+0x16c>)
 8006a94:	4a22      	ldr	r2, [pc, #136]	; (8006b20 <worker_thread_takeover+0x170>)
 8006a96:	f7fd fb41 	bl	800411c <uavcan_send_debug_msg>
        chSysLock();
 8006a9a:	f001 fe01 	bl	80086a0 <chSysLock.lto_priv.125>

        if (ticks_to_next_timer_task == TIME_IMMEDIATE) {
 8006a9e:	8abb      	ldrh	r3, [r7, #20]
 8006aa0:	2b00      	cmp	r3, #0
 8006aa2:	d11c      	bne.n	8006ade <worker_thread_takeover+0x12e>
=======
 8006a18:	f001 fe56 	bl	80086c8 <chSysLock.lto_priv.124>
        uint32_t tnow_millis = millis();
 8006a1c:	f001 f946 	bl	8007cac <millis>
 8006a20:	6238      	str	r0, [r7, #32]
        uint32_t millis_to_next_timer_task =
                worker_thread_get_millis_to_timer_task_I(worker_thread->timer_task_list_head, tnow_millis);
 8006a22:	687b      	ldr	r3, [r7, #4]
 8006a24:	691b      	ldr	r3, [r3, #16]
            }
        }
#endif
        chSysLock();
        uint32_t tnow_millis = millis();
        uint32_t millis_to_next_timer_task =
 8006a26:	4618      	mov	r0, r3
 8006a28:	6a39      	ldr	r1, [r7, #32]
 8006a2a:	f000 f935 	bl	8006c98 <worker_thread_get_millis_to_timer_task_I>
 8006a2e:	61f8      	str	r0, [r7, #28]

//        chSysUnlock();
//        uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "rem_millis: %u", ticks_to_next_timer_task);
//        chSysLock();

        if (millis_to_next_timer_task == 0) {
 8006a30:	69fb      	ldr	r3, [r7, #28]
 8006a32:	2b00      	cmp	r3, #0
 8006a34:	d167      	bne.n	8006b06 <worker_thread_takeover+0x1aa>
>>>>>>> 752c83b... update binaries
            // Task is due - pop the task off the task list, run it, reschedule if task is auto-repeat
            struct worker_thread_timer_task_s* next_timer_task = worker_thread->timer_task_list_head;
 8006a36:	687b      	ldr	r3, [r7, #4]
 8006a38:	691b      	ldr	r3, [r3, #16]
 8006a3a:	61bb      	str	r3, [r7, #24]
            worker_thread->timer_task_list_head = next_timer_task->next;
 8006a3c:	69bb      	ldr	r3, [r7, #24]
 8006a3e:	695a      	ldr	r2, [r3, #20]
 8006a40:	687b      	ldr	r3, [r7, #4]
 8006a42:	611a      	str	r2, [r3, #16]

            chSysUnlock();
<<<<<<< HEAD
 8006ab2:	f001 fdfd 	bl	80086b0 <chSysUnlock.lto_priv.123>
=======
 8006a44:	f001 fe48 	bl	80086d8 <chSysUnlock.lto_priv.122>
>>>>>>> 752c83b... update binaries

            // Perform task
            next_timer_task->task_func(next_timer_task);
 8006a48:	69bb      	ldr	r3, [r7, #24]
 8006a4a:	681b      	ldr	r3, [r3, #0]
 8006a4c:	69b8      	ldr	r0, [r7, #24]
 8006a4e:	4798      	blx	r3
            next_timer_task->timer_begin_millis = tnow_millis;
 8006a50:	69bb      	ldr	r3, [r7, #24]
 8006a52:	6a3a      	ldr	r2, [r7, #32]
 8006a54:	60da      	str	r2, [r3, #12]

            if (next_timer_task->auto_repeat) {
 8006a56:	69bb      	ldr	r3, [r7, #24]
 8006a58:	7c1b      	ldrb	r3, [r3, #16]
 8006a5a:	2b00      	cmp	r3, #0
 8006a5c:	d091      	beq.n	8006982 <worker_thread_takeover+0x26>

                uint16_t task_run_time = next_timer_task->timer_begin_millis + next_timer_task->timer_expiration_millis;
 8006a5e:	69bb      	ldr	r3, [r7, #24]
 8006a60:	68db      	ldr	r3, [r3, #12]
 8006a62:	b29a      	uxth	r2, r3
 8006a64:	69bb      	ldr	r3, [r7, #24]
 8006a66:	689b      	ldr	r3, [r3, #8]
 8006a68:	b29b      	uxth	r3, r3
 8006a6a:	4413      	add	r3, r2
 8006a6c:	82fb      	strh	r3, [r7, #22]
                struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;
 8006a6e:	687b      	ldr	r3, [r7, #4]
 8006a70:	3310      	adds	r3, #16
 8006a72:	627b      	str	r3, [r7, #36]	; 0x24

                uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "thread %x task %x, now: %u, runtime: %u\ntask list",
 8006a74:	69bb      	ldr	r3, [r7, #24]
 8006a76:	681a      	ldr	r2, [r3, #0]
 8006a78:	8afb      	ldrh	r3, [r7, #22]
 8006a7a:	9200      	str	r2, [sp, #0]
 8006a7c:	6a3a      	ldr	r2, [r7, #32]
 8006a7e:	9201      	str	r2, [sp, #4]
 8006a80:	9302      	str	r3, [sp, #8]
 8006a82:	2001      	movs	r0, #1
 8006a84:	4930      	ldr	r1, [pc, #192]	; (8006b48 <worker_thread_takeover+0x1ec>)
 8006a86:	4a31      	ldr	r2, [pc, #196]	; (8006b4c <worker_thread_takeover+0x1f0>)
 8006a88:	687b      	ldr	r3, [r7, #4]
 8006a8a:	f7fd fb47 	bl	800411c <uavcan_send_debug_msg>
                                      worker_thread, next_timer_task->task_func, tnow_millis, task_run_time);
                uint16_t time_till_run;
                uint16_t period;
                if (*insert_ptr) {
 8006a8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006a90:	681b      	ldr	r3, [r3, #0]
 8006a92:	2b00      	cmp	r3, #0
 8006a94:	d027      	beq.n	8006ae6 <worker_thread_takeover+0x18a>
                    do {
                        time_till_run = task_run_time - (*insert_ptr)->timer_begin_millis;
 8006a96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006a98:	681b      	ldr	r3, [r3, #0]
 8006a9a:	68db      	ldr	r3, [r3, #12]
 8006a9c:	b29b      	uxth	r3, r3
 8006a9e:	8afa      	ldrh	r2, [r7, #22]
 8006aa0:	1ad3      	subs	r3, r2, r3
 8006aa2:	82bb      	strh	r3, [r7, #20]
                        period = (*insert_ptr)->timer_expiration_millis;
 8006aa4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006aa6:	681b      	ldr	r3, [r3, #0]
 8006aa8:	689b      	ldr	r3, [r3, #8]
 8006aaa:	827b      	strh	r3, [r7, #18]
                        uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "",
                                              "%x, dt: %u, period: %u, begin: %u",
                                              (*insert_ptr)->task_func, time_till_run, period,
 8006aac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006aae:	681b      	ldr	r3, [r3, #0]
                uint16_t period;
                if (*insert_ptr) {
                    do {
                        time_till_run = task_run_time - (*insert_ptr)->timer_begin_millis;
                        period = (*insert_ptr)->timer_expiration_millis;
                        uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "",
 8006ab0:	681c      	ldr	r4, [r3, #0]
 8006ab2:	8ab9      	ldrh	r1, [r7, #20]
 8006ab4:	8a7a      	ldrh	r2, [r7, #18]
                                              "%x, dt: %u, period: %u, begin: %u",
                                              (*insert_ptr)->task_func, time_till_run, period,
                                              (*insert_ptr)->timer_begin_millis);
 8006ab6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ab8:	681b      	ldr	r3, [r3, #0]
                uint16_t period;
                if (*insert_ptr) {
                    do {
                        time_till_run = task_run_time - (*insert_ptr)->timer_begin_millis;
                        period = (*insert_ptr)->timer_expiration_millis;
                        uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "",
 8006aba:	68db      	ldr	r3, [r3, #12]
 8006abc:	9100      	str	r1, [sp, #0]
 8006abe:	9201      	str	r2, [sp, #4]
 8006ac0:	9302      	str	r3, [sp, #8]
 8006ac2:	2001      	movs	r0, #1
 8006ac4:	4920      	ldr	r1, [pc, #128]	; (8006b48 <worker_thread_takeover+0x1ec>)
 8006ac6:	4a22      	ldr	r2, [pc, #136]	; (8006b50 <worker_thread_takeover+0x1f4>)
 8006ac8:	4623      	mov	r3, r4
 8006aca:	f7fd fb27 	bl	800411c <uavcan_send_debug_msg>
                                              "%x, dt: %u, period: %u, begin: %u",
                                              (*insert_ptr)->task_func, time_till_run, period,
                                              (*insert_ptr)->timer_begin_millis);
                        insert_ptr = &(*insert_ptr)->next;
 8006ace:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ad0:	681b      	ldr	r3, [r3, #0]
 8006ad2:	3314      	adds	r3, #20
 8006ad4:	627b      	str	r3, [r7, #36]	; 0x24
                    } while (*insert_ptr && (time_till_run >= period));
 8006ad6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ad8:	681b      	ldr	r3, [r3, #0]
 8006ada:	2b00      	cmp	r3, #0
 8006adc:	d003      	beq.n	8006ae6 <worker_thread_takeover+0x18a>
 8006ade:	8aba      	ldrh	r2, [r7, #20]
 8006ae0:	8a7b      	ldrh	r3, [r7, #18]
 8006ae2:	429a      	cmp	r2, r3
 8006ae4:	d2d7      	bcs.n	8006a96 <worker_thread_takeover+0x13a>
                }
                uavcan_send_debug_msg(UAVCAN_PROTOCOL_DEBUG_LOGLEVEL_INFO, "", "insert %x", next_timer_task->task_func);
 8006ae6:	69bb      	ldr	r3, [r7, #24]
 8006ae8:	681b      	ldr	r3, [r3, #0]
 8006aea:	2001      	movs	r0, #1
 8006aec:	4916      	ldr	r1, [pc, #88]	; (8006b48 <worker_thread_takeover+0x1ec>)
 8006aee:	4a19      	ldr	r2, [pc, #100]	; (8006b54 <worker_thread_takeover+0x1f8>)
 8006af0:	f7fd fb14 	bl	800411c <uavcan_send_debug_msg>

                // Re-insert task
                chSysLock();
<<<<<<< HEAD
 8006acc:	f001 fde8 	bl	80086a0 <chSysLock.lto_priv.125>
=======
 8006af4:	f001 fde8 	bl	80086c8 <chSysLock.lto_priv.124>
>>>>>>> 752c83b... update binaries
                worker_thread_insert_timer_task_I(worker_thread, next_timer_task);
 8006af8:	6878      	ldr	r0, [r7, #4]
 8006afa:	69b9      	ldr	r1, [r7, #24]
 8006afc:	f000 f88e 	bl	8006c1c <worker_thread_insert_timer_task_I.lto_priv.160>
                chSysUnlock();
<<<<<<< HEAD
 8006ad8:	f001 fdea 	bl	80086b0 <chSysUnlock.lto_priv.123>
 8006adc:	e77b      	b.n	80069d6 <worker_thread_takeover+0x26>
=======
 8006b00:	f001 fdea 	bl	80086d8 <chSysUnlock.lto_priv.122>
 8006b04:	e73d      	b.n	8006982 <worker_thread_takeover+0x26>
>>>>>>> 752c83b... update binaries
            }
        } else {
#ifdef MODULE_PUBSUB_ENABLED
            // If a listener task is due, we should not sleep until we've handled it
            if (worker_thread_get_any_listener_task_due_I(worker_thread)) {
 8006b06:	6878      	ldr	r0, [r7, #4]
 8006b08:	f000 f958 	bl	8006dbc <worker_thread_get_any_listener_task_due_I>
 8006b0c:	4603      	mov	r3, r0
 8006b0e:	2b00      	cmp	r3, #0
 8006b10:	d002      	beq.n	8006b18 <worker_thread_takeover+0x1bc>
                chSysUnlock();
<<<<<<< HEAD
 8006aea:	f001 fde1 	bl	80086b0 <chSysUnlock.lto_priv.123>
 8006aee:	e772      	b.n	80069d6 <worker_thread_takeover+0x26>
=======
 8006b12:	f001 fde1 	bl	80086d8 <chSysUnlock.lto_priv.122>
 8006b16:	e734      	b.n	8006982 <worker_thread_takeover+0x26>
>>>>>>> 752c83b... update binaries
                continue;
            }

            // If a publisher task is due, we should not sleep until we've handled it
            if (worker_thread_get_any_publisher_task_due_I(worker_thread)) {
 8006b18:	6878      	ldr	r0, [r7, #4]
 8006b1a:	f000 f8ff 	bl	8006d1c <worker_thread_get_any_publisher_task_due_I>
 8006b1e:	4603      	mov	r3, r0
 8006b20:	2b00      	cmp	r3, #0
 8006b22:	d002      	beq.n	8006b2a <worker_thread_takeover+0x1ce>
                chSysUnlock();
<<<<<<< HEAD
 8006afc:	f001 fdd8 	bl	80086b0 <chSysUnlock.lto_priv.123>
 8006b00:	e769      	b.n	80069d6 <worker_thread_takeover+0x26>
=======
 8006b24:	f001 fdd8 	bl	80086d8 <chSysUnlock.lto_priv.122>
 8006b28:	e72b      	b.n	8006982 <worker_thread_takeover+0x26>
>>>>>>> 752c83b... update binaries
                continue;
            }
#endif

            // No task due - go to sleep until there is a task
<<<<<<< HEAD
            chThdSuspendTimeoutS(&worker_thread->suspend_trp, ticks_to_next_timer_task);
 8006b02:	687b      	ldr	r3, [r7, #4]
 8006b04:	f103 020c 	add.w	r2, r3, #12
 8006b08:	8abb      	ldrh	r3, [r7, #20]
 8006b0a:	4610      	mov	r0, r2
 8006b0c:	4619      	mov	r1, r3
 8006b0e:	f003 fc3b 	bl	800a388 <chThdSuspendTimeoutS>

            chSysUnlock();
 8006b12:	f001 fdcd 	bl	80086b0 <chSysUnlock.lto_priv.123>
 8006b16:	e75e      	b.n	80069d6 <worker_thread_takeover+0x26>
 8006b18:	080082a9 	.word	0x080082a9
 8006b1c:	0800e654 	.word	0x0800e654
 8006b20:	0800e658 	.word	0x0800e658

08006b24 <worker_thread_func.lto_priv.138>:
=======
            chThdSuspendTimeoutS(&worker_thread->suspend_trp, millis_to_next_timer_task);
 8006b2a:	687b      	ldr	r3, [r7, #4]
 8006b2c:	f103 020c 	add.w	r2, r3, #12
 8006b30:	69fb      	ldr	r3, [r7, #28]
 8006b32:	b29b      	uxth	r3, r3
 8006b34:	4610      	mov	r0, r2
 8006b36:	4619      	mov	r1, r3
 8006b38:	f003 fc6a 	bl	800a410 <chThdSuspendTimeoutS>

            chSysUnlock();
 8006b3c:	f001 fdcc 	bl	80086d8 <chSysUnlock.lto_priv.122>
 8006b40:	e71f      	b.n	8006982 <worker_thread_takeover+0x26>
 8006b42:	bf00      	nop
 8006b44:	080082f9 	.word	0x080082f9
 8006b48:	0800e6dc 	.word	0x0800e6dc
 8006b4c:	0800e6e0 	.word	0x0800e6e0
 8006b50:	0800e714 	.word	0x0800e714
 8006b54:	0800e738 	.word	0x0800e738

08006b58 <worker_thread_func.lto_priv.137>:
>>>>>>> 752c83b... update binaries
        }
    }
}

static THD_FUNCTION(worker_thread_func, arg) {
 8006b58:	b580      	push	{r7, lr}
 8006b5a:	b084      	sub	sp, #16
 8006b5c:	af00      	add	r7, sp, #0
 8006b5e:	6078      	str	r0, [r7, #4]
    struct worker_thread_s* worker_thread = arg;
 8006b60:	687b      	ldr	r3, [r7, #4]
 8006b62:	60fb      	str	r3, [r7, #12]
    worker_thread_takeover(worker_thread);
 8006b64:	68f8      	ldr	r0, [r7, #12]
 8006b66:	f7ff fef9 	bl	800695c <worker_thread_takeover>
}
 8006b6a:	3710      	adds	r7, #16
 8006b6c:	46bd      	mov	sp, r7
 8006b6e:	bd80      	pop	{r7, pc}

08006b70 <worker_thread_wake_I.lto_priv.159>:

static void worker_thread_wake_I(struct worker_thread_s* worker_thread) {
 8006b70:	b580      	push	{r7, lr}
 8006b72:	b082      	sub	sp, #8
 8006b74:	af00      	add	r7, sp, #0
 8006b76:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006b44:	f004 fa0c 	bl	800af60 <chDbgCheckClassI>

    chThdResumeI(&worker_thread->suspend_trp, MSG_TIMEOUT);
 8006b48:	687b      	ldr	r3, [r7, #4]
 8006b4a:	330c      	adds	r3, #12
 8006b4c:	4618      	mov	r0, r3
 8006b4e:	f04f 31ff 	mov.w	r1, #4294967295
 8006b52:	f003 fc41 	bl	800a3d8 <chThdResumeI>
=======
 8006b78:	f004 fa36 	bl	800afe8 <chDbgCheckClassI>

    chThdResumeI(&worker_thread->suspend_trp, MSG_TIMEOUT);
 8006b7c:	687b      	ldr	r3, [r7, #4]
 8006b7e:	330c      	adds	r3, #12
 8006b80:	4618      	mov	r0, r3
 8006b82:	f04f 31ff 	mov.w	r1, #4294967295
 8006b86:	f003 fc6b 	bl	800a460 <chThdResumeI>
>>>>>>> 752c83b... update binaries
}
 8006b8a:	3708      	adds	r7, #8
 8006b8c:	46bd      	mov	sp, r7
 8006b8e:	bd80      	pop	{r7, pc}

08006b90 <worker_thread_wake.lto_priv.157>:

static void worker_thread_wake(struct worker_thread_s* worker_thread) {
 8006b90:	b580      	push	{r7, lr}
 8006b92:	b082      	sub	sp, #8
 8006b94:	af00      	add	r7, sp, #0
 8006b96:	6078      	str	r0, [r7, #4]
    chThdResume(&worker_thread->suspend_trp, MSG_TIMEOUT);
<<<<<<< HEAD
 8006b64:	687b      	ldr	r3, [r7, #4]
 8006b66:	330c      	adds	r3, #12
 8006b68:	4618      	mov	r0, r3
 8006b6a:	f04f 31ff 	mov.w	r1, #4294967295
 8006b6e:	f003 fc75 	bl	800a45c <chThdResume>
}
 8006b72:	3708      	adds	r7, #8
 8006b74:	46bd      	mov	sp, r7
 8006b76:	bd80      	pop	{r7, pc}

08006b78 <worker_thread_init_timer_task.lto_priv.164>:

static void worker_thread_init_timer_task(struct worker_thread_timer_task_s* task, systime_t timer_begin_systime, systime_t timer_expiration_ticks, bool auto_repeat, timer_task_handler_func_ptr task_func, void* ctx) {
 8006b78:	b480      	push	{r7}
 8006b7a:	b085      	sub	sp, #20
 8006b7c:	af00      	add	r7, sp, #0
 8006b7e:	60f8      	str	r0, [r7, #12]
 8006b80:	4608      	mov	r0, r1
 8006b82:	4611      	mov	r1, r2
 8006b84:	461a      	mov	r2, r3
 8006b86:	4603      	mov	r3, r0
 8006b88:	817b      	strh	r3, [r7, #10]
 8006b8a:	460b      	mov	r3, r1
 8006b8c:	813b      	strh	r3, [r7, #8]
 8006b8e:	4613      	mov	r3, r2
 8006b90:	71fb      	strb	r3, [r7, #7]
=======
 8006b98:	687b      	ldr	r3, [r7, #4]
 8006b9a:	330c      	adds	r3, #12
 8006b9c:	4618      	mov	r0, r3
 8006b9e:	f04f 31ff 	mov.w	r1, #4294967295
 8006ba2:	f003 fc9f 	bl	800a4e4 <chThdResume>
}
 8006ba6:	3708      	adds	r7, #8
 8006ba8:	46bd      	mov	sp, r7
 8006baa:	bd80      	pop	{r7, pc}

08006bac <worker_thread_init_timer_task.lto_priv.161>:

static void worker_thread_init_timer_task(struct worker_thread_timer_task_s* task, uint32_t timer_begin_millis, uint32_t timer_expiration_millis, bool auto_repeat, timer_task_handler_func_ptr task_func, void* ctx) {
 8006bac:	b480      	push	{r7}
 8006bae:	b085      	sub	sp, #20
 8006bb0:	af00      	add	r7, sp, #0
 8006bb2:	60f8      	str	r0, [r7, #12]
 8006bb4:	60b9      	str	r1, [r7, #8]
 8006bb6:	607a      	str	r2, [r7, #4]
 8006bb8:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    task->task_func = task_func;
 8006bba:	68fb      	ldr	r3, [r7, #12]
 8006bbc:	69ba      	ldr	r2, [r7, #24]
 8006bbe:	601a      	str	r2, [r3, #0]
    task->ctx = ctx;
 8006bc0:	68fb      	ldr	r3, [r7, #12]
 8006bc2:	69fa      	ldr	r2, [r7, #28]
 8006bc4:	605a      	str	r2, [r3, #4]
    task->timer_expiration_millis = timer_expiration_millis;
 8006bc6:	68fb      	ldr	r3, [r7, #12]
 8006bc8:	687a      	ldr	r2, [r7, #4]
 8006bca:	609a      	str	r2, [r3, #8]
    task->auto_repeat = auto_repeat;
 8006bcc:	68fb      	ldr	r3, [r7, #12]
 8006bce:	78fa      	ldrb	r2, [r7, #3]
 8006bd0:	741a      	strb	r2, [r3, #16]
    task->timer_begin_millis = timer_begin_millis;
 8006bd2:	68fb      	ldr	r3, [r7, #12]
 8006bd4:	68ba      	ldr	r2, [r7, #8]
 8006bd6:	60da      	str	r2, [r3, #12]
}
 8006bd8:	3714      	adds	r7, #20
 8006bda:	46bd      	mov	sp, r7
 8006bdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006be0:	4770      	bx	lr
 8006be2:	bf00      	nop

08006be4 <worker_thread_timer_task_is_registered_I>:

static bool worker_thread_timer_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* check_task) {
 8006be4:	b580      	push	{r7, lr}
 8006be6:	b084      	sub	sp, #16
 8006be8:	af00      	add	r7, sp, #0
 8006bea:	6078      	str	r0, [r7, #4]
 8006bec:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006bc6:	f004 f9cb 	bl	800af60 <chDbgCheckClassI>
=======
 8006bee:	f004 f9fb 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    struct worker_thread_timer_task_s* task = worker_thread->timer_task_list_head;
 8006bf2:	687b      	ldr	r3, [r7, #4]
 8006bf4:	691b      	ldr	r3, [r3, #16]
 8006bf6:	60fb      	str	r3, [r7, #12]
 8006bf8:	e008      	b.n	8006c0c <worker_thread_timer_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 8006bfa:	68fa      	ldr	r2, [r7, #12]
 8006bfc:	683b      	ldr	r3, [r7, #0]
 8006bfe:	429a      	cmp	r2, r3
 8006c00:	d101      	bne.n	8006c06 <worker_thread_timer_task_is_registered_I+0x22>
            return true;
 8006c02:	2301      	movs	r3, #1
 8006c04:	e006      	b.n	8006c14 <worker_thread_timer_task_is_registered_I+0x30>
        }
        task = task->next;
 8006c06:	68fb      	ldr	r3, [r7, #12]
 8006c08:	695b      	ldr	r3, [r3, #20]
 8006c0a:	60fb      	str	r3, [r7, #12]

static bool worker_thread_timer_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_timer_task_s* task = worker_thread->timer_task_list_head;
    while (task) {
 8006c0c:	68fb      	ldr	r3, [r7, #12]
 8006c0e:	2b00      	cmp	r3, #0
 8006c10:	d1f3      	bne.n	8006bfa <worker_thread_timer_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006c12:	2300      	movs	r3, #0
}
 8006c14:	4618      	mov	r0, r3
 8006c16:	3710      	adds	r7, #16
 8006c18:	46bd      	mov	sp, r7
 8006c1a:	bd80      	pop	{r7, pc}

08006c1c <worker_thread_insert_timer_task_I.lto_priv.160>:

static void worker_thread_insert_timer_task_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8006c1c:	b580      	push	{r7, lr}
 8006c1e:	b084      	sub	sp, #16
 8006c20:	af00      	add	r7, sp, #0
 8006c22:	6078      	str	r0, [r7, #4]
 8006c24:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006bfe:	f004 f9af 	bl	800af60 <chDbgCheckClassI>
    chDbgCheck(!worker_thread_timer_task_is_registered_I(worker_thread, task));
 8006c02:	6878      	ldr	r0, [r7, #4]
 8006c04:	6839      	ldr	r1, [r7, #0]
 8006c06:	f7ff ffd9 	bl	8006bbc <worker_thread_timer_task_is_registered_I>
 8006c0a:	4603      	mov	r3, r0
 8006c0c:	2b00      	cmp	r3, #0
 8006c0e:	d002      	beq.n	8006c16 <worker_thread_insert_timer_task_I.lto_priv.163+0x22>
 8006c10:	4817      	ldr	r0, [pc, #92]	; (8006c70 <worker_thread_insert_timer_task_I.lto_priv.163+0x7c>)
 8006c12:	f004 f8c7 	bl	800ada4 <chSysHalt>

    if (task->timer_expiration_ticks == TIME_INFINITE) {
 8006c16:	683b      	ldr	r3, [r7, #0]
 8006c18:	891b      	ldrh	r3, [r3, #8]
 8006c1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006c1e:	4293      	cmp	r3, r2
 8006c20:	d022      	beq.n	8006c68 <worker_thread_insert_timer_task_I.lto_priv.163+0x74>
=======
 8006c26:	f004 f9df 	bl	800afe8 <chDbgCheckClassI>
    chDbgCheck(!worker_thread_timer_task_is_registered_I(worker_thread, task));
 8006c2a:	6878      	ldr	r0, [r7, #4]
 8006c2c:	6839      	ldr	r1, [r7, #0]
 8006c2e:	f7ff ffd9 	bl	8006be4 <worker_thread_timer_task_is_registered_I>
 8006c32:	4603      	mov	r3, r0
 8006c34:	2b00      	cmp	r3, #0
 8006c36:	d002      	beq.n	8006c3e <worker_thread_insert_timer_task_I.lto_priv.160+0x22>
 8006c38:	4816      	ldr	r0, [pc, #88]	; (8006c94 <worker_thread_insert_timer_task_I.lto_priv.160+0x78>)
 8006c3a:	f004 f8f7 	bl	800ae2c <chSysHalt>

    if (task->timer_expiration_millis == (uint32_t)-1) {
 8006c3e:	683b      	ldr	r3, [r7, #0]
 8006c40:	689b      	ldr	r3, [r3, #8]
 8006c42:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006c46:	d022      	beq.n	8006c8e <worker_thread_insert_timer_task_I.lto_priv.160+0x72>
>>>>>>> 752c83b... update binaries
        return;
    }

    // since the system timer is only 16 bits on STM32F1xx, and wraparound occurs every 6.5536 seconds at 10KHz
    uint32_t task_run_time = task->timer_begin_millis + task->timer_expiration_millis;
 8006c48:	683b      	ldr	r3, [r7, #0]
 8006c4a:	68da      	ldr	r2, [r3, #12]
 8006c4c:	683b      	ldr	r3, [r7, #0]
 8006c4e:	689b      	ldr	r3, [r3, #8]
 8006c50:	4413      	add	r3, r2
 8006c52:	60bb      	str	r3, [r7, #8]
    struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;
<<<<<<< HEAD
 8006c2e:	687b      	ldr	r3, [r7, #4]
 8006c30:	3310      	adds	r3, #16
 8006c32:	60fb      	str	r3, [r7, #12]
 8006c34:	e003      	b.n	8006c3e <worker_thread_insert_timer_task_I.lto_priv.163+0x4a>
    while (*insert_ptr && task_run_time - (*insert_ptr)->timer_begin_systime >= (*insert_ptr)->timer_expiration_ticks) {
        insert_ptr = &(*insert_ptr)->next;
 8006c36:	68fb      	ldr	r3, [r7, #12]
 8006c38:	681b      	ldr	r3, [r3, #0]
 8006c3a:	3310      	adds	r3, #16
 8006c3c:	60fb      	str	r3, [r7, #12]
        return;
    }

    systime_t task_run_time = task->timer_begin_systime + task->timer_expiration_ticks;
    struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;
    while (*insert_ptr && task_run_time - (*insert_ptr)->timer_begin_systime >= (*insert_ptr)->timer_expiration_ticks) {
 8006c3e:	68fb      	ldr	r3, [r7, #12]
 8006c40:	681b      	ldr	r3, [r3, #0]
 8006c42:	2b00      	cmp	r3, #0
 8006c44:	d009      	beq.n	8006c5a <worker_thread_insert_timer_task_I.lto_priv.163+0x66>
 8006c46:	897b      	ldrh	r3, [r7, #10]
 8006c48:	68fa      	ldr	r2, [r7, #12]
 8006c4a:	6812      	ldr	r2, [r2, #0]
 8006c4c:	8952      	ldrh	r2, [r2, #10]
 8006c4e:	1a9b      	subs	r3, r3, r2
 8006c50:	68fa      	ldr	r2, [r7, #12]
 8006c52:	6812      	ldr	r2, [r2, #0]
 8006c54:	8912      	ldrh	r2, [r2, #8]
 8006c56:	4293      	cmp	r3, r2
 8006c58:	daed      	bge.n	8006c36 <worker_thread_insert_timer_task_I.lto_priv.163+0x42>
=======
 8006c54:	687b      	ldr	r3, [r7, #4]
 8006c56:	3310      	adds	r3, #16
 8006c58:	60fb      	str	r3, [r7, #12]
 8006c5a:	e003      	b.n	8006c64 <worker_thread_insert_timer_task_I.lto_priv.160+0x48>

    while (*insert_ptr &&
           (uint32_t)(task_run_time - (*insert_ptr)->timer_begin_millis) >= (*insert_ptr)->timer_expiration_millis) {
        insert_ptr = &(*insert_ptr)->next;
 8006c5c:	68fb      	ldr	r3, [r7, #12]
 8006c5e:	681b      	ldr	r3, [r3, #0]
 8006c60:	3314      	adds	r3, #20
 8006c62:	60fb      	str	r3, [r7, #12]

    // since the system timer is only 16 bits on STM32F1xx, and wraparound occurs every 6.5536 seconds at 10KHz
    uint32_t task_run_time = task->timer_begin_millis + task->timer_expiration_millis;
    struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;

    while (*insert_ptr &&
 8006c64:	68fb      	ldr	r3, [r7, #12]
 8006c66:	681b      	ldr	r3, [r3, #0]
 8006c68:	2b00      	cmp	r3, #0
 8006c6a:	d009      	beq.n	8006c80 <worker_thread_insert_timer_task_I.lto_priv.160+0x64>
           (uint32_t)(task_run_time - (*insert_ptr)->timer_begin_millis) >= (*insert_ptr)->timer_expiration_millis) {
 8006c6c:	68fb      	ldr	r3, [r7, #12]
 8006c6e:	681b      	ldr	r3, [r3, #0]
 8006c70:	68db      	ldr	r3, [r3, #12]
 8006c72:	68ba      	ldr	r2, [r7, #8]
 8006c74:	1ad2      	subs	r2, r2, r3
 8006c76:	68fb      	ldr	r3, [r7, #12]
 8006c78:	681b      	ldr	r3, [r3, #0]
 8006c7a:	689b      	ldr	r3, [r3, #8]

    // since the system timer is only 16 bits on STM32F1xx, and wraparound occurs every 6.5536 seconds at 10KHz
    uint32_t task_run_time = task->timer_begin_millis + task->timer_expiration_millis;
    struct worker_thread_timer_task_s** insert_ptr = &worker_thread->timer_task_list_head;

    while (*insert_ptr &&
 8006c7c:	429a      	cmp	r2, r3
 8006c7e:	d2ed      	bcs.n	8006c5c <worker_thread_insert_timer_task_I.lto_priv.160+0x40>
           (uint32_t)(task_run_time - (*insert_ptr)->timer_begin_millis) >= (*insert_ptr)->timer_expiration_millis) {
>>>>>>> 752c83b... update binaries
        insert_ptr = &(*insert_ptr)->next;
    }
    task->next = *insert_ptr;
<<<<<<< HEAD
 8006c5a:	68fb      	ldr	r3, [r7, #12]
 8006c5c:	681a      	ldr	r2, [r3, #0]
 8006c5e:	683b      	ldr	r3, [r7, #0]
 8006c60:	611a      	str	r2, [r3, #16]
    *insert_ptr = task;
 8006c62:	68fb      	ldr	r3, [r7, #12]
 8006c64:	683a      	ldr	r2, [r7, #0]
 8006c66:	601a      	str	r2, [r3, #0]
}
 8006c68:	3710      	adds	r7, #16
 8006c6a:	46bd      	mov	sp, r7
 8006c6c:	bd80      	pop	{r7, pc}
 8006c6e:	bf00      	nop
 8006c70:	0800ebe8 	.word	0x0800ebe8

08006c74 <worker_thread_get_ticks_to_timer_task_I>:

static systime_t worker_thread_get_ticks_to_timer_task_I(struct worker_thread_timer_task_s* task, systime_t tnow_ticks) {
 8006c74:	b580      	push	{r7, lr}
 8006c76:	b084      	sub	sp, #16
 8006c78:	af00      	add	r7, sp, #0
 8006c7a:	6078      	str	r0, [r7, #4]
 8006c7c:	460b      	mov	r3, r1
 8006c7e:	807b      	strh	r3, [r7, #2]
    chDbgCheckClassI();
 8006c80:	f004 f96e 	bl	800af60 <chDbgCheckClassI>

    if (task && task->timer_expiration_ticks != TIME_INFINITE) {
 8006c84:	687b      	ldr	r3, [r7, #4]
 8006c86:	2b00      	cmp	r3, #0
 8006c88:	d017      	beq.n	8006cba <worker_thread_get_ticks_to_timer_task_I+0x46>
 8006c8a:	687b      	ldr	r3, [r7, #4]
 8006c8c:	891b      	ldrh	r3, [r3, #8]
 8006c8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006c92:	4293      	cmp	r3, r2
 8006c94:	d011      	beq.n	8006cba <worker_thread_get_ticks_to_timer_task_I+0x46>
        systime_t elapsed = tnow_ticks - task->timer_begin_systime;
 8006c96:	687b      	ldr	r3, [r7, #4]
 8006c98:	895b      	ldrh	r3, [r3, #10]
 8006c9a:	887a      	ldrh	r2, [r7, #2]
 8006c9c:	1ad3      	subs	r3, r2, r3
 8006c9e:	81fb      	strh	r3, [r7, #14]
        if (elapsed >= task->timer_expiration_ticks) {
 8006ca0:	687b      	ldr	r3, [r7, #4]
 8006ca2:	891b      	ldrh	r3, [r3, #8]
 8006ca4:	89fa      	ldrh	r2, [r7, #14]
 8006ca6:	429a      	cmp	r2, r3
 8006ca8:	d301      	bcc.n	8006cae <worker_thread_get_ticks_to_timer_task_I+0x3a>
            return TIME_IMMEDIATE;
 8006caa:	2300      	movs	r3, #0
 8006cac:	e007      	b.n	8006cbe <worker_thread_get_ticks_to_timer_task_I+0x4a>
=======
 8006c80:	68fb      	ldr	r3, [r7, #12]
 8006c82:	681a      	ldr	r2, [r3, #0]
 8006c84:	683b      	ldr	r3, [r7, #0]
 8006c86:	615a      	str	r2, [r3, #20]
    *insert_ptr = task;
 8006c88:	68fb      	ldr	r3, [r7, #12]
 8006c8a:	683a      	ldr	r2, [r7, #0]
 8006c8c:	601a      	str	r2, [r3, #0]
}
 8006c8e:	3710      	adds	r7, #16
 8006c90:	46bd      	mov	sp, r7
 8006c92:	bd80      	pop	{r7, pc}
 8006c94:	0800ecc0 	.word	0x0800ecc0

08006c98 <worker_thread_get_millis_to_timer_task_I>:

static uint32_t worker_thread_get_millis_to_timer_task_I(struct worker_thread_timer_task_s* task, uint32_t tnow_millis) {
 8006c98:	b580      	push	{r7, lr}
 8006c9a:	b084      	sub	sp, #16
 8006c9c:	af00      	add	r7, sp, #0
 8006c9e:	6078      	str	r0, [r7, #4]
 8006ca0:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 8006ca2:	f004 f9a1 	bl	800afe8 <chDbgCheckClassI>

    if (task && task->timer_expiration_millis != (uint32_t)-1) {
 8006ca6:	687b      	ldr	r3, [r7, #4]
 8006ca8:	2b00      	cmp	r3, #0
 8006caa:	d015      	beq.n	8006cd8 <worker_thread_get_millis_to_timer_task_I+0x40>
 8006cac:	687b      	ldr	r3, [r7, #4]
 8006cae:	689b      	ldr	r3, [r3, #8]
 8006cb0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006cb4:	d010      	beq.n	8006cd8 <worker_thread_get_millis_to_timer_task_I+0x40>
        uint32_t elapsed = tnow_millis - task->timer_begin_millis;
 8006cb6:	687b      	ldr	r3, [r7, #4]
 8006cb8:	68db      	ldr	r3, [r3, #12]
 8006cba:	683a      	ldr	r2, [r7, #0]
 8006cbc:	1ad3      	subs	r3, r2, r3
 8006cbe:	60fb      	str	r3, [r7, #12]
        if (elapsed >= task->timer_expiration_millis) {
 8006cc0:	687b      	ldr	r3, [r7, #4]
 8006cc2:	689a      	ldr	r2, [r3, #8]
 8006cc4:	68fb      	ldr	r3, [r7, #12]
 8006cc6:	429a      	cmp	r2, r3
 8006cc8:	d801      	bhi.n	8006cce <worker_thread_get_millis_to_timer_task_I+0x36>
            return 0;
 8006cca:	2300      	movs	r3, #0
 8006ccc:	e006      	b.n	8006cdc <worker_thread_get_millis_to_timer_task_I+0x44>
>>>>>>> 752c83b... update binaries
        } else {
            return task->timer_expiration_millis - elapsed;
 8006cce:	687b      	ldr	r3, [r7, #4]
 8006cd0:	689a      	ldr	r2, [r3, #8]
 8006cd2:	68fb      	ldr	r3, [r7, #12]
 8006cd4:	1ad3      	subs	r3, r2, r3
 8006cd6:	e001      	b.n	8006cdc <worker_thread_get_millis_to_timer_task_I+0x44>
        }
    } else {
        return (uint32_t)-1;
 8006cd8:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 8006cdc:	4618      	mov	r0, r3
 8006cde:	3710      	adds	r7, #16
 8006ce0:	46bd      	mov	sp, r7
 8006ce2:	bd80      	pop	{r7, pc}

08006ce4 <worker_thread_publisher_task_is_registered_I>:

#ifdef MODULE_PUBSUB_ENABLED
static bool worker_thread_publisher_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* check_task) {
 8006ce4:	b580      	push	{r7, lr}
 8006ce6:	b084      	sub	sp, #16
 8006ce8:	af00      	add	r7, sp, #0
 8006cea:	6078      	str	r0, [r7, #4]
 8006cec:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006cd2:	f004 f945 	bl	800af60 <chDbgCheckClassI>
=======
 8006cee:	f004 f97b 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 8006cf2:	687b      	ldr	r3, [r7, #4]
 8006cf4:	699b      	ldr	r3, [r3, #24]
 8006cf6:	60fb      	str	r3, [r7, #12]
 8006cf8:	e008      	b.n	8006d0c <worker_thread_publisher_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 8006cfa:	68fa      	ldr	r2, [r7, #12]
 8006cfc:	683b      	ldr	r3, [r7, #0]
 8006cfe:	429a      	cmp	r2, r3
 8006d00:	d101      	bne.n	8006d06 <worker_thread_publisher_task_is_registered_I+0x22>
            return true;
 8006d02:	2301      	movs	r3, #1
 8006d04:	e006      	b.n	8006d14 <worker_thread_publisher_task_is_registered_I+0x30>
        }
        task = task->next;
 8006d06:	68fb      	ldr	r3, [r7, #12]
 8006d08:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006d0a:	60fb      	str	r3, [r7, #12]
#ifdef MODULE_PUBSUB_ENABLED
static bool worker_thread_publisher_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_publisher_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
    while (task) {
 8006d0c:	68fb      	ldr	r3, [r7, #12]
 8006d0e:	2b00      	cmp	r3, #0
 8006d10:	d1f3      	bne.n	8006cfa <worker_thread_publisher_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006d12:	2300      	movs	r3, #0
}
 8006d14:	4618      	mov	r0, r3
 8006d16:	3710      	adds	r7, #16
 8006d18:	46bd      	mov	sp, r7
 8006d1a:	bd80      	pop	{r7, pc}

08006d1c <worker_thread_get_any_publisher_task_due_I>:

static bool worker_thread_get_any_publisher_task_due_I(struct worker_thread_s* worker_thread) {
 8006d1c:	b580      	push	{r7, lr}
 8006d1e:	b084      	sub	sp, #16
 8006d20:	af00      	add	r7, sp, #0
 8006d22:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006d08:	f004 f92a 	bl	800af60 <chDbgCheckClassI>
=======
 8006d24:	f004 f960 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
 8006d28:	687b      	ldr	r3, [r7, #4]
 8006d2a:	699b      	ldr	r3, [r3, #24]
 8006d2c:	60fb      	str	r3, [r7, #12]
 8006d2e:	e00c      	b.n	8006d4a <worker_thread_get_any_publisher_task_due_I+0x2e>
    while (task) {
        if (chMBGetUsedCountI(&task->mailbox) != 0) {
<<<<<<< HEAD
 8006d14:	68fb      	ldr	r3, [r7, #12]
 8006d16:	3310      	adds	r3, #16
 8006d18:	4618      	mov	r0, r3
 8006d1a:	f001 fd09 	bl	8008730 <chMBGetUsedCountI.lto_priv.131>
 8006d1e:	4603      	mov	r3, r0
 8006d20:	2b00      	cmp	r3, #0
 8006d22:	d001      	beq.n	8006d28 <worker_thread_get_any_publisher_task_due_I+0x28>
=======
 8006d30:	68fb      	ldr	r3, [r7, #12]
 8006d32:	3310      	adds	r3, #16
 8006d34:	4618      	mov	r0, r3
 8006d36:	f001 fd07 	bl	8008748 <chMBGetUsedCountI.lto_priv.130>
 8006d3a:	4603      	mov	r3, r0
 8006d3c:	2b00      	cmp	r3, #0
 8006d3e:	d001      	beq.n	8006d44 <worker_thread_get_any_publisher_task_due_I+0x28>
>>>>>>> 752c83b... update binaries
            return true;
 8006d40:	2301      	movs	r3, #1
 8006d42:	e006      	b.n	8006d52 <worker_thread_get_any_publisher_task_due_I+0x36>
        }
        task = task->next;
 8006d44:	68fb      	ldr	r3, [r7, #12]
 8006d46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006d48:	60fb      	str	r3, [r7, #12]

static bool worker_thread_get_any_publisher_task_due_I(struct worker_thread_s* worker_thread) {
    chDbgCheckClassI();

    struct worker_thread_publisher_task_s* task = worker_thread->publisher_task_list_head;
    while (task) {
 8006d4a:	68fb      	ldr	r3, [r7, #12]
 8006d4c:	2b00      	cmp	r3, #0
 8006d4e:	d1ef      	bne.n	8006d30 <worker_thread_get_any_publisher_task_due_I+0x14>
        if (chMBGetUsedCountI(&task->mailbox) != 0) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006d50:	2300      	movs	r3, #0
}
 8006d52:	4618      	mov	r0, r3
 8006d54:	3710      	adds	r7, #16
 8006d56:	46bd      	mov	sp, r7
 8006d58:	bd80      	pop	{r7, pc}
 8006d5a:	bf00      	nop

08006d5c <worker_thread_listener_task_is_registered_I>:

static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
 8006d5c:	b580      	push	{r7, lr}
 8006d5e:	b084      	sub	sp, #16
 8006d60:	af00      	add	r7, sp, #0
 8006d62:	6078      	str	r0, [r7, #4]
 8006d64:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006d4a:	f004 f909 	bl	800af60 <chDbgCheckClassI>
=======
 8006d66:	f004 f93f 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    struct worker_thread_listener_task_s* task = worker_thread->listener_task_list_head;
 8006d6a:	687b      	ldr	r3, [r7, #4]
 8006d6c:	695b      	ldr	r3, [r3, #20]
 8006d6e:	60fb      	str	r3, [r7, #12]
 8006d70:	e008      	b.n	8006d84 <worker_thread_listener_task_is_registered_I+0x28>
    while (task) {
        if (task == check_task) {
 8006d72:	68fa      	ldr	r2, [r7, #12]
 8006d74:	683b      	ldr	r3, [r7, #0]
 8006d76:	429a      	cmp	r2, r3
 8006d78:	d101      	bne.n	8006d7e <worker_thread_listener_task_is_registered_I+0x22>
            return true;
 8006d7a:	2301      	movs	r3, #1
 8006d7c:	e006      	b.n	8006d8c <worker_thread_listener_task_is_registered_I+0x30>
        }
        task = task->next;
 8006d7e:	68fb      	ldr	r3, [r7, #12]
 8006d80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d82:	60fb      	str	r3, [r7, #12]

static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
    chDbgCheckClassI();

    struct worker_thread_listener_task_s* task = worker_thread->listener_task_list_head;
    while (task) {
 8006d84:	68fb      	ldr	r3, [r7, #12]
 8006d86:	2b00      	cmp	r3, #0
 8006d88:	d1f3      	bne.n	8006d72 <worker_thread_listener_task_is_registered_I+0x16>
        if (task == check_task) {
            return true;
        }
        task = task->next;
    }
    return false;
 8006d8a:	2300      	movs	r3, #0
}
 8006d8c:	4618      	mov	r0, r3
 8006d8e:	3710      	adds	r7, #16
 8006d90:	46bd      	mov	sp, r7
 8006d92:	bd80      	pop	{r7, pc}

08006d94 <worker_thread_listener_task_is_registered.lto_priv.158>:

static bool worker_thread_listener_task_is_registered(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task) {
 8006d94:	b580      	push	{r7, lr}
 8006d96:	b084      	sub	sp, #16
 8006d98:	af00      	add	r7, sp, #0
 8006d9a:	6078      	str	r0, [r7, #4]
 8006d9c:	6039      	str	r1, [r7, #0]
    chSysLock();
<<<<<<< HEAD
 8006d82:	f001 fc8d 	bl	80086a0 <chSysLock.lto_priv.125>
=======
 8006d9e:	f001 fc93 	bl	80086c8 <chSysLock.lto_priv.124>
>>>>>>> 752c83b... update binaries
    bool ret = worker_thread_listener_task_is_registered_I(worker_thread, check_task);
 8006da2:	6878      	ldr	r0, [r7, #4]
 8006da4:	6839      	ldr	r1, [r7, #0]
 8006da6:	f7ff ffd9 	bl	8006d5c <worker_thread_listener_task_is_registered_I>
 8006daa:	4603      	mov	r3, r0
 8006dac:	73fb      	strb	r3, [r7, #15]
    chSysUnlock();
<<<<<<< HEAD
 8006d92:	f001 fc8d 	bl	80086b0 <chSysUnlock.lto_priv.123>
=======
 8006dae:	f001 fc93 	bl	80086d8 <chSysUnlock.lto_priv.122>
>>>>>>> 752c83b... update binaries
    return ret;
 8006db2:	7bfb      	ldrb	r3, [r7, #15]
}
 8006db4:	4618      	mov	r0, r3
 8006db6:	3710      	adds	r7, #16
 8006db8:	46bd      	mov	sp, r7
 8006dba:	bd80      	pop	{r7, pc}

08006dbc <worker_thread_get_any_listener_task_due_I>:

static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread) {
 8006dbc:	b580      	push	{r7, lr}
 8006dbe:	b084      	sub	sp, #16
 8006dc0:	af00      	add	r7, sp, #0
 8006dc2:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8006da8:	f004 f8da 	bl	800af60 <chDbgCheckClassI>
=======
 8006dc4:	f004 f910 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
 8006dc8:	687b      	ldr	r3, [r7, #4]
 8006dca:	695b      	ldr	r3, [r3, #20]
 8006dcc:	60fb      	str	r3, [r7, #12]
 8006dce:	e00b      	b.n	8006de8 <worker_thread_get_any_listener_task_due_I+0x2c>
    while (listener_task) {
        if (pubsub_listener_has_message(&listener_task->listener)) {
<<<<<<< HEAD
 8006db4:	68fb      	ldr	r3, [r7, #12]
 8006db6:	4618      	mov	r0, r3
 8006db8:	f001 fa64 	bl	8008284 <pubsub_listener_has_message>
 8006dbc:	4603      	mov	r3, r0
 8006dbe:	2b00      	cmp	r3, #0
 8006dc0:	d001      	beq.n	8006dc6 <worker_thread_get_any_listener_task_due_I+0x26>
=======
 8006dd0:	68fb      	ldr	r3, [r7, #12]
 8006dd2:	4618      	mov	r0, r3
 8006dd4:	f001 fa7e 	bl	80082d4 <pubsub_listener_has_message>
 8006dd8:	4603      	mov	r3, r0
 8006dda:	2b00      	cmp	r3, #0
 8006ddc:	d001      	beq.n	8006de2 <worker_thread_get_any_listener_task_due_I+0x26>
>>>>>>> 752c83b... update binaries
            return true;
 8006dde:	2301      	movs	r3, #1
 8006de0:	e006      	b.n	8006df0 <worker_thread_get_any_listener_task_due_I+0x34>
        }
        listener_task = listener_task->next;
 8006de2:	68fb      	ldr	r3, [r7, #12]
 8006de4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006de6:	60fb      	str	r3, [r7, #12]

static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread) {
    chDbgCheckClassI();

    struct worker_thread_listener_task_s* listener_task = worker_thread->listener_task_list_head;
    while (listener_task) {
 8006de8:	68fb      	ldr	r3, [r7, #12]
 8006dea:	2b00      	cmp	r3, #0
 8006dec:	d1f0      	bne.n	8006dd0 <worker_thread_get_any_listener_task_due_I+0x14>
        if (pubsub_listener_has_message(&listener_task->listener)) {
            return true;
        }
        listener_task = listener_task->next;
    }
    return false;
 8006dee:	2300      	movs	r3, #0
}
 8006df0:	4618      	mov	r0, r3
 8006df2:	3710      	adds	r7, #16
 8006df4:	46bd      	mov	sp, r7
 8006df6:	bd80      	pop	{r7, pc}

08006df8 <port_lock.lto_priv.113>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006df8:	b480      	push	{r7}
 8006dfa:	b083      	sub	sp, #12
 8006dfc:	af00      	add	r7, sp, #0
 8006dfe:	2320      	movs	r3, #32
 8006e00:	607b      	str	r3, [r7, #4]
 8006e02:	687b      	ldr	r3, [r7, #4]
 8006e04:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006e08:	370c      	adds	r7, #12
 8006e0a:	46bd      	mov	sp, r7
 8006e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e10:	4770      	bx	lr
 8006e12:	bf00      	nop

08006e14 <port_unlock.lto_priv.110>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006e14:	b480      	push	{r7}
 8006e16:	b083      	sub	sp, #12
 8006e18:	af00      	add	r7, sp, #0
 8006e1a:	2300      	movs	r3, #0
 8006e1c:	607b      	str	r3, [r7, #4]
 8006e1e:	687b      	ldr	r3, [r7, #4]
 8006e20:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006e24:	370c      	adds	r7, #12
 8006e26:	46bd      	mov	sp, r7
 8006e28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e2c:	4770      	bx	lr
 8006e2e:	bf00      	nop

08006e30 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006e30:	b580      	push	{r7, lr}
 8006e32:	af00      	add	r7, sp, #0

  port_lock();
 8006e34:	f7ff ffe0 	bl	8006df8 <port_lock.lto_priv.113>
}
 8006e38:	bd80      	pop	{r7, pc}
 8006e3a:	bf00      	nop

08006e3c <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006e3c:	b580      	push	{r7, lr}
 8006e3e:	af00      	add	r7, sp, #0

  port_unlock();
 8006e40:	f7ff ffe8 	bl	8006e14 <port_unlock.lto_priv.110>
}
 8006e44:	bd80      	pop	{r7, pc}
 8006e46:	bf00      	nop

08006e48 <st_lld_get_counter.lto_priv.107>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8006e48:	b480      	push	{r7}
 8006e4a:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8006e4c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006e52:	b29b      	uxth	r3, r3
}
 8006e54:	4618      	mov	r0, r3
 8006e56:	46bd      	mov	sp, r7
 8006e58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e5c:	4770      	bx	lr
 8006e5e:	bf00      	nop

08006e60 <port_timer_get_time.lto_priv.104>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006e60:	b580      	push	{r7, lr}
 8006e62:	af00      	add	r7, sp, #0

  return stGetCounter();
 8006e64:	f7ff fff0 	bl	8006e48 <st_lld_get_counter.lto_priv.107>
 8006e68:	4603      	mov	r3, r0
}
 8006e6a:	4618      	mov	r0, r3
 8006e6c:	bd80      	pop	{r7, pc}
 8006e6e:	bf00      	nop

08006e70 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006e70:	b580      	push	{r7, lr}
 8006e72:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8006e74:	f7ff ffdc 	bl	8006e30 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
<<<<<<< HEAD
 8006e5c:	f004 f81c 	bl	800ae98 <_dbg_check_lock_from_isr>
=======
 8006e78:	f004 f852 	bl	800af20 <_dbg_check_lock_from_isr>
>>>>>>> 752c83b... update binaries
}
 8006e7c:	bd80      	pop	{r7, pc}
 8006e7e:	bf00      	nop

08006e80 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006e80:	b580      	push	{r7, lr}
 8006e82:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
<<<<<<< HEAD
 8006e68:	f004 f82c 	bl	800aec4 <_dbg_check_unlock_from_isr>
=======
 8006e84:	f004 f862 	bl	800af4c <_dbg_check_unlock_from_isr>
>>>>>>> 752c83b... update binaries
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006e88:	f7ff ffd8 	bl	8006e3c <port_unlock_from_isr>
}
 8006e8c:	bd80      	pop	{r7, pc}
 8006e8e:	bf00      	nop

08006e90 <chVTGetSystemTimeX.lto_priv.116>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006e90:	b580      	push	{r7, lr}
 8006e92:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006e94:	f7ff ffe4 	bl	8006e60 <port_timer_get_time.lto_priv.104>
 8006e98:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006e9a:	4618      	mov	r0, r3
 8006e9c:	bd80      	pop	{r7, pc}
 8006e9e:	bf00      	nop

08006ea0 <_local_ctor_41>:
    CAN_TypeDef* can;
};

static struct can_driver_stm32_instance_s can1_instance;

RUN_ON(CAN_INIT) {
 8006ea0:	b580      	push	{r7, lr}
 8006ea2:	b082      	sub	sp, #8
 8006ea4:	af02      	add	r7, sp, #8
    // TODO make this index configurable and enable multiple instances
    can1_instance.can = CAN1;
 8006ea6:	4b09      	ldr	r3, [pc, #36]	; (8006ecc <_local_ctor_41+0x2c>)
 8006ea8:	4a09      	ldr	r2, [pc, #36]	; (8006ed0 <_local_ctor_41+0x30>)
 8006eaa:	605a      	str	r2, [r3, #4]
    can1_instance.frontend = can_driver_register(0, &can1_instance, &can_driver_stm32_iface, NUM_TX_MAILBOXES, NUM_RX_MAILBOXES, RX_FIFO_DEPTH);
 8006eac:	2302      	movs	r3, #2
 8006eae:	9300      	str	r3, [sp, #0]
 8006eb0:	2303      	movs	r3, #3
 8006eb2:	9301      	str	r3, [sp, #4]
 8006eb4:	2000      	movs	r0, #0
 8006eb6:	4905      	ldr	r1, [pc, #20]	; (8006ecc <_local_ctor_41+0x2c>)
 8006eb8:	4a06      	ldr	r2, [pc, #24]	; (8006ed4 <_local_ctor_41+0x34>)
 8006eba:	2303      	movs	r3, #3
 8006ebc:	f7fe fdf6 	bl	8005aac <can_driver_register>
 8006ec0:	4602      	mov	r2, r0
 8006ec2:	4b02      	ldr	r3, [pc, #8]	; (8006ecc <_local_ctor_41+0x2c>)
 8006ec4:	601a      	str	r2, [r3, #0]
}
 8006ec6:	46bd      	mov	sp, r7
 8006ec8:	bd80      	pop	{r7, pc}
 8006eca:	bf00      	nop
 8006ecc:	20001468 	.word	0x20001468
 8006ed0:	40006400 	.word	0x40006400
 8006ed4:	0800ece4 	.word	0x0800ece4

08006ed8 <can_driver_stm32_start.lto_priv.22>:

static void can_driver_stm32_start(void* ctx, bool silent, bool auto_retransmit, uint32_t baudrate) {
 8006ed8:	b580      	push	{r7, lr}
 8006eda:	b08c      	sub	sp, #48	; 0x30
 8006edc:	af00      	add	r7, sp, #0
 8006ede:	60f8      	str	r0, [r7, #12]
 8006ee0:	607b      	str	r3, [r7, #4]
 8006ee2:	460b      	mov	r3, r1
 8006ee4:	72fb      	strb	r3, [r7, #11]
 8006ee6:	4613      	mov	r3, r2
 8006ee8:	72bb      	strb	r3, [r7, #10]
    struct can_driver_stm32_instance_s* instance = ctx;
 8006eea:	68fb      	ldr	r3, [r7, #12]
 8006eec:	62bb      	str	r3, [r7, #40]	; 0x28

    rccEnableCAN1(FALSE);
 8006eee:	4a84      	ldr	r2, [pc, #528]	; (8007100 <can_driver_stm32_start.lto_priv.22+0x228>)
 8006ef0:	4b83      	ldr	r3, [pc, #524]	; (8007100 <can_driver_stm32_start.lto_priv.22+0x228>)
 8006ef2:	69db      	ldr	r3, [r3, #28]
 8006ef4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006ef8:	61d3      	str	r3, [r2, #28]

    instance->can->FMR = (instance->can->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
 8006efa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006efc:	685a      	ldr	r2, [r3, #4]
 8006efe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f00:	685b      	ldr	r3, [r3, #4]
 8006f02:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8006f06:	0c1b      	lsrs	r3, r3, #16
 8006f08:	041b      	lsls	r3, r3, #16
 8006f0a:	f043 0301 	orr.w	r3, r3, #1
 8006f0e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    instance->can->sFilterRegister[0].FR1 = 0;
 8006f12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f14:	685b      	ldr	r3, [r3, #4]
 8006f16:	2200      	movs	r2, #0
 8006f18:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
    instance->can->sFilterRegister[0].FR2 = 0;
 8006f1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f1e:	685b      	ldr	r3, [r3, #4]
 8006f20:	2200      	movs	r2, #0
 8006f22:	f8c3 2244 	str.w	r2, [r3, #580]	; 0x244
    instance->can->FM1R = 0;
 8006f26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f28:	685b      	ldr	r3, [r3, #4]
 8006f2a:	2200      	movs	r2, #0
 8006f2c:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    instance->can->FFA1R = 0;
 8006f30:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f32:	685b      	ldr	r3, [r3, #4]
 8006f34:	2200      	movs	r2, #0
 8006f36:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    instance->can->FS1R = 1;
 8006f3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f3c:	685b      	ldr	r3, [r3, #4]
 8006f3e:	2201      	movs	r2, #1
 8006f40:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
    instance->can->FA1R = 1;
 8006f44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f46:	685b      	ldr	r3, [r3, #4]
 8006f48:	2201      	movs	r2, #1
 8006f4a:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c

    instance->can->FMR &= ~CAN_FMR_FINIT;
 8006f4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f50:	685b      	ldr	r3, [r3, #4]
 8006f52:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006f54:	6852      	ldr	r2, [r2, #4]
 8006f56:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
 8006f5a:	f022 0201 	bic.w	r2, r2, #1
 8006f5e:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
<<<<<<< HEAD
 8006f46:	2013      	movs	r0, #19
 8006f48:	210b      	movs	r1, #11
 8006f4a:	f002 f8b5 	bl	80090b8 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8006f4e:	2014      	movs	r0, #20
 8006f50:	210b      	movs	r1, #11
 8006f52:	f002 f8b1 	bl	80090b8 <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8006f56:	2016      	movs	r0, #22
 8006f58:	210b      	movs	r1, #11
 8006f5a:	f002 f8ad 	bl	80090b8 <nvicEnableVector>
=======
 8006f62:	2013      	movs	r0, #19
 8006f64:	210b      	movs	r1, #11
 8006f66:	f002 f8e9 	bl	800913c <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8006f6a:	2014      	movs	r0, #20
 8006f6c:	210b      	movs	r1, #11
 8006f6e:	f002 f8e5 	bl	800913c <nvicEnableVector>
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
 8006f72:	2016      	movs	r0, #22
 8006f74:	210b      	movs	r1, #11
 8006f76:	f002 f8e1 	bl	800913c <nvicEnableVector>
>>>>>>> 752c83b... update binaries

    instance->can->MCR = CAN_MCR_INRQ;
 8006f7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f7c:	685b      	ldr	r3, [r3, #4]
 8006f7e:	2201      	movs	r2, #1
 8006f80:	601a      	str	r2, [r3, #0]
 8006f82:	e000      	b.n	8006f86 <can_driver_stm32_start.lto_priv.22+0xae>
    while((instance->can->MSR & CAN_MSR_INAK) == 0) {
        __asm__("nop");
 8006f84:	bf00      	nop
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);

    instance->can->MCR = CAN_MCR_INRQ;
    while((instance->can->MSR & CAN_MSR_INAK) == 0) {
 8006f86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006f88:	685b      	ldr	r3, [r3, #4]
 8006f8a:	685b      	ldr	r3, [r3, #4]
 8006f8c:	f003 0301 	and.w	r3, r3, #1
 8006f90:	2b00      	cmp	r3, #0
 8006f92:	d0f7      	beq.n	8006f84 <can_driver_stm32_start.lto_priv.22+0xac>
    uint8_t bs1;
    uint8_t bs2;
    uint32_t prescaler;

    {
        const uint8_t max_quanta_per_bit = (baudrate >= 1000000) ? 10 : 17;
 8006f94:	687b      	ldr	r3, [r7, #4]
 8006f96:	4a5b      	ldr	r2, [pc, #364]	; (8007104 <can_driver_stm32_start.lto_priv.22+0x22c>)
 8006f98:	4293      	cmp	r3, r2
 8006f9a:	d901      	bls.n	8006fa0 <can_driver_stm32_start.lto_priv.22+0xc8>
 8006f9c:	230a      	movs	r3, #10
 8006f9e:	e000      	b.n	8006fa2 <can_driver_stm32_start.lto_priv.22+0xca>
 8006fa0:	2311      	movs	r3, #17
 8006fa2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        const uint32_t prescaler_bs = STM32_PCLK1 / baudrate;
 8006fa6:	4a58      	ldr	r2, [pc, #352]	; (8007108 <can_driver_stm32_start.lto_priv.22+0x230>)
 8006fa8:	687b      	ldr	r3, [r7, #4]
 8006faa:	fbb2 f3f3 	udiv	r3, r2, r3
 8006fae:	623b      	str	r3, [r7, #32]

        uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);
 8006fb0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8006fb4:	3b01      	subs	r3, #1
 8006fb6:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
 8006fba:	e009      	b.n	8006fd0 <can_driver_stm32_start.lto_priv.22+0xf8>

        // Search for the highest valid prescalar value
        while ((prescaler_bs % (1 + bs1_bs2_sum)) != 0) {
            if (bs1_bs2_sum <= 2) {
 8006fbc:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fc0:	2b02      	cmp	r3, #2
 8006fc2:	f240 8099 	bls.w	80070f8 <can_driver_stm32_start.lto_priv.22+0x220>
                return;
            }
            bs1_bs2_sum--;
 8006fc6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fca:	3b01      	subs	r3, #1
 8006fcc:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
        const uint32_t prescaler_bs = STM32_PCLK1 / baudrate;

        uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);

        // Search for the highest valid prescalar value
        while ((prescaler_bs % (1 + bs1_bs2_sum)) != 0) {
 8006fd0:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fd4:	3301      	adds	r3, #1
 8006fd6:	461a      	mov	r2, r3
 8006fd8:	6a3b      	ldr	r3, [r7, #32]
 8006fda:	fbb3 f1f2 	udiv	r1, r3, r2
 8006fde:	fb02 f201 	mul.w	r2, r2, r1
 8006fe2:	1a9b      	subs	r3, r3, r2
 8006fe4:	2b00      	cmp	r3, #0
 8006fe6:	d1e9      	bne.n	8006fbc <can_driver_stm32_start.lto_priv.22+0xe4>
                return;
            }
            bs1_bs2_sum--;
        }

        prescaler = prescaler_bs / (1 + bs1_bs2_sum);
 8006fe8:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8006fec:	3301      	adds	r3, #1
 8006fee:	461a      	mov	r2, r3
 8006ff0:	6a3b      	ldr	r3, [r7, #32]
 8006ff2:	fbb3 f3f2 	udiv	r3, r3, r2
 8006ff6:	61fb      	str	r3, [r7, #28]
        if (prescaler < 1 || prescaler > 1024) {
 8006ff8:	69fb      	ldr	r3, [r7, #28]
 8006ffa:	2b00      	cmp	r3, #0
 8006ffc:	d07c      	beq.n	80070f8 <can_driver_stm32_start.lto_priv.22+0x220>
 8006ffe:	69fb      	ldr	r3, [r7, #28]
 8007000:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8007004:	d878      	bhi.n	80070f8 <can_driver_stm32_start.lto_priv.22+0x220>
            return;
        }

        // The recommended sample point location is 87.5% or 7/8. Compute the values of BS1 and BS2 that satisfy BS1+BS2 == bs1_bs2_sum and minimize ((1+BS1)/(1+BS1/BS2) - 7/8)
        bs1 = ((7 * bs1_bs2_sum - 1) + 4) / 8;
 8007006:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 800700a:	4613      	mov	r3, r2
 800700c:	00db      	lsls	r3, r3, #3
 800700e:	1a9b      	subs	r3, r3, r2
 8007010:	3303      	adds	r3, #3
 8007012:	2b00      	cmp	r3, #0
 8007014:	da00      	bge.n	8007018 <can_driver_stm32_start.lto_priv.22+0x140>
 8007016:	3307      	adds	r3, #7
 8007018:	10db      	asrs	r3, r3, #3
 800701a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        // Check sample point constraints
        const uint16_t max_sample_point_per_mille = 900;
 800701e:	f44f 7361 	mov.w	r3, #900	; 0x384
 8007022:	837b      	strh	r3, [r7, #26]
        const uint16_t min_sample_point_per_mille = (baudrate >= 1000000) ? 750 : 850;
 8007024:	687b      	ldr	r3, [r7, #4]
 8007026:	4a37      	ldr	r2, [pc, #220]	; (8007104 <can_driver_stm32_start.lto_priv.22+0x22c>)
 8007028:	4293      	cmp	r3, r2
 800702a:	d902      	bls.n	8007032 <can_driver_stm32_start.lto_priv.22+0x15a>
 800702c:	f240 23ee 	movw	r3, #750	; 0x2ee
 8007030:	e001      	b.n	8007036 <can_driver_stm32_start.lto_priv.22+0x15e>
 8007032:	f240 3352 	movw	r3, #850	; 0x352
 8007036:	833b      	strh	r3, [r7, #24]

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) >= max_sample_point_per_mille) {
 8007038:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800703c:	3301      	adds	r3, #1
 800703e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8007042:	fb02 f203 	mul.w	r2, r2, r3
 8007046:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800704a:	3301      	adds	r3, #1
 800704c:	fb92 f2f3 	sdiv	r2, r2, r3
 8007050:	8b7b      	ldrh	r3, [r7, #26]
 8007052:	429a      	cmp	r2, r3
 8007054:	db04      	blt.n	8007060 <can_driver_stm32_start.lto_priv.22+0x188>
            bs1--;
 8007056:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800705a:	3b01      	subs	r3, #1
 800705c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) < min_sample_point_per_mille) {
 8007060:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007064:	3301      	adds	r3, #1
 8007066:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800706a:	fb02 f203 	mul.w	r2, r2, r3
 800706e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8007072:	3301      	adds	r3, #1
 8007074:	fb92 f2f3 	sdiv	r2, r2, r3
 8007078:	8b3b      	ldrh	r3, [r7, #24]
 800707a:	429a      	cmp	r2, r3
 800707c:	da04      	bge.n	8007088 <can_driver_stm32_start.lto_priv.22+0x1b0>
            bs1++;
 800707e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007082:	3301      	adds	r3, #1
 8007084:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        }

        if (1000 * (1 + bs1) / (1 + bs1_bs2_sum) >= max_sample_point_per_mille) {
 8007088:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800708c:	3301      	adds	r3, #1
 800708e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8007092:	fb02 f203 	mul.w	r2, r2, r3
 8007096:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 800709a:	3301      	adds	r3, #1
 800709c:	fb92 f2f3 	sdiv	r2, r2, r3
 80070a0:	8b7b      	ldrh	r3, [r7, #26]
 80070a2:	429a      	cmp	r2, r3
 80070a4:	da28      	bge.n	80070f8 <can_driver_stm32_start.lto_priv.22+0x220>
            return;
        }

        bs2 = bs1_bs2_sum-bs1;
 80070a6:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 80070aa:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80070ae:	1ad3      	subs	r3, r2, r3
 80070b0:	75fb      	strb	r3, [r7, #23]
    }

    instance->can->BTR = (silent?CAN_BTR_SILM:0) | CAN_BTR_SJW(0) | CAN_BTR_TS1(bs1-1) | CAN_BTR_TS2(bs2-1) | CAN_BTR_BRP(prescaler - 1);
 80070b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80070b4:	685b      	ldr	r3, [r3, #4]
 80070b6:	7afa      	ldrb	r2, [r7, #11]
 80070b8:	2a00      	cmp	r2, #0
 80070ba:	d002      	beq.n	80070c2 <can_driver_stm32_start.lto_priv.22+0x1ea>
 80070bc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80070c0:	e000      	b.n	80070c4 <can_driver_stm32_start.lto_priv.22+0x1ec>
 80070c2:	2200      	movs	r2, #0
 80070c4:	f897 102f 	ldrb.w	r1, [r7, #47]	; 0x2f
 80070c8:	3901      	subs	r1, #1
 80070ca:	0409      	lsls	r1, r1, #16
 80070cc:	430a      	orrs	r2, r1
 80070ce:	7df9      	ldrb	r1, [r7, #23]
 80070d0:	3901      	subs	r1, #1
 80070d2:	0509      	lsls	r1, r1, #20
 80070d4:	4311      	orrs	r1, r2
 80070d6:	69fa      	ldr	r2, [r7, #28]
 80070d8:	3a01      	subs	r2, #1
 80070da:	430a      	orrs	r2, r1
 80070dc:	61da      	str	r2, [r3, #28]

    instance->can->MCR = CAN_MCR_ABOM | CAN_MCR_AWUM | (auto_retransmit?0:CAN_MCR_NART);
 80070de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80070e0:	685b      	ldr	r3, [r3, #4]
 80070e2:	7aba      	ldrb	r2, [r7, #10]
 80070e4:	2a00      	cmp	r2, #0
 80070e6:	d001      	beq.n	80070ec <can_driver_stm32_start.lto_priv.22+0x214>
 80070e8:	2260      	movs	r2, #96	; 0x60
 80070ea:	e000      	b.n	80070ee <can_driver_stm32_start.lto_priv.22+0x216>
 80070ec:	2270      	movs	r2, #112	; 0x70
 80070ee:	601a      	str	r2, [r3, #0]

    instance->can->IER = CAN_IER_TMEIE | CAN_IER_FMPIE0; // TODO: review reference manual for other interrupt flags needed
 80070f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80070f2:	685b      	ldr	r3, [r3, #4]
 80070f4:	2203      	movs	r2, #3
 80070f6:	615a      	str	r2, [r3, #20]
}
 80070f8:	3730      	adds	r7, #48	; 0x30
 80070fa:	46bd      	mov	sp, r7
 80070fc:	bd80      	pop	{r7, pc}
 80070fe:	bf00      	nop
 8007100:	40021000 	.word	0x40021000
 8007104:	000f423f 	.word	0x000f423f
 8007108:	02255100 	.word	0x02255100

0800710c <can_driver_stm32_stop.lto_priv.23>:

static void can_driver_stm32_stop(void* ctx) {
 800710c:	b580      	push	{r7, lr}
 800710e:	b084      	sub	sp, #16
 8007110:	af00      	add	r7, sp, #0
 8007112:	6078      	str	r0, [r7, #4]
    struct can_driver_stm32_instance_s* instance = ctx;
 8007114:	687b      	ldr	r3, [r7, #4]
 8007116:	60fb      	str	r3, [r7, #12]

    instance->can->MCR = 0x00010002;
 8007118:	68fb      	ldr	r3, [r7, #12]
 800711a:	685b      	ldr	r3, [r3, #4]
 800711c:	4a0b      	ldr	r2, [pc, #44]	; (800714c <can_driver_stm32_stop.lto_priv.23+0x40>)
 800711e:	601a      	str	r2, [r3, #0]
    instance->can->IER = 0x00000000;
 8007120:	68fb      	ldr	r3, [r7, #12]
 8007122:	685b      	ldr	r3, [r3, #4]
 8007124:	2200      	movs	r2, #0
 8007126:	615a      	str	r2, [r3, #20]

    nvicDisableVector(STM32_CAN1_TX_NUMBER);
<<<<<<< HEAD
 800710c:	2013      	movs	r0, #19
 800710e:	f002 f801 	bl	8009114 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_RX0_NUMBER);
 8007112:	2014      	movs	r0, #20
 8007114:	f001 fffe 	bl	8009114 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_SCE_NUMBER);
 8007118:	2016      	movs	r0, #22
 800711a:	f001 fffb 	bl	8009114 <nvicDisableVector>
=======
 8007128:	2013      	movs	r0, #19
 800712a:	f002 f835 	bl	8009198 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_RX0_NUMBER);
 800712e:	2014      	movs	r0, #20
 8007130:	f002 f832 	bl	8009198 <nvicDisableVector>
    nvicDisableVector(STM32_CAN1_SCE_NUMBER);
 8007134:	2016      	movs	r0, #22
 8007136:	f002 f82f 	bl	8009198 <nvicDisableVector>
>>>>>>> 752c83b... update binaries

    rccDisableCAN1(FALSE);
 800713a:	4a05      	ldr	r2, [pc, #20]	; (8007150 <can_driver_stm32_stop.lto_priv.23+0x44>)
 800713c:	4b04      	ldr	r3, [pc, #16]	; (8007150 <can_driver_stm32_stop.lto_priv.23+0x44>)
 800713e:	69db      	ldr	r3, [r3, #28]
 8007140:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8007144:	61d3      	str	r3, [r2, #28]
}
 8007146:	3710      	adds	r7, #16
 8007148:	46bd      	mov	sp, r7
 800714a:	bd80      	pop	{r7, pc}
 800714c:	00010002 	.word	0x00010002
 8007150:	40021000 	.word	0x40021000

08007154 <can_driver_stm32_abort_tx_mailbox_I>:

bool can_driver_stm32_abort_tx_mailbox_I(void* ctx, uint8_t mb_idx) {
 8007154:	b580      	push	{r7, lr}
 8007156:	b084      	sub	sp, #16
 8007158:	af00      	add	r7, sp, #0
 800715a:	6078      	str	r0, [r7, #4]
 800715c:	460b      	mov	r3, r1
 800715e:	70fb      	strb	r3, [r7, #3]
    struct can_driver_stm32_instance_s* instance = ctx;
 8007160:	687b      	ldr	r3, [r7, #4]
 8007162:	60fb      	str	r3, [r7, #12]

    chDbgCheckClassI();
<<<<<<< HEAD
 8007148:	f003 ff0a 	bl	800af60 <chDbgCheckClassI>
=======
 8007164:	f003 ff40 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    switch(mb_idx) {
 8007168:	78fb      	ldrb	r3, [r7, #3]
 800716a:	2b01      	cmp	r3, #1
 800716c:	d009      	beq.n	8007182 <can_driver_stm32_abort_tx_mailbox_I+0x2e>
 800716e:	2b02      	cmp	r3, #2
 8007170:	d00e      	beq.n	8007190 <can_driver_stm32_abort_tx_mailbox_I+0x3c>
 8007172:	2b00      	cmp	r3, #0
 8007174:	d113      	bne.n	800719e <can_driver_stm32_abort_tx_mailbox_I+0x4a>
        case 0:
            instance->can->TSR = CAN_TSR_ABRQ0;
 8007176:	68fb      	ldr	r3, [r7, #12]
 8007178:	685b      	ldr	r3, [r3, #4]
 800717a:	2280      	movs	r2, #128	; 0x80
 800717c:	609a      	str	r2, [r3, #8]
            return true;
 800717e:	2301      	movs	r3, #1
 8007180:	e00e      	b.n	80071a0 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
        case 1:
            instance->can->TSR = CAN_TSR_ABRQ1;
 8007182:	68fb      	ldr	r3, [r7, #12]
 8007184:	685b      	ldr	r3, [r3, #4]
 8007186:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800718a:	609a      	str	r2, [r3, #8]
            return true;
 800718c:	2301      	movs	r3, #1
 800718e:	e007      	b.n	80071a0 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
        case 2:
            instance->can->TSR = CAN_TSR_ABRQ2;
 8007190:	68fb      	ldr	r3, [r7, #12]
 8007192:	685b      	ldr	r3, [r3, #4]
 8007194:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8007198:	609a      	str	r2, [r3, #8]
            return true;
 800719a:	2301      	movs	r3, #1
 800719c:	e000      	b.n	80071a0 <can_driver_stm32_abort_tx_mailbox_I+0x4c>
    }
    return false;
 800719e:	2300      	movs	r3, #0
}
 80071a0:	4618      	mov	r0, r3
 80071a2:	3710      	adds	r7, #16
 80071a4:	46bd      	mov	sp, r7
 80071a6:	bd80      	pop	{r7, pc}

080071a8 <can_driver_stm32_load_tx_mailbox_I>:

bool can_driver_stm32_load_tx_mailbox_I(void* ctx, uint8_t mb_idx, struct can_frame_s* frame) {
 80071a8:	b580      	push	{r7, lr}
 80071aa:	b086      	sub	sp, #24
 80071ac:	af00      	add	r7, sp, #0
 80071ae:	60f8      	str	r0, [r7, #12]
 80071b0:	460b      	mov	r3, r1
 80071b2:	607a      	str	r2, [r7, #4]
 80071b4:	72fb      	strb	r3, [r7, #11]
    struct can_driver_stm32_instance_s* instance = ctx;
 80071b6:	68fb      	ldr	r3, [r7, #12]
 80071b8:	617b      	str	r3, [r7, #20]

    chDbgCheckClassI();
<<<<<<< HEAD
 800719e:	f003 fedf 	bl	800af60 <chDbgCheckClassI>
=======
 80071ba:	f003 ff15 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    CAN_TxMailBox_TypeDef* mailbox = &instance->can->sTxMailBox[mb_idx];
 80071be:	697b      	ldr	r3, [r7, #20]
 80071c0:	685a      	ldr	r2, [r3, #4]
 80071c2:	7afb      	ldrb	r3, [r7, #11]
 80071c4:	3318      	adds	r3, #24
 80071c6:	011b      	lsls	r3, r3, #4
 80071c8:	4413      	add	r3, r2
 80071ca:	613b      	str	r3, [r7, #16]

    mailbox->TDTR = frame->DLC;
 80071cc:	687b      	ldr	r3, [r7, #4]
 80071ce:	781b      	ldrb	r3, [r3, #0]
 80071d0:	f3c3 0383 	ubfx	r3, r3, #2, #4
 80071d4:	b2db      	uxtb	r3, r3
 80071d6:	461a      	mov	r2, r3
 80071d8:	693b      	ldr	r3, [r7, #16]
 80071da:	605a      	str	r2, [r3, #4]
    mailbox->TDLR = frame->data32[0];
 80071dc:	687b      	ldr	r3, [r7, #4]
 80071de:	689a      	ldr	r2, [r3, #8]
 80071e0:	693b      	ldr	r3, [r7, #16]
 80071e2:	609a      	str	r2, [r3, #8]
    mailbox->TDHR = frame->data32[1];
 80071e4:	687b      	ldr	r3, [r7, #4]
 80071e6:	68da      	ldr	r2, [r3, #12]
 80071e8:	693b      	ldr	r3, [r7, #16]
 80071ea:	60da      	str	r2, [r3, #12]

    if (frame->IDE) {
 80071ec:	687b      	ldr	r3, [r7, #4]
 80071ee:	781b      	ldrb	r3, [r3, #0]
 80071f0:	f003 0302 	and.w	r3, r3, #2
 80071f4:	b2db      	uxtb	r3, r3
 80071f6:	2b00      	cmp	r3, #0
 80071f8:	d014      	beq.n	8007224 <can_driver_stm32_load_tx_mailbox_I+0x7c>
        mailbox->TIR = ((uint32_t)frame->EID << 3) | (frame->RTR ? CAN_TI0R_RTR : 0) | CAN_TI0R_IDE | CAN_TI0R_TXRQ;
 80071fa:	687b      	ldr	r3, [r7, #4]
 80071fc:	685b      	ldr	r3, [r3, #4]
 80071fe:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8007202:	00da      	lsls	r2, r3, #3
 8007204:	687b      	ldr	r3, [r7, #4]
 8007206:	781b      	ldrb	r3, [r3, #0]
 8007208:	f003 0301 	and.w	r3, r3, #1
 800720c:	b2db      	uxtb	r3, r3
 800720e:	2b00      	cmp	r3, #0
 8007210:	d001      	beq.n	8007216 <can_driver_stm32_load_tx_mailbox_I+0x6e>
 8007212:	2302      	movs	r3, #2
 8007214:	e000      	b.n	8007218 <can_driver_stm32_load_tx_mailbox_I+0x70>
 8007216:	2300      	movs	r3, #0
 8007218:	4313      	orrs	r3, r2
 800721a:	f043 0205 	orr.w	r2, r3, #5
 800721e:	693b      	ldr	r3, [r7, #16]
 8007220:	601a      	str	r2, [r3, #0]
 8007222:	e014      	b.n	800724e <can_driver_stm32_load_tx_mailbox_I+0xa6>
    } else {
        mailbox->TIR = ((uint32_t)frame->SID << 21) | (frame->RTR ? CAN_TI0R_RTR : 0) | CAN_TI0R_TXRQ;
 8007224:	687b      	ldr	r3, [r7, #4]
 8007226:	889b      	ldrh	r3, [r3, #4]
 8007228:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800722c:	b29b      	uxth	r3, r3
 800722e:	055a      	lsls	r2, r3, #21
 8007230:	687b      	ldr	r3, [r7, #4]
 8007232:	781b      	ldrb	r3, [r3, #0]
 8007234:	f003 0301 	and.w	r3, r3, #1
 8007238:	b2db      	uxtb	r3, r3
 800723a:	2b00      	cmp	r3, #0
 800723c:	d001      	beq.n	8007242 <can_driver_stm32_load_tx_mailbox_I+0x9a>
 800723e:	2302      	movs	r3, #2
 8007240:	e000      	b.n	8007244 <can_driver_stm32_load_tx_mailbox_I+0x9c>
 8007242:	2300      	movs	r3, #0
 8007244:	4313      	orrs	r3, r2
 8007246:	f043 0201 	orr.w	r2, r3, #1
 800724a:	693b      	ldr	r3, [r7, #16]
 800724c:	601a      	str	r2, [r3, #0]
    }

    return true;
 800724e:	2301      	movs	r3, #1
}
 8007250:	4618      	mov	r0, r3
 8007252:	3718      	adds	r7, #24
 8007254:	46bd      	mov	sp, r7
 8007256:	bd80      	pop	{r7, pc}

08007258 <can_driver_stm32_retreive_rx_frame_I>:

static void can_driver_stm32_retreive_rx_frame_I(struct can_frame_s* frame, CAN_FIFOMailBox_TypeDef* mailbox) {
 8007258:	b480      	push	{r7}
 800725a:	b083      	sub	sp, #12
 800725c:	af00      	add	r7, sp, #0
 800725e:	6078      	str	r0, [r7, #4]
 8007260:	6039      	str	r1, [r7, #0]
    frame->data32[0] = mailbox->RDLR;
 8007262:	683b      	ldr	r3, [r7, #0]
 8007264:	689a      	ldr	r2, [r3, #8]
 8007266:	687b      	ldr	r3, [r7, #4]
 8007268:	609a      	str	r2, [r3, #8]
    frame->data32[1] = mailbox->RDHR;
 800726a:	683b      	ldr	r3, [r7, #0]
 800726c:	68da      	ldr	r2, [r3, #12]
 800726e:	687b      	ldr	r3, [r7, #4]
 8007270:	60da      	str	r2, [r3, #12]
    frame->RTR = (mailbox->RIR & CAN_RI0R_RTR) != 0;
 8007272:	683b      	ldr	r3, [r7, #0]
 8007274:	681b      	ldr	r3, [r3, #0]
 8007276:	f003 0302 	and.w	r3, r3, #2
 800727a:	2b00      	cmp	r3, #0
 800727c:	bf14      	ite	ne
 800727e:	2301      	movne	r3, #1
 8007280:	2300      	moveq	r3, #0
 8007282:	b2d9      	uxtb	r1, r3
 8007284:	687a      	ldr	r2, [r7, #4]
 8007286:	7813      	ldrb	r3, [r2, #0]
 8007288:	f361 0300 	bfi	r3, r1, #0, #1
 800728c:	7013      	strb	r3, [r2, #0]
    frame->IDE = (mailbox->RIR & CAN_RI0R_IDE) != 0;
 800728e:	683b      	ldr	r3, [r7, #0]
 8007290:	681b      	ldr	r3, [r3, #0]
 8007292:	f003 0304 	and.w	r3, r3, #4
 8007296:	2b00      	cmp	r3, #0
 8007298:	bf14      	ite	ne
 800729a:	2301      	movne	r3, #1
 800729c:	2300      	moveq	r3, #0
 800729e:	b2d9      	uxtb	r1, r3
 80072a0:	687a      	ldr	r2, [r7, #4]
 80072a2:	7813      	ldrb	r3, [r2, #0]
 80072a4:	f361 0341 	bfi	r3, r1, #1, #1
 80072a8:	7013      	strb	r3, [r2, #0]
    if (frame->IDE) {
 80072aa:	687b      	ldr	r3, [r7, #4]
 80072ac:	781b      	ldrb	r3, [r3, #0]
 80072ae:	f003 0302 	and.w	r3, r3, #2
 80072b2:	b2db      	uxtb	r3, r3
 80072b4:	2b00      	cmp	r3, #0
 80072b6:	d00a      	beq.n	80072ce <can_driver_stm32_retreive_rx_frame_I+0x76>
        frame->EID = (mailbox->RIR & (CAN_RI0R_STID|CAN_RI0R_EXID)) >> 3;
 80072b8:	683b      	ldr	r3, [r7, #0]
 80072ba:	681b      	ldr	r3, [r3, #0]
 80072bc:	08db      	lsrs	r3, r3, #3
 80072be:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 80072c2:	687a      	ldr	r2, [r7, #4]
 80072c4:	6853      	ldr	r3, [r2, #4]
 80072c6:	f361 031c 	bfi	r3, r1, #0, #29
 80072ca:	6053      	str	r3, [r2, #4]
 80072cc:	e00b      	b.n	80072e6 <can_driver_stm32_retreive_rx_frame_I+0x8e>
    } else {
        frame->SID = (mailbox->RIR & CAN_RI0R_STID) >> 21;
 80072ce:	683b      	ldr	r3, [r7, #0]
 80072d0:	681b      	ldr	r3, [r3, #0]
 80072d2:	0d5b      	lsrs	r3, r3, #21
 80072d4:	b29b      	uxth	r3, r3
 80072d6:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80072da:	b299      	uxth	r1, r3
 80072dc:	687a      	ldr	r2, [r7, #4]
 80072de:	8893      	ldrh	r3, [r2, #4]
 80072e0:	f361 030a 	bfi	r3, r1, #0, #11
 80072e4:	8093      	strh	r3, [r2, #4]
    }
    frame->DLC = mailbox->RDTR & CAN_RDT0R_DLC;
 80072e6:	683b      	ldr	r3, [r7, #0]
 80072e8:	685b      	ldr	r3, [r3, #4]
 80072ea:	b2db      	uxtb	r3, r3
 80072ec:	f003 030f 	and.w	r3, r3, #15
 80072f0:	b2d9      	uxtb	r1, r3
 80072f2:	687a      	ldr	r2, [r7, #4]
 80072f4:	7813      	ldrb	r3, [r2, #0]
 80072f6:	f361 0385 	bfi	r3, r1, #2, #4
 80072fa:	7013      	strb	r3, [r2, #0]
}
 80072fc:	370c      	adds	r7, #12
 80072fe:	46bd      	mov	sp, r7
 8007300:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007304:	4770      	bx	lr
 8007306:	bf00      	nop

08007308 <stm32_can_rx_handler>:

static void stm32_can_rx_handler(struct can_driver_stm32_instance_s* instance) {
 8007308:	b580      	push	{r7, lr}
 800730a:	b08c      	sub	sp, #48	; 0x30
 800730c:	af00      	add	r7, sp, #0
 800730e:	6078      	str	r0, [r7, #4]
    systime_t rx_systime = chVTGetSystemTimeX();
 8007310:	f7ff fdbe 	bl	8006e90 <chVTGetSystemTimeX.lto_priv.116>
 8007314:	4603      	mov	r3, r0
 8007316:	85fb      	strh	r3, [r7, #46]	; 0x2e
    while (true) {
        chSysLockFromISR();
 8007318:	f7ff fdaa 	bl	8006e70 <chSysLockFromISR>
        if ((instance->can->RF0R & CAN_RF0R_FMP0) == 0) {
 800731c:	687b      	ldr	r3, [r7, #4]
 800731e:	685b      	ldr	r3, [r3, #4]
 8007320:	68db      	ldr	r3, [r3, #12]
 8007322:	f003 0303 	and.w	r3, r3, #3
 8007326:	2b00      	cmp	r3, #0
 8007328:	d102      	bne.n	8007330 <stm32_can_rx_handler+0x28>
            chSysUnlockFromISR();
 800732a:	f7ff fda9 	bl	8006e80 <chSysUnlockFromISR>
 800732e:	e019      	b.n	8007364 <stm32_can_rx_handler+0x5c>
            break;
        }
        struct can_frame_s frame;
        can_driver_stm32_retreive_rx_frame_I(&frame, &instance->can->sFIFOMailBox[0]);
 8007330:	687b      	ldr	r3, [r7, #4]
 8007332:	685b      	ldr	r3, [r3, #4]
 8007334:	f503 73d8 	add.w	r3, r3, #432	; 0x1b0
 8007338:	f107 020c 	add.w	r2, r7, #12
 800733c:	4610      	mov	r0, r2
 800733e:	4619      	mov	r1, r3
 8007340:	f7ff ff8a 	bl	8007258 <can_driver_stm32_retreive_rx_frame_I>
        can_driver_rx_frame_received_I(instance->frontend, 0, rx_systime, &frame);
 8007344:	687b      	ldr	r3, [r7, #4]
 8007346:	6819      	ldr	r1, [r3, #0]
 8007348:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800734a:	f107 030c 	add.w	r3, r7, #12
 800734e:	4608      	mov	r0, r1
 8007350:	2100      	movs	r1, #0
 8007352:	f7fe fe77 	bl	8006044 <can_driver_rx_frame_received_I>
        instance->can->RF0R = CAN_RF0R_RFOM0;
 8007356:	687b      	ldr	r3, [r7, #4]
 8007358:	685b      	ldr	r3, [r3, #4]
 800735a:	2220      	movs	r2, #32
 800735c:	60da      	str	r2, [r3, #12]
        chSysUnlockFromISR();
 800735e:	f7ff fd8f 	bl	8006e80 <chSysUnlockFromISR>
 8007362:	e7d9      	b.n	8007318 <stm32_can_rx_handler+0x10>
    }

    while (true) {
        chSysLockFromISR();
 8007364:	f7ff fd84 	bl	8006e70 <chSysLockFromISR>
        if ((instance->can->RF1R & CAN_RF1R_FMP1) == 0) {
 8007368:	687b      	ldr	r3, [r7, #4]
 800736a:	685b      	ldr	r3, [r3, #4]
 800736c:	691b      	ldr	r3, [r3, #16]
 800736e:	f003 0303 	and.w	r3, r3, #3
 8007372:	2b00      	cmp	r3, #0
 8007374:	d102      	bne.n	800737c <stm32_can_rx_handler+0x74>
            chSysUnlockFromISR();
 8007376:	f7ff fd83 	bl	8006e80 <chSysUnlockFromISR>
 800737a:	e019      	b.n	80073b0 <stm32_can_rx_handler+0xa8>
            break;
        }
        struct can_frame_s frame;
        can_driver_stm32_retreive_rx_frame_I(&frame, &instance->can->sFIFOMailBox[1]);
 800737c:	687b      	ldr	r3, [r7, #4]
 800737e:	685b      	ldr	r3, [r3, #4]
 8007380:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
 8007384:	f107 021c 	add.w	r2, r7, #28
 8007388:	4610      	mov	r0, r2
 800738a:	4619      	mov	r1, r3
 800738c:	f7ff ff64 	bl	8007258 <can_driver_stm32_retreive_rx_frame_I>
        can_driver_rx_frame_received_I(instance->frontend, 1, rx_systime, &frame);
 8007390:	687b      	ldr	r3, [r7, #4]
 8007392:	6819      	ldr	r1, [r3, #0]
 8007394:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 8007396:	f107 031c 	add.w	r3, r7, #28
 800739a:	4608      	mov	r0, r1
 800739c:	2101      	movs	r1, #1
 800739e:	f7fe fe51 	bl	8006044 <can_driver_rx_frame_received_I>
        instance->can->RF1R = CAN_RF1R_RFOM1;
 80073a2:	687b      	ldr	r3, [r7, #4]
 80073a4:	685b      	ldr	r3, [r3, #4]
 80073a6:	2220      	movs	r2, #32
 80073a8:	611a      	str	r2, [r3, #16]
        chSysUnlockFromISR();
 80073aa:	f7ff fd69 	bl	8006e80 <chSysUnlockFromISR>
 80073ae:	e7d9      	b.n	8007364 <stm32_can_rx_handler+0x5c>
    }
}
 80073b0:	3730      	adds	r7, #48	; 0x30
 80073b2:	46bd      	mov	sp, r7
 80073b4:	bd80      	pop	{r7, pc}
 80073b6:	bf00      	nop

080073b8 <stm32_can_tx_handler>:

static void stm32_can_tx_handler(struct can_driver_stm32_instance_s* instance) {
 80073b8:	b580      	push	{r7, lr}
 80073ba:	b084      	sub	sp, #16
 80073bc:	af00      	add	r7, sp, #0
 80073be:	6078      	str	r0, [r7, #4]
    systime_t t_now = chVTGetSystemTimeX();
 80073c0:	f7ff fd66 	bl	8006e90 <chVTGetSystemTimeX.lto_priv.116>
 80073c4:	4603      	mov	r3, r0
 80073c6:	81fb      	strh	r3, [r7, #14]

    chSysLockFromISR();
 80073c8:	f7ff fd52 	bl	8006e70 <chSysLockFromISR>
    if ((instance->can->TSR & CAN_TSR_RQCP0) != 0) {
 80073cc:	687b      	ldr	r3, [r7, #4]
 80073ce:	685b      	ldr	r3, [r3, #4]
 80073d0:	689b      	ldr	r3, [r3, #8]
 80073d2:	f003 0301 	and.w	r3, r3, #1
 80073d6:	2b00      	cmp	r3, #0
 80073d8:	d014      	beq.n	8007404 <stm32_can_tx_handler+0x4c>
        can_driver_tx_request_complete_I(instance->frontend, 0, (instance->can->TSR & CAN_TSR_TXOK0) != 0, t_now);
 80073da:	687b      	ldr	r3, [r7, #4]
 80073dc:	6819      	ldr	r1, [r3, #0]
 80073de:	687b      	ldr	r3, [r7, #4]
 80073e0:	685b      	ldr	r3, [r3, #4]
 80073e2:	689b      	ldr	r3, [r3, #8]
 80073e4:	f003 0302 	and.w	r3, r3, #2
 80073e8:	2b00      	cmp	r3, #0
 80073ea:	bf14      	ite	ne
 80073ec:	2301      	movne	r3, #1
 80073ee:	2300      	moveq	r3, #0
 80073f0:	b2da      	uxtb	r2, r3
 80073f2:	89fb      	ldrh	r3, [r7, #14]
 80073f4:	4608      	mov	r0, r1
 80073f6:	2100      	movs	r1, #0
 80073f8:	f7fe fdce 	bl	8005f98 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP0;
 80073fc:	687b      	ldr	r3, [r7, #4]
 80073fe:	685b      	ldr	r3, [r3, #4]
 8007400:	2201      	movs	r2, #1
 8007402:	609a      	str	r2, [r3, #8]
    }

    if ((instance->can->TSR & CAN_TSR_RQCP1) != 0) {
 8007404:	687b      	ldr	r3, [r7, #4]
 8007406:	685b      	ldr	r3, [r3, #4]
 8007408:	689b      	ldr	r3, [r3, #8]
 800740a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800740e:	2b00      	cmp	r3, #0
 8007410:	d015      	beq.n	800743e <stm32_can_tx_handler+0x86>
        can_driver_tx_request_complete_I(instance->frontend, 1, (instance->can->TSR & CAN_TSR_TXOK1) != 0, t_now);
 8007412:	687b      	ldr	r3, [r7, #4]
 8007414:	6819      	ldr	r1, [r3, #0]
 8007416:	687b      	ldr	r3, [r7, #4]
 8007418:	685b      	ldr	r3, [r3, #4]
 800741a:	689b      	ldr	r3, [r3, #8]
 800741c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8007420:	2b00      	cmp	r3, #0
 8007422:	bf14      	ite	ne
 8007424:	2301      	movne	r3, #1
 8007426:	2300      	moveq	r3, #0
 8007428:	b2da      	uxtb	r2, r3
 800742a:	89fb      	ldrh	r3, [r7, #14]
 800742c:	4608      	mov	r0, r1
 800742e:	2101      	movs	r1, #1
 8007430:	f7fe fdb2 	bl	8005f98 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP1;
 8007434:	687b      	ldr	r3, [r7, #4]
 8007436:	685b      	ldr	r3, [r3, #4]
 8007438:	f44f 7280 	mov.w	r2, #256	; 0x100
 800743c:	609a      	str	r2, [r3, #8]
    }

    if ((instance->can->TSR & CAN_TSR_RQCP2) != 0) {
 800743e:	687b      	ldr	r3, [r7, #4]
 8007440:	685b      	ldr	r3, [r3, #4]
 8007442:	689b      	ldr	r3, [r3, #8]
 8007444:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8007448:	2b00      	cmp	r3, #0
 800744a:	d015      	beq.n	8007478 <stm32_can_tx_handler+0xc0>
        can_driver_tx_request_complete_I(instance->frontend, 2, (instance->can->TSR & CAN_TSR_TXOK2) != 0, t_now);
 800744c:	687b      	ldr	r3, [r7, #4]
 800744e:	6819      	ldr	r1, [r3, #0]
 8007450:	687b      	ldr	r3, [r7, #4]
 8007452:	685b      	ldr	r3, [r3, #4]
 8007454:	689b      	ldr	r3, [r3, #8]
 8007456:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800745a:	2b00      	cmp	r3, #0
 800745c:	bf14      	ite	ne
 800745e:	2301      	movne	r3, #1
 8007460:	2300      	moveq	r3, #0
 8007462:	b2da      	uxtb	r2, r3
 8007464:	89fb      	ldrh	r3, [r7, #14]
 8007466:	4608      	mov	r0, r1
 8007468:	2102      	movs	r1, #2
 800746a:	f7fe fd95 	bl	8005f98 <can_driver_tx_request_complete_I>
        instance->can->TSR = CAN_TSR_RQCP2;
 800746e:	687b      	ldr	r3, [r7, #4]
 8007470:	685b      	ldr	r3, [r3, #4]
 8007472:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8007476:	609a      	str	r2, [r3, #8]
    }
    chSysUnlockFromISR();
 8007478:	f7ff fd02 	bl	8006e80 <chSysUnlockFromISR>
}
 800747c:	3710      	adds	r7, #16
 800747e:	46bd      	mov	sp, r7
 8007480:	bd80      	pop	{r7, pc}
 8007482:	bf00      	nop

08007484 <Vector8C>:

OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 8007484:	b580      	push	{r7, lr}
 8007486:	af00      	add	r7, sp, #0
    OSAL_IRQ_PROLOGUE();
<<<<<<< HEAD
 800746c:	f003 fd40 	bl	800aef0 <_dbg_check_enter_isr>
=======
 8007488:	f003 fd76 	bl	800af78 <_dbg_check_enter_isr>
>>>>>>> 752c83b... update binaries

    stm32_can_tx_handler(&can1_instance);
 800748c:	4803      	ldr	r0, [pc, #12]	; (800749c <Vector8C+0x18>)
 800748e:	f7ff ff93 	bl	80073b8 <stm32_can_tx_handler>

    OSAL_IRQ_EPILOGUE();
<<<<<<< HEAD
 8007476:	f003 fd57 	bl	800af28 <_dbg_check_leave_isr>
 800747a:	f002 fc79 	bl	8009d70 <_port_irq_epilogue>
=======
 8007492:	f003 fd8d 	bl	800afb0 <_dbg_check_leave_isr>
 8007496:	f002 fcaf 	bl	8009df8 <_port_irq_epilogue>
>>>>>>> 752c83b... update binaries
}
 800749a:	bd80      	pop	{r7, pc}
 800749c:	20001468 	.word	0x20001468

080074a0 <Vector90>:

OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 80074a0:	b580      	push	{r7, lr}
 80074a2:	af00      	add	r7, sp, #0
    OSAL_IRQ_PROLOGUE();
<<<<<<< HEAD
 8007488:	f003 fd32 	bl	800aef0 <_dbg_check_enter_isr>
=======
 80074a4:	f003 fd68 	bl	800af78 <_dbg_check_enter_isr>
>>>>>>> 752c83b... update binaries

    stm32_can_rx_handler(&can1_instance);
 80074a8:	4803      	ldr	r0, [pc, #12]	; (80074b8 <Vector90+0x18>)
 80074aa:	f7ff ff2d 	bl	8007308 <stm32_can_rx_handler>

    OSAL_IRQ_EPILOGUE();
<<<<<<< HEAD
 8007492:	f003 fd49 	bl	800af28 <_dbg_check_leave_isr>
 8007496:	f002 fc6b 	bl	8009d70 <_port_irq_epilogue>
=======
 80074ae:	f003 fd7f 	bl	800afb0 <_dbg_check_leave_isr>
 80074b2:	f002 fca1 	bl	8009df8 <_port_irq_epilogue>
>>>>>>> 752c83b... update binaries
}
 80074b6:	bd80      	pop	{r7, pc}
 80074b8:	20001468 	.word	0x20001468

080074bc <port_lock.lto_priv.114>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80074bc:	b480      	push	{r7}
 80074be:	b083      	sub	sp, #12
 80074c0:	af00      	add	r7, sp, #0
 80074c2:	2320      	movs	r3, #32
 80074c4:	607b      	str	r3, [r7, #4]
 80074c6:	687b      	ldr	r3, [r7, #4]
 80074c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80074cc:	370c      	adds	r7, #12
 80074ce:	46bd      	mov	sp, r7
 80074d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074d4:	4770      	bx	lr
 80074d6:	bf00      	nop

080074d8 <port_unlock.lto_priv.111>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80074d8:	b480      	push	{r7}
 80074da:	b083      	sub	sp, #12
 80074dc:	af00      	add	r7, sp, #0
 80074de:	2300      	movs	r3, #0
 80074e0:	607b      	str	r3, [r7, #4]
 80074e2:	687b      	ldr	r3, [r7, #4]
 80074e4:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80074e8:	370c      	adds	r7, #12
 80074ea:	46bd      	mov	sp, r7
 80074ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074f0:	4770      	bx	lr
 80074f2:	bf00      	nop

080074f4 <chSysLock.lto_priv.125>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80074f4:	b580      	push	{r7, lr}
 80074f6:	af00      	add	r7, sp, #0

  port_lock();
 80074f8:	f7ff ffe0 	bl	80074bc <port_lock.lto_priv.114>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
<<<<<<< HEAD
 80074e0:	f003 fcae 	bl	800ae40 <_dbg_check_lock>
=======
 80074fc:	f003 fce4 	bl	800aec8 <_dbg_check_lock>
>>>>>>> 752c83b... update binaries
}
 8007500:	bd80      	pop	{r7, pc}
 8007502:	bf00      	nop

08007504 <chSysUnlock.lto_priv.123>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007504:	b580      	push	{r7, lr}
 8007506:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
<<<<<<< HEAD
 80074ec:	f003 fcbe 	bl	800ae6c <_dbg_check_unlock>
=======
 8007508:	f003 fcf4 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 80074f0:	4b09      	ldr	r3, [pc, #36]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 80074f2:	681b      	ldr	r3, [r3, #0]
 80074f4:	4a08      	ldr	r2, [pc, #32]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 80074f6:	4293      	cmp	r3, r2
 80074f8:	d00a      	beq.n	8007510 <chSysUnlock.lto_priv.124+0x28>
 80074fa:	4b07      	ldr	r3, [pc, #28]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 80074fc:	699b      	ldr	r3, [r3, #24]
 80074fe:	689a      	ldr	r2, [r3, #8]
 8007500:	4b05      	ldr	r3, [pc, #20]	; (8007518 <chSysUnlock.lto_priv.124+0x30>)
 8007502:	681b      	ldr	r3, [r3, #0]
 8007504:	689b      	ldr	r3, [r3, #8]
 8007506:	429a      	cmp	r2, r3
 8007508:	d202      	bcs.n	8007510 <chSysUnlock.lto_priv.124+0x28>
 800750a:	4804      	ldr	r0, [pc, #16]	; (800751c <chSysUnlock.lto_priv.124+0x34>)
 800750c:	f003 fc4a 	bl	800ada4 <chSysHalt>
=======
 800750c:	4b09      	ldr	r3, [pc, #36]	; (8007534 <chSysUnlock.lto_priv.123+0x30>)
 800750e:	681b      	ldr	r3, [r3, #0]
 8007510:	4a08      	ldr	r2, [pc, #32]	; (8007534 <chSysUnlock.lto_priv.123+0x30>)
 8007512:	4293      	cmp	r3, r2
 8007514:	d00a      	beq.n	800752c <chSysUnlock.lto_priv.123+0x28>
 8007516:	4b07      	ldr	r3, [pc, #28]	; (8007534 <chSysUnlock.lto_priv.123+0x30>)
 8007518:	699b      	ldr	r3, [r3, #24]
 800751a:	689a      	ldr	r2, [r3, #8]
 800751c:	4b05      	ldr	r3, [pc, #20]	; (8007534 <chSysUnlock.lto_priv.123+0x30>)
 800751e:	681b      	ldr	r3, [r3, #0]
 8007520:	689b      	ldr	r3, [r3, #8]
 8007522:	429a      	cmp	r2, r3
 8007524:	d202      	bcs.n	800752c <chSysUnlock.lto_priv.123+0x28>
 8007526:	4804      	ldr	r0, [pc, #16]	; (8007538 <chSysUnlock.lto_priv.123+0x34>)
 8007528:	f003 fc80 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800752c:	f7ff ffd4 	bl	80074d8 <port_unlock.lto_priv.111>
}
 8007530:	bd80      	pop	{r7, pc}
 8007532:	bf00      	nop
 8007534:	20001338 	.word	0x20001338
 8007538:	0800ed08 	.word	0x0800ed08

0800753c <can_tx_queue_init>:

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame);
#endif

bool can_tx_queue_init(struct can_tx_queue_s* instance) {
 800753c:	b480      	push	{r7}
 800753e:	b083      	sub	sp, #12
 8007540:	af00      	add	r7, sp, #0
 8007542:	6078      	str	r0, [r7, #4]
    instance->head = NULL;
 8007544:	687b      	ldr	r3, [r7, #4]
 8007546:	2200      	movs	r2, #0
 8007548:	601a      	str	r2, [r3, #0]
    return true;
 800754a:	2301      	movs	r3, #1
}
 800754c:	4618      	mov	r0, r3
 800754e:	370c      	adds	r7, #12
 8007550:	46bd      	mov	sp, r7
 8007552:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007556:	4770      	bx	lr

08007558 <can_tx_queue_push_I>:

void can_tx_queue_push_I(struct can_tx_queue_s* instance, struct can_tx_frame_s* push_frame) {
 8007558:	b580      	push	{r7, lr}
 800755a:	b084      	sub	sp, #16
 800755c:	af00      	add	r7, sp, #0
 800755e:	6078      	str	r0, [r7, #4]
 8007560:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 8007546:	f003 fd0b 	bl	800af60 <chDbgCheckClassI>
    
#if CH_DBG_ENABLE_CHECKS
    chDbgCheck(!can_tx_queue_frame_exists_in_queue(instance, push_frame));
 800754a:	6878      	ldr	r0, [r7, #4]
 800754c:	6839      	ldr	r1, [r7, #0]
 800754e:	f000 f8c9 	bl	80076e4 <can_tx_queue_frame_exists_in_queue>
 8007552:	4603      	mov	r3, r0
 8007554:	2b00      	cmp	r3, #0
 8007556:	d002      	beq.n	800755e <can_tx_queue_push_I+0x22>
 8007558:	4812      	ldr	r0, [pc, #72]	; (80075a4 <can_tx_queue_push_I+0x68>)
 800755a:	f003 fc23 	bl	800ada4 <chSysHalt>
=======
 8007562:	f003 fd41 	bl	800afe8 <chDbgCheckClassI>
    
#if CH_DBG_ENABLE_CHECKS
    chDbgCheck(!can_tx_queue_frame_exists_in_queue(instance, push_frame));
 8007566:	6878      	ldr	r0, [r7, #4]
 8007568:	6839      	ldr	r1, [r7, #0]
 800756a:	f000 f8c9 	bl	8007700 <can_tx_queue_frame_exists_in_queue>
 800756e:	4603      	mov	r3, r0
 8007570:	2b00      	cmp	r3, #0
 8007572:	d002      	beq.n	800757a <can_tx_queue_push_I+0x22>
 8007574:	4812      	ldr	r0, [pc, #72]	; (80075c0 <can_tx_queue_push_I+0x68>)
 8007576:	f003 fc59 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
#endif

    can_frame_priority_t push_frame_prio = can_get_tx_frame_priority_X(push_frame);
 800757a:	6838      	ldr	r0, [r7, #0]
 800757c:	f000 f984 	bl	8007888 <can_get_tx_frame_priority_X>
 8007580:	60b8      	str	r0, [r7, #8]

    struct can_tx_frame_s** insert_ptr = &instance->head;
 8007582:	687b      	ldr	r3, [r7, #4]
 8007584:	60fb      	str	r3, [r7, #12]
 8007586:	e003      	b.n	8007590 <can_tx_queue_push_I+0x38>
    while(*insert_ptr != NULL && push_frame_prio <= can_get_tx_frame_priority_X(*insert_ptr)) {
        insert_ptr = &(*insert_ptr)->next;
 8007588:	68fb      	ldr	r3, [r7, #12]
 800758a:	681b      	ldr	r3, [r3, #0]
 800758c:	3318      	adds	r3, #24
 800758e:	60fb      	str	r3, [r7, #12]
#endif

    can_frame_priority_t push_frame_prio = can_get_tx_frame_priority_X(push_frame);

    struct can_tx_frame_s** insert_ptr = &instance->head;
    while(*insert_ptr != NULL && push_frame_prio <= can_get_tx_frame_priority_X(*insert_ptr)) {
 8007590:	68fb      	ldr	r3, [r7, #12]
 8007592:	681b      	ldr	r3, [r3, #0]
 8007594:	2b00      	cmp	r3, #0
 8007596:	d008      	beq.n	80075aa <can_tx_queue_push_I+0x52>
 8007598:	68fb      	ldr	r3, [r7, #12]
 800759a:	681b      	ldr	r3, [r3, #0]
 800759c:	4618      	mov	r0, r3
 800759e:	f000 f973 	bl	8007888 <can_get_tx_frame_priority_X>
 80075a2:	4602      	mov	r2, r0
 80075a4:	68bb      	ldr	r3, [r7, #8]
 80075a6:	429a      	cmp	r2, r3
 80075a8:	d2ee      	bcs.n	8007588 <can_tx_queue_push_I+0x30>
        insert_ptr = &(*insert_ptr)->next;
    }

    push_frame->next = *insert_ptr;
 80075aa:	68fb      	ldr	r3, [r7, #12]
 80075ac:	681a      	ldr	r2, [r3, #0]
 80075ae:	683b      	ldr	r3, [r7, #0]
 80075b0:	619a      	str	r2, [r3, #24]
    *insert_ptr = push_frame;
 80075b2:	68fb      	ldr	r3, [r7, #12]
 80075b4:	683a      	ldr	r2, [r7, #0]
 80075b6:	601a      	str	r2, [r3, #0]
}
 80075b8:	3710      	adds	r7, #16
 80075ba:	46bd      	mov	sp, r7
 80075bc:	bd80      	pop	{r7, pc}
 80075be:	bf00      	nop
 80075c0:	0800ecf4 	.word	0x0800ecf4

080075c4 <can_tx_queue_push>:

void can_tx_queue_push(struct can_tx_queue_s* instance, struct can_tx_frame_s* push_frame) {
 80075c4:	b580      	push	{r7, lr}
 80075c6:	b082      	sub	sp, #8
 80075c8:	af00      	add	r7, sp, #0
 80075ca:	6078      	str	r0, [r7, #4]
 80075cc:	6039      	str	r1, [r7, #0]
    chSysLock();
 80075ce:	f7ff ff91 	bl	80074f4 <chSysLock.lto_priv.125>
    can_tx_queue_push_I(instance, push_frame);
 80075d2:	6878      	ldr	r0, [r7, #4]
 80075d4:	6839      	ldr	r1, [r7, #0]
 80075d6:	f7ff ffbf 	bl	8007558 <can_tx_queue_push_I>
    chSysUnlock();
 80075da:	f7ff ff93 	bl	8007504 <chSysUnlock.lto_priv.123>
}
 80075de:	3708      	adds	r7, #8
 80075e0:	46bd      	mov	sp, r7
 80075e2:	bd80      	pop	{r7, pc}

080075e4 <can_tx_queue_iterate_I>:
    chSysLock();
    can_tx_queue_push_ahead_I(instance, push_frame);
    chSysUnlock();
}

bool can_tx_queue_iterate_I(struct can_tx_queue_s* instance, struct can_tx_frame_s** frame_ptr) {
 80075e4:	b580      	push	{r7, lr}
 80075e6:	b082      	sub	sp, #8
 80075e8:	af00      	add	r7, sp, #0
 80075ea:	6078      	str	r0, [r7, #4]
 80075ec:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
<<<<<<< HEAD
 80075d2:	f003 fcc5 	bl	800af60 <chDbgCheckClassI>
    chDbgCheck(frame_ptr != NULL);
 80075d6:	683b      	ldr	r3, [r7, #0]
 80075d8:	2b00      	cmp	r3, #0
 80075da:	d102      	bne.n	80075e2 <can_tx_queue_iterate_I+0x1a>
 80075dc:	4810      	ldr	r0, [pc, #64]	; (8007620 <can_tx_queue_iterate_I+0x58>)
 80075de:	f003 fbe1 	bl	800ada4 <chSysHalt>
=======
 80075ee:	f003 fcfb 	bl	800afe8 <chDbgCheckClassI>
    chDbgCheck(frame_ptr != NULL);
 80075f2:	683b      	ldr	r3, [r7, #0]
 80075f4:	2b00      	cmp	r3, #0
 80075f6:	d102      	bne.n	80075fe <can_tx_queue_iterate_I+0x1a>
 80075f8:	4810      	ldr	r0, [pc, #64]	; (800763c <can_tx_queue_iterate_I+0x58>)
 80075fa:	f003 fc17 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

    if (frame_ptr == NULL) {
 80075fe:	683b      	ldr	r3, [r7, #0]
 8007600:	2b00      	cmp	r3, #0
 8007602:	d101      	bne.n	8007608 <can_tx_queue_iterate_I+0x24>
        return false;
 8007604:	2300      	movs	r3, #0
 8007606:	e014      	b.n	8007632 <can_tx_queue_iterate_I+0x4e>
    }

    if (*frame_ptr == NULL) {
 8007608:	683b      	ldr	r3, [r7, #0]
 800760a:	681b      	ldr	r3, [r3, #0]
 800760c:	2b00      	cmp	r3, #0
 800760e:	d104      	bne.n	800761a <can_tx_queue_iterate_I+0x36>
        *frame_ptr = instance->head;
 8007610:	687b      	ldr	r3, [r7, #4]
 8007612:	681a      	ldr	r2, [r3, #0]
 8007614:	683b      	ldr	r3, [r7, #0]
 8007616:	601a      	str	r2, [r3, #0]
 8007618:	e004      	b.n	8007624 <can_tx_queue_iterate_I+0x40>
    } else {
        *frame_ptr = (*frame_ptr)->next;
 800761a:	683b      	ldr	r3, [r7, #0]
 800761c:	681b      	ldr	r3, [r3, #0]
 800761e:	699a      	ldr	r2, [r3, #24]
 8007620:	683b      	ldr	r3, [r7, #0]
 8007622:	601a      	str	r2, [r3, #0]
    }

    return *frame_ptr != NULL;
 8007624:	683b      	ldr	r3, [r7, #0]
 8007626:	681b      	ldr	r3, [r3, #0]
 8007628:	2b00      	cmp	r3, #0
 800762a:	bf14      	ite	ne
 800762c:	2301      	movne	r3, #1
 800762e:	2300      	moveq	r3, #0
 8007630:	b2db      	uxtb	r3, r3
}
 8007632:	4618      	mov	r0, r3
 8007634:	3708      	adds	r7, #8
 8007636:	46bd      	mov	sp, r7
 8007638:	bd80      	pop	{r7, pc}
 800763a:	bf00      	nop
 800763c:	0800ed14 	.word	0x0800ed14

08007640 <can_tx_queue_peek_I>:
#endif

    LINKED_LIST_REMOVE(struct can_tx_frame_s, instance->head, frame);
}

struct can_tx_frame_s* can_tx_queue_peek_I(struct can_tx_queue_s* instance) {
 8007640:	b580      	push	{r7, lr}
 8007642:	b082      	sub	sp, #8
 8007644:	af00      	add	r7, sp, #0
 8007646:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 800762c:	f003 fc98 	bl	800af60 <chDbgCheckClassI>
=======
 8007648:	f003 fcce 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
    
    return instance->head;
 800764c:	687b      	ldr	r3, [r7, #4]
 800764e:	681b      	ldr	r3, [r3, #0]
}
 8007650:	4618      	mov	r0, r3
 8007652:	3708      	adds	r7, #8
 8007654:	46bd      	mov	sp, r7
 8007656:	bd80      	pop	{r7, pc}

08007658 <can_tx_queue_pop_I>:
    struct can_tx_frame_s* ret = can_tx_queue_peek_I(instance);
    chSysUnlock();
    return ret;
}

void can_tx_queue_pop_I(struct can_tx_queue_s* instance) {
 8007658:	b580      	push	{r7, lr}
 800765a:	b082      	sub	sp, #8
 800765c:	af00      	add	r7, sp, #0
 800765e:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8007644:	f003 fc8c 	bl	800af60 <chDbgCheckClassI>
=======
 8007660:	f003 fcc2 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries

    if (instance->head) {
 8007664:	687b      	ldr	r3, [r7, #4]
 8007666:	681b      	ldr	r3, [r3, #0]
 8007668:	2b00      	cmp	r3, #0
 800766a:	d004      	beq.n	8007676 <can_tx_queue_pop_I+0x1e>
        instance->head = instance->head->next;
 800766c:	687b      	ldr	r3, [r7, #4]
 800766e:	681b      	ldr	r3, [r3, #0]
 8007670:	699a      	ldr	r2, [r3, #24]
 8007672:	687b      	ldr	r3, [r7, #4]
 8007674:	601a      	str	r2, [r3, #0]
    }
}
 8007676:	3708      	adds	r7, #8
 8007678:	46bd      	mov	sp, r7
 800767a:	bd80      	pop	{r7, pc}

0800767c <can_tx_queue_pop_expired_I>:
    chSysLock();
    can_tx_queue_pop_I(instance);
    chSysUnlock();
}

struct can_tx_frame_s* can_tx_queue_pop_expired_I(struct can_tx_queue_s* instance) {
 800767c:	b580      	push	{r7, lr}
 800767e:	b084      	sub	sp, #16
 8007680:	af00      	add	r7, sp, #0
 8007682:	6078      	str	r0, [r7, #4]
    chDbgCheckClassI();
<<<<<<< HEAD
 8007668:	f003 fc7a 	bl	800af60 <chDbgCheckClassI>
=======
 8007684:	f003 fcb0 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
    
    struct can_tx_frame_s* ret = NULL;
 8007688:	2300      	movs	r3, #0
 800768a:	60fb      	str	r3, [r7, #12]
    struct can_tx_frame_s** expired_ptr = &instance->head;
 800768c:	687b      	ldr	r3, [r7, #4]
 800768e:	60bb      	str	r3, [r7, #8]
 8007690:	e003      	b.n	800769a <can_tx_queue_pop_expired_I+0x1e>
    while (*expired_ptr && !can_tx_frame_expired_X(*expired_ptr)) {
        expired_ptr = &(*expired_ptr)->next;
 8007692:	68bb      	ldr	r3, [r7, #8]
 8007694:	681b      	ldr	r3, [r3, #0]
 8007696:	3318      	adds	r3, #24
 8007698:	60bb      	str	r3, [r7, #8]
struct can_tx_frame_s* can_tx_queue_pop_expired_I(struct can_tx_queue_s* instance) {
    chDbgCheckClassI();
    
    struct can_tx_frame_s* ret = NULL;
    struct can_tx_frame_s** expired_ptr = &instance->head;
    while (*expired_ptr && !can_tx_frame_expired_X(*expired_ptr)) {
 800769a:	68bb      	ldr	r3, [r7, #8]
 800769c:	681b      	ldr	r3, [r3, #0]
 800769e:	2b00      	cmp	r3, #0
 80076a0:	d00a      	beq.n	80076b8 <can_tx_queue_pop_expired_I+0x3c>
 80076a2:	68bb      	ldr	r3, [r7, #8]
 80076a4:	681b      	ldr	r3, [r3, #0]
 80076a6:	4618      	mov	r0, r3
 80076a8:	f000 f862 	bl	8007770 <can_tx_frame_expired_X>
 80076ac:	4603      	mov	r3, r0
 80076ae:	f083 0301 	eor.w	r3, r3, #1
 80076b2:	b2db      	uxtb	r3, r3
 80076b4:	2b00      	cmp	r3, #0
 80076b6:	d1ec      	bne.n	8007692 <can_tx_queue_pop_expired_I+0x16>
        expired_ptr = &(*expired_ptr)->next;
    }
    
    if (*expired_ptr) {
 80076b8:	68bb      	ldr	r3, [r7, #8]
 80076ba:	681b      	ldr	r3, [r3, #0]
 80076bc:	2b00      	cmp	r3, #0
 80076be:	d007      	beq.n	80076d0 <can_tx_queue_pop_expired_I+0x54>
        ret = *expired_ptr;
 80076c0:	68bb      	ldr	r3, [r7, #8]
 80076c2:	681b      	ldr	r3, [r3, #0]
 80076c4:	60fb      	str	r3, [r7, #12]
        *expired_ptr = (*expired_ptr)->next;
 80076c6:	68bb      	ldr	r3, [r7, #8]
 80076c8:	681b      	ldr	r3, [r3, #0]
 80076ca:	699a      	ldr	r2, [r3, #24]
 80076cc:	68bb      	ldr	r3, [r7, #8]
 80076ce:	601a      	str	r2, [r3, #0]
    }
    
    return ret;
 80076d0:	68fb      	ldr	r3, [r7, #12]
}
 80076d2:	4618      	mov	r0, r3
 80076d4:	3710      	adds	r7, #16
 80076d6:	46bd      	mov	sp, r7
 80076d8:	bd80      	pop	{r7, pc}
 80076da:	bf00      	nop

080076dc <can_tx_queue_pop_expired>:

struct can_tx_frame_s* can_tx_queue_pop_expired(struct can_tx_queue_s* instance) {
 80076dc:	b580      	push	{r7, lr}
 80076de:	b084      	sub	sp, #16
 80076e0:	af00      	add	r7, sp, #0
 80076e2:	6078      	str	r0, [r7, #4]
    struct can_tx_frame_s* ret;
    chSysLock();
 80076e4:	f7ff ff06 	bl	80074f4 <chSysLock.lto_priv.125>
    ret = can_tx_queue_pop_expired_I(instance);
 80076e8:	6878      	ldr	r0, [r7, #4]
 80076ea:	f7ff ffc7 	bl	800767c <can_tx_queue_pop_expired_I>
 80076ee:	60f8      	str	r0, [r7, #12]
    chSysUnlock();
 80076f0:	f7ff ff08 	bl	8007504 <chSysUnlock.lto_priv.123>
    return ret;
 80076f4:	68fb      	ldr	r3, [r7, #12]
}
 80076f6:	4618      	mov	r0, r3
 80076f8:	3710      	adds	r7, #16
 80076fa:	46bd      	mov	sp, r7
 80076fc:	bd80      	pop	{r7, pc}
 80076fe:	bf00      	nop

08007700 <can_tx_queue_frame_exists_in_queue>:

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame) {
 8007700:	b580      	push	{r7, lr}
 8007702:	b084      	sub	sp, #16
 8007704:	af00      	add	r7, sp, #0
 8007706:	6078      	str	r0, [r7, #4]
 8007708:	6039      	str	r1, [r7, #0]
    struct can_tx_frame_s* frame = NULL;
 800770a:	2300      	movs	r3, #0
 800770c:	60fb      	str	r3, [r7, #12]
 800770e:	e005      	b.n	800771c <can_tx_queue_frame_exists_in_queue+0x1c>
    while (can_tx_queue_iterate_I(instance, &frame)) {
        if (check_frame == frame) {
 8007710:	68fb      	ldr	r3, [r7, #12]
 8007712:	683a      	ldr	r2, [r7, #0]
 8007714:	429a      	cmp	r2, r3
 8007716:	d101      	bne.n	800771c <can_tx_queue_frame_exists_in_queue+0x1c>
            return true;
 8007718:	2301      	movs	r3, #1
 800771a:	e009      	b.n	8007730 <can_tx_queue_frame_exists_in_queue+0x30>
}

#if CH_DBG_ENABLE_CHECKS
static bool can_tx_queue_frame_exists_in_queue(struct can_tx_queue_s* instance, struct can_tx_frame_s* check_frame) {
    struct can_tx_frame_s* frame = NULL;
    while (can_tx_queue_iterate_I(instance, &frame)) {
 800771c:	f107 030c 	add.w	r3, r7, #12
 8007720:	6878      	ldr	r0, [r7, #4]
 8007722:	4619      	mov	r1, r3
 8007724:	f7ff ff5e 	bl	80075e4 <can_tx_queue_iterate_I>
 8007728:	4603      	mov	r3, r0
 800772a:	2b00      	cmp	r3, #0
 800772c:	d1f0      	bne.n	8007710 <can_tx_queue_frame_exists_in_queue+0x10>
        if (check_frame == frame) {
            return true;
        }
    }
    return false;
 800772e:	2300      	movs	r3, #0
}
 8007730:	4618      	mov	r0, r3
 8007732:	3710      	adds	r7, #16
 8007734:	46bd      	mov	sp, r7
 8007736:	bd80      	pop	{r7, pc}

08007738 <st_lld_get_counter.lto_priv.108>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8007738:	b480      	push	{r7}
 800773a:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800773c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007740:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007742:	b29b      	uxth	r3, r3
}
 8007744:	4618      	mov	r0, r3
 8007746:	46bd      	mov	sp, r7
 8007748:	f85d 7b04 	ldr.w	r7, [sp], #4
 800774c:	4770      	bx	lr
 800774e:	bf00      	nop

08007750 <port_timer_get_time.lto_priv.105>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8007750:	b580      	push	{r7, lr}
 8007752:	af00      	add	r7, sp, #0

  return stGetCounter();
 8007754:	f7ff fff0 	bl	8007738 <st_lld_get_counter.lto_priv.108>
 8007758:	4603      	mov	r3, r0
}
 800775a:	4618      	mov	r0, r3
 800775c:	bd80      	pop	{r7, pc}
 800775e:	bf00      	nop

08007760 <chVTGetSystemTimeX.lto_priv.117>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007760:	b580      	push	{r7, lr}
 8007762:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007764:	f7ff fff4 	bl	8007750 <port_timer_get_time.lto_priv.105>
 8007768:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800776a:	4618      	mov	r0, r3
 800776c:	bd80      	pop	{r7, pc}
 800776e:	bf00      	nop

08007770 <can_tx_frame_expired_X>:
#include "can_helpers.h"

bool can_tx_frame_expired_X(struct can_tx_frame_s* frame) {
 8007770:	b580      	push	{r7, lr}
 8007772:	b082      	sub	sp, #8
 8007774:	af00      	add	r7, sp, #0
 8007776:	6078      	str	r0, [r7, #4]
    return chVTGetSystemTimeX() - frame->creation_systime > frame->tx_timeout;
 8007778:	f7ff fff2 	bl	8007760 <chVTGetSystemTimeX.lto_priv.117>
 800777c:	4603      	mov	r3, r0
 800777e:	461a      	mov	r2, r3
 8007780:	687b      	ldr	r3, [r7, #4]
 8007782:	8a1b      	ldrh	r3, [r3, #16]
 8007784:	1ad3      	subs	r3, r2, r3
 8007786:	687a      	ldr	r2, [r7, #4]
 8007788:	8a52      	ldrh	r2, [r2, #18]
 800778a:	4293      	cmp	r3, r2
 800778c:	bfcc      	ite	gt
 800778e:	2301      	movgt	r3, #1
 8007790:	2300      	movle	r3, #0
 8007792:	b2db      	uxtb	r3, r3
}
 8007794:	4618      	mov	r0, r3
 8007796:	3708      	adds	r7, #8
 8007798:	46bd      	mov	sp, r7
 800779a:	bd80      	pop	{r7, pc}

0800779c <can_tx_frame_time_until_expire_X>:

systime_t can_tx_frame_time_until_expire_X(struct can_tx_frame_s* frame, systime_t t_now) {
 800779c:	b480      	push	{r7}
 800779e:	b085      	sub	sp, #20
 80077a0:	af00      	add	r7, sp, #0
 80077a2:	6078      	str	r0, [r7, #4]
 80077a4:	460b      	mov	r3, r1
 80077a6:	807b      	strh	r3, [r7, #2]
    if (frame->tx_timeout == TIME_INFINITE) {
 80077a8:	687b      	ldr	r3, [r7, #4]
 80077aa:	8a5b      	ldrh	r3, [r3, #18]
 80077ac:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80077b0:	4293      	cmp	r3, r2
 80077b2:	d102      	bne.n	80077ba <can_tx_frame_time_until_expire_X+0x1e>
        return TIME_INFINITE;
 80077b4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80077b8:	e010      	b.n	80077dc <can_tx_frame_time_until_expire_X+0x40>
    }

    systime_t time_elapsed = t_now - frame->creation_systime;
 80077ba:	687b      	ldr	r3, [r7, #4]
 80077bc:	8a1b      	ldrh	r3, [r3, #16]
 80077be:	887a      	ldrh	r2, [r7, #2]
 80077c0:	1ad3      	subs	r3, r2, r3
 80077c2:	81fb      	strh	r3, [r7, #14]
    if (time_elapsed > frame->tx_timeout) {
 80077c4:	687b      	ldr	r3, [r7, #4]
 80077c6:	8a5b      	ldrh	r3, [r3, #18]
 80077c8:	89fa      	ldrh	r2, [r7, #14]
 80077ca:	429a      	cmp	r2, r3
 80077cc:	d901      	bls.n	80077d2 <can_tx_frame_time_until_expire_X+0x36>
        return TIME_IMMEDIATE;
 80077ce:	2300      	movs	r3, #0
 80077d0:	e004      	b.n	80077dc <can_tx_frame_time_until_expire_X+0x40>
    }

    return frame->tx_timeout - time_elapsed;
 80077d2:	687b      	ldr	r3, [r7, #4]
 80077d4:	8a5a      	ldrh	r2, [r3, #18]
 80077d6:	89fb      	ldrh	r3, [r7, #14]
 80077d8:	1ad3      	subs	r3, r2, r3
 80077da:	b29b      	uxth	r3, r3
}
 80077dc:	4618      	mov	r0, r3
 80077de:	3714      	adds	r7, #20
 80077e0:	46bd      	mov	sp, r7
 80077e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077e6:	4770      	bx	lr

080077e8 <can_get_frame_priority_X>:

can_frame_priority_t can_get_frame_priority_X(const struct can_frame_s* frame) {
 80077e8:	b480      	push	{r7}
 80077ea:	b085      	sub	sp, #20
 80077ec:	af00      	add	r7, sp, #0
 80077ee:	6078      	str	r0, [r7, #4]
    can_frame_priority_t ret = 0;
 80077f0:	2300      	movs	r3, #0
 80077f2:	60fb      	str	r3, [r7, #12]

    if (frame->IDE) {
 80077f4:	687b      	ldr	r3, [r7, #4]
 80077f6:	781b      	ldrb	r3, [r3, #0]
 80077f8:	f003 0302 	and.w	r3, r3, #2
 80077fc:	b2db      	uxtb	r3, r3
 80077fe:	2b00      	cmp	r3, #0
 8007800:	d026      	beq.n	8007850 <can_get_frame_priority_X+0x68>
        ret |= ((frame->EID >> 18) & 0x7ff) << 21; // Identifier A
 8007802:	687b      	ldr	r3, [r7, #4]
 8007804:	685b      	ldr	r3, [r3, #4]
 8007806:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800780a:	149b      	asrs	r3, r3, #18
 800780c:	055b      	lsls	r3, r3, #21
 800780e:	461a      	mov	r2, r3
 8007810:	68fb      	ldr	r3, [r7, #12]
 8007812:	4313      	orrs	r3, r2
 8007814:	60fb      	str	r3, [r7, #12]
        ret |= 1<<20; // SRR
 8007816:	68fb      	ldr	r3, [r7, #12]
 8007818:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800781c:	60fb      	str	r3, [r7, #12]
        ret |= 1<<19; // EID
 800781e:	68fb      	ldr	r3, [r7, #12]
 8007820:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8007824:	60fb      	str	r3, [r7, #12]
        ret |= (frame->EID & 0x3ffff) << 1; // Identifier B
 8007826:	687b      	ldr	r3, [r7, #4]
 8007828:	685b      	ldr	r3, [r3, #4]
 800782a:	f3c3 031c 	ubfx	r3, r3, #0, #29
 800782e:	f3c3 0311 	ubfx	r3, r3, #0, #18
 8007832:	005b      	lsls	r3, r3, #1
 8007834:	461a      	mov	r2, r3
 8007836:	68fb      	ldr	r3, [r7, #12]
 8007838:	4313      	orrs	r3, r2
 800783a:	60fb      	str	r3, [r7, #12]
        ret |= frame->RTR; // RTR
 800783c:	687b      	ldr	r3, [r7, #4]
 800783e:	781b      	ldrb	r3, [r3, #0]
 8007840:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8007844:	b2db      	uxtb	r3, r3
 8007846:	461a      	mov	r2, r3
 8007848:	68fb      	ldr	r3, [r7, #12]
 800784a:	4313      	orrs	r3, r2
 800784c:	60fb      	str	r3, [r7, #12]
 800784e:	e013      	b.n	8007878 <can_get_frame_priority_X+0x90>
    } else {
        ret |= frame->SID << 21; // Identifier
 8007850:	687b      	ldr	r3, [r7, #4]
 8007852:	889b      	ldrh	r3, [r3, #4]
 8007854:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8007858:	b29b      	uxth	r3, r3
 800785a:	055b      	lsls	r3, r3, #21
 800785c:	461a      	mov	r2, r3
 800785e:	68fb      	ldr	r3, [r7, #12]
 8007860:	4313      	orrs	r3, r2
 8007862:	60fb      	str	r3, [r7, #12]
        ret |= frame->RTR << 20; // RTR
 8007864:	687b      	ldr	r3, [r7, #4]
 8007866:	781b      	ldrb	r3, [r3, #0]
 8007868:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800786c:	b2db      	uxtb	r3, r3
 800786e:	051b      	lsls	r3, r3, #20
 8007870:	461a      	mov	r2, r3
 8007872:	68fb      	ldr	r3, [r7, #12]
 8007874:	4313      	orrs	r3, r2
 8007876:	60fb      	str	r3, [r7, #12]
    }

    return ~ret;
 8007878:	68fb      	ldr	r3, [r7, #12]
 800787a:	43db      	mvns	r3, r3
}
 800787c:	4618      	mov	r0, r3
 800787e:	3714      	adds	r7, #20
 8007880:	46bd      	mov	sp, r7
 8007882:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007886:	4770      	bx	lr

08007888 <can_get_tx_frame_priority_X>:

can_frame_priority_t can_get_tx_frame_priority_X(const struct can_tx_frame_s* frame) {
 8007888:	b580      	push	{r7, lr}
 800788a:	b082      	sub	sp, #8
 800788c:	af00      	add	r7, sp, #0
 800788e:	6078      	str	r0, [r7, #4]
    return can_get_frame_priority_X(&frame->content);
 8007890:	687b      	ldr	r3, [r7, #4]
 8007892:	4618      	mov	r0, r3
 8007894:	f7ff ffa8 	bl	80077e8 <can_get_frame_priority_X>
 8007898:	4603      	mov	r3, r0
}
 800789a:	4618      	mov	r0, r3
 800789c:	3708      	adds	r7, #8
 800789e:	46bd      	mov	sp, r7
 80078a0:	bd80      	pop	{r7, pc}
 80078a2:	bf00      	nop

080078a4 <port_lock.lto_priv.115>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80078a4:	b480      	push	{r7}
 80078a6:	b083      	sub	sp, #12
 80078a8:	af00      	add	r7, sp, #0
 80078aa:	2320      	movs	r3, #32
 80078ac:	607b      	str	r3, [r7, #4]
 80078ae:	687b      	ldr	r3, [r7, #4]
 80078b0:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80078b4:	370c      	adds	r7, #12
 80078b6:	46bd      	mov	sp, r7
 80078b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078bc:	4770      	bx	lr
 80078be:	bf00      	nop

080078c0 <port_unlock.lto_priv.112>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80078c0:	b480      	push	{r7}
 80078c2:	b083      	sub	sp, #12
 80078c4:	af00      	add	r7, sp, #0
 80078c6:	2300      	movs	r3, #0
 80078c8:	607b      	str	r3, [r7, #4]
 80078ca:	687b      	ldr	r3, [r7, #4]
 80078cc:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80078d0:	370c      	adds	r7, #12
 80078d2:	46bd      	mov	sp, r7
 80078d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078d8:	4770      	bx	lr
 80078da:	bf00      	nop

080078dc <st_lld_get_counter.lto_priv.109>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 80078dc:	b480      	push	{r7}
 80078de:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 80078e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80078e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80078e6:	b29b      	uxth	r3, r3
}
 80078e8:	4618      	mov	r0, r3
 80078ea:	46bd      	mov	sp, r7
 80078ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078f0:	4770      	bx	lr
 80078f2:	bf00      	nop

080078f4 <port_timer_get_time.lto_priv.106>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80078f4:	b580      	push	{r7, lr}
 80078f6:	af00      	add	r7, sp, #0

  return stGetCounter();
 80078f8:	f7ff fff0 	bl	80078dc <st_lld_get_counter.lto_priv.109>
 80078fc:	4603      	mov	r3, r0
}
 80078fe:	4618      	mov	r0, r3
 8007900:	bd80      	pop	{r7, pc}
 8007902:	bf00      	nop

08007904 <chSysLock.lto_priv.102>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8007904:	b580      	push	{r7, lr}
 8007906:	af00      	add	r7, sp, #0

  port_lock();
 8007908:	f7ff ffcc 	bl	80078a4 <port_lock.lto_priv.115>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
<<<<<<< HEAD
 80078f0:	f003 faa6 	bl	800ae40 <_dbg_check_lock>
=======
 800790c:	f003 fadc 	bl	800aec8 <_dbg_check_lock>
>>>>>>> 752c83b... update binaries
}
 8007910:	bd80      	pop	{r7, pc}
 8007912:	bf00      	nop

08007914 <chSysUnlock.lto_priv.101>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007914:	b580      	push	{r7, lr}
 8007916:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
<<<<<<< HEAD
 80078fc:	f003 fab6 	bl	800ae6c <_dbg_check_unlock>
=======
 8007918:	f003 faec 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 8007900:	4b09      	ldr	r3, [pc, #36]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 8007902:	681b      	ldr	r3, [r3, #0]
 8007904:	4a08      	ldr	r2, [pc, #32]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 8007906:	4293      	cmp	r3, r2
 8007908:	d00a      	beq.n	8007920 <chSysUnlock.lto_priv.101+0x28>
 800790a:	4b07      	ldr	r3, [pc, #28]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 800790c:	699b      	ldr	r3, [r3, #24]
 800790e:	689a      	ldr	r2, [r3, #8]
 8007910:	4b05      	ldr	r3, [pc, #20]	; (8007928 <chSysUnlock.lto_priv.101+0x30>)
 8007912:	681b      	ldr	r3, [r3, #0]
 8007914:	689b      	ldr	r3, [r3, #8]
 8007916:	429a      	cmp	r2, r3
 8007918:	d202      	bcs.n	8007920 <chSysUnlock.lto_priv.101+0x28>
 800791a:	4804      	ldr	r0, [pc, #16]	; (800792c <chSysUnlock.lto_priv.101+0x34>)
 800791c:	f003 fa42 	bl	800ada4 <chSysHalt>
=======
 800791c:	4b09      	ldr	r3, [pc, #36]	; (8007944 <chSysUnlock.lto_priv.101+0x30>)
 800791e:	681b      	ldr	r3, [r3, #0]
 8007920:	4a08      	ldr	r2, [pc, #32]	; (8007944 <chSysUnlock.lto_priv.101+0x30>)
 8007922:	4293      	cmp	r3, r2
 8007924:	d00a      	beq.n	800793c <chSysUnlock.lto_priv.101+0x28>
 8007926:	4b07      	ldr	r3, [pc, #28]	; (8007944 <chSysUnlock.lto_priv.101+0x30>)
 8007928:	699b      	ldr	r3, [r3, #24]
 800792a:	689a      	ldr	r2, [r3, #8]
 800792c:	4b05      	ldr	r3, [pc, #20]	; (8007944 <chSysUnlock.lto_priv.101+0x30>)
 800792e:	681b      	ldr	r3, [r3, #0]
 8007930:	689b      	ldr	r3, [r3, #8]
 8007932:	429a      	cmp	r2, r3
 8007934:	d202      	bcs.n	800793c <chSysUnlock.lto_priv.101+0x28>
 8007936:	4804      	ldr	r0, [pc, #16]	; (8007948 <chSysUnlock.lto_priv.101+0x34>)
 8007938:	f003 fa78 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800793c:	f7ff ffc0 	bl	80078c0 <port_unlock.lto_priv.112>
}
 8007940:	bd80      	pop	{r7, pc}
 8007942:	bf00      	nop
 8007944:	20001338 	.word	0x20001338
 8007948:	0800ed40 	.word	0x0800ed40

0800794c <chVTGetSystemTimeX.lto_priv.100>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800794c:	b580      	push	{r7, lr}
 800794e:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007950:	f7ff ffd0 	bl	80078f4 <port_timer_get_time.lto_priv.106>
 8007954:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8007956:	4618      	mov	r0, r3
 8007958:	bd80      	pop	{r7, pc}
 800795a:	bf00      	nop

0800795c <chCoreAllocAlignedI.lto_priv.8>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 800795c:	b580      	push	{r7, lr}
 800795e:	b082      	sub	sp, #8
 8007960:	af00      	add	r7, sp, #0
 8007962:	6078      	str	r0, [r7, #4]
 8007964:	6039      	str	r1, [r7, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
<<<<<<< HEAD
 800794a:	6878      	ldr	r0, [r7, #4]
 800794c:	6839      	ldr	r1, [r7, #0]
 800794e:	2200      	movs	r2, #0
 8007950:	f002 f86c 	bl	8009a2c <chCoreAllocAlignedWithOffsetI>
 8007954:	4603      	mov	r3, r0
}
 8007956:	4618      	mov	r0, r3
 8007958:	3708      	adds	r7, #8
 800795a:	46bd      	mov	sp, r7
 800795c:	bd80      	pop	{r7, pc}
 800795e:	bf00      	nop

08007960 <chCoreAlloc.lto_priv.84>:
=======
 8007966:	6878      	ldr	r0, [r7, #4]
 8007968:	6839      	ldr	r1, [r7, #0]
 800796a:	2200      	movs	r2, #0
 800796c:	f002 f8a2 	bl	8009ab4 <chCoreAllocAlignedWithOffsetI>
 8007970:	4603      	mov	r3, r0
}
 8007972:	4618      	mov	r0, r3
 8007974:	3708      	adds	r7, #8
 8007976:	46bd      	mov	sp, r7
 8007978:	bd80      	pop	{r7, pc}
 800797a:	bf00      	nop

0800797c <chCoreAlloc.lto_priv.84>:
>>>>>>> 752c83b... update binaries
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {
 800797c:	b580      	push	{r7, lr}
 800797e:	b082      	sub	sp, #8
 8007980:	af00      	add	r7, sp, #0
 8007982:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
<<<<<<< HEAD
 8007968:	6878      	ldr	r0, [r7, #4]
 800796a:	2104      	movs	r1, #4
 800796c:	2200      	movs	r2, #0
 800796e:	f002 f8a1 	bl	8009ab4 <chCoreAllocAlignedWithOffset>
 8007972:	4603      	mov	r3, r0
}
 8007974:	4618      	mov	r0, r3
 8007976:	3708      	adds	r7, #8
 8007978:	46bd      	mov	sp, r7
 800797a:	bd80      	pop	{r7, pc}

0800797c <can_iterate_instances>:
=======
 8007984:	6878      	ldr	r0, [r7, #4]
 8007986:	2104      	movs	r1, #4
 8007988:	2200      	movs	r2, #0
 800798a:	f002 f8d7 	bl	8009b3c <chCoreAllocAlignedWithOffset>
 800798e:	4603      	mov	r3, r0
}
 8007990:	4618      	mov	r0, r3
 8007992:	3708      	adds	r7, #8
 8007994:	46bd      	mov	sp, r7
 8007996:	bd80      	pop	{r7, pc}

08007998 <can_iterate_instances>:
>>>>>>> 752c83b... update binaries
static void can_reschedule_expire_timer_I(struct can_instance_s* instance);
static void can_reschedule_expire_timer(struct can_instance_s* instance);
static void can_try_enqueue_waiting_frame_I(struct can_instance_s* instance);
static void can_try_enqueue_waiting_frame(struct can_instance_s* instance);

bool can_iterate_instances(struct can_instance_s** instance_ptr) {
 8007998:	b480      	push	{r7}
 800799a:	b083      	sub	sp, #12
 800799c:	af00      	add	r7, sp, #0
 800799e:	6078      	str	r0, [r7, #4]
    if (!instance_ptr) {
 80079a0:	687b      	ldr	r3, [r7, #4]
 80079a2:	2b00      	cmp	r3, #0
 80079a4:	d101      	bne.n	80079aa <can_iterate_instances+0x12>
        return false;
 80079a6:	2300      	movs	r3, #0
 80079a8:	e015      	b.n	80079d6 <can_iterate_instances+0x3e>
    }

    if (!(*instance_ptr)) {
 80079aa:	687b      	ldr	r3, [r7, #4]
 80079ac:	681b      	ldr	r3, [r3, #0]
 80079ae:	2b00      	cmp	r3, #0
 80079b0:	d104      	bne.n	80079bc <can_iterate_instances+0x24>
        *instance_ptr = can_instance_list_head;
 80079b2:	4b0c      	ldr	r3, [pc, #48]	; (80079e4 <can_iterate_instances+0x4c>)
 80079b4:	681a      	ldr	r2, [r3, #0]
 80079b6:	687b      	ldr	r3, [r7, #4]
 80079b8:	601a      	str	r2, [r3, #0]
 80079ba:	e005      	b.n	80079c8 <can_iterate_instances+0x30>
    } else {
        *instance_ptr = (*instance_ptr)->next;
 80079bc:	687b      	ldr	r3, [r7, #4]
 80079be:	681b      	ldr	r3, [r3, #0]
 80079c0:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
 80079c4:	687b      	ldr	r3, [r7, #4]
 80079c6:	601a      	str	r2, [r3, #0]
    }

    return *instance_ptr != NULL;
 80079c8:	687b      	ldr	r3, [r7, #4]
 80079ca:	681b      	ldr	r3, [r3, #0]
 80079cc:	2b00      	cmp	r3, #0
 80079ce:	bf14      	ite	ne
 80079d0:	2301      	movne	r3, #1
 80079d2:	2300      	moveq	r3, #0
 80079d4:	b2db      	uxtb	r3, r3
}
 80079d6:	4618      	mov	r0, r3
 80079d8:	370c      	adds	r7, #12
 80079da:	46bd      	mov	sp, r7
 80079dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079e0:	4770      	bx	lr
 80079e2:	bf00      	nop
 80079e4:	20001470 	.word	0x20001470

080079e8 <can_get_instance>:

struct can_instance_s* can_get_instance(uint8_t can_idx) {
 80079e8:	b480      	push	{r7}
 80079ea:	b085      	sub	sp, #20
 80079ec:	af00      	add	r7, sp, #0
 80079ee:	4603      	mov	r3, r0
 80079f0:	71fb      	strb	r3, [r7, #7]
    for (struct can_instance_s* instance = can_instance_list_head; instance != NULL; instance = instance->next) {
 80079f2:	4b0c      	ldr	r3, [pc, #48]	; (8007a24 <can_get_instance+0x3c>)
 80079f4:	681b      	ldr	r3, [r3, #0]
 80079f6:	60fb      	str	r3, [r7, #12]
 80079f8:	e00a      	b.n	8007a10 <can_get_instance+0x28>
        if (instance->idx == can_idx) {
 80079fa:	68fb      	ldr	r3, [r7, #12]
 80079fc:	781b      	ldrb	r3, [r3, #0]
 80079fe:	79fa      	ldrb	r2, [r7, #7]
 8007a00:	429a      	cmp	r2, r3
 8007a02:	d101      	bne.n	8007a08 <can_get_instance+0x20>
            return instance;
 8007a04:	68fb      	ldr	r3, [r7, #12]
 8007a06:	e007      	b.n	8007a18 <can_get_instance+0x30>

    return *instance_ptr != NULL;
}

struct can_instance_s* can_get_instance(uint8_t can_idx) {
    for (struct can_instance_s* instance = can_instance_list_head; instance != NULL; instance = instance->next) {
 8007a08:	68fb      	ldr	r3, [r7, #12]
 8007a0a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 8007a0e:	60fb      	str	r3, [r7, #12]
 8007a10:	68fb      	ldr	r3, [r7, #12]
 8007a12:	2b00      	cmp	r3, #0
 8007a14:	d1f1      	bne.n	80079fa <can_get_instance+0x12>
        if (instance->idx == can_idx) {
            return instance;
        }
    }

    return NULL;
 8007a16:	2300      	movs	r3, #0
}
 8007a18:	4618      	mov	r0, r3
 8007a1a:	3714      	adds	r7, #20
 8007a1c:	46bd      	mov	sp, r7
 8007a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a22:	4770      	bx	lr
 8007a24:	20001470 	.word	0x20001470

08007a28 <can_get_rx_topic>:

struct pubsub_topic_s* can_get_rx_topic(struct can_instance_s* instance) {
 8007a28:	b580      	push	{r7, lr}
 8007a2a:	b082      	sub	sp, #8
 8007a2c:	af00      	add	r7, sp, #0
 8007a2e:	6078      	str	r0, [r7, #4]
    chDbgCheck(instance != NULL);
<<<<<<< HEAD
 8007a14:	687b      	ldr	r3, [r7, #4]
 8007a16:	2b00      	cmp	r3, #0
 8007a18:	d102      	bne.n	8007a20 <can_get_rx_topic+0x14>
 8007a1a:	4807      	ldr	r0, [pc, #28]	; (8007a38 <can_get_rx_topic+0x2c>)
 8007a1c:	f003 f9c2 	bl	800ada4 <chSysHalt>
=======
 8007a30:	687b      	ldr	r3, [r7, #4]
 8007a32:	2b00      	cmp	r3, #0
 8007a34:	d102      	bne.n	8007a3c <can_get_rx_topic+0x14>
 8007a36:	4807      	ldr	r0, [pc, #28]	; (8007a54 <can_get_rx_topic+0x2c>)
 8007a38:	f003 f9f8 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
    if (!instance) {
 8007a3c:	687b      	ldr	r3, [r7, #4]
 8007a3e:	2b00      	cmp	r3, #0
 8007a40:	d101      	bne.n	8007a46 <can_get_rx_topic+0x1e>
        return NULL;
 8007a42:	2300      	movs	r3, #0
 8007a44:	e001      	b.n	8007a4a <can_get_rx_topic+0x22>
    }

    return &instance->rx_topic;
 8007a46:	687b      	ldr	r3, [r7, #4]
 8007a48:	3340      	adds	r3, #64	; 0x40
}
 8007a4a:	4618      	mov	r0, r3
 8007a4c:	3708      	adds	r7, #8
 8007a4e:	46bd      	mov	sp, r7
 8007a50:	bd80      	pop	{r7, pc}
 8007a52:	bf00      	nop
 8007a54:	0800ed2c 	.word	0x0800ed2c

08007a58 <can_set_silent_mode>:
    }

    return instance->baudrate;
}

void can_set_silent_mode(struct can_instance_s* instance, bool silent) {
 8007a58:	b580      	push	{r7, lr}
 8007a5a:	b082      	sub	sp, #8
 8007a5c:	af00      	add	r7, sp, #0
 8007a5e:	6078      	str	r0, [r7, #4]
 8007a60:	460b      	mov	r3, r1
 8007a62:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8007a64:	687b      	ldr	r3, [r7, #4]
 8007a66:	2b00      	cmp	r3, #0
 8007a68:	d014      	beq.n	8007a94 <can_set_silent_mode+0x3c>
        return;
    }

    chSysLock();
 8007a6a:	f7ff ff4b 	bl	8007904 <chSysLock.lto_priv.102>
    if (instance->started && instance->silent != silent) {
 8007a6e:	687b      	ldr	r3, [r7, #4]
 8007a70:	785b      	ldrb	r3, [r3, #1]
 8007a72:	2b00      	cmp	r3, #0
 8007a74:	d00c      	beq.n	8007a90 <can_set_silent_mode+0x38>
 8007a76:	687b      	ldr	r3, [r7, #4]
 8007a78:	789b      	ldrb	r3, [r3, #2]
 8007a7a:	78fa      	ldrb	r2, [r7, #3]
 8007a7c:	429a      	cmp	r2, r3
 8007a7e:	d007      	beq.n	8007a90 <can_set_silent_mode+0x38>
        can_start_I(instance, silent, instance->auto_retransmit, instance->baudrate);
 8007a80:	687b      	ldr	r3, [r7, #4]
 8007a82:	78da      	ldrb	r2, [r3, #3]
 8007a84:	687b      	ldr	r3, [r7, #4]
 8007a86:	685b      	ldr	r3, [r3, #4]
 8007a88:	78f9      	ldrb	r1, [r7, #3]
 8007a8a:	6878      	ldr	r0, [r7, #4]
 8007a8c:	f000 f85c 	bl	8007b48 <can_start_I>
    }
    chSysUnlock();
 8007a90:	f7ff ff40 	bl	8007914 <chSysUnlock.lto_priv.101>
}
 8007a94:	3708      	adds	r7, #8
 8007a96:	46bd      	mov	sp, r7
 8007a98:	bd80      	pop	{r7, pc}
 8007a9a:	bf00      	nop

08007a9c <can_set_auto_retransmit_mode>:

void can_set_auto_retransmit_mode(struct can_instance_s* instance, bool auto_retransmit) {
 8007a9c:	b580      	push	{r7, lr}
 8007a9e:	b082      	sub	sp, #8
 8007aa0:	af00      	add	r7, sp, #0
 8007aa2:	6078      	str	r0, [r7, #4]
 8007aa4:	460b      	mov	r3, r1
 8007aa6:	70fb      	strb	r3, [r7, #3]
    if (!instance) {
 8007aa8:	687b      	ldr	r3, [r7, #4]
 8007aaa:	2b00      	cmp	r3, #0
 8007aac:	d014      	beq.n	8007ad8 <can_set_auto_retransmit_mode+0x3c>
        return;
    }

    chSysLock();
 8007aae:	f7ff ff29 	bl	8007904 <chSysLock.lto_priv.102>
    if (instance->started && instance->auto_retransmit != auto_retransmit) {
 8007ab2:	687b      	ldr	r3, [r7, #4]
 8007ab4:	785b      	ldrb	r3, [r3, #1]
 8007ab6:	2b00      	cmp	r3, #0
 8007ab8:	d00c      	beq.n	8007ad4 <can_set_auto_retransmit_mode+0x38>
 8007aba:	687b      	ldr	r3, [r7, #4]
 8007abc:	78db      	ldrb	r3, [r3, #3]
 8007abe:	78fa      	ldrb	r2, [r7, #3]
 8007ac0:	429a      	cmp	r2, r3
 8007ac2:	d007      	beq.n	8007ad4 <can_set_auto_retransmit_mode+0x38>
        can_start_I(instance, instance->silent, auto_retransmit, instance->baudrate);
 8007ac4:	687b      	ldr	r3, [r7, #4]
 8007ac6:	7899      	ldrb	r1, [r3, #2]
 8007ac8:	687b      	ldr	r3, [r7, #4]
 8007aca:	685b      	ldr	r3, [r3, #4]
 8007acc:	78fa      	ldrb	r2, [r7, #3]
 8007ace:	6878      	ldr	r0, [r7, #4]
 8007ad0:	f000 f83a 	bl	8007b48 <can_start_I>
    }
    chSysUnlock();
 8007ad4:	f7ff ff1e 	bl	8007914 <chSysUnlock.lto_priv.101>
}
 8007ad8:	3708      	adds	r7, #8
 8007ada:	46bd      	mov	sp, r7
 8007adc:	bd80      	pop	{r7, pc}
 8007ade:	bf00      	nop

08007ae0 <can_set_baudrate>:

void can_set_baudrate(struct can_instance_s* instance, uint32_t baudrate) {
 8007ae0:	b580      	push	{r7, lr}
 8007ae2:	b082      	sub	sp, #8
 8007ae4:	af00      	add	r7, sp, #0
 8007ae6:	6078      	str	r0, [r7, #4]
 8007ae8:	6039      	str	r1, [r7, #0]
    if (!instance) {
 8007aea:	687b      	ldr	r3, [r7, #4]
 8007aec:	2b00      	cmp	r3, #0
 8007aee:	d016      	beq.n	8007b1e <can_set_baudrate+0x3e>
        return;
    }

    chSysLock();
 8007af0:	f7ff ff08 	bl	8007904 <chSysLock.lto_priv.102>
    if (instance->started && instance->baudrate != baudrate) {
 8007af4:	687b      	ldr	r3, [r7, #4]
 8007af6:	785b      	ldrb	r3, [r3, #1]
 8007af8:	2b00      	cmp	r3, #0
 8007afa:	d00e      	beq.n	8007b1a <can_set_baudrate+0x3a>
 8007afc:	687b      	ldr	r3, [r7, #4]
 8007afe:	685a      	ldr	r2, [r3, #4]
 8007b00:	683b      	ldr	r3, [r7, #0]
 8007b02:	429a      	cmp	r2, r3
 8007b04:	d009      	beq.n	8007b1a <can_set_baudrate+0x3a>
        can_start_I(instance, instance->silent, instance->auto_retransmit, baudrate);
 8007b06:	687b      	ldr	r3, [r7, #4]
 8007b08:	789a      	ldrb	r2, [r3, #2]
 8007b0a:	687b      	ldr	r3, [r7, #4]
 8007b0c:	78db      	ldrb	r3, [r3, #3]
 8007b0e:	6878      	ldr	r0, [r7, #4]
 8007b10:	4611      	mov	r1, r2
 8007b12:	461a      	mov	r2, r3
 8007b14:	683b      	ldr	r3, [r7, #0]
 8007b16:	f000 f817 	bl	8007b48 <can_start_I>
    }
    chSysUnlock();
 8007b1a:	f7ff fefb 	bl	8007914 <chSysUnlock.lto_priv.101>
}
 8007b1e:	3708      	adds	r7, #8
 8007b20:	46bd      	mov	sp, r7
 8007b22:	bd80      	pop	{r7, pc}

08007b24 <can_get_baudrate_confirmed>:

bool can_get_baudrate_confirmed(struct can_instance_s* instance) {
 8007b24:	b480      	push	{r7}
 8007b26:	b083      	sub	sp, #12
 8007b28:	af00      	add	r7, sp, #0
 8007b2a:	6078      	str	r0, [r7, #4]
    if (!instance) {
 8007b2c:	687b      	ldr	r3, [r7, #4]
 8007b2e:	2b00      	cmp	r3, #0
 8007b30:	d101      	bne.n	8007b36 <can_get_baudrate_confirmed+0x12>
        return false;
 8007b32:	2300      	movs	r3, #0
 8007b34:	e001      	b.n	8007b3a <can_get_baudrate_confirmed+0x16>
    }

    return instance->baudrate_confirmed;
 8007b36:	687b      	ldr	r3, [r7, #4]
 8007b38:	7a1b      	ldrb	r3, [r3, #8]
}
 8007b3a:	4618      	mov	r0, r3
 8007b3c:	370c      	adds	r7, #12
 8007b3e:	46bd      	mov	sp, r7
 8007b40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b44:	4770      	bx	lr
 8007b46:	bf00      	nop

08007b48 <can_start_I>:

void can_start_I(struct can_instance_s* instance, bool silent, bool auto_retransmit, uint32_t baudrate) {
 8007b48:	b590      	push	{r4, r7, lr}
 8007b4a:	b085      	sub	sp, #20
 8007b4c:	af00      	add	r7, sp, #0
 8007b4e:	60f8      	str	r0, [r7, #12]
 8007b50:	607b      	str	r3, [r7, #4]
 8007b52:	460b      	mov	r3, r1
 8007b54:	72fb      	strb	r3, [r7, #11]
 8007b56:	4613      	mov	r3, r2
 8007b58:	72bb      	strb	r3, [r7, #10]
    chDbgCheckClassI();
<<<<<<< HEAD
 8007b3e:	f003 fa0f 	bl	800af60 <chDbgCheckClassI>
=======
 8007b5a:	f003 fa45 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
    if (!instance) {
 8007b5e:	68fb      	ldr	r3, [r7, #12]
 8007b60:	2b00      	cmp	r3, #0
 8007b62:	d026      	beq.n	8007bb2 <can_start_I+0x6a>
        return;
    }

    if (instance->started) {
 8007b64:	68fb      	ldr	r3, [r7, #12]
 8007b66:	785b      	ldrb	r3, [r3, #1]
 8007b68:	2b00      	cmp	r3, #0
 8007b6a:	d002      	beq.n	8007b72 <can_start_I+0x2a>
        // TODO prevent dropped frames when re-starting CAN driver
        can_stop_I(instance);
 8007b6c:	68f8      	ldr	r0, [r7, #12]
 8007b6e:	f7fd fee5 	bl	800593c <can_stop_I>
    }

    instance->driver_iface->start(instance->driver_ctx, silent, auto_retransmit, baudrate);
 8007b72:	68fb      	ldr	r3, [r7, #12]
 8007b74:	691b      	ldr	r3, [r3, #16]
 8007b76:	681c      	ldr	r4, [r3, #0]
 8007b78:	68fb      	ldr	r3, [r7, #12]
 8007b7a:	68d9      	ldr	r1, [r3, #12]
 8007b7c:	7afa      	ldrb	r2, [r7, #11]
 8007b7e:	7abb      	ldrb	r3, [r7, #10]
 8007b80:	4608      	mov	r0, r1
 8007b82:	4611      	mov	r1, r2
 8007b84:	461a      	mov	r2, r3
 8007b86:	687b      	ldr	r3, [r7, #4]
 8007b88:	47a0      	blx	r4
    instance->started = true;
 8007b8a:	68fb      	ldr	r3, [r7, #12]
 8007b8c:	2201      	movs	r2, #1
 8007b8e:	705a      	strb	r2, [r3, #1]
    instance->silent = silent;
 8007b90:	68fb      	ldr	r3, [r7, #12]
 8007b92:	7afa      	ldrb	r2, [r7, #11]
 8007b94:	709a      	strb	r2, [r3, #2]
    instance->auto_retransmit = auto_retransmit;
 8007b96:	68fb      	ldr	r3, [r7, #12]
 8007b98:	7aba      	ldrb	r2, [r7, #10]
 8007b9a:	70da      	strb	r2, [r3, #3]
    if (baudrate != instance->baudrate) {
 8007b9c:	68fb      	ldr	r3, [r7, #12]
 8007b9e:	685a      	ldr	r2, [r3, #4]
 8007ba0:	687b      	ldr	r3, [r7, #4]
 8007ba2:	429a      	cmp	r2, r3
 8007ba4:	d002      	beq.n	8007bac <can_start_I+0x64>
        instance->baudrate_confirmed = false;
 8007ba6:	68fb      	ldr	r3, [r7, #12]
 8007ba8:	2200      	movs	r2, #0
 8007baa:	721a      	strb	r2, [r3, #8]
    }
    instance->baudrate = baudrate;
 8007bac:	68fb      	ldr	r3, [r7, #12]
 8007bae:	687a      	ldr	r2, [r7, #4]
 8007bb0:	605a      	str	r2, [r3, #4]
}
<<<<<<< HEAD
 8007b96:	3714      	adds	r7, #20
 8007b98:	46bd      	mov	sp, r7
 8007b9a:	bd90      	pop	{r4, r7, pc}

08007b9c <crc16_ccitt>:
=======
 8007bb2:	3714      	adds	r7, #20
 8007bb4:	46bd      	mov	sp, r7
 8007bb6:	bd90      	pop	{r4, r7, pc}

08007bb8 <crc16_ccitt>:
>>>>>>> 752c83b... update binaries
        *hash ^= (uint64_t)buf[i];
        *hash *= FNV_1_PRIME_64;
    }
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
<<<<<<< HEAD
 8007b9c:	b480      	push	{r7}
 8007b9e:	b087      	sub	sp, #28
 8007ba0:	af00      	add	r7, sp, #0
 8007ba2:	60f8      	str	r0, [r7, #12]
 8007ba4:	60b9      	str	r1, [r7, #8]
 8007ba6:	4613      	mov	r3, r2
 8007ba8:	80fb      	strh	r3, [r7, #6]
    for (size_t i = 0; i < len; i++) {
 8007baa:	2300      	movs	r3, #0
 8007bac:	617b      	str	r3, [r7, #20]
 8007bae:	e026      	b.n	8007bfe <crc16_ccitt+0x62>
        crc = crc ^ (((uint8_t*)buf)[i] << 8);
 8007bb0:	68fa      	ldr	r2, [r7, #12]
 8007bb2:	697b      	ldr	r3, [r7, #20]
 8007bb4:	4413      	add	r3, r2
 8007bb6:	781b      	ldrb	r3, [r3, #0]
 8007bb8:	021b      	lsls	r3, r3, #8
 8007bba:	b29a      	uxth	r2, r3
 8007bbc:	88fb      	ldrh	r3, [r7, #6]
 8007bbe:	4053      	eors	r3, r2
 8007bc0:	b29b      	uxth	r3, r3
 8007bc2:	80fb      	strh	r3, [r7, #6]
        for (int j = 0; j < 8; j++) {
 8007bc4:	2300      	movs	r3, #0
 8007bc6:	613b      	str	r3, [r7, #16]
 8007bc8:	e013      	b.n	8007bf2 <crc16_ccitt+0x56>
            if (crc & 0x8000) {
 8007bca:	88fb      	ldrh	r3, [r7, #6]
 8007bcc:	b21b      	sxth	r3, r3
 8007bce:	2b00      	cmp	r3, #0
 8007bd0:	da09      	bge.n	8007be6 <crc16_ccitt+0x4a>
                crc = (crc << 1) ^ 0x1021;
 8007bd2:	88fb      	ldrh	r3, [r7, #6]
 8007bd4:	005b      	lsls	r3, r3, #1
 8007bd6:	b29b      	uxth	r3, r3
 8007bd8:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 8007bdc:	f083 0301 	eor.w	r3, r3, #1
 8007be0:	b29b      	uxth	r3, r3
 8007be2:	80fb      	strh	r3, [r7, #6]
 8007be4:	e002      	b.n	8007bec <crc16_ccitt+0x50>
            } else {
                crc = (crc << 1);
 8007be6:	88fb      	ldrh	r3, [r7, #6]
 8007be8:	005b      	lsls	r3, r3, #1
 8007bea:	80fb      	strh	r3, [r7, #6]
=======
 8007bb8:	b480      	push	{r7}
 8007bba:	b087      	sub	sp, #28
 8007bbc:	af00      	add	r7, sp, #0
 8007bbe:	60f8      	str	r0, [r7, #12]
 8007bc0:	60b9      	str	r1, [r7, #8]
 8007bc2:	4613      	mov	r3, r2
 8007bc4:	80fb      	strh	r3, [r7, #6]
    for (size_t i = 0; i < len; i++) {
 8007bc6:	2300      	movs	r3, #0
 8007bc8:	617b      	str	r3, [r7, #20]
 8007bca:	e026      	b.n	8007c1a <crc16_ccitt+0x62>
        crc = crc ^ (((uint8_t*)buf)[i] << 8);
 8007bcc:	68fa      	ldr	r2, [r7, #12]
 8007bce:	697b      	ldr	r3, [r7, #20]
 8007bd0:	4413      	add	r3, r2
 8007bd2:	781b      	ldrb	r3, [r3, #0]
 8007bd4:	021b      	lsls	r3, r3, #8
 8007bd6:	b29a      	uxth	r2, r3
 8007bd8:	88fb      	ldrh	r3, [r7, #6]
 8007bda:	4053      	eors	r3, r2
 8007bdc:	b29b      	uxth	r3, r3
 8007bde:	80fb      	strh	r3, [r7, #6]
        for (int j = 0; j < 8; j++) {
 8007be0:	2300      	movs	r3, #0
 8007be2:	613b      	str	r3, [r7, #16]
 8007be4:	e013      	b.n	8007c0e <crc16_ccitt+0x56>
            if (crc & 0x8000) {
 8007be6:	88fb      	ldrh	r3, [r7, #6]
 8007be8:	b21b      	sxth	r3, r3
 8007bea:	2b00      	cmp	r3, #0
 8007bec:	da09      	bge.n	8007c02 <crc16_ccitt+0x4a>
                crc = (crc << 1) ^ 0x1021;
 8007bee:	88fb      	ldrh	r3, [r7, #6]
 8007bf0:	005b      	lsls	r3, r3, #1
 8007bf2:	b29b      	uxth	r3, r3
 8007bf4:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 8007bf8:	f083 0301 	eor.w	r3, r3, #1
 8007bfc:	b29b      	uxth	r3, r3
 8007bfe:	80fb      	strh	r3, [r7, #6]
 8007c00:	e002      	b.n	8007c08 <crc16_ccitt+0x50>
            } else {
                crc = (crc << 1);
 8007c02:	88fb      	ldrh	r3, [r7, #6]
 8007c04:	005b      	lsls	r3, r3, #1
 8007c06:	80fb      	strh	r3, [r7, #6]
>>>>>>> 752c83b... update binaries
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
    for (size_t i = 0; i < len; i++) {
        crc = crc ^ (((uint8_t*)buf)[i] << 8);
        for (int j = 0; j < 8; j++) {
<<<<<<< HEAD
 8007bec:	693b      	ldr	r3, [r7, #16]
 8007bee:	3301      	adds	r3, #1
 8007bf0:	613b      	str	r3, [r7, #16]
 8007bf2:	693b      	ldr	r3, [r7, #16]
 8007bf4:	2b07      	cmp	r3, #7
 8007bf6:	dde8      	ble.n	8007bca <crc16_ccitt+0x2e>
=======
 8007c08:	693b      	ldr	r3, [r7, #16]
 8007c0a:	3301      	adds	r3, #1
 8007c0c:	613b      	str	r3, [r7, #16]
 8007c0e:	693b      	ldr	r3, [r7, #16]
 8007c10:	2b07      	cmp	r3, #7
 8007c12:	dde8      	ble.n	8007be6 <crc16_ccitt+0x2e>
>>>>>>> 752c83b... update binaries
        *hash *= FNV_1_PRIME_64;
    }
}

uint16_t crc16_ccitt(const void *buf, size_t len, uint16_t crc) {
    for (size_t i = 0; i < len; i++) {
<<<<<<< HEAD
 8007bf8:	697b      	ldr	r3, [r7, #20]
 8007bfa:	3301      	adds	r3, #1
 8007bfc:	617b      	str	r3, [r7, #20]
 8007bfe:	697a      	ldr	r2, [r7, #20]
 8007c00:	68bb      	ldr	r3, [r7, #8]
 8007c02:	429a      	cmp	r2, r3
 8007c04:	d3d4      	bcc.n	8007bb0 <crc16_ccitt+0x14>
=======
 8007c14:	697b      	ldr	r3, [r7, #20]
 8007c16:	3301      	adds	r3, #1
 8007c18:	617b      	str	r3, [r7, #20]
 8007c1a:	697a      	ldr	r2, [r7, #20]
 8007c1c:	68bb      	ldr	r3, [r7, #8]
 8007c1e:	429a      	cmp	r2, r3
 8007c20:	d3d4      	bcc.n	8007bcc <crc16_ccitt+0x14>
>>>>>>> 752c83b... update binaries
                crc = (crc << 1);
            }
        }
    }

    return crc;
<<<<<<< HEAD
 8007c06:	88fb      	ldrh	r3, [r7, #6]
}
 8007c08:	4618      	mov	r0, r3
 8007c0a:	371c      	adds	r7, #28
 8007c0c:	46bd      	mov	sp, r7
 8007c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c12:	4770      	bx	lr

08007c14 <_local_ctor_5.lto_priv.158>:
=======
 8007c22:	88fb      	ldrh	r3, [r7, #6]
}
 8007c24:	4618      	mov	r0, r3
 8007c26:	371c      	adds	r7, #28
 8007c28:	46bd      	mov	sp, r7
 8007c2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c2e:	4770      	bx	lr

08007c30 <_local_ctor_5.lto_priv.155>:
>>>>>>> 752c83b... update binaries
#include <common/ctor.h>

#include <ch.h>

RUN_ON(CH_SYS_INIT) {
<<<<<<< HEAD
 8007c14:	b580      	push	{r7, lr}
 8007c16:	af00      	add	r7, sp, #0
    chSysInit();
 8007c18:	f004 fe92 	bl	800c940 <chSysInit>
}
 8007c1c:	bd80      	pop	{r7, pc}
 8007c1e:	bf00      	nop

08007c20 <_local_ctor_5.lto_priv.159>:
=======
 8007c30:	b580      	push	{r7, lr}
 8007c32:	af00      	add	r7, sp, #0
    chSysInit();
 8007c34:	f004 fec8 	bl	800c9c8 <chSysInit>
}
 8007c38:	bd80      	pop	{r7, pc}
 8007c3a:	bf00      	nop

08007c3c <_local_ctor_5.lto_priv.156>:
>>>>>>> 752c83b... update binaries
#include <common/ctor.h>

#include <hal.h>

RUN_ON(CH_HAL_INIT) {
<<<<<<< HEAD
 8007c20:	b580      	push	{r7, lr}
 8007c22:	af00      	add	r7, sp, #0
    halInit();
 8007c24:	f002 f8de 	bl	8009de4 <halInit>
}
 8007c28:	bd80      	pop	{r7, pc}
 8007c2a:	bf00      	nop

08007c2c <st_lld_get_counter.lto_priv.143>:
=======
 8007c3c:	b580      	push	{r7, lr}
 8007c3e:	af00      	add	r7, sp, #0
    halInit();
 8007c40:	f002 f914 	bl	8009e6c <halInit>
}
 8007c44:	bd80      	pop	{r7, pc}
 8007c46:	bf00      	nop

08007c48 <st_lld_get_counter.lto_priv.149>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
<<<<<<< HEAD
 8007c2c:	b480      	push	{r7}
 8007c2e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8007c30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007c34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007c36:	b29b      	uxth	r3, r3
}
 8007c38:	4618      	mov	r0, r3
 8007c3a:	46bd      	mov	sp, r7
 8007c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c40:	4770      	bx	lr
 8007c42:	bf00      	nop

08007c44 <port_timer_get_time.lto_priv.140>:
=======
 8007c48:	b480      	push	{r7}
 8007c4a:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8007c4c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007c50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007c52:	b29b      	uxth	r3, r3
}
 8007c54:	4618      	mov	r0, r3
 8007c56:	46bd      	mov	sp, r7
 8007c58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c5c:	4770      	bx	lr
 8007c5e:	bf00      	nop

08007c60 <port_timer_get_time.lto_priv.147>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
<<<<<<< HEAD
 8007c44:	b580      	push	{r7, lr}
 8007c46:	af00      	add	r7, sp, #0

  return stGetCounter();
 8007c48:	f7ff fff0 	bl	8007c2c <st_lld_get_counter.lto_priv.143>
 8007c4c:	4603      	mov	r3, r0
}
 8007c4e:	4618      	mov	r0, r3
 8007c50:	bd80      	pop	{r7, pc}
 8007c52:	bf00      	nop

08007c54 <chVTGetSystemTimeX.lto_priv.151>:
=======
 8007c60:	b580      	push	{r7, lr}
 8007c62:	af00      	add	r7, sp, #0

  return stGetCounter();
 8007c64:	f7ff fff0 	bl	8007c48 <st_lld_get_counter.lto_priv.149>
 8007c68:	4603      	mov	r3, r0
}
 8007c6a:	4618      	mov	r0, r3
 8007c6c:	bd80      	pop	{r7, pc}
 8007c6e:	bf00      	nop

08007c70 <chVTGetSystemTimeX.lto_priv.144>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
<<<<<<< HEAD
 8007c54:	b580      	push	{r7, lr}
 8007c56:	af00      	add	r7, sp, #0
=======
 8007c70:	b580      	push	{r7, lr}
 8007c72:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
<<<<<<< HEAD
 8007c58:	f7ff fff4 	bl	8007c44 <port_timer_get_time.lto_priv.140>
 8007c5c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8007c5e:	4618      	mov	r0, r3
 8007c60:	bd80      	pop	{r7, pc}
 8007c62:	bf00      	nop

08007c64 <_local_ctor_39>:
=======
 8007c74:	f7ff fff4 	bl	8007c60 <port_timer_get_time.lto_priv.147>
 8007c78:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8007c7a:	4618      	mov	r0, r3
 8007c7c:	bd80      	pop	{r7, pc}
 8007c7e:	bf00      	nop
>>>>>>> 752c83b... update binaries

08007c80 <_local_ctor_41>:

static void timing_state_update_task_func(struct worker_thread_timer_task_s* task);

// This task must run more frequently than the system timer wraps
// For a 16 bit timer running at 10KHz, the wraparound interval is 6.5536 seconds
RUN_AFTER(WORKER_THREADS_INIT) {
<<<<<<< HEAD
 8007c64:	b580      	push	{r7, lr}
 8007c66:	b082      	sub	sp, #8
 8007c68:	af02      	add	r7, sp, #8
    worker_thread_add_timer_task(&WT, &timing_state_update_task, timing_state_update_task_func, NULL, S2ST(10), true);
 8007c6a:	f248 63a0 	movw	r3, #34464	; 0x86a0
 8007c6e:	9300      	str	r3, [sp, #0]
 8007c70:	2301      	movs	r3, #1
 8007c72:	9301      	str	r3, [sp, #4]
 8007c74:	4803      	ldr	r0, [pc, #12]	; (8007c84 <_local_ctor_39+0x20>)
 8007c76:	4904      	ldr	r1, [pc, #16]	; (8007c88 <_local_ctor_39+0x24>)
 8007c78:	4a04      	ldr	r2, [pc, #16]	; (8007c8c <_local_ctor_39+0x28>)
 8007c7a:	2300      	movs	r3, #0
 8007c7c:	f000 fe18 	bl	80088b0 <worker_thread_add_timer_task>
}
 8007c80:	46bd      	mov	sp, r7
 8007c82:	bd80      	pop	{r7, pc}
 8007c84:	20000a20 	.word	0x20000a20
 8007c88:	2000144c 	.word	0x2000144c
 8007c8c:	08007dbd 	.word	0x08007dbd

08007c90 <micros>:
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
    uint32_t delta_ms = delta_ticks * (1000.0f / CH_CFG_ST_FREQUENCY);
    return ((uint32_t)timing_state[idx].update_seconds*1000) + delta_ms;
}

uint32_t micros(void) {
 8007c90:	b580      	push	{r7, lr}
 8007c92:	b084      	sub	sp, #16
 8007c94:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007c96:	4b16      	ldr	r3, [pc, #88]	; (8007cf0 <micros+0x60>)
 8007c98:	781b      	ldrb	r3, [r3, #0]
 8007c9a:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 8007c9c:	f7ff ffda 	bl	8007c54 <chVTGetSystemTimeX.lto_priv.151>
 8007ca0:	4603      	mov	r3, r0
 8007ca2:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
 8007ca4:	89bb      	ldrh	r3, [r7, #12]
 8007ca6:	7bfa      	ldrb	r2, [r7, #15]
 8007ca8:	4912      	ldr	r1, [pc, #72]	; (8007cf4 <micros+0x64>)
 8007caa:	0112      	lsls	r2, r2, #4
 8007cac:	440a      	add	r2, r1
 8007cae:	3208      	adds	r2, #8
 8007cb0:	8812      	ldrh	r2, [r2, #0]
 8007cb2:	1a9b      	subs	r3, r3, r2
 8007cb4:	60bb      	str	r3, [r7, #8]
    uint32_t delta_us = delta_ticks * (1000000.0f / CH_CFG_ST_FREQUENCY);
 8007cb6:	68b8      	ldr	r0, [r7, #8]
 8007cb8:	f7fb febc 	bl	8003a34 <__aeabi_ui2f>
 8007cbc:	4603      	mov	r3, r0
 8007cbe:	4618      	mov	r0, r3
 8007cc0:	490d      	ldr	r1, [pc, #52]	; (8007cf8 <micros+0x68>)
 8007cc2:	f7fb ff0f 	bl	8003ae4 <__aeabi_fmul>
 8007cc6:	4603      	mov	r3, r0
 8007cc8:	4618      	mov	r0, r3
 8007cca:	f7fb fb05 	bl	80032d8 <__aeabi_f2uiz>
 8007cce:	4603      	mov	r3, r0
 8007cd0:	607b      	str	r3, [r7, #4]
    return ((uint32_t)timing_state[idx].update_seconds*1000000) + delta_us;
 8007cd2:	7bfb      	ldrb	r3, [r7, #15]
 8007cd4:	4a07      	ldr	r2, [pc, #28]	; (8007cf4 <micros+0x64>)
 8007cd6:	011b      	lsls	r3, r3, #4
 8007cd8:	4413      	add	r3, r2
 8007cda:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007cde:	4b07      	ldr	r3, [pc, #28]	; (8007cfc <micros+0x6c>)
 8007ce0:	fb03 f202 	mul.w	r2, r3, r2
 8007ce4:	687b      	ldr	r3, [r7, #4]
 8007ce6:	4413      	add	r3, r2
}
 8007ce8:	4618      	mov	r0, r3
 8007cea:	3710      	adds	r7, #16
 8007cec:	46bd      	mov	sp, r7
 8007cee:	bd80      	pop	{r7, pc}
 8007cf0:	20001448 	.word	0x20001448
 8007cf4:	20001428 	.word	0x20001428
 8007cf8:	42c80000 	.word	0x42c80000
 8007cfc:	000f4240 	.word	0x000f4240

08007d00 <micros64>:

uint64_t micros64(void) {
 8007d00:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8007d04:	b084      	sub	sp, #16
 8007d06:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007d08:	4b29      	ldr	r3, [pc, #164]	; (8007db0 <micros64+0xb0>)
 8007d0a:	781b      	ldrb	r3, [r3, #0]
 8007d0c:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 8007d0e:	f7ff ffa1 	bl	8007c54 <chVTGetSystemTimeX.lto_priv.151>
 8007d12:	4603      	mov	r3, r0
 8007d14:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[idx].update_systime;
 8007d16:	89bb      	ldrh	r3, [r7, #12]
 8007d18:	7bfa      	ldrb	r2, [r7, #15]
 8007d1a:	4926      	ldr	r1, [pc, #152]	; (8007db4 <micros64+0xb4>)
 8007d1c:	0112      	lsls	r2, r2, #4
 8007d1e:	440a      	add	r2, r1
 8007d20:	3208      	adds	r2, #8
 8007d22:	8812      	ldrh	r2, [r2, #0]
 8007d24:	1a9b      	subs	r3, r3, r2
 8007d26:	60bb      	str	r3, [r7, #8]
    uint32_t delta_us = delta_ticks * (1000000.0f / CH_CFG_ST_FREQUENCY);
 8007d28:	68b8      	ldr	r0, [r7, #8]
 8007d2a:	f7fb fe83 	bl	8003a34 <__aeabi_ui2f>
 8007d2e:	4603      	mov	r3, r0
 8007d30:	4618      	mov	r0, r3
 8007d32:	4921      	ldr	r1, [pc, #132]	; (8007db8 <micros64+0xb8>)
 8007d34:	f7fb fed6 	bl	8003ae4 <__aeabi_fmul>
 8007d38:	4603      	mov	r3, r0
 8007d3a:	4618      	mov	r0, r3
 8007d3c:	f7fb facc 	bl	80032d8 <__aeabi_f2uiz>
 8007d40:	4603      	mov	r3, r0
 8007d42:	607b      	str	r3, [r7, #4]
    return (timing_state[idx].update_seconds*1000000) + delta_us;
 8007d44:	7bfb      	ldrb	r3, [r7, #15]
 8007d46:	4a1b      	ldr	r2, [pc, #108]	; (8007db4 <micros64+0xb4>)
 8007d48:	011b      	lsls	r3, r3, #4
 8007d4a:	4413      	add	r3, r2
 8007d4c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007d50:	4602      	mov	r2, r0
 8007d52:	460b      	mov	r3, r1
 8007d54:	ea4f 2b43 	mov.w	fp, r3, lsl #9
 8007d58:	ea4b 5bd2 	orr.w	fp, fp, r2, lsr #23
 8007d5c:	ea4f 2a42 	mov.w	sl, r2, lsl #9
 8007d60:	4652      	mov	r2, sl
 8007d62:	465b      	mov	r3, fp
 8007d64:	015d      	lsls	r5, r3, #5
 8007d66:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8007d6a:	0154      	lsls	r4, r2, #5
 8007d6c:	1aa4      	subs	r4, r4, r2
 8007d6e:	eb65 0503 	sbc.w	r5, r5, r3
 8007d72:	1824      	adds	r4, r4, r0
 8007d74:	eb45 0501 	adc.w	r5, r5, r1
 8007d78:	ea4f 1985 	mov.w	r9, r5, lsl #6
 8007d7c:	ea49 6994 	orr.w	r9, r9, r4, lsr #26
 8007d80:	ea4f 1884 	mov.w	r8, r4, lsl #6
 8007d84:	ebb8 0804 	subs.w	r8, r8, r4
 8007d88:	eb69 0905 	sbc.w	r9, r9, r5
 8007d8c:	eb10 0008 	adds.w	r0, r0, r8
 8007d90:	eb41 0109 	adc.w	r1, r1, r9
 8007d94:	687b      	ldr	r3, [r7, #4]
 8007d96:	461a      	mov	r2, r3
 8007d98:	f04f 0300 	mov.w	r3, #0
 8007d9c:	1812      	adds	r2, r2, r0
 8007d9e:	eb43 0301 	adc.w	r3, r3, r1
}
 8007da2:	4610      	mov	r0, r2
 8007da4:	4619      	mov	r1, r3
 8007da6:	3710      	adds	r7, #16
 8007da8:	46bd      	mov	sp, r7
 8007daa:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8007dae:	bf00      	nop
 8007db0:	20001448 	.word	0x20001448
 8007db4:	20001428 	.word	0x20001428
 8007db8:	42c80000 	.word	0x42c80000

08007dbc <timing_state_update_task_func>:
=======
 8007c80:	b580      	push	{r7, lr}
 8007c82:	b082      	sub	sp, #8
 8007c84:	af02      	add	r7, sp, #8
    worker_thread_add_timer_task(&WT, &timing_state_update_task, timing_state_update_task_func, NULL, S2ST(5), true);
 8007c86:	f24c 3350 	movw	r3, #50000	; 0xc350
 8007c8a:	9300      	str	r3, [sp, #0]
 8007c8c:	2301      	movs	r3, #1
 8007c8e:	9301      	str	r3, [sp, #4]
 8007c90:	4803      	ldr	r0, [pc, #12]	; (8007ca0 <_local_ctor_41+0x20>)
 8007c92:	4904      	ldr	r1, [pc, #16]	; (8007ca4 <_local_ctor_41+0x24>)
 8007c94:	4a04      	ldr	r2, [pc, #16]	; (8007ca8 <_local_ctor_41+0x28>)
 8007c96:	2300      	movs	r3, #0
 8007c98:	f000 fe16 	bl	80088c8 <worker_thread_add_timer_task>
}
 8007c9c:	46bd      	mov	sp, r7
 8007c9e:	bd80      	pop	{r7, pc}
 8007ca0:	20000a20 	.word	0x20000a20
 8007ca4:	2000144c 	.word	0x2000144c
 8007ca8:	08007e0d 	.word	0x08007e0d

08007cac <millis>:

uint32_t millis(void) {
 8007cac:	b580      	push	{r7, lr}
 8007cae:	b084      	sub	sp, #16
 8007cb0:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007cb2:	4b13      	ldr	r3, [pc, #76]	; (8007d00 <millis+0x54>)
 8007cb4:	781b      	ldrb	r3, [r3, #0]
 8007cb6:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 8007cb8:	f7ff ffda 	bl	8007c70 <chVTGetSystemTimeX.lto_priv.144>
 8007cbc:	4603      	mov	r3, r0
 8007cbe:	81bb      	strh	r3, [r7, #12]
    systime_t delta_ticks = systime_now - timing_state[idx].update_systime;
 8007cc0:	7bfb      	ldrb	r3, [r7, #15]
 8007cc2:	4a10      	ldr	r2, [pc, #64]	; (8007d04 <millis+0x58>)
 8007cc4:	011b      	lsls	r3, r3, #4
 8007cc6:	4413      	add	r3, r2
 8007cc8:	3308      	adds	r3, #8
 8007cca:	881b      	ldrh	r3, [r3, #0]
 8007ccc:	89ba      	ldrh	r2, [r7, #12]
 8007cce:	1ad3      	subs	r3, r2, r3
 8007cd0:	817b      	strh	r3, [r7, #10]
    // assume (CH_CFG_ST_FREQUENCY/1000) > 0
    uint32_t delta_ms = delta_ticks / (CH_CFG_ST_FREQUENCY / 1000UL);
 8007cd2:	897b      	ldrh	r3, [r7, #10]
 8007cd4:	4a0c      	ldr	r2, [pc, #48]	; (8007d08 <millis+0x5c>)
 8007cd6:	fba2 2303 	umull	r2, r3, r2, r3
 8007cda:	08db      	lsrs	r3, r3, #3
 8007cdc:	b29b      	uxth	r3, r3
 8007cde:	607b      	str	r3, [r7, #4]
    return ((uint32_t)timing_state[idx].update_seconds * 1000UL) + delta_ms;
 8007ce0:	7bfb      	ldrb	r3, [r7, #15]
 8007ce2:	4a08      	ldr	r2, [pc, #32]	; (8007d04 <millis+0x58>)
 8007ce4:	011b      	lsls	r3, r3, #4
 8007ce6:	4413      	add	r3, r2
 8007ce8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007cec:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8007cf0:	fb03 f202 	mul.w	r2, r3, r2
 8007cf4:	687b      	ldr	r3, [r7, #4]
 8007cf6:	4413      	add	r3, r2
}
 8007cf8:	4618      	mov	r0, r3
 8007cfa:	3710      	adds	r7, #16
 8007cfc:	46bd      	mov	sp, r7
 8007cfe:	bd80      	pop	{r7, pc}
 8007d00:	20001448 	.word	0x20001448
 8007d04:	20001428 	.word	0x20001428
 8007d08:	cccccccd 	.word	0xcccccccd

08007d0c <micros>:

uint32_t micros(void) {
 8007d0c:	b580      	push	{r7, lr}
 8007d0e:	b084      	sub	sp, #16
 8007d10:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007d12:	4b12      	ldr	r3, [pc, #72]	; (8007d5c <micros+0x50>)
 8007d14:	781b      	ldrb	r3, [r3, #0]
 8007d16:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 8007d18:	f7ff ffaa 	bl	8007c70 <chVTGetSystemTimeX.lto_priv.144>
 8007d1c:	4603      	mov	r3, r0
 8007d1e:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now - timing_state[idx].update_systime;
 8007d20:	89bb      	ldrh	r3, [r7, #12]
 8007d22:	7bfa      	ldrb	r2, [r7, #15]
 8007d24:	490e      	ldr	r1, [pc, #56]	; (8007d60 <micros+0x54>)
 8007d26:	0112      	lsls	r2, r2, #4
 8007d28:	440a      	add	r2, r1
 8007d2a:	3208      	adds	r2, #8
 8007d2c:	8812      	ldrh	r2, [r2, #0]
 8007d2e:	1a9b      	subs	r3, r3, r2
 8007d30:	60bb      	str	r3, [r7, #8]
    // don't assume (CH_CFG_ST_FREQUENCY/1000) > 0
    uint32_t delta_us = delta_ticks * (1000000UL / CH_CFG_ST_FREQUENCY);
 8007d32:	68bb      	ldr	r3, [r7, #8]
 8007d34:	2264      	movs	r2, #100	; 0x64
 8007d36:	fb02 f303 	mul.w	r3, r2, r3
 8007d3a:	607b      	str	r3, [r7, #4]
    return ((uint32_t)timing_state[idx].update_seconds * 1000000UL) + delta_us;
 8007d3c:	7bfb      	ldrb	r3, [r7, #15]
 8007d3e:	4a08      	ldr	r2, [pc, #32]	; (8007d60 <micros+0x54>)
 8007d40:	011b      	lsls	r3, r3, #4
 8007d42:	4413      	add	r3, r2
 8007d44:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007d48:	4b06      	ldr	r3, [pc, #24]	; (8007d64 <micros+0x58>)
 8007d4a:	fb03 f202 	mul.w	r2, r3, r2
 8007d4e:	687b      	ldr	r3, [r7, #4]
 8007d50:	4413      	add	r3, r2
}
 8007d52:	4618      	mov	r0, r3
 8007d54:	3710      	adds	r7, #16
 8007d56:	46bd      	mov	sp, r7
 8007d58:	bd80      	pop	{r7, pc}
 8007d5a:	bf00      	nop
 8007d5c:	20001448 	.word	0x20001448
 8007d60:	20001428 	.word	0x20001428
 8007d64:	000f4240 	.word	0x000f4240

08007d68 <micros64>:

uint64_t micros64(void) {
 8007d68:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8007d6c:	b084      	sub	sp, #16
 8007d6e:	af00      	add	r7, sp, #0
    uint8_t idx = timing_state_idx;
 8007d70:	4b24      	ldr	r3, [pc, #144]	; (8007e04 <micros64+0x9c>)
 8007d72:	781b      	ldrb	r3, [r3, #0]
 8007d74:	73fb      	strb	r3, [r7, #15]
    systime_t systime_now = chVTGetSystemTimeX();
 8007d76:	f7ff ff7b 	bl	8007c70 <chVTGetSystemTimeX.lto_priv.144>
 8007d7a:	4603      	mov	r3, r0
 8007d7c:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now - timing_state[idx].update_systime;
 8007d7e:	89bb      	ldrh	r3, [r7, #12]
 8007d80:	7bfa      	ldrb	r2, [r7, #15]
 8007d82:	4921      	ldr	r1, [pc, #132]	; (8007e08 <micros64+0xa0>)
 8007d84:	0112      	lsls	r2, r2, #4
 8007d86:	440a      	add	r2, r1
 8007d88:	3208      	adds	r2, #8
 8007d8a:	8812      	ldrh	r2, [r2, #0]
 8007d8c:	1a9b      	subs	r3, r3, r2
 8007d8e:	60bb      	str	r3, [r7, #8]
    // don't assume (CH_CFG_ST_FREQUENCY/1000) > 0
    uint32_t delta_us = delta_ticks * (1000000UL / CH_CFG_ST_FREQUENCY);
 8007d90:	68bb      	ldr	r3, [r7, #8]
 8007d92:	2264      	movs	r2, #100	; 0x64
 8007d94:	fb02 f303 	mul.w	r3, r2, r3
 8007d98:	607b      	str	r3, [r7, #4]
    return (timing_state[idx].update_seconds * 1000000UL) + delta_us;
 8007d9a:	7bfb      	ldrb	r3, [r7, #15]
 8007d9c:	4a1a      	ldr	r2, [pc, #104]	; (8007e08 <micros64+0xa0>)
 8007d9e:	011b      	lsls	r3, r3, #4
 8007da0:	4413      	add	r3, r2
 8007da2:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007da6:	4602      	mov	r2, r0
 8007da8:	460b      	mov	r3, r1
 8007daa:	ea4f 2b43 	mov.w	fp, r3, lsl #9
 8007dae:	ea4b 5bd2 	orr.w	fp, fp, r2, lsr #23
 8007db2:	ea4f 2a42 	mov.w	sl, r2, lsl #9
 8007db6:	4652      	mov	r2, sl
 8007db8:	465b      	mov	r3, fp
 8007dba:	015d      	lsls	r5, r3, #5
 8007dbc:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8007dc0:	0154      	lsls	r4, r2, #5
 8007dc2:	1aa4      	subs	r4, r4, r2
 8007dc4:	eb65 0503 	sbc.w	r5, r5, r3
 8007dc8:	1824      	adds	r4, r4, r0
 8007dca:	eb45 0501 	adc.w	r5, r5, r1
 8007dce:	ea4f 1985 	mov.w	r9, r5, lsl #6
 8007dd2:	ea49 6994 	orr.w	r9, r9, r4, lsr #26
 8007dd6:	ea4f 1884 	mov.w	r8, r4, lsl #6
 8007dda:	ebb8 0804 	subs.w	r8, r8, r4
 8007dde:	eb69 0905 	sbc.w	r9, r9, r5
 8007de2:	eb10 0008 	adds.w	r0, r0, r8
 8007de6:	eb41 0109 	adc.w	r1, r1, r9
 8007dea:	687b      	ldr	r3, [r7, #4]
 8007dec:	461a      	mov	r2, r3
 8007dee:	f04f 0300 	mov.w	r3, #0
 8007df2:	1812      	adds	r2, r2, r0
 8007df4:	eb43 0301 	adc.w	r3, r3, r1
}
 8007df8:	4610      	mov	r0, r2
 8007dfa:	4619      	mov	r1, r3
 8007dfc:	3710      	adds	r7, #16
 8007dfe:	46bd      	mov	sp, r7
 8007e00:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8007e04:	20001448 	.word	0x20001448
 8007e08:	20001428 	.word	0x20001428

08007e0c <timing_state_update_task_func>:
>>>>>>> 752c83b... update binaries
void usleep(uint32_t delay) {
    uint32_t tbegin = micros();
    while (micros() - tbegin < delay);
}

static void timing_state_update_task_func(struct worker_thread_timer_task_s* task) {
<<<<<<< HEAD
 8007dbc:	b590      	push	{r4, r7, lr}
 8007dbe:	b085      	sub	sp, #20
 8007dc0:	af00      	add	r7, sp, #0
 8007dc2:	6078      	str	r0, [r7, #4]
    (void)task;
    uint8_t next_timing_state_idx = (timing_state_idx+1) % 2;
 8007dc4:	4b27      	ldr	r3, [pc, #156]	; (8007e64 <timing_state_update_task_func+0xa8>)
 8007dc6:	781b      	ldrb	r3, [r3, #0]
 8007dc8:	b2db      	uxtb	r3, r3
 8007dca:	1c5a      	adds	r2, r3, #1
 8007dcc:	4b26      	ldr	r3, [pc, #152]	; (8007e68 <timing_state_update_task_func+0xac>)
 8007dce:	4013      	ands	r3, r2
 8007dd0:	2b00      	cmp	r3, #0
 8007dd2:	da03      	bge.n	8007ddc <timing_state_update_task_func+0x20>
 8007dd4:	3b01      	subs	r3, #1
 8007dd6:	f063 0301 	orn	r3, r3, #1
 8007dda:	3301      	adds	r3, #1
 8007ddc:	73fb      	strb	r3, [r7, #15]

    systime_t systime_now = chVTGetSystemTimeX();
 8007dde:	f7ff ff39 	bl	8007c54 <chVTGetSystemTimeX.lto_priv.151>
 8007de2:	4603      	mov	r3, r0
 8007de4:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now-timing_state[timing_state_idx].update_systime;
 8007de6:	89bb      	ldrh	r3, [r7, #12]
 8007de8:	4a1e      	ldr	r2, [pc, #120]	; (8007e64 <timing_state_update_task_func+0xa8>)
 8007dea:	7812      	ldrb	r2, [r2, #0]
 8007dec:	b2d2      	uxtb	r2, r2
 8007dee:	491f      	ldr	r1, [pc, #124]	; (8007e6c <timing_state_update_task_func+0xb0>)
 8007df0:	0112      	lsls	r2, r2, #4
 8007df2:	440a      	add	r2, r1
 8007df4:	3208      	adds	r2, #8
 8007df6:	8812      	ldrh	r2, [r2, #0]
 8007df8:	1a9b      	subs	r3, r3, r2
 8007dfa:	60bb      	str	r3, [r7, #8]

    timing_state[next_timing_state_idx].update_seconds = timing_state[timing_state_idx].update_seconds + delta_ticks / CH_CFG_ST_FREQUENCY;
 8007dfc:	7bfc      	ldrb	r4, [r7, #15]
 8007dfe:	4b19      	ldr	r3, [pc, #100]	; (8007e64 <timing_state_update_task_func+0xa8>)
 8007e00:	781b      	ldrb	r3, [r3, #0]
 8007e02:	b2db      	uxtb	r3, r3
 8007e04:	4a19      	ldr	r2, [pc, #100]	; (8007e6c <timing_state_update_task_func+0xb0>)
 8007e06:	011b      	lsls	r3, r3, #4
 8007e08:	4413      	add	r3, r2
 8007e0a:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007e0e:	68bb      	ldr	r3, [r7, #8]
 8007e10:	4a17      	ldr	r2, [pc, #92]	; (8007e70 <timing_state_update_task_func+0xb4>)
 8007e12:	fba2 2303 	umull	r2, r3, r2, r3
 8007e16:	0b5b      	lsrs	r3, r3, #13
 8007e18:	461a      	mov	r2, r3
 8007e1a:	f04f 0300 	mov.w	r3, #0
 8007e1e:	1812      	adds	r2, r2, r0
 8007e20:	eb43 0301 	adc.w	r3, r3, r1
 8007e24:	4811      	ldr	r0, [pc, #68]	; (8007e6c <timing_state_update_task_func+0xb0>)
 8007e26:	0121      	lsls	r1, r4, #4
 8007e28:	4401      	add	r1, r0
 8007e2a:	e9c1 2300 	strd	r2, r3, [r1]
    timing_state[next_timing_state_idx].update_systime = systime_now - (delta_ticks % CH_CFG_ST_FREQUENCY);
 8007e2e:	7bf9      	ldrb	r1, [r7, #15]
 8007e30:	68ba      	ldr	r2, [r7, #8]
 8007e32:	4b0f      	ldr	r3, [pc, #60]	; (8007e70 <timing_state_update_task_func+0xb4>)
 8007e34:	fba3 0302 	umull	r0, r3, r3, r2
 8007e38:	0b5b      	lsrs	r3, r3, #13
 8007e3a:	f242 7010 	movw	r0, #10000	; 0x2710
 8007e3e:	fb00 f303 	mul.w	r3, r0, r3
 8007e42:	1ad3      	subs	r3, r2, r3
 8007e44:	b29b      	uxth	r3, r3
 8007e46:	89ba      	ldrh	r2, [r7, #12]
 8007e48:	1ad3      	subs	r3, r2, r3
 8007e4a:	b298      	uxth	r0, r3
 8007e4c:	4a07      	ldr	r2, [pc, #28]	; (8007e6c <timing_state_update_task_func+0xb0>)
 8007e4e:	010b      	lsls	r3, r1, #4
 8007e50:	4413      	add	r3, r2
 8007e52:	3308      	adds	r3, #8
 8007e54:	4602      	mov	r2, r0
 8007e56:	801a      	strh	r2, [r3, #0]

    timing_state_idx = next_timing_state_idx;
 8007e58:	4a02      	ldr	r2, [pc, #8]	; (8007e64 <timing_state_update_task_func+0xa8>)
 8007e5a:	7bfb      	ldrb	r3, [r7, #15]
 8007e5c:	7013      	strb	r3, [r2, #0]
}
 8007e5e:	3714      	adds	r7, #20
 8007e60:	46bd      	mov	sp, r7
 8007e62:	bd90      	pop	{r4, r7, pc}
 8007e64:	20001448 	.word	0x20001448
 8007e68:	80000001 	.word	0x80000001
 8007e6c:	20001428 	.word	0x20001428
 8007e70:	d1b71759 	.word	0xd1b71759

08007e74 <system_get_restart_allowed>:
=======
 8007e0c:	b590      	push	{r4, r7, lr}
 8007e0e:	b085      	sub	sp, #20
 8007e10:	af00      	add	r7, sp, #0
 8007e12:	6078      	str	r0, [r7, #4]
    (void)task;
    uint8_t next_timing_state_idx = (timing_state_idx+1) % 2;
 8007e14:	4b27      	ldr	r3, [pc, #156]	; (8007eb4 <timing_state_update_task_func+0xa8>)
 8007e16:	781b      	ldrb	r3, [r3, #0]
 8007e18:	b2db      	uxtb	r3, r3
 8007e1a:	1c5a      	adds	r2, r3, #1
 8007e1c:	4b26      	ldr	r3, [pc, #152]	; (8007eb8 <timing_state_update_task_func+0xac>)
 8007e1e:	4013      	ands	r3, r2
 8007e20:	2b00      	cmp	r3, #0
 8007e22:	da03      	bge.n	8007e2c <timing_state_update_task_func+0x20>
 8007e24:	3b01      	subs	r3, #1
 8007e26:	f063 0301 	orn	r3, r3, #1
 8007e2a:	3301      	adds	r3, #1
 8007e2c:	73fb      	strb	r3, [r7, #15]

    systime_t systime_now = chVTGetSystemTimeX();
 8007e2e:	f7ff ff1f 	bl	8007c70 <chVTGetSystemTimeX.lto_priv.144>
 8007e32:	4603      	mov	r3, r0
 8007e34:	81bb      	strh	r3, [r7, #12]
    uint32_t delta_ticks = systime_now - timing_state[timing_state_idx].update_systime;
 8007e36:	89bb      	ldrh	r3, [r7, #12]
 8007e38:	4a1e      	ldr	r2, [pc, #120]	; (8007eb4 <timing_state_update_task_func+0xa8>)
 8007e3a:	7812      	ldrb	r2, [r2, #0]
 8007e3c:	b2d2      	uxtb	r2, r2
 8007e3e:	491f      	ldr	r1, [pc, #124]	; (8007ebc <timing_state_update_task_func+0xb0>)
 8007e40:	0112      	lsls	r2, r2, #4
 8007e42:	440a      	add	r2, r1
 8007e44:	3208      	adds	r2, #8
 8007e46:	8812      	ldrh	r2, [r2, #0]
 8007e48:	1a9b      	subs	r3, r3, r2
 8007e4a:	60bb      	str	r3, [r7, #8]

    timing_state[next_timing_state_idx].update_seconds = timing_state[timing_state_idx].update_seconds + delta_ticks / CH_CFG_ST_FREQUENCY;
 8007e4c:	7bfc      	ldrb	r4, [r7, #15]
 8007e4e:	4b19      	ldr	r3, [pc, #100]	; (8007eb4 <timing_state_update_task_func+0xa8>)
 8007e50:	781b      	ldrb	r3, [r3, #0]
 8007e52:	b2db      	uxtb	r3, r3
 8007e54:	4a19      	ldr	r2, [pc, #100]	; (8007ebc <timing_state_update_task_func+0xb0>)
 8007e56:	011b      	lsls	r3, r3, #4
 8007e58:	4413      	add	r3, r2
 8007e5a:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007e5e:	68bb      	ldr	r3, [r7, #8]
 8007e60:	4a17      	ldr	r2, [pc, #92]	; (8007ec0 <timing_state_update_task_func+0xb4>)
 8007e62:	fba2 2303 	umull	r2, r3, r2, r3
 8007e66:	0b5b      	lsrs	r3, r3, #13
 8007e68:	461a      	mov	r2, r3
 8007e6a:	f04f 0300 	mov.w	r3, #0
 8007e6e:	1812      	adds	r2, r2, r0
 8007e70:	eb43 0301 	adc.w	r3, r3, r1
 8007e74:	4811      	ldr	r0, [pc, #68]	; (8007ebc <timing_state_update_task_func+0xb0>)
 8007e76:	0121      	lsls	r1, r4, #4
 8007e78:	4401      	add	r1, r0
 8007e7a:	e9c1 2300 	strd	r2, r3, [r1]
    timing_state[next_timing_state_idx].update_systime = systime_now - (delta_ticks % CH_CFG_ST_FREQUENCY);
 8007e7e:	7bf9      	ldrb	r1, [r7, #15]
 8007e80:	68ba      	ldr	r2, [r7, #8]
 8007e82:	4b0f      	ldr	r3, [pc, #60]	; (8007ec0 <timing_state_update_task_func+0xb4>)
 8007e84:	fba3 0302 	umull	r0, r3, r3, r2
 8007e88:	0b5b      	lsrs	r3, r3, #13
 8007e8a:	f242 7010 	movw	r0, #10000	; 0x2710
 8007e8e:	fb00 f303 	mul.w	r3, r0, r3
 8007e92:	1ad3      	subs	r3, r2, r3
 8007e94:	b29b      	uxth	r3, r3
 8007e96:	89ba      	ldrh	r2, [r7, #12]
 8007e98:	1ad3      	subs	r3, r2, r3
 8007e9a:	b298      	uxth	r0, r3
 8007e9c:	4a07      	ldr	r2, [pc, #28]	; (8007ebc <timing_state_update_task_func+0xb0>)
 8007e9e:	010b      	lsls	r3, r1, #4
 8007ea0:	4413      	add	r3, r2
 8007ea2:	3308      	adds	r3, #8
 8007ea4:	4602      	mov	r2, r0
 8007ea6:	801a      	strh	r2, [r3, #0]

    timing_state_idx = next_timing_state_idx;
 8007ea8:	4a02      	ldr	r2, [pc, #8]	; (8007eb4 <timing_state_update_task_func+0xa8>)
 8007eaa:	7bfb      	ldrb	r3, [r7, #15]
 8007eac:	7013      	strb	r3, [r2, #0]
}
 8007eae:	3714      	adds	r7, #20
 8007eb0:	46bd      	mov	sp, r7
 8007eb2:	bd90      	pop	{r4, r7, pc}
 8007eb4:	20001448 	.word	0x20001448
 8007eb8:	80000001 	.word	0x80000001
 8007ebc:	20001428 	.word	0x20001428
 8007ec0:	d1b71759 	.word	0xd1b71759

08007ec4 <system_get_restart_allowed>:
>>>>>>> 752c83b... update binaries

void system_set_restart_allowed_cb(restart_allowed_func_ptr_t cb) {
    restart_allowed_cb = cb;
}

bool system_get_restart_allowed(void) {
<<<<<<< HEAD
 8007e74:	b580      	push	{r7, lr}
 8007e76:	af00      	add	r7, sp, #0
    return !restart_allowed_cb || restart_allowed_cb();
 8007e78:	4b08      	ldr	r3, [pc, #32]	; (8007e9c <system_get_restart_allowed+0x28>)
 8007e7a:	681b      	ldr	r3, [r3, #0]
 8007e7c:	2b00      	cmp	r3, #0
 8007e7e:	d005      	beq.n	8007e8c <system_get_restart_allowed+0x18>
 8007e80:	4b06      	ldr	r3, [pc, #24]	; (8007e9c <system_get_restart_allowed+0x28>)
 8007e82:	681b      	ldr	r3, [r3, #0]
 8007e84:	4798      	blx	r3
 8007e86:	4603      	mov	r3, r0
 8007e88:	2b00      	cmp	r3, #0
 8007e8a:	d001      	beq.n	8007e90 <system_get_restart_allowed+0x1c>
 8007e8c:	2301      	movs	r3, #1
 8007e8e:	e000      	b.n	8007e92 <system_get_restart_allowed+0x1e>
 8007e90:	2300      	movs	r3, #0
 8007e92:	f003 0301 	and.w	r3, r3, #1
 8007e96:	b2db      	uxtb	r3, r3
}
 8007e98:	4618      	mov	r0, r3
 8007e9a:	bd80      	pop	{r7, pc}
 8007e9c:	20001460 	.word	0x20001460

08007ea0 <fifoallocator_init>:
=======
 8007ec4:	b580      	push	{r7, lr}
 8007ec6:	af00      	add	r7, sp, #0
    return !restart_allowed_cb || restart_allowed_cb();
 8007ec8:	4b08      	ldr	r3, [pc, #32]	; (8007eec <system_get_restart_allowed+0x28>)
 8007eca:	681b      	ldr	r3, [r3, #0]
 8007ecc:	2b00      	cmp	r3, #0
 8007ece:	d005      	beq.n	8007edc <system_get_restart_allowed+0x18>
 8007ed0:	4b06      	ldr	r3, [pc, #24]	; (8007eec <system_get_restart_allowed+0x28>)
 8007ed2:	681b      	ldr	r3, [r3, #0]
 8007ed4:	4798      	blx	r3
 8007ed6:	4603      	mov	r3, r0
 8007ed8:	2b00      	cmp	r3, #0
 8007eda:	d001      	beq.n	8007ee0 <system_get_restart_allowed+0x1c>
 8007edc:	2301      	movs	r3, #1
 8007ede:	e000      	b.n	8007ee2 <system_get_restart_allowed+0x1e>
 8007ee0:	2300      	movs	r3, #0
 8007ee2:	f003 0301 	and.w	r3, r3, #1
 8007ee6:	b2db      	uxtb	r3, r3
}
 8007ee8:	4618      	mov	r0, r3
 8007eea:	bd80      	pop	{r7, pc}
 8007eec:	20001464 	.word	0x20001464

08007ef0 <fifoallocator_init>:
>>>>>>> 752c83b... update binaries

#define FIFOALLOCATOR_ALIGN(ptr) ((void*)(((size_t)(ptr) + (sizeof(void*)-1)) & ~(sizeof(void*)-1)))

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size);

void fifoallocator_init(struct fifoallocator_instance_s* instance, size_t memory_pool_size, void* memory_pool) {
<<<<<<< HEAD
 8007ea0:	b480      	push	{r7}
 8007ea2:	b085      	sub	sp, #20
 8007ea4:	af00      	add	r7, sp, #0
 8007ea6:	60f8      	str	r0, [r7, #12]
 8007ea8:	60b9      	str	r1, [r7, #8]
 8007eaa:	607a      	str	r2, [r7, #4]
    if (!instance || !memory_pool) {
 8007eac:	68fb      	ldr	r3, [r7, #12]
 8007eae:	2b00      	cmp	r3, #0
 8007eb0:	d00e      	beq.n	8007ed0 <fifoallocator_init+0x30>
 8007eb2:	687b      	ldr	r3, [r7, #4]
 8007eb4:	2b00      	cmp	r3, #0
 8007eb6:	d00b      	beq.n	8007ed0 <fifoallocator_init+0x30>
=======
 8007ef0:	b480      	push	{r7}
 8007ef2:	b085      	sub	sp, #20
 8007ef4:	af00      	add	r7, sp, #0
 8007ef6:	60f8      	str	r0, [r7, #12]
 8007ef8:	60b9      	str	r1, [r7, #8]
 8007efa:	607a      	str	r2, [r7, #4]
    if (!instance || !memory_pool) {
 8007efc:	68fb      	ldr	r3, [r7, #12]
 8007efe:	2b00      	cmp	r3, #0
 8007f00:	d00e      	beq.n	8007f20 <fifoallocator_init+0x30>
 8007f02:	687b      	ldr	r3, [r7, #4]
 8007f04:	2b00      	cmp	r3, #0
 8007f06:	d00b      	beq.n	8007f20 <fifoallocator_init+0x30>
>>>>>>> 752c83b... update binaries
        return;
    }

    instance->memory_pool = memory_pool;
<<<<<<< HEAD
 8007eb8:	68fb      	ldr	r3, [r7, #12]
 8007eba:	687a      	ldr	r2, [r7, #4]
 8007ebc:	601a      	str	r2, [r3, #0]
    instance->memory_pool_size = memory_pool_size;
 8007ebe:	68fb      	ldr	r3, [r7, #12]
 8007ec0:	68ba      	ldr	r2, [r7, #8]
 8007ec2:	605a      	str	r2, [r3, #4]
    instance->newest = NULL;
 8007ec4:	68fb      	ldr	r3, [r7, #12]
 8007ec6:	2200      	movs	r2, #0
 8007ec8:	609a      	str	r2, [r3, #8]
    instance->oldest = NULL;
 8007eca:	68fb      	ldr	r3, [r7, #12]
 8007ecc:	2200      	movs	r2, #0
 8007ece:	60da      	str	r2, [r3, #12]
}
 8007ed0:	3714      	adds	r7, #20
 8007ed2:	46bd      	mov	sp, r7
 8007ed4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ed8:	4770      	bx	lr
 8007eda:	bf00      	nop

08007edc <fifoallocator_allocate>:

void* fifoallocator_allocate(struct fifoallocator_instance_s* instance, size_t data_size) {
 8007edc:	b580      	push	{r7, lr}
 8007ede:	b084      	sub	sp, #16
 8007ee0:	af00      	add	r7, sp, #0
 8007ee2:	6078      	str	r0, [r7, #4]
 8007ee4:	6039      	str	r1, [r7, #0]

    if (!instance || !instance->memory_pool) {
 8007ee6:	687b      	ldr	r3, [r7, #4]
 8007ee8:	2b00      	cmp	r3, #0
 8007eea:	d003      	beq.n	8007ef4 <fifoallocator_allocate+0x18>
 8007eec:	687b      	ldr	r3, [r7, #4]
 8007eee:	681b      	ldr	r3, [r3, #0]
 8007ef0:	2b00      	cmp	r3, #0
 8007ef2:	d101      	bne.n	8007ef8 <fifoallocator_allocate+0x1c>
        return NULL;
 8007ef4:	2300      	movs	r3, #0
 8007ef6:	e06c      	b.n	8007fd2 <fifoallocator_allocate+0xf6>
    }

    size_t insert_block_size = data_size+sizeof(struct fifoallocator_block_s);
 8007ef8:	683b      	ldr	r3, [r7, #0]
 8007efa:	3308      	adds	r3, #8
 8007efc:	60bb      	str	r3, [r7, #8]

    struct fifoallocator_block_s* insert_block;
    if (instance->newest) {
 8007efe:	687b      	ldr	r3, [r7, #4]
 8007f00:	689b      	ldr	r3, [r3, #8]
 8007f02:	2b00      	cmp	r3, #0
 8007f04:	d008      	beq.n	8007f18 <fifoallocator_allocate+0x3c>
        insert_block = (struct fifoallocator_block_s*)((uint8_t*)instance->newest->data + instance->newest->data_size);
 8007f06:	687b      	ldr	r3, [r7, #4]
 8007f08:	689a      	ldr	r2, [r3, #8]
 8007f0a:	687b      	ldr	r3, [r7, #4]
 8007f0c:	689b      	ldr	r3, [r3, #8]
 8007f0e:	685b      	ldr	r3, [r3, #4]
 8007f10:	3308      	adds	r3, #8
 8007f12:	4413      	add	r3, r2
 8007f14:	60fb      	str	r3, [r7, #12]
 8007f16:	e002      	b.n	8007f1e <fifoallocator_allocate+0x42>
    } else {
        insert_block = (struct fifoallocator_block_s*)instance->memory_pool;
 8007f18:	687b      	ldr	r3, [r7, #4]
 8007f1a:	681b      	ldr	r3, [r3, #0]
 8007f1c:	60fb      	str	r3, [r7, #12]
    }

    insert_block = FIFOALLOCATOR_ALIGN(insert_block);
 8007f1e:	68fb      	ldr	r3, [r7, #12]
 8007f20:	3303      	adds	r3, #3
 8007f22:	f023 0303 	bic.w	r3, r3, #3
 8007f26:	60fb      	str	r3, [r7, #12]

    // Check if the block to be inserted is inside the memory pool
    if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 8007f28:	6878      	ldr	r0, [r7, #4]
 8007f2a:	68f9      	ldr	r1, [r7, #12]
 8007f2c:	68ba      	ldr	r2, [r7, #8]
 8007f2e:	f000 f89b 	bl	8008068 <fifoallocator_block_in_range>
 8007f32:	4603      	mov	r3, r0
 8007f34:	f083 0301 	eor.w	r3, r3, #1
 8007f38:	b2db      	uxtb	r3, r3
 8007f3a:	2b00      	cmp	r3, #0
 8007f3c:	d01b      	beq.n	8007f76 <fifoallocator_allocate+0x9a>
        // The block doesn't fit. Move it to the beginning of the memory pool.
        insert_block = FIFOALLOCATOR_ALIGN((struct fifoallocator_block_s*)instance->memory_pool);
 8007f3e:	687b      	ldr	r3, [r7, #4]
 8007f40:	681b      	ldr	r3, [r3, #0]
 8007f42:	3303      	adds	r3, #3
 8007f44:	f023 0303 	bic.w	r3, r3, #3
 8007f48:	60fb      	str	r3, [r7, #12]

        if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 8007f4a:	6878      	ldr	r0, [r7, #4]
 8007f4c:	68f9      	ldr	r1, [r7, #12]
 8007f4e:	68ba      	ldr	r2, [r7, #8]
 8007f50:	f000 f88a 	bl	8008068 <fifoallocator_block_in_range>
 8007f54:	4603      	mov	r3, r0
 8007f56:	f083 0301 	eor.w	r3, r3, #1
 8007f5a:	b2db      	uxtb	r3, r3
 8007f5c:	2b00      	cmp	r3, #0
 8007f5e:	d001      	beq.n	8007f64 <fifoallocator_allocate+0x88>
            // Block does not fit in pool
            return NULL;
 8007f60:	2300      	movs	r3, #0
 8007f62:	e036      	b.n	8007fd2 <fifoallocator_allocate+0xf6>
        }

        if ((size_t)instance->oldest > (size_t)instance->newest) {
 8007f64:	687b      	ldr	r3, [r7, #4]
 8007f66:	68db      	ldr	r3, [r3, #12]
 8007f68:	461a      	mov	r2, r3
 8007f6a:	687b      	ldr	r3, [r7, #4]
 8007f6c:	689b      	ldr	r3, [r3, #8]
 8007f6e:	429a      	cmp	r2, r3
 8007f70:	d901      	bls.n	8007f76 <fifoallocator_allocate+0x9a>
            // Allocated blocks wrap, beginning of memory pool is allocated
            return NULL;
 8007f72:	2300      	movs	r3, #0
 8007f74:	e02d      	b.n	8007fd2 <fifoallocator_allocate+0xf6>
=======
 8007f08:	68fb      	ldr	r3, [r7, #12]
 8007f0a:	687a      	ldr	r2, [r7, #4]
 8007f0c:	601a      	str	r2, [r3, #0]
    instance->memory_pool_size = memory_pool_size;
 8007f0e:	68fb      	ldr	r3, [r7, #12]
 8007f10:	68ba      	ldr	r2, [r7, #8]
 8007f12:	605a      	str	r2, [r3, #4]
    instance->newest = NULL;
 8007f14:	68fb      	ldr	r3, [r7, #12]
 8007f16:	2200      	movs	r2, #0
 8007f18:	609a      	str	r2, [r3, #8]
    instance->oldest = NULL;
 8007f1a:	68fb      	ldr	r3, [r7, #12]
 8007f1c:	2200      	movs	r2, #0
 8007f1e:	60da      	str	r2, [r3, #12]
}
 8007f20:	3714      	adds	r7, #20
 8007f22:	46bd      	mov	sp, r7
 8007f24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f28:	4770      	bx	lr
 8007f2a:	bf00      	nop

08007f2c <fifoallocator_allocate>:

void* fifoallocator_allocate(struct fifoallocator_instance_s* instance, size_t data_size) {
 8007f2c:	b580      	push	{r7, lr}
 8007f2e:	b084      	sub	sp, #16
 8007f30:	af00      	add	r7, sp, #0
 8007f32:	6078      	str	r0, [r7, #4]
 8007f34:	6039      	str	r1, [r7, #0]

    if (!instance || !instance->memory_pool) {
 8007f36:	687b      	ldr	r3, [r7, #4]
 8007f38:	2b00      	cmp	r3, #0
 8007f3a:	d003      	beq.n	8007f44 <fifoallocator_allocate+0x18>
 8007f3c:	687b      	ldr	r3, [r7, #4]
 8007f3e:	681b      	ldr	r3, [r3, #0]
 8007f40:	2b00      	cmp	r3, #0
 8007f42:	d101      	bne.n	8007f48 <fifoallocator_allocate+0x1c>
        return NULL;
 8007f44:	2300      	movs	r3, #0
 8007f46:	e06c      	b.n	8008022 <fifoallocator_allocate+0xf6>
    }

    size_t insert_block_size = data_size+sizeof(struct fifoallocator_block_s);
 8007f48:	683b      	ldr	r3, [r7, #0]
 8007f4a:	3308      	adds	r3, #8
 8007f4c:	60bb      	str	r3, [r7, #8]

    struct fifoallocator_block_s* insert_block;
    if (instance->newest) {
 8007f4e:	687b      	ldr	r3, [r7, #4]
 8007f50:	689b      	ldr	r3, [r3, #8]
 8007f52:	2b00      	cmp	r3, #0
 8007f54:	d008      	beq.n	8007f68 <fifoallocator_allocate+0x3c>
        insert_block = (struct fifoallocator_block_s*)((uint8_t*)instance->newest->data + instance->newest->data_size);
 8007f56:	687b      	ldr	r3, [r7, #4]
 8007f58:	689a      	ldr	r2, [r3, #8]
 8007f5a:	687b      	ldr	r3, [r7, #4]
 8007f5c:	689b      	ldr	r3, [r3, #8]
 8007f5e:	685b      	ldr	r3, [r3, #4]
 8007f60:	3308      	adds	r3, #8
 8007f62:	4413      	add	r3, r2
 8007f64:	60fb      	str	r3, [r7, #12]
 8007f66:	e002      	b.n	8007f6e <fifoallocator_allocate+0x42>
    } else {
        insert_block = (struct fifoallocator_block_s*)instance->memory_pool;
 8007f68:	687b      	ldr	r3, [r7, #4]
 8007f6a:	681b      	ldr	r3, [r3, #0]
 8007f6c:	60fb      	str	r3, [r7, #12]
    }

    insert_block = FIFOALLOCATOR_ALIGN(insert_block);
 8007f6e:	68fb      	ldr	r3, [r7, #12]
 8007f70:	3303      	adds	r3, #3
 8007f72:	f023 0303 	bic.w	r3, r3, #3
 8007f76:	60fb      	str	r3, [r7, #12]

    // Check if the block to be inserted is inside the memory pool
    if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 8007f78:	6878      	ldr	r0, [r7, #4]
 8007f7a:	68f9      	ldr	r1, [r7, #12]
 8007f7c:	68ba      	ldr	r2, [r7, #8]
 8007f7e:	f000 f89b 	bl	80080b8 <fifoallocator_block_in_range>
 8007f82:	4603      	mov	r3, r0
 8007f84:	f083 0301 	eor.w	r3, r3, #1
 8007f88:	b2db      	uxtb	r3, r3
 8007f8a:	2b00      	cmp	r3, #0
 8007f8c:	d01b      	beq.n	8007fc6 <fifoallocator_allocate+0x9a>
        // The block doesn't fit. Move it to the beginning of the memory pool.
        insert_block = FIFOALLOCATOR_ALIGN((struct fifoallocator_block_s*)instance->memory_pool);
 8007f8e:	687b      	ldr	r3, [r7, #4]
 8007f90:	681b      	ldr	r3, [r3, #0]
 8007f92:	3303      	adds	r3, #3
 8007f94:	f023 0303 	bic.w	r3, r3, #3
 8007f98:	60fb      	str	r3, [r7, #12]

        if (!fifoallocator_block_in_range(instance, insert_block, insert_block_size)) {
 8007f9a:	6878      	ldr	r0, [r7, #4]
 8007f9c:	68f9      	ldr	r1, [r7, #12]
 8007f9e:	68ba      	ldr	r2, [r7, #8]
 8007fa0:	f000 f88a 	bl	80080b8 <fifoallocator_block_in_range>
 8007fa4:	4603      	mov	r3, r0
 8007fa6:	f083 0301 	eor.w	r3, r3, #1
 8007faa:	b2db      	uxtb	r3, r3
 8007fac:	2b00      	cmp	r3, #0
 8007fae:	d001      	beq.n	8007fb4 <fifoallocator_allocate+0x88>
            // Block does not fit in pool
            return NULL;
 8007fb0:	2300      	movs	r3, #0
 8007fb2:	e036      	b.n	8008022 <fifoallocator_allocate+0xf6>
        }

        if ((size_t)instance->oldest > (size_t)instance->newest) {
 8007fb4:	687b      	ldr	r3, [r7, #4]
 8007fb6:	68db      	ldr	r3, [r3, #12]
 8007fb8:	461a      	mov	r2, r3
 8007fba:	687b      	ldr	r3, [r7, #4]
 8007fbc:	689b      	ldr	r3, [r3, #8]
 8007fbe:	429a      	cmp	r2, r3
 8007fc0:	d901      	bls.n	8007fc6 <fifoallocator_allocate+0x9a>
            // Allocated blocks wrap, beginning of memory pool is allocated
            return NULL;
 8007fc2:	2300      	movs	r3, #0
 8007fc4:	e02d      	b.n	8008022 <fifoallocator_allocate+0xf6>
>>>>>>> 752c83b... update binaries
        }
    }

    // Check if the insert block overlaps with the oldest block
    if (instance->oldest && (size_t)instance->oldest >= (size_t)insert_block && (size_t)instance->oldest < (size_t)insert_block+insert_block_size) {
<<<<<<< HEAD
 8007f76:	687b      	ldr	r3, [r7, #4]
 8007f78:	68db      	ldr	r3, [r3, #12]
 8007f7a:	2b00      	cmp	r3, #0
 8007f7c:	d00f      	beq.n	8007f9e <fifoallocator_allocate+0xc2>
 8007f7e:	687b      	ldr	r3, [r7, #4]
 8007f80:	68db      	ldr	r3, [r3, #12]
 8007f82:	461a      	mov	r2, r3
 8007f84:	68fb      	ldr	r3, [r7, #12]
 8007f86:	429a      	cmp	r2, r3
 8007f88:	d309      	bcc.n	8007f9e <fifoallocator_allocate+0xc2>
 8007f8a:	687b      	ldr	r3, [r7, #4]
 8007f8c:	68db      	ldr	r3, [r3, #12]
 8007f8e:	4619      	mov	r1, r3
 8007f90:	68fa      	ldr	r2, [r7, #12]
 8007f92:	68bb      	ldr	r3, [r7, #8]
 8007f94:	4413      	add	r3, r2
 8007f96:	4299      	cmp	r1, r3
 8007f98:	d201      	bcs.n	8007f9e <fifoallocator_allocate+0xc2>
        return NULL;
 8007f9a:	2300      	movs	r3, #0
 8007f9c:	e019      	b.n	8007fd2 <fifoallocator_allocate+0xf6>
    }

    insert_block->next_oldest = NULL;
 8007f9e:	68fb      	ldr	r3, [r7, #12]
 8007fa0:	2200      	movs	r2, #0
 8007fa2:	601a      	str	r2, [r3, #0]
    insert_block->data_size = data_size;
 8007fa4:	68fb      	ldr	r3, [r7, #12]
 8007fa6:	683a      	ldr	r2, [r7, #0]
 8007fa8:	605a      	str	r2, [r3, #4]

    if (instance->newest) {
 8007faa:	687b      	ldr	r3, [r7, #4]
 8007fac:	689b      	ldr	r3, [r3, #8]
 8007fae:	2b00      	cmp	r3, #0
 8007fb0:	d003      	beq.n	8007fba <fifoallocator_allocate+0xde>
        instance->newest->next_oldest = insert_block;
 8007fb2:	687b      	ldr	r3, [r7, #4]
 8007fb4:	689b      	ldr	r3, [r3, #8]
 8007fb6:	68fa      	ldr	r2, [r7, #12]
 8007fb8:	601a      	str	r2, [r3, #0]
    }

    instance->newest = insert_block;
 8007fba:	687b      	ldr	r3, [r7, #4]
 8007fbc:	68fa      	ldr	r2, [r7, #12]
 8007fbe:	609a      	str	r2, [r3, #8]

    if (!instance->oldest) {
 8007fc0:	687b      	ldr	r3, [r7, #4]
 8007fc2:	68db      	ldr	r3, [r3, #12]
 8007fc4:	2b00      	cmp	r3, #0
 8007fc6:	d102      	bne.n	8007fce <fifoallocator_allocate+0xf2>
        instance->oldest = insert_block;
 8007fc8:	687b      	ldr	r3, [r7, #4]
 8007fca:	68fa      	ldr	r2, [r7, #12]
 8007fcc:	60da      	str	r2, [r3, #12]
    }

    return insert_block->data;
 8007fce:	68fb      	ldr	r3, [r7, #12]
 8007fd0:	3308      	adds	r3, #8
}
 8007fd2:	4618      	mov	r0, r3
 8007fd4:	3710      	adds	r7, #16
 8007fd6:	46bd      	mov	sp, r7
 8007fd8:	bd80      	pop	{r7, pc}
 8007fda:	bf00      	nop

08007fdc <fifoallocator_peek_oldest>:

void* fifoallocator_peek_oldest(struct fifoallocator_instance_s* instance) {
 8007fdc:	b480      	push	{r7}
 8007fde:	b083      	sub	sp, #12
 8007fe0:	af00      	add	r7, sp, #0
 8007fe2:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 8007fe4:	687b      	ldr	r3, [r7, #4]
 8007fe6:	2b00      	cmp	r3, #0
 8007fe8:	d003      	beq.n	8007ff2 <fifoallocator_peek_oldest+0x16>
 8007fea:	687b      	ldr	r3, [r7, #4]
 8007fec:	68db      	ldr	r3, [r3, #12]
 8007fee:	2b00      	cmp	r3, #0
 8007ff0:	d101      	bne.n	8007ff6 <fifoallocator_peek_oldest+0x1a>
        return NULL;
 8007ff2:	2300      	movs	r3, #0
 8007ff4:	e002      	b.n	8007ffc <fifoallocator_peek_oldest+0x20>
    }

    return instance->oldest->data;
 8007ff6:	687b      	ldr	r3, [r7, #4]
 8007ff8:	68db      	ldr	r3, [r3, #12]
 8007ffa:	3308      	adds	r3, #8
}
 8007ffc:	4618      	mov	r0, r3
 8007ffe:	370c      	adds	r7, #12
 8008000:	46bd      	mov	sp, r7
 8008002:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008006:	4770      	bx	lr

08008008 <fifoallocator_get_block_size>:

size_t fifoallocator_get_block_size(const void* block) {
 8008008:	b480      	push	{r7}
 800800a:	b083      	sub	sp, #12
 800800c:	af00      	add	r7, sp, #0
 800800e:	6078      	str	r0, [r7, #4]
    if (!block) {
 8008010:	687b      	ldr	r3, [r7, #4]
 8008012:	2b00      	cmp	r3, #0
 8008014:	d101      	bne.n	800801a <fifoallocator_get_block_size+0x12>
        return 0;
 8008016:	2300      	movs	r3, #0
 8008018:	e002      	b.n	8008020 <fifoallocator_get_block_size+0x18>
    }

    return ((struct fifoallocator_block_s*)((uint8_t*)block - offsetof(struct fifoallocator_block_s, data)))->data_size;
 800801a:	687b      	ldr	r3, [r7, #4]
 800801c:	3b08      	subs	r3, #8
 800801e:	685b      	ldr	r3, [r3, #4]
}
 8008020:	4618      	mov	r0, r3
 8008022:	370c      	adds	r7, #12
 8008024:	46bd      	mov	sp, r7
 8008026:	f85d 7b04 	ldr.w	r7, [sp], #4
 800802a:	4770      	bx	lr

0800802c <fifoallocator_pop_oldest>:

void fifoallocator_pop_oldest(struct fifoallocator_instance_s* instance) {
 800802c:	b480      	push	{r7}
 800802e:	b083      	sub	sp, #12
 8008030:	af00      	add	r7, sp, #0
 8008032:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 8008034:	687b      	ldr	r3, [r7, #4]
 8008036:	2b00      	cmp	r3, #0
 8008038:	d011      	beq.n	800805e <fifoallocator_pop_oldest+0x32>
 800803a:	687b      	ldr	r3, [r7, #4]
 800803c:	68db      	ldr	r3, [r3, #12]
 800803e:	2b00      	cmp	r3, #0
 8008040:	d00d      	beq.n	800805e <fifoallocator_pop_oldest+0x32>
=======
 8007fc6:	687b      	ldr	r3, [r7, #4]
 8007fc8:	68db      	ldr	r3, [r3, #12]
 8007fca:	2b00      	cmp	r3, #0
 8007fcc:	d00f      	beq.n	8007fee <fifoallocator_allocate+0xc2>
 8007fce:	687b      	ldr	r3, [r7, #4]
 8007fd0:	68db      	ldr	r3, [r3, #12]
 8007fd2:	461a      	mov	r2, r3
 8007fd4:	68fb      	ldr	r3, [r7, #12]
 8007fd6:	429a      	cmp	r2, r3
 8007fd8:	d309      	bcc.n	8007fee <fifoallocator_allocate+0xc2>
 8007fda:	687b      	ldr	r3, [r7, #4]
 8007fdc:	68db      	ldr	r3, [r3, #12]
 8007fde:	4619      	mov	r1, r3
 8007fe0:	68fa      	ldr	r2, [r7, #12]
 8007fe2:	68bb      	ldr	r3, [r7, #8]
 8007fe4:	4413      	add	r3, r2
 8007fe6:	4299      	cmp	r1, r3
 8007fe8:	d201      	bcs.n	8007fee <fifoallocator_allocate+0xc2>
        return NULL;
 8007fea:	2300      	movs	r3, #0
 8007fec:	e019      	b.n	8008022 <fifoallocator_allocate+0xf6>
    }

    insert_block->next_oldest = NULL;
 8007fee:	68fb      	ldr	r3, [r7, #12]
 8007ff0:	2200      	movs	r2, #0
 8007ff2:	601a      	str	r2, [r3, #0]
    insert_block->data_size = data_size;
 8007ff4:	68fb      	ldr	r3, [r7, #12]
 8007ff6:	683a      	ldr	r2, [r7, #0]
 8007ff8:	605a      	str	r2, [r3, #4]

    if (instance->newest) {
 8007ffa:	687b      	ldr	r3, [r7, #4]
 8007ffc:	689b      	ldr	r3, [r3, #8]
 8007ffe:	2b00      	cmp	r3, #0
 8008000:	d003      	beq.n	800800a <fifoallocator_allocate+0xde>
        instance->newest->next_oldest = insert_block;
 8008002:	687b      	ldr	r3, [r7, #4]
 8008004:	689b      	ldr	r3, [r3, #8]
 8008006:	68fa      	ldr	r2, [r7, #12]
 8008008:	601a      	str	r2, [r3, #0]
    }

    instance->newest = insert_block;
 800800a:	687b      	ldr	r3, [r7, #4]
 800800c:	68fa      	ldr	r2, [r7, #12]
 800800e:	609a      	str	r2, [r3, #8]

    if (!instance->oldest) {
 8008010:	687b      	ldr	r3, [r7, #4]
 8008012:	68db      	ldr	r3, [r3, #12]
 8008014:	2b00      	cmp	r3, #0
 8008016:	d102      	bne.n	800801e <fifoallocator_allocate+0xf2>
        instance->oldest = insert_block;
 8008018:	687b      	ldr	r3, [r7, #4]
 800801a:	68fa      	ldr	r2, [r7, #12]
 800801c:	60da      	str	r2, [r3, #12]
    }

    return insert_block->data;
 800801e:	68fb      	ldr	r3, [r7, #12]
 8008020:	3308      	adds	r3, #8
}
 8008022:	4618      	mov	r0, r3
 8008024:	3710      	adds	r7, #16
 8008026:	46bd      	mov	sp, r7
 8008028:	bd80      	pop	{r7, pc}
 800802a:	bf00      	nop

0800802c <fifoallocator_peek_oldest>:

void* fifoallocator_peek_oldest(struct fifoallocator_instance_s* instance) {
 800802c:	b480      	push	{r7}
 800802e:	b083      	sub	sp, #12
 8008030:	af00      	add	r7, sp, #0
 8008032:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 8008034:	687b      	ldr	r3, [r7, #4]
 8008036:	2b00      	cmp	r3, #0
 8008038:	d003      	beq.n	8008042 <fifoallocator_peek_oldest+0x16>
 800803a:	687b      	ldr	r3, [r7, #4]
 800803c:	68db      	ldr	r3, [r3, #12]
 800803e:	2b00      	cmp	r3, #0
 8008040:	d101      	bne.n	8008046 <fifoallocator_peek_oldest+0x1a>
        return NULL;
 8008042:	2300      	movs	r3, #0
 8008044:	e002      	b.n	800804c <fifoallocator_peek_oldest+0x20>
    }

    return instance->oldest->data;
 8008046:	687b      	ldr	r3, [r7, #4]
 8008048:	68db      	ldr	r3, [r3, #12]
 800804a:	3308      	adds	r3, #8
}
 800804c:	4618      	mov	r0, r3
 800804e:	370c      	adds	r7, #12
 8008050:	46bd      	mov	sp, r7
 8008052:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008056:	4770      	bx	lr

08008058 <fifoallocator_get_block_size>:

size_t fifoallocator_get_block_size(const void* block) {
 8008058:	b480      	push	{r7}
 800805a:	b083      	sub	sp, #12
 800805c:	af00      	add	r7, sp, #0
 800805e:	6078      	str	r0, [r7, #4]
    if (!block) {
 8008060:	687b      	ldr	r3, [r7, #4]
 8008062:	2b00      	cmp	r3, #0
 8008064:	d101      	bne.n	800806a <fifoallocator_get_block_size+0x12>
        return 0;
 8008066:	2300      	movs	r3, #0
 8008068:	e002      	b.n	8008070 <fifoallocator_get_block_size+0x18>
    }

    return ((struct fifoallocator_block_s*)((uint8_t*)block - offsetof(struct fifoallocator_block_s, data)))->data_size;
 800806a:	687b      	ldr	r3, [r7, #4]
 800806c:	3b08      	subs	r3, #8
 800806e:	685b      	ldr	r3, [r3, #4]
}
 8008070:	4618      	mov	r0, r3
 8008072:	370c      	adds	r7, #12
 8008074:	46bd      	mov	sp, r7
 8008076:	f85d 7b04 	ldr.w	r7, [sp], #4
 800807a:	4770      	bx	lr

0800807c <fifoallocator_pop_oldest>:

void fifoallocator_pop_oldest(struct fifoallocator_instance_s* instance) {
 800807c:	b480      	push	{r7}
 800807e:	b083      	sub	sp, #12
 8008080:	af00      	add	r7, sp, #0
 8008082:	6078      	str	r0, [r7, #4]
    if (!instance || !instance->oldest) {
 8008084:	687b      	ldr	r3, [r7, #4]
 8008086:	2b00      	cmp	r3, #0
 8008088:	d011      	beq.n	80080ae <fifoallocator_pop_oldest+0x32>
 800808a:	687b      	ldr	r3, [r7, #4]
 800808c:	68db      	ldr	r3, [r3, #12]
 800808e:	2b00      	cmp	r3, #0
 8008090:	d00d      	beq.n	80080ae <fifoallocator_pop_oldest+0x32>
>>>>>>> 752c83b... update binaries
        return;
    }

    if (instance->newest == instance->oldest) {
<<<<<<< HEAD
 8008042:	687b      	ldr	r3, [r7, #4]
 8008044:	689a      	ldr	r2, [r3, #8]
 8008046:	687b      	ldr	r3, [r7, #4]
 8008048:	68db      	ldr	r3, [r3, #12]
 800804a:	429a      	cmp	r2, r3
 800804c:	d102      	bne.n	8008054 <fifoallocator_pop_oldest+0x28>
        instance->newest = NULL;
 800804e:	687b      	ldr	r3, [r7, #4]
 8008050:	2200      	movs	r2, #0
 8008052:	609a      	str	r2, [r3, #8]
    }

    instance->oldest = instance->oldest->next_oldest;
 8008054:	687b      	ldr	r3, [r7, #4]
 8008056:	68db      	ldr	r3, [r3, #12]
 8008058:	681a      	ldr	r2, [r3, #0]
 800805a:	687b      	ldr	r3, [r7, #4]
 800805c:	60da      	str	r2, [r3, #12]
}
 800805e:	370c      	adds	r7, #12
 8008060:	46bd      	mov	sp, r7
 8008062:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008066:	4770      	bx	lr

08008068 <fifoallocator_block_in_range>:

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
 8008068:	b480      	push	{r7}
 800806a:	b085      	sub	sp, #20
 800806c:	af00      	add	r7, sp, #0
 800806e:	60f8      	str	r0, [r7, #12]
 8008070:	60b9      	str	r1, [r7, #8]
 8008072:	607a      	str	r2, [r7, #4]
    return instance && instance->memory_pool &&
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 8008074:	68fb      	ldr	r3, [r7, #12]
 8008076:	2b00      	cmp	r3, #0
 8008078:	d017      	beq.n	80080aa <fifoallocator_block_in_range+0x42>
=======
 8008092:	687b      	ldr	r3, [r7, #4]
 8008094:	689a      	ldr	r2, [r3, #8]
 8008096:	687b      	ldr	r3, [r7, #4]
 8008098:	68db      	ldr	r3, [r3, #12]
 800809a:	429a      	cmp	r2, r3
 800809c:	d102      	bne.n	80080a4 <fifoallocator_pop_oldest+0x28>
        instance->newest = NULL;
 800809e:	687b      	ldr	r3, [r7, #4]
 80080a0:	2200      	movs	r2, #0
 80080a2:	609a      	str	r2, [r3, #8]
    }

    instance->oldest = instance->oldest->next_oldest;
 80080a4:	687b      	ldr	r3, [r7, #4]
 80080a6:	68db      	ldr	r3, [r3, #12]
 80080a8:	681a      	ldr	r2, [r3, #0]
 80080aa:	687b      	ldr	r3, [r7, #4]
 80080ac:	60da      	str	r2, [r3, #12]
}
 80080ae:	370c      	adds	r7, #12
 80080b0:	46bd      	mov	sp, r7
 80080b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080b6:	4770      	bx	lr

080080b8 <fifoallocator_block_in_range>:

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
 80080b8:	b480      	push	{r7}
 80080ba:	b085      	sub	sp, #20
 80080bc:	af00      	add	r7, sp, #0
 80080be:	60f8      	str	r0, [r7, #12]
 80080c0:	60b9      	str	r1, [r7, #8]
 80080c2:	607a      	str	r2, [r7, #4]
    return instance && instance->memory_pool &&
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 80080c4:	68fb      	ldr	r3, [r7, #12]
 80080c6:	2b00      	cmp	r3, #0
 80080c8:	d017      	beq.n	80080fa <fifoallocator_block_in_range+0x42>
>>>>>>> 752c83b... update binaries

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
<<<<<<< HEAD
 800807a:	68fb      	ldr	r3, [r7, #12]
 800807c:	681b      	ldr	r3, [r3, #0]
 800807e:	2b00      	cmp	r3, #0
 8008080:	d013      	beq.n	80080aa <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 8008082:	68bb      	ldr	r3, [r7, #8]
 8008084:	68fa      	ldr	r2, [r7, #12]
 8008086:	6812      	ldr	r2, [r2, #0]
 8008088:	1a9a      	subs	r2, r3, r2
 800808a:	68fb      	ldr	r3, [r7, #12]
 800808c:	685b      	ldr	r3, [r3, #4]
=======
 80080ca:	68fb      	ldr	r3, [r7, #12]
 80080cc:	681b      	ldr	r3, [r3, #0]
 80080ce:	2b00      	cmp	r3, #0
 80080d0:	d013      	beq.n	80080fa <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
 80080d2:	68bb      	ldr	r3, [r7, #8]
 80080d4:	68fa      	ldr	r2, [r7, #12]
 80080d6:	6812      	ldr	r2, [r2, #0]
 80080d8:	1a9a      	subs	r2, r3, r2
 80080da:	68fb      	ldr	r3, [r7, #12]
 80080dc:	685b      	ldr	r3, [r3, #4]
>>>>>>> 752c83b... update binaries

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
<<<<<<< HEAD
 800808e:	429a      	cmp	r2, r3
 8008090:	d20b      	bcs.n	80080aa <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
 8008092:	68ba      	ldr	r2, [r7, #8]
 8008094:	687b      	ldr	r3, [r7, #4]
 8008096:	4413      	add	r3, r2
 8008098:	68fa      	ldr	r2, [r7, #12]
 800809a:	6812      	ldr	r2, [r2, #0]
 800809c:	1a9a      	subs	r2, r3, r2
 800809e:	68fb      	ldr	r3, [r7, #12]
 80080a0:	685b      	ldr	r3, [r3, #4]
=======
 80080de:	429a      	cmp	r2, r3
 80080e0:	d20b      	bcs.n	80080fa <fifoallocator_block_in_range+0x42>
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
 80080e2:	68ba      	ldr	r2, [r7, #8]
 80080e4:	687b      	ldr	r3, [r7, #4]
 80080e6:	4413      	add	r3, r2
 80080e8:	68fa      	ldr	r2, [r7, #12]
 80080ea:	6812      	ldr	r2, [r2, #0]
 80080ec:	1a9a      	subs	r2, r3, r2
 80080ee:	68fb      	ldr	r3, [r7, #12]
 80080f0:	685b      	ldr	r3, [r3, #4]
>>>>>>> 752c83b... update binaries
    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
<<<<<<< HEAD
 80080a2:	429a      	cmp	r2, r3
 80080a4:	d801      	bhi.n	80080aa <fifoallocator_block_in_range+0x42>
 80080a6:	2301      	movs	r3, #1
 80080a8:	e000      	b.n	80080ac <fifoallocator_block_in_range+0x44>
 80080aa:	2300      	movs	r3, #0
=======
 80080f2:	429a      	cmp	r2, r3
 80080f4:	d801      	bhi.n	80080fa <fifoallocator_block_in_range+0x42>
 80080f6:	2301      	movs	r3, #1
 80080f8:	e000      	b.n	80080fc <fifoallocator_block_in_range+0x44>
 80080fa:	2300      	movs	r3, #0
>>>>>>> 752c83b... update binaries

    instance->oldest = instance->oldest->next_oldest;
}

static bool fifoallocator_block_in_range(struct fifoallocator_instance_s* instance, void* block, size_t block_size) {
    return instance && instance->memory_pool &&
<<<<<<< HEAD
 80080ac:	f003 0301 	and.w	r3, r3, #1
 80080b0:	b2db      	uxtb	r3, r3
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
}
 80080b2:	4618      	mov	r0, r3
 80080b4:	3714      	adds	r7, #20
 80080b6:	46bd      	mov	sp, r7
 80080b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080bc:	4770      	bx	lr
 80080be:	bf00      	nop

080080c0 <port_lock.lto_priv.148>:
=======
 80080fc:	f003 0301 	and.w	r3, r3, #1
 8008100:	b2db      	uxtb	r3, r3
           (size_t)block-(size_t)instance->memory_pool < instance->memory_pool_size &&
           (size_t)block+block_size-(size_t)instance->memory_pool <= instance->memory_pool_size;
}
 8008102:	4618      	mov	r0, r3
 8008104:	3714      	adds	r7, #20
 8008106:	46bd      	mov	sp, r7
 8008108:	f85d 7b04 	ldr.w	r7, [sp], #4
 800810c:	4770      	bx	lr
 800810e:	bf00      	nop

08008110 <port_lock.lto_priv.141>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 80080c0:	b480      	push	{r7}
 80080c2:	b083      	sub	sp, #12
 80080c4:	af00      	add	r7, sp, #0
 80080c6:	2320      	movs	r3, #32
 80080c8:	607b      	str	r3, [r7, #4]
 80080ca:	687b      	ldr	r3, [r7, #4]
 80080cc:	f383 8811 	msr	BASEPRI, r3
=======
 8008110:	b480      	push	{r7}
 8008112:	b083      	sub	sp, #12
 8008114:	af00      	add	r7, sp, #0
 8008116:	2320      	movs	r3, #32
 8008118:	607b      	str	r3, [r7, #4]
 800811a:	687b      	ldr	r3, [r7, #4]
 800811c:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 80080d0:	370c      	adds	r7, #12
 80080d2:	46bd      	mov	sp, r7
 80080d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080d8:	4770      	bx	lr
 80080da:	bf00      	nop

080080dc <port_unlock.lto_priv.146>:
=======
 8008120:	370c      	adds	r7, #12
 8008122:	46bd      	mov	sp, r7
 8008124:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008128:	4770      	bx	lr
 800812a:	bf00      	nop

0800812c <port_unlock.lto_priv.139>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 80080dc:	b480      	push	{r7}
 80080de:	b083      	sub	sp, #12
 80080e0:	af00      	add	r7, sp, #0
 80080e2:	2300      	movs	r3, #0
 80080e4:	607b      	str	r3, [r7, #4]
 80080e6:	687b      	ldr	r3, [r7, #4]
 80080e8:	f383 8811 	msr	BASEPRI, r3
=======
 800812c:	b480      	push	{r7}
 800812e:	b083      	sub	sp, #12
 8008130:	af00      	add	r7, sp, #0
 8008132:	2300      	movs	r3, #0
 8008134:	607b      	str	r3, [r7, #4]
 8008136:	687b      	ldr	r3, [r7, #4]
 8008138:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 80080ec:	370c      	adds	r7, #12
 80080ee:	46bd      	mov	sp, r7
 80080f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080f4:	4770      	bx	lr
 80080f6:	bf00      	nop

080080f8 <chSysLock>:
=======
 800813c:	370c      	adds	r7, #12
 800813e:	46bd      	mov	sp, r7
 8008140:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008144:	4770      	bx	lr
 8008146:	bf00      	nop

08008148 <chSysLock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 80080f8:	b580      	push	{r7, lr}
 80080fa:	af00      	add	r7, sp, #0

  port_lock();
 80080fc:	f7ff ffe0 	bl	80080c0 <port_lock.lto_priv.148>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8008100:	f002 fe9e 	bl	800ae40 <_dbg_check_lock>
}
 8008104:	bd80      	pop	{r7, pc}
 8008106:	bf00      	nop

08008108 <chSysUnlock>:
=======
 8008148:	b580      	push	{r7, lr}
 800814a:	af00      	add	r7, sp, #0

  port_lock();
 800814c:	f7ff ffe0 	bl	8008110 <port_lock.lto_priv.141>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8008150:	f002 feba 	bl	800aec8 <_dbg_check_lock>
}
 8008154:	bd80      	pop	{r7, pc}
 8008156:	bf00      	nop

08008158 <chSysUnlock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 8008108:	b580      	push	{r7, lr}
 800810a:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800810c:	f002 feae 	bl	800ae6c <_dbg_check_unlock>
=======
 8008158:	b580      	push	{r7, lr}
 800815a:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800815c:	f002 feca 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 8008110:	4b09      	ldr	r3, [pc, #36]	; (8008138 <chSysUnlock+0x30>)
 8008112:	681b      	ldr	r3, [r3, #0]
 8008114:	4a08      	ldr	r2, [pc, #32]	; (8008138 <chSysUnlock+0x30>)
 8008116:	4293      	cmp	r3, r2
 8008118:	d00a      	beq.n	8008130 <chSysUnlock+0x28>
 800811a:	4b07      	ldr	r3, [pc, #28]	; (8008138 <chSysUnlock+0x30>)
 800811c:	699b      	ldr	r3, [r3, #24]
 800811e:	689a      	ldr	r2, [r3, #8]
 8008120:	4b05      	ldr	r3, [pc, #20]	; (8008138 <chSysUnlock+0x30>)
 8008122:	681b      	ldr	r3, [r3, #0]
 8008124:	689b      	ldr	r3, [r3, #8]
 8008126:	429a      	cmp	r2, r3
 8008128:	d202      	bcs.n	8008130 <chSysUnlock+0x28>
 800812a:	4804      	ldr	r0, [pc, #16]	; (800813c <chSysUnlock+0x34>)
 800812c:	f002 fe3a 	bl	800ada4 <chSysHalt>
=======
 8008160:	4b09      	ldr	r3, [pc, #36]	; (8008188 <chSysUnlock+0x30>)
 8008162:	681b      	ldr	r3, [r3, #0]
 8008164:	4a08      	ldr	r2, [pc, #32]	; (8008188 <chSysUnlock+0x30>)
 8008166:	4293      	cmp	r3, r2
 8008168:	d00a      	beq.n	8008180 <chSysUnlock+0x28>
 800816a:	4b07      	ldr	r3, [pc, #28]	; (8008188 <chSysUnlock+0x30>)
 800816c:	699b      	ldr	r3, [r3, #24]
 800816e:	689a      	ldr	r2, [r3, #8]
 8008170:	4b05      	ldr	r3, [pc, #20]	; (8008188 <chSysUnlock+0x30>)
 8008172:	681b      	ldr	r3, [r3, #0]
 8008174:	689b      	ldr	r3, [r3, #8]
 8008176:	429a      	cmp	r2, r3
 8008178:	d202      	bcs.n	8008180 <chSysUnlock+0x28>
 800817a:	4804      	ldr	r0, [pc, #16]	; (800818c <chSysUnlock+0x34>)
 800817c:	f002 fe56 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 8008130:	f7ff ffd4 	bl	80080dc <port_unlock.lto_priv.146>
}
 8008134:	bd80      	pop	{r7, pc}
 8008136:	bf00      	nop
 8008138:	20001338 	.word	0x20001338
 800813c:	0800eb4c 	.word	0x0800eb4c

08008140 <pubsub_create_topic_group>:
=======
 8008180:	f7ff ffd4 	bl	800812c <port_unlock.lto_priv.139>
}
 8008184:	bd80      	pop	{r7, pc}
 8008186:	bf00      	nop
 8008188:	20001338 	.word	0x20001338
 800818c:	0800ec24 	.word	0x0800ec24

08008190 <pubsub_create_topic_group>:
>>>>>>> 752c83b... update binaries
#error Please define PUBSUB_DEFAULT_TOPIC_GROUP in framework_conf.h.
#endif

PUBSUB_TOPIC_GROUP_DECLARE_EXTERN(PUBSUB_DEFAULT_TOPIC_GROUP);

void pubsub_create_topic_group(struct pubsub_topic_group_s* topic_group, size_t memory_pool_size, void* memory_pool) {
<<<<<<< HEAD
 8008140:	b580      	push	{r7, lr}
 8008142:	b084      	sub	sp, #16
 8008144:	af00      	add	r7, sp, #0
 8008146:	60f8      	str	r0, [r7, #12]
 8008148:	60b9      	str	r1, [r7, #8]
 800814a:	607a      	str	r2, [r7, #4]
    if (!topic_group || !memory_pool) {
 800814c:	68fb      	ldr	r3, [r7, #12]
 800814e:	2b00      	cmp	r3, #0
 8008150:	d008      	beq.n	8008164 <pubsub_create_topic_group+0x24>
 8008152:	687b      	ldr	r3, [r7, #4]
 8008154:	2b00      	cmp	r3, #0
 8008156:	d005      	beq.n	8008164 <pubsub_create_topic_group+0x24>
=======
 8008190:	b580      	push	{r7, lr}
 8008192:	b084      	sub	sp, #16
 8008194:	af00      	add	r7, sp, #0
 8008196:	60f8      	str	r0, [r7, #12]
 8008198:	60b9      	str	r1, [r7, #8]
 800819a:	607a      	str	r2, [r7, #4]
    if (!topic_group || !memory_pool) {
 800819c:	68fb      	ldr	r3, [r7, #12]
 800819e:	2b00      	cmp	r3, #0
 80081a0:	d008      	beq.n	80081b4 <pubsub_create_topic_group+0x24>
 80081a2:	687b      	ldr	r3, [r7, #4]
 80081a4:	2b00      	cmp	r3, #0
 80081a6:	d005      	beq.n	80081b4 <pubsub_create_topic_group+0x24>
>>>>>>> 752c83b... update binaries
        return;
    }

    fifoallocator_init(&topic_group->allocator, memory_pool_size, memory_pool);
<<<<<<< HEAD
 8008158:	68fb      	ldr	r3, [r7, #12]
 800815a:	4618      	mov	r0, r3
 800815c:	68b9      	ldr	r1, [r7, #8]
 800815e:	687a      	ldr	r2, [r7, #4]
 8008160:	f7ff fe9e 	bl	8007ea0 <fifoallocator_init>
}
 8008164:	3710      	adds	r7, #16
 8008166:	46bd      	mov	sp, r7
 8008168:	bd80      	pop	{r7, pc}
 800816a:	bf00      	nop

0800816c <pubsub_init_topic>:

void pubsub_init_topic(struct pubsub_topic_s* topic, struct pubsub_topic_group_s* topic_group) {
 800816c:	b480      	push	{r7}
 800816e:	b083      	sub	sp, #12
 8008170:	af00      	add	r7, sp, #0
 8008172:	6078      	str	r0, [r7, #4]
 8008174:	6039      	str	r1, [r7, #0]
    if (!topic) {
 8008176:	687b      	ldr	r3, [r7, #4]
 8008178:	2b00      	cmp	r3, #0
 800817a:	d00d      	beq.n	8008198 <pubsub_init_topic+0x2c>
=======
 80081a8:	68fb      	ldr	r3, [r7, #12]
 80081aa:	4618      	mov	r0, r3
 80081ac:	68b9      	ldr	r1, [r7, #8]
 80081ae:	687a      	ldr	r2, [r7, #4]
 80081b0:	f7ff fe9e 	bl	8007ef0 <fifoallocator_init>
}
 80081b4:	3710      	adds	r7, #16
 80081b6:	46bd      	mov	sp, r7
 80081b8:	bd80      	pop	{r7, pc}
 80081ba:	bf00      	nop

080081bc <pubsub_init_topic>:

void pubsub_init_topic(struct pubsub_topic_s* topic, struct pubsub_topic_group_s* topic_group) {
 80081bc:	b480      	push	{r7}
 80081be:	b083      	sub	sp, #12
 80081c0:	af00      	add	r7, sp, #0
 80081c2:	6078      	str	r0, [r7, #4]
 80081c4:	6039      	str	r1, [r7, #0]
    if (!topic) {
 80081c6:	687b      	ldr	r3, [r7, #4]
 80081c8:	2b00      	cmp	r3, #0
 80081ca:	d00d      	beq.n	80081e8 <pubsub_init_topic+0x2c>
>>>>>>> 752c83b... update binaries
        return;
    }

    if (!topic_group) {
<<<<<<< HEAD
 800817c:	683b      	ldr	r3, [r7, #0]
 800817e:	2b00      	cmp	r3, #0
 8008180:	d101      	bne.n	8008186 <pubsub_init_topic+0x1a>
        topic_group = &PUBSUB_DEFAULT_TOPIC_GROUP;
 8008182:	4b08      	ldr	r3, [pc, #32]	; (80081a4 <pubsub_init_topic+0x38>)
 8008184:	603b      	str	r3, [r7, #0]
    }

    topic->message_list_tail = NULL;
 8008186:	687b      	ldr	r3, [r7, #4]
 8008188:	2200      	movs	r2, #0
 800818a:	601a      	str	r2, [r3, #0]
    topic->group = topic_group;
 800818c:	687b      	ldr	r3, [r7, #4]
 800818e:	683a      	ldr	r2, [r7, #0]
 8008190:	605a      	str	r2, [r3, #4]
    topic->listener_list_head = NULL;
 8008192:	687b      	ldr	r3, [r7, #4]
 8008194:	2200      	movs	r2, #0
 8008196:	609a      	str	r2, [r3, #8]
}
 8008198:	370c      	adds	r7, #12
 800819a:	46bd      	mov	sp, r7
 800819c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081a0:	4770      	bx	lr
 80081a2:	bf00      	nop
 80081a4:	20000a58 	.word	0x20000a58

080081a8 <pubsub_listener_init_and_register>:

void pubsub_listener_init_and_register(struct pubsub_listener_s* listener, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 80081a8:	b580      	push	{r7, lr}
 80081aa:	b086      	sub	sp, #24
 80081ac:	af00      	add	r7, sp, #0
 80081ae:	60f8      	str	r0, [r7, #12]
 80081b0:	60b9      	str	r1, [r7, #8]
 80081b2:	607a      	str	r2, [r7, #4]
 80081b4:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !listener) {
 80081b6:	68bb      	ldr	r3, [r7, #8]
 80081b8:	2b00      	cmp	r3, #0
 80081ba:	d036      	beq.n	800822a <pubsub_listener_init_and_register+0x82>
 80081bc:	68bb      	ldr	r3, [r7, #8]
 80081be:	685b      	ldr	r3, [r3, #4]
 80081c0:	2b00      	cmp	r3, #0
 80081c2:	d032      	beq.n	800822a <pubsub_listener_init_and_register+0x82>
 80081c4:	68fb      	ldr	r3, [r7, #12]
 80081c6:	2b00      	cmp	r3, #0
 80081c8:	d02f      	beq.n	800822a <pubsub_listener_init_and_register+0x82>
=======
 80081cc:	683b      	ldr	r3, [r7, #0]
 80081ce:	2b00      	cmp	r3, #0
 80081d0:	d101      	bne.n	80081d6 <pubsub_init_topic+0x1a>
        topic_group = &PUBSUB_DEFAULT_TOPIC_GROUP;
 80081d2:	4b08      	ldr	r3, [pc, #32]	; (80081f4 <pubsub_init_topic+0x38>)
 80081d4:	603b      	str	r3, [r7, #0]
    }

    topic->message_list_tail = NULL;
 80081d6:	687b      	ldr	r3, [r7, #4]
 80081d8:	2200      	movs	r2, #0
 80081da:	601a      	str	r2, [r3, #0]
    topic->group = topic_group;
 80081dc:	687b      	ldr	r3, [r7, #4]
 80081de:	683a      	ldr	r2, [r7, #0]
 80081e0:	605a      	str	r2, [r3, #4]
    topic->listener_list_head = NULL;
 80081e2:	687b      	ldr	r3, [r7, #4]
 80081e4:	2200      	movs	r2, #0
 80081e6:	609a      	str	r2, [r3, #8]
}
 80081e8:	370c      	adds	r7, #12
 80081ea:	46bd      	mov	sp, r7
 80081ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081f0:	4770      	bx	lr
 80081f2:	bf00      	nop
 80081f4:	20000a58 	.word	0x20000a58

080081f8 <pubsub_listener_init_and_register>:

void pubsub_listener_init_and_register(struct pubsub_listener_s* listener, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 80081f8:	b580      	push	{r7, lr}
 80081fa:	b086      	sub	sp, #24
 80081fc:	af00      	add	r7, sp, #0
 80081fe:	60f8      	str	r0, [r7, #12]
 8008200:	60b9      	str	r1, [r7, #8]
 8008202:	607a      	str	r2, [r7, #4]
 8008204:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !listener) {
 8008206:	68bb      	ldr	r3, [r7, #8]
 8008208:	2b00      	cmp	r3, #0
 800820a:	d036      	beq.n	800827a <pubsub_listener_init_and_register+0x82>
 800820c:	68bb      	ldr	r3, [r7, #8]
 800820e:	685b      	ldr	r3, [r3, #4]
 8008210:	2b00      	cmp	r3, #0
 8008212:	d032      	beq.n	800827a <pubsub_listener_init_and_register+0x82>
 8008214:	68fb      	ldr	r3, [r7, #12]
 8008216:	2b00      	cmp	r3, #0
 8008218:	d02f      	beq.n	800827a <pubsub_listener_init_and_register+0x82>
>>>>>>> 752c83b... update binaries
        return;
    }

    // initialize listener
    listener->topic = topic;
<<<<<<< HEAD
 80081ca:	68fb      	ldr	r3, [r7, #12]
 80081cc:	68ba      	ldr	r2, [r7, #8]
 80081ce:	601a      	str	r2, [r3, #0]
    listener->next_message = NULL;
 80081d0:	68fb      	ldr	r3, [r7, #12]
 80081d2:	2200      	movs	r2, #0
 80081d4:	605a      	str	r2, [r3, #4]
    listener->waiting_thread_reference_ptr = NULL;
 80081d6:	68fb      	ldr	r3, [r7, #12]
 80081d8:	2200      	movs	r2, #0
 80081da:	609a      	str	r2, [r3, #8]
    listener->handler_cb = handler_cb;
 80081dc:	68fb      	ldr	r3, [r7, #12]
 80081de:	687a      	ldr	r2, [r7, #4]
 80081e0:	60da      	str	r2, [r3, #12]
    listener->handler_cb_ctx = handler_cb_ctx;
 80081e2:	68fb      	ldr	r3, [r7, #12]
 80081e4:	683a      	ldr	r2, [r7, #0]
 80081e6:	611a      	str	r2, [r3, #16]
    chMtxObjectInit(&listener->mtx);
 80081e8:	68fb      	ldr	r3, [r7, #12]
 80081ea:	3318      	adds	r3, #24
 80081ec:	4618      	mov	r0, r3
 80081ee:	f002 fa97 	bl	800a720 <chMtxObjectInit>
    listener->next = NULL;
 80081f2:	68fb      	ldr	r3, [r7, #12]
 80081f4:	2200      	movs	r2, #0
 80081f6:	62da      	str	r2, [r3, #44]	; 0x2c
    listener->misses = 0;
 80081f8:	68fb      	ldr	r3, [r7, #12]
 80081fa:	2200      	movs	r2, #0
 80081fc:	615a      	str	r2, [r3, #20]

    // append listener to topic's listener list
    chSysLock();
 80081fe:	f7ff ff7b 	bl	80080f8 <chSysLock>
    LINKED_LIST_APPEND(struct pubsub_listener_s, topic->listener_list_head, listener);
 8008202:	68fb      	ldr	r3, [r7, #12]
 8008204:	2200      	movs	r2, #0
 8008206:	62da      	str	r2, [r3, #44]	; 0x2c
 8008208:	68bb      	ldr	r3, [r7, #8]
 800820a:	3308      	adds	r3, #8
 800820c:	617b      	str	r3, [r7, #20]
 800820e:	e003      	b.n	8008218 <pubsub_listener_init_and_register+0x70>
 8008210:	697b      	ldr	r3, [r7, #20]
 8008212:	681b      	ldr	r3, [r3, #0]
 8008214:	332c      	adds	r3, #44	; 0x2c
 8008216:	617b      	str	r3, [r7, #20]
 8008218:	697b      	ldr	r3, [r7, #20]
 800821a:	681b      	ldr	r3, [r3, #0]
 800821c:	2b00      	cmp	r3, #0
 800821e:	d1f7      	bne.n	8008210 <pubsub_listener_init_and_register+0x68>
 8008220:	697b      	ldr	r3, [r7, #20]
 8008222:	68fa      	ldr	r2, [r7, #12]
 8008224:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008226:	f7ff ff6f 	bl	8008108 <chSysUnlock>
}
 800822a:	3718      	adds	r7, #24
 800822c:	46bd      	mov	sp, r7
 800822e:	bd80      	pop	{r7, pc}

08008230 <pubsub_listener_unregister>:

void pubsub_listener_unregister(struct pubsub_listener_s* listener) {
 8008230:	b580      	push	{r7, lr}
 8008232:	b084      	sub	sp, #16
 8008234:	af00      	add	r7, sp, #0
 8008236:	6078      	str	r0, [r7, #4]
    if (!listener) {
 8008238:	687b      	ldr	r3, [r7, #4]
 800823a:	2b00      	cmp	r3, #0
 800823c:	d01e      	beq.n	800827c <pubsub_listener_unregister+0x4c>
=======
 800821a:	68fb      	ldr	r3, [r7, #12]
 800821c:	68ba      	ldr	r2, [r7, #8]
 800821e:	601a      	str	r2, [r3, #0]
    listener->next_message = NULL;
 8008220:	68fb      	ldr	r3, [r7, #12]
 8008222:	2200      	movs	r2, #0
 8008224:	605a      	str	r2, [r3, #4]
    listener->waiting_thread_reference_ptr = NULL;
 8008226:	68fb      	ldr	r3, [r7, #12]
 8008228:	2200      	movs	r2, #0
 800822a:	609a      	str	r2, [r3, #8]
    listener->handler_cb = handler_cb;
 800822c:	68fb      	ldr	r3, [r7, #12]
 800822e:	687a      	ldr	r2, [r7, #4]
 8008230:	60da      	str	r2, [r3, #12]
    listener->handler_cb_ctx = handler_cb_ctx;
 8008232:	68fb      	ldr	r3, [r7, #12]
 8008234:	683a      	ldr	r2, [r7, #0]
 8008236:	611a      	str	r2, [r3, #16]
    chMtxObjectInit(&listener->mtx);
 8008238:	68fb      	ldr	r3, [r7, #12]
 800823a:	3318      	adds	r3, #24
 800823c:	4618      	mov	r0, r3
 800823e:	f002 fab3 	bl	800a7a8 <chMtxObjectInit>
    listener->next = NULL;
 8008242:	68fb      	ldr	r3, [r7, #12]
 8008244:	2200      	movs	r2, #0
 8008246:	62da      	str	r2, [r3, #44]	; 0x2c
    listener->misses = 0;
 8008248:	68fb      	ldr	r3, [r7, #12]
 800824a:	2200      	movs	r2, #0
 800824c:	615a      	str	r2, [r3, #20]

    // append listener to topic's listener list
    chSysLock();
 800824e:	f7ff ff7b 	bl	8008148 <chSysLock>
    LINKED_LIST_APPEND(struct pubsub_listener_s, topic->listener_list_head, listener);
 8008252:	68fb      	ldr	r3, [r7, #12]
 8008254:	2200      	movs	r2, #0
 8008256:	62da      	str	r2, [r3, #44]	; 0x2c
 8008258:	68bb      	ldr	r3, [r7, #8]
 800825a:	3308      	adds	r3, #8
 800825c:	617b      	str	r3, [r7, #20]
 800825e:	e003      	b.n	8008268 <pubsub_listener_init_and_register+0x70>
 8008260:	697b      	ldr	r3, [r7, #20]
 8008262:	681b      	ldr	r3, [r3, #0]
 8008264:	332c      	adds	r3, #44	; 0x2c
 8008266:	617b      	str	r3, [r7, #20]
 8008268:	697b      	ldr	r3, [r7, #20]
 800826a:	681b      	ldr	r3, [r3, #0]
 800826c:	2b00      	cmp	r3, #0
 800826e:	d1f7      	bne.n	8008260 <pubsub_listener_init_and_register+0x68>
 8008270:	697b      	ldr	r3, [r7, #20]
 8008272:	68fa      	ldr	r2, [r7, #12]
 8008274:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008276:	f7ff ff6f 	bl	8008158 <chSysUnlock>
}
 800827a:	3718      	adds	r7, #24
 800827c:	46bd      	mov	sp, r7
 800827e:	bd80      	pop	{r7, pc}

08008280 <pubsub_listener_unregister>:

void pubsub_listener_unregister(struct pubsub_listener_s* listener) {
 8008280:	b580      	push	{r7, lr}
 8008282:	b084      	sub	sp, #16
 8008284:	af00      	add	r7, sp, #0
 8008286:	6078      	str	r0, [r7, #4]
    if (!listener) {
 8008288:	687b      	ldr	r3, [r7, #4]
 800828a:	2b00      	cmp	r3, #0
 800828c:	d01e      	beq.n	80082cc <pubsub_listener_unregister+0x4c>
>>>>>>> 752c83b... update binaries
        return;
    }

    // remove listener from topic's listener list
    chSysLock();
<<<<<<< HEAD
 800823e:	f7ff ff5b 	bl	80080f8 <chSysLock>
    LINKED_LIST_REMOVE(struct pubsub_listener_s, listener->topic->listener_list_head, listener);
 8008242:	687b      	ldr	r3, [r7, #4]
 8008244:	681b      	ldr	r3, [r3, #0]
 8008246:	3308      	adds	r3, #8
 8008248:	60fb      	str	r3, [r7, #12]
 800824a:	e003      	b.n	8008254 <pubsub_listener_unregister+0x24>
 800824c:	68fb      	ldr	r3, [r7, #12]
 800824e:	681b      	ldr	r3, [r3, #0]
 8008250:	332c      	adds	r3, #44	; 0x2c
 8008252:	60fb      	str	r3, [r7, #12]
 8008254:	68fb      	ldr	r3, [r7, #12]
 8008256:	681b      	ldr	r3, [r3, #0]
 8008258:	2b00      	cmp	r3, #0
 800825a:	d004      	beq.n	8008266 <pubsub_listener_unregister+0x36>
 800825c:	68fb      	ldr	r3, [r7, #12]
 800825e:	681a      	ldr	r2, [r3, #0]
 8008260:	687b      	ldr	r3, [r7, #4]
 8008262:	429a      	cmp	r2, r3
 8008264:	d1f2      	bne.n	800824c <pubsub_listener_unregister+0x1c>
 8008266:	68fb      	ldr	r3, [r7, #12]
 8008268:	681b      	ldr	r3, [r3, #0]
 800826a:	2b00      	cmp	r3, #0
 800826c:	d004      	beq.n	8008278 <pubsub_listener_unregister+0x48>
 800826e:	68fb      	ldr	r3, [r7, #12]
 8008270:	681b      	ldr	r3, [r3, #0]
 8008272:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008274:	68fb      	ldr	r3, [r7, #12]
 8008276:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008278:	f7ff ff46 	bl	8008108 <chSysUnlock>
}
 800827c:	3710      	adds	r7, #16
 800827e:	46bd      	mov	sp, r7
 8008280:	bd80      	pop	{r7, pc}
 8008282:	bf00      	nop

08008284 <pubsub_listener_has_message>:
=======
 800828e:	f7ff ff5b 	bl	8008148 <chSysLock>
    LINKED_LIST_REMOVE(struct pubsub_listener_s, listener->topic->listener_list_head, listener);
 8008292:	687b      	ldr	r3, [r7, #4]
 8008294:	681b      	ldr	r3, [r3, #0]
 8008296:	3308      	adds	r3, #8
 8008298:	60fb      	str	r3, [r7, #12]
 800829a:	e003      	b.n	80082a4 <pubsub_listener_unregister+0x24>
 800829c:	68fb      	ldr	r3, [r7, #12]
 800829e:	681b      	ldr	r3, [r3, #0]
 80082a0:	332c      	adds	r3, #44	; 0x2c
 80082a2:	60fb      	str	r3, [r7, #12]
 80082a4:	68fb      	ldr	r3, [r7, #12]
 80082a6:	681b      	ldr	r3, [r3, #0]
 80082a8:	2b00      	cmp	r3, #0
 80082aa:	d004      	beq.n	80082b6 <pubsub_listener_unregister+0x36>
 80082ac:	68fb      	ldr	r3, [r7, #12]
 80082ae:	681a      	ldr	r2, [r3, #0]
 80082b0:	687b      	ldr	r3, [r7, #4]
 80082b2:	429a      	cmp	r2, r3
 80082b4:	d1f2      	bne.n	800829c <pubsub_listener_unregister+0x1c>
 80082b6:	68fb      	ldr	r3, [r7, #12]
 80082b8:	681b      	ldr	r3, [r3, #0]
 80082ba:	2b00      	cmp	r3, #0
 80082bc:	d004      	beq.n	80082c8 <pubsub_listener_unregister+0x48>
 80082be:	68fb      	ldr	r3, [r7, #12]
 80082c0:	681b      	ldr	r3, [r3, #0]
 80082c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80082c4:	68fb      	ldr	r3, [r7, #12]
 80082c6:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 80082c8:	f7ff ff46 	bl	8008158 <chSysUnlock>
}
 80082cc:	3710      	adds	r7, #16
 80082ce:	46bd      	mov	sp, r7
 80082d0:	bd80      	pop	{r7, pc}
 80082d2:	bf00      	nop

080082d4 <pubsub_listener_has_message>:
>>>>>>> 752c83b... update binaries
    chMtxLock(&listener->mtx);
    listener->next_message = NULL;
    chMtxUnlock(&listener->mtx);
}

bool pubsub_listener_has_message(struct pubsub_listener_s* listener) {
<<<<<<< HEAD
 8008284:	b480      	push	{r7}
 8008286:	b083      	sub	sp, #12
 8008288:	af00      	add	r7, sp, #0
 800828a:	6078      	str	r0, [r7, #4]
    return listener->next_message != NULL;
 800828c:	687b      	ldr	r3, [r7, #4]
 800828e:	685b      	ldr	r3, [r3, #4]
 8008290:	2b00      	cmp	r3, #0
 8008292:	bf14      	ite	ne
 8008294:	2301      	movne	r3, #1
 8008296:	2300      	moveq	r3, #0
 8008298:	b2db      	uxtb	r3, r3
}
 800829a:	4618      	mov	r0, r3
 800829c:	370c      	adds	r7, #12
 800829e:	46bd      	mov	sp, r7
 80082a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082a4:	4770      	bx	lr
 80082a6:	bf00      	nop

080082a8 <pubsub_copy_writer_func>:

void pubsub_copy_writer_func(size_t msg_size, void* msg, void* ctx) {
 80082a8:	b580      	push	{r7, lr}
 80082aa:	b084      	sub	sp, #16
 80082ac:	af00      	add	r7, sp, #0
 80082ae:	60f8      	str	r0, [r7, #12]
 80082b0:	60b9      	str	r1, [r7, #8]
 80082b2:	607a      	str	r2, [r7, #4]
    memcpy(msg, ctx, msg_size);
 80082b4:	68b8      	ldr	r0, [r7, #8]
 80082b6:	6879      	ldr	r1, [r7, #4]
 80082b8:	68fa      	ldr	r2, [r7, #12]
 80082ba:	f006 f95f 	bl	800e57c <memcpy>
}
 80082be:	3710      	adds	r7, #16
 80082c0:	46bd      	mov	sp, r7
 80082c2:	bd80      	pop	{r7, pc}

080082c4 <pubsub_delete_message_S>:

static void pubsub_delete_message_S(struct pubsub_message_s* message_to_delete) {
 80082c4:	b580      	push	{r7, lr}
 80082c6:	b084      	sub	sp, #16
 80082c8:	af00      	add	r7, sp, #0
 80082ca:	6078      	str	r0, [r7, #4]
    struct pubsub_listener_s* listener = message_to_delete->topic->listener_list_head;
 80082cc:	687b      	ldr	r3, [r7, #4]
 80082ce:	681b      	ldr	r3, [r3, #0]
 80082d0:	689b      	ldr	r3, [r3, #8]
 80082d2:	60fb      	str	r3, [r7, #12]

    if (message_to_delete->topic->message_list_tail == message_to_delete) {
 80082d4:	687b      	ldr	r3, [r7, #4]
 80082d6:	681b      	ldr	r3, [r3, #0]
 80082d8:	681a      	ldr	r2, [r3, #0]
 80082da:	687b      	ldr	r3, [r7, #4]
 80082dc:	429a      	cmp	r2, r3
 80082de:	d124      	bne.n	800832a <pubsub_delete_message_S+0x66>
        message_to_delete->topic->message_list_tail = NULL;
 80082e0:	687b      	ldr	r3, [r7, #4]
 80082e2:	681b      	ldr	r3, [r3, #0]
 80082e4:	2200      	movs	r2, #0
 80082e6:	601a      	str	r2, [r3, #0]
 80082e8:	e01f      	b.n	800832a <pubsub_delete_message_S+0x66>
=======
 80082d4:	b480      	push	{r7}
 80082d6:	b083      	sub	sp, #12
 80082d8:	af00      	add	r7, sp, #0
 80082da:	6078      	str	r0, [r7, #4]
    return listener->next_message != NULL;
 80082dc:	687b      	ldr	r3, [r7, #4]
 80082de:	685b      	ldr	r3, [r3, #4]
 80082e0:	2b00      	cmp	r3, #0
 80082e2:	bf14      	ite	ne
 80082e4:	2301      	movne	r3, #1
 80082e6:	2300      	moveq	r3, #0
 80082e8:	b2db      	uxtb	r3, r3
}
 80082ea:	4618      	mov	r0, r3
 80082ec:	370c      	adds	r7, #12
 80082ee:	46bd      	mov	sp, r7
 80082f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082f4:	4770      	bx	lr
 80082f6:	bf00      	nop

080082f8 <pubsub_copy_writer_func>:

void pubsub_copy_writer_func(size_t msg_size, void* msg, void* ctx) {
 80082f8:	b580      	push	{r7, lr}
 80082fa:	b084      	sub	sp, #16
 80082fc:	af00      	add	r7, sp, #0
 80082fe:	60f8      	str	r0, [r7, #12]
 8008300:	60b9      	str	r1, [r7, #8]
 8008302:	607a      	str	r2, [r7, #4]
    memcpy(msg, ctx, msg_size);
 8008304:	68b8      	ldr	r0, [r7, #8]
 8008306:	6879      	ldr	r1, [r7, #4]
 8008308:	68fa      	ldr	r2, [r7, #12]
 800830a:	f006 f97b 	bl	800e604 <memcpy>
}
 800830e:	3710      	adds	r7, #16
 8008310:	46bd      	mov	sp, r7
 8008312:	bd80      	pop	{r7, pc}

08008314 <pubsub_delete_message_S>:

static void pubsub_delete_message_S(struct pubsub_message_s* message_to_delete) {
 8008314:	b580      	push	{r7, lr}
 8008316:	b084      	sub	sp, #16
 8008318:	af00      	add	r7, sp, #0
 800831a:	6078      	str	r0, [r7, #4]
    struct pubsub_listener_s* listener = message_to_delete->topic->listener_list_head;
 800831c:	687b      	ldr	r3, [r7, #4]
 800831e:	681b      	ldr	r3, [r3, #0]
 8008320:	689b      	ldr	r3, [r3, #8]
 8008322:	60fb      	str	r3, [r7, #12]

    if (message_to_delete->topic->message_list_tail == message_to_delete) {
 8008324:	687b      	ldr	r3, [r7, #4]
 8008326:	681b      	ldr	r3, [r3, #0]
 8008328:	681a      	ldr	r2, [r3, #0]
 800832a:	687b      	ldr	r3, [r7, #4]
 800832c:	429a      	cmp	r2, r3
 800832e:	d124      	bne.n	800837a <pubsub_delete_message_S+0x66>
        message_to_delete->topic->message_list_tail = NULL;
 8008330:	687b      	ldr	r3, [r7, #4]
 8008332:	681b      	ldr	r3, [r3, #0]
 8008334:	2200      	movs	r2, #0
 8008336:	601a      	str	r2, [r3, #0]
 8008338:	e01f      	b.n	800837a <pubsub_delete_message_S+0x66>
>>>>>>> 752c83b... update binaries
    }

    while (listener) {
        if (listener->next_message == message_to_delete) {
<<<<<<< HEAD
 80082ea:	68fb      	ldr	r3, [r7, #12]
 80082ec:	685a      	ldr	r2, [r3, #4]
 80082ee:	687b      	ldr	r3, [r7, #4]
 80082f0:	429a      	cmp	r2, r3
 80082f2:	d117      	bne.n	8008324 <pubsub_delete_message_S+0x60>
            chMtxLockS(&listener->mtx);
 80082f4:	68fb      	ldr	r3, [r7, #12]
 80082f6:	3318      	adds	r3, #24
 80082f8:	4618      	mov	r0, r3
 80082fa:	f002 fa2b 	bl	800a754 <chMtxLockS>
            if (listener->next_message == message_to_delete) {
 80082fe:	68fb      	ldr	r3, [r7, #12]
 8008300:	685a      	ldr	r2, [r3, #4]
 8008302:	687b      	ldr	r3, [r7, #4]
 8008304:	429a      	cmp	r2, r3
 8008306:	d108      	bne.n	800831a <pubsub_delete_message_S+0x56>
                listener->next_message = message_to_delete->next_in_topic;
 8008308:	687b      	ldr	r3, [r7, #4]
 800830a:	685a      	ldr	r2, [r3, #4]
 800830c:	68fb      	ldr	r3, [r7, #12]
 800830e:	605a      	str	r2, [r3, #4]
                listener->misses++;
 8008310:	68fb      	ldr	r3, [r7, #12]
 8008312:	695b      	ldr	r3, [r3, #20]
 8008314:	1c5a      	adds	r2, r3, #1
 8008316:	68fb      	ldr	r3, [r7, #12]
 8008318:	615a      	str	r2, [r3, #20]
            }
            chMtxUnlockS(&listener->mtx);
 800831a:	68fb      	ldr	r3, [r7, #12]
 800831c:	3318      	adds	r3, #24
 800831e:	4618      	mov	r0, r3
 8008320:	f002 fb34 	bl	800a98c <chMtxUnlockS>
        }
        listener = listener->next;
 8008324:	68fb      	ldr	r3, [r7, #12]
 8008326:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008328:	60fb      	str	r3, [r7, #12]
=======
 800833a:	68fb      	ldr	r3, [r7, #12]
 800833c:	685a      	ldr	r2, [r3, #4]
 800833e:	687b      	ldr	r3, [r7, #4]
 8008340:	429a      	cmp	r2, r3
 8008342:	d117      	bne.n	8008374 <pubsub_delete_message_S+0x60>
            chMtxLockS(&listener->mtx);
 8008344:	68fb      	ldr	r3, [r7, #12]
 8008346:	3318      	adds	r3, #24
 8008348:	4618      	mov	r0, r3
 800834a:	f002 fa47 	bl	800a7dc <chMtxLockS>
            if (listener->next_message == message_to_delete) {
 800834e:	68fb      	ldr	r3, [r7, #12]
 8008350:	685a      	ldr	r2, [r3, #4]
 8008352:	687b      	ldr	r3, [r7, #4]
 8008354:	429a      	cmp	r2, r3
 8008356:	d108      	bne.n	800836a <pubsub_delete_message_S+0x56>
                listener->next_message = message_to_delete->next_in_topic;
 8008358:	687b      	ldr	r3, [r7, #4]
 800835a:	685a      	ldr	r2, [r3, #4]
 800835c:	68fb      	ldr	r3, [r7, #12]
 800835e:	605a      	str	r2, [r3, #4]
                listener->misses++;
 8008360:	68fb      	ldr	r3, [r7, #12]
 8008362:	695b      	ldr	r3, [r3, #20]
 8008364:	1c5a      	adds	r2, r3, #1
 8008366:	68fb      	ldr	r3, [r7, #12]
 8008368:	615a      	str	r2, [r3, #20]
            }
            chMtxUnlockS(&listener->mtx);
 800836a:	68fb      	ldr	r3, [r7, #12]
 800836c:	3318      	adds	r3, #24
 800836e:	4618      	mov	r0, r3
 8008370:	f002 fb50 	bl	800aa14 <chMtxUnlockS>
        }
        listener = listener->next;
 8008374:	68fb      	ldr	r3, [r7, #12]
 8008376:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008378:	60fb      	str	r3, [r7, #12]
>>>>>>> 752c83b... update binaries

    if (message_to_delete->topic->message_list_tail == message_to_delete) {
        message_to_delete->topic->message_list_tail = NULL;
    }

    while (listener) {
<<<<<<< HEAD
 800832a:	68fb      	ldr	r3, [r7, #12]
 800832c:	2b00      	cmp	r3, #0
 800832e:	d1dc      	bne.n	80082ea <pubsub_delete_message_S+0x26>
=======
 800837a:	68fb      	ldr	r3, [r7, #12]
 800837c:	2b00      	cmp	r3, #0
 800837e:	d1dc      	bne.n	800833a <pubsub_delete_message_S+0x26>
>>>>>>> 752c83b... update binaries
            }
            chMtxUnlockS(&listener->mtx);
        }
        listener = listener->next;
    }
}
<<<<<<< HEAD
 8008330:	3710      	adds	r7, #16
 8008332:	46bd      	mov	sp, r7
 8008334:	bd80      	pop	{r7, pc}
 8008336:	bf00      	nop

08008338 <pubsub_publish_message>:

void pubsub_publish_message(struct pubsub_topic_s* topic, size_t size, pubsub_message_writer_func_ptr writer_cb, void* ctx) {
 8008338:	b580      	push	{r7, lr}
 800833a:	b088      	sub	sp, #32
 800833c:	af00      	add	r7, sp, #0
 800833e:	60f8      	str	r0, [r7, #12]
 8008340:	60b9      	str	r1, [r7, #8]
 8008342:	607a      	str	r2, [r7, #4]
 8008344:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !topic->listener_list_head) {
 8008346:	68fb      	ldr	r3, [r7, #12]
 8008348:	2b00      	cmp	r3, #0
 800834a:	d07c      	beq.n	8008446 <pubsub_publish_message+0x10e>
 800834c:	68fb      	ldr	r3, [r7, #12]
 800834e:	685b      	ldr	r3, [r3, #4]
 8008350:	2b00      	cmp	r3, #0
 8008352:	d078      	beq.n	8008446 <pubsub_publish_message+0x10e>
 8008354:	68fb      	ldr	r3, [r7, #12]
 8008356:	689b      	ldr	r3, [r3, #8]
 8008358:	2b00      	cmp	r3, #0
 800835a:	d074      	beq.n	8008446 <pubsub_publish_message+0x10e>
=======
 8008380:	3710      	adds	r7, #16
 8008382:	46bd      	mov	sp, r7
 8008384:	bd80      	pop	{r7, pc}
 8008386:	bf00      	nop

08008388 <pubsub_publish_message>:

void pubsub_publish_message(struct pubsub_topic_s* topic, size_t size, pubsub_message_writer_func_ptr writer_cb, void* ctx) {
 8008388:	b580      	push	{r7, lr}
 800838a:	b088      	sub	sp, #32
 800838c:	af00      	add	r7, sp, #0
 800838e:	60f8      	str	r0, [r7, #12]
 8008390:	60b9      	str	r1, [r7, #8]
 8008392:	607a      	str	r2, [r7, #4]
 8008394:	603b      	str	r3, [r7, #0]
    if (!topic || !topic->group || !topic->listener_list_head) {
 8008396:	68fb      	ldr	r3, [r7, #12]
 8008398:	2b00      	cmp	r3, #0
 800839a:	d07c      	beq.n	8008496 <pubsub_publish_message+0x10e>
 800839c:	68fb      	ldr	r3, [r7, #12]
 800839e:	685b      	ldr	r3, [r3, #4]
 80083a0:	2b00      	cmp	r3, #0
 80083a2:	d078      	beq.n	8008496 <pubsub_publish_message+0x10e>
 80083a4:	68fb      	ldr	r3, [r7, #12]
 80083a6:	689b      	ldr	r3, [r3, #8]
 80083a8:	2b00      	cmp	r3, #0
 80083aa:	d074      	beq.n	8008496 <pubsub_publish_message+0x10e>
>>>>>>> 752c83b... update binaries
        return;
    }

    struct pubsub_message_s* message;
    while (true) {
        chSysLock();
<<<<<<< HEAD
 800835c:	f7ff fecc 	bl	80080f8 <chSysLock>
        message = fifoallocator_allocate(&topic->group->allocator, size+sizeof(struct pubsub_message_s));
 8008360:	68fb      	ldr	r3, [r7, #12]
 8008362:	685b      	ldr	r3, [r3, #4]
 8008364:	461a      	mov	r2, r3
 8008366:	68bb      	ldr	r3, [r7, #8]
 8008368:	3308      	adds	r3, #8
 800836a:	4610      	mov	r0, r2
 800836c:	4619      	mov	r1, r3
 800836e:	f7ff fdb5 	bl	8007edc <fifoallocator_allocate>
 8008372:	61b8      	str	r0, [r7, #24]

        if (message != NULL) {
 8008374:	69bb      	ldr	r3, [r7, #24]
 8008376:	2b00      	cmp	r3, #0
 8008378:	d119      	bne.n	80083ae <pubsub_publish_message+0x76>
=======
 80083ac:	f7ff fecc 	bl	8008148 <chSysLock>
        message = fifoallocator_allocate(&topic->group->allocator, size+sizeof(struct pubsub_message_s));
 80083b0:	68fb      	ldr	r3, [r7, #12]
 80083b2:	685b      	ldr	r3, [r3, #4]
 80083b4:	461a      	mov	r2, r3
 80083b6:	68bb      	ldr	r3, [r7, #8]
 80083b8:	3308      	adds	r3, #8
 80083ba:	4610      	mov	r0, r2
 80083bc:	4619      	mov	r1, r3
 80083be:	f7ff fdb5 	bl	8007f2c <fifoallocator_allocate>
 80083c2:	61b8      	str	r0, [r7, #24]

        if (message != NULL) {
 80083c4:	69bb      	ldr	r3, [r7, #24]
 80083c6:	2b00      	cmp	r3, #0
 80083c8:	d119      	bne.n	80083fe <pubsub_publish_message+0x76>
>>>>>>> 752c83b... update binaries
            break;
        }

        // Delete the oldest message in the topic group
        struct pubsub_message_s* message_to_delete = fifoallocator_peek_oldest(&topic->group->allocator);
<<<<<<< HEAD
 800837a:	68fb      	ldr	r3, [r7, #12]
 800837c:	685b      	ldr	r3, [r3, #4]
 800837e:	4618      	mov	r0, r3
 8008380:	f7ff fe2c 	bl	8007fdc <fifoallocator_peek_oldest>
 8008384:	6178      	str	r0, [r7, #20]
        pubsub_delete_message_S(message_to_delete);
 8008386:	6978      	ldr	r0, [r7, #20]
 8008388:	f7ff ff9c 	bl	80082c4 <pubsub_delete_message_S>

        if (fifoallocator_peek_oldest(&topic->group->allocator) == message_to_delete) {
 800838c:	68fb      	ldr	r3, [r7, #12]
 800838e:	685b      	ldr	r3, [r3, #4]
 8008390:	4618      	mov	r0, r3
 8008392:	f7ff fe23 	bl	8007fdc <fifoallocator_peek_oldest>
 8008396:	4602      	mov	r2, r0
 8008398:	697b      	ldr	r3, [r7, #20]
 800839a:	429a      	cmp	r2, r3
 800839c:	d104      	bne.n	80083a8 <pubsub_publish_message+0x70>
            fifoallocator_pop_oldest(&topic->group->allocator);
 800839e:	68fb      	ldr	r3, [r7, #12]
 80083a0:	685b      	ldr	r3, [r3, #4]
 80083a2:	4618      	mov	r0, r3
 80083a4:	f7ff fe42 	bl	800802c <fifoallocator_pop_oldest>
        }

        chSysUnlock();
 80083a8:	f7ff feae 	bl	8008108 <chSysUnlock>
 80083ac:	e7d6      	b.n	800835c <pubsub_publish_message+0x24>
    }

    message->topic = topic;
 80083ae:	69bb      	ldr	r3, [r7, #24]
 80083b0:	68fa      	ldr	r2, [r7, #12]
 80083b2:	601a      	str	r2, [r3, #0]
    message->next_in_topic = NULL;
 80083b4:	69bb      	ldr	r3, [r7, #24]
 80083b6:	2200      	movs	r2, #0
 80083b8:	605a      	str	r2, [r3, #4]

    if (writer_cb) {
 80083ba:	687b      	ldr	r3, [r7, #4]
 80083bc:	2b00      	cmp	r3, #0
 80083be:	d007      	beq.n	80083d0 <pubsub_publish_message+0x98>
        writer_cb(size, message->data, ctx);
 80083c0:	69bb      	ldr	r3, [r7, #24]
 80083c2:	f103 0208 	add.w	r2, r3, #8
 80083c6:	687b      	ldr	r3, [r7, #4]
 80083c8:	68b8      	ldr	r0, [r7, #8]
 80083ca:	4611      	mov	r1, r2
 80083cc:	683a      	ldr	r2, [r7, #0]
 80083ce:	4798      	blx	r3
    }

    if (topic->message_list_tail) {
 80083d0:	68fb      	ldr	r3, [r7, #12]
 80083d2:	681b      	ldr	r3, [r3, #0]
 80083d4:	2b00      	cmp	r3, #0
 80083d6:	d00b      	beq.n	80083f0 <pubsub_publish_message+0xb8>
        chDbgCheck(topic->message_list_tail != message); // Circular reference
 80083d8:	68fb      	ldr	r3, [r7, #12]
 80083da:	681a      	ldr	r2, [r3, #0]
 80083dc:	69bb      	ldr	r3, [r7, #24]
 80083de:	429a      	cmp	r2, r3
 80083e0:	d102      	bne.n	80083e8 <pubsub_publish_message+0xb0>
 80083e2:	481a      	ldr	r0, [pc, #104]	; (800844c <pubsub_publish_message+0x114>)
 80083e4:	f002 fcde 	bl	800ada4 <chSysHalt>
        topic->message_list_tail->next_in_topic = message;
 80083e8:	68fb      	ldr	r3, [r7, #12]
 80083ea:	681b      	ldr	r3, [r3, #0]
 80083ec:	69ba      	ldr	r2, [r7, #24]
 80083ee:	605a      	str	r2, [r3, #4]
    }
    topic->message_list_tail = message;
 80083f0:	68fb      	ldr	r3, [r7, #12]
 80083f2:	69ba      	ldr	r2, [r7, #24]
 80083f4:	601a      	str	r2, [r3, #0]

    // Set listeners' next messages
    struct pubsub_listener_s* listener = topic->listener_list_head;
 80083f6:	68fb      	ldr	r3, [r7, #12]
 80083f8:	689b      	ldr	r3, [r3, #8]
 80083fa:	61fb      	str	r3, [r7, #28]
 80083fc:	e009      	b.n	8008412 <pubsub_publish_message+0xda>
    while (listener) {
        if (!listener->next_message) {
 80083fe:	69fb      	ldr	r3, [r7, #28]
 8008400:	685b      	ldr	r3, [r3, #4]
 8008402:	2b00      	cmp	r3, #0
 8008404:	d102      	bne.n	800840c <pubsub_publish_message+0xd4>
            listener->next_message = message;
 8008406:	69fb      	ldr	r3, [r7, #28]
 8008408:	69ba      	ldr	r2, [r7, #24]
 800840a:	605a      	str	r2, [r3, #4]
        }

        listener = listener->next;
 800840c:	69fb      	ldr	r3, [r7, #28]
 800840e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008410:	61fb      	str	r3, [r7, #28]
=======
 80083ca:	68fb      	ldr	r3, [r7, #12]
 80083cc:	685b      	ldr	r3, [r3, #4]
 80083ce:	4618      	mov	r0, r3
 80083d0:	f7ff fe2c 	bl	800802c <fifoallocator_peek_oldest>
 80083d4:	6178      	str	r0, [r7, #20]
        pubsub_delete_message_S(message_to_delete);
 80083d6:	6978      	ldr	r0, [r7, #20]
 80083d8:	f7ff ff9c 	bl	8008314 <pubsub_delete_message_S>

        if (fifoallocator_peek_oldest(&topic->group->allocator) == message_to_delete) {
 80083dc:	68fb      	ldr	r3, [r7, #12]
 80083de:	685b      	ldr	r3, [r3, #4]
 80083e0:	4618      	mov	r0, r3
 80083e2:	f7ff fe23 	bl	800802c <fifoallocator_peek_oldest>
 80083e6:	4602      	mov	r2, r0
 80083e8:	697b      	ldr	r3, [r7, #20]
 80083ea:	429a      	cmp	r2, r3
 80083ec:	d104      	bne.n	80083f8 <pubsub_publish_message+0x70>
            fifoallocator_pop_oldest(&topic->group->allocator);
 80083ee:	68fb      	ldr	r3, [r7, #12]
 80083f0:	685b      	ldr	r3, [r3, #4]
 80083f2:	4618      	mov	r0, r3
 80083f4:	f7ff fe42 	bl	800807c <fifoallocator_pop_oldest>
        }

        chSysUnlock();
 80083f8:	f7ff feae 	bl	8008158 <chSysUnlock>
 80083fc:	e7d6      	b.n	80083ac <pubsub_publish_message+0x24>
    }

    message->topic = topic;
 80083fe:	69bb      	ldr	r3, [r7, #24]
 8008400:	68fa      	ldr	r2, [r7, #12]
 8008402:	601a      	str	r2, [r3, #0]
    message->next_in_topic = NULL;
 8008404:	69bb      	ldr	r3, [r7, #24]
 8008406:	2200      	movs	r2, #0
 8008408:	605a      	str	r2, [r3, #4]

    if (writer_cb) {
 800840a:	687b      	ldr	r3, [r7, #4]
 800840c:	2b00      	cmp	r3, #0
 800840e:	d007      	beq.n	8008420 <pubsub_publish_message+0x98>
        writer_cb(size, message->data, ctx);
 8008410:	69bb      	ldr	r3, [r7, #24]
 8008412:	f103 0208 	add.w	r2, r3, #8
 8008416:	687b      	ldr	r3, [r7, #4]
 8008418:	68b8      	ldr	r0, [r7, #8]
 800841a:	4611      	mov	r1, r2
 800841c:	683a      	ldr	r2, [r7, #0]
 800841e:	4798      	blx	r3
    }

    if (topic->message_list_tail) {
 8008420:	68fb      	ldr	r3, [r7, #12]
 8008422:	681b      	ldr	r3, [r3, #0]
 8008424:	2b00      	cmp	r3, #0
 8008426:	d00b      	beq.n	8008440 <pubsub_publish_message+0xb8>
        chDbgCheck(topic->message_list_tail != message); // Circular reference
 8008428:	68fb      	ldr	r3, [r7, #12]
 800842a:	681a      	ldr	r2, [r3, #0]
 800842c:	69bb      	ldr	r3, [r7, #24]
 800842e:	429a      	cmp	r2, r3
 8008430:	d102      	bne.n	8008438 <pubsub_publish_message+0xb0>
 8008432:	481a      	ldr	r0, [pc, #104]	; (800849c <pubsub_publish_message+0x114>)
 8008434:	f002 fcfa 	bl	800ae2c <chSysHalt>
        topic->message_list_tail->next_in_topic = message;
 8008438:	68fb      	ldr	r3, [r7, #12]
 800843a:	681b      	ldr	r3, [r3, #0]
 800843c:	69ba      	ldr	r2, [r7, #24]
 800843e:	605a      	str	r2, [r3, #4]
    }
    topic->message_list_tail = message;
 8008440:	68fb      	ldr	r3, [r7, #12]
 8008442:	69ba      	ldr	r2, [r7, #24]
 8008444:	601a      	str	r2, [r3, #0]

    // Set listeners' next messages
    struct pubsub_listener_s* listener = topic->listener_list_head;
 8008446:	68fb      	ldr	r3, [r7, #12]
 8008448:	689b      	ldr	r3, [r3, #8]
 800844a:	61fb      	str	r3, [r7, #28]
 800844c:	e009      	b.n	8008462 <pubsub_publish_message+0xda>
    while (listener) {
        if (!listener->next_message) {
 800844e:	69fb      	ldr	r3, [r7, #28]
 8008450:	685b      	ldr	r3, [r3, #4]
 8008452:	2b00      	cmp	r3, #0
 8008454:	d102      	bne.n	800845c <pubsub_publish_message+0xd4>
            listener->next_message = message;
 8008456:	69fb      	ldr	r3, [r7, #28]
 8008458:	69ba      	ldr	r2, [r7, #24]
 800845a:	605a      	str	r2, [r3, #4]
        }

        listener = listener->next;
 800845c:	69fb      	ldr	r3, [r7, #28]
 800845e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008460:	61fb      	str	r3, [r7, #28]
>>>>>>> 752c83b... update binaries
    }
    topic->message_list_tail = message;

    // Set listeners' next messages
    struct pubsub_listener_s* listener = topic->listener_list_head;
    while (listener) {
<<<<<<< HEAD
 8008412:	69fb      	ldr	r3, [r7, #28]
 8008414:	2b00      	cmp	r3, #0
 8008416:	d1f2      	bne.n	80083fe <pubsub_publish_message+0xc6>
=======
 8008462:	69fb      	ldr	r3, [r7, #28]
 8008464:	2b00      	cmp	r3, #0
 8008466:	d1f2      	bne.n	800844e <pubsub_publish_message+0xc6>
>>>>>>> 752c83b... update binaries

        listener = listener->next;
    }

    // Wake listener threads
    listener = topic->listener_list_head;
<<<<<<< HEAD
 8008418:	68fb      	ldr	r3, [r7, #12]
 800841a:	689b      	ldr	r3, [r3, #8]
 800841c:	61fb      	str	r3, [r7, #28]
 800841e:	e00d      	b.n	800843c <pubsub_publish_message+0x104>
    while (listener) {
        if (listener->waiting_thread_reference_ptr) {
 8008420:	69fb      	ldr	r3, [r7, #28]
 8008422:	689b      	ldr	r3, [r3, #8]
 8008424:	2b00      	cmp	r3, #0
 8008426:	d006      	beq.n	8008436 <pubsub_publish_message+0xfe>
            chThdResumeS(listener->waiting_thread_reference_ptr, (msg_t)listener);
 8008428:	69fb      	ldr	r3, [r7, #28]
 800842a:	689a      	ldr	r2, [r3, #8]
 800842c:	69fb      	ldr	r3, [r7, #28]
 800842e:	4610      	mov	r0, r2
 8008430:	4619      	mov	r1, r3
 8008432:	f001 fff3 	bl	800a41c <chThdResumeS>
        }

        listener = listener->next;
 8008436:	69fb      	ldr	r3, [r7, #28]
 8008438:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800843a:	61fb      	str	r3, [r7, #28]
=======
 8008468:	68fb      	ldr	r3, [r7, #12]
 800846a:	689b      	ldr	r3, [r3, #8]
 800846c:	61fb      	str	r3, [r7, #28]
 800846e:	e00d      	b.n	800848c <pubsub_publish_message+0x104>
    while (listener) {
        if (listener->waiting_thread_reference_ptr) {
 8008470:	69fb      	ldr	r3, [r7, #28]
 8008472:	689b      	ldr	r3, [r3, #8]
 8008474:	2b00      	cmp	r3, #0
 8008476:	d006      	beq.n	8008486 <pubsub_publish_message+0xfe>
            chThdResumeS(listener->waiting_thread_reference_ptr, (msg_t)listener);
 8008478:	69fb      	ldr	r3, [r7, #28]
 800847a:	689a      	ldr	r2, [r3, #8]
 800847c:	69fb      	ldr	r3, [r7, #28]
 800847e:	4610      	mov	r0, r2
 8008480:	4619      	mov	r1, r3
 8008482:	f002 f80f 	bl	800a4a4 <chThdResumeS>
        }

        listener = listener->next;
 8008486:	69fb      	ldr	r3, [r7, #28]
 8008488:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800848a:	61fb      	str	r3, [r7, #28]
>>>>>>> 752c83b... update binaries
        listener = listener->next;
    }

    // Wake listener threads
    listener = topic->listener_list_head;
    while (listener) {
<<<<<<< HEAD
 800843c:	69fb      	ldr	r3, [r7, #28]
 800843e:	2b00      	cmp	r3, #0
 8008440:	d1ee      	bne.n	8008420 <pubsub_publish_message+0xe8>
=======
 800848c:	69fb      	ldr	r3, [r7, #28]
 800848e:	2b00      	cmp	r3, #0
 8008490:	d1ee      	bne.n	8008470 <pubsub_publish_message+0xe8>
>>>>>>> 752c83b... update binaries
        }

        listener = listener->next;
    }

    chSysUnlock();
<<<<<<< HEAD
 8008442:	f7ff fe61 	bl	8008108 <chSysUnlock>
}
 8008446:	3720      	adds	r7, #32
 8008448:	46bd      	mov	sp, r7
 800844a:	bd80      	pop	{r7, pc}
 800844c:	0800eb58 	.word	0x0800eb58

08008450 <pubsub_listener_handle_one_timeout>:
=======
 8008492:	f7ff fe61 	bl	8008158 <chSysUnlock>
}
 8008496:	3720      	adds	r7, #32
 8008498:	46bd      	mov	sp, r7
 800849a:	bd80      	pop	{r7, pc}
 800849c:	0800ec30 	.word	0x0800ec30

080084a0 <pubsub_listener_handle_one_timeout>:
>>>>>>> 752c83b... update binaries

void pubsub_listener_handle_until_timeout(struct pubsub_listener_s* listener, systime_t timeout) {
    pubsub_multiple_listener_handle_until_timeout(1, &listener, timeout);
}

bool pubsub_listener_handle_one_timeout(struct pubsub_listener_s* listener, systime_t timeout) {
<<<<<<< HEAD
 8008450:	b580      	push	{r7, lr}
 8008452:	b082      	sub	sp, #8
 8008454:	af00      	add	r7, sp, #0
 8008456:	6078      	str	r0, [r7, #4]
 8008458:	460b      	mov	r3, r1
 800845a:	807b      	strh	r3, [r7, #2]
    return pubsub_multiple_listener_handle_one_timeout(1, &listener, timeout);
 800845c:	1d3a      	adds	r2, r7, #4
 800845e:	887b      	ldrh	r3, [r7, #2]
 8008460:	2001      	movs	r0, #1
 8008462:	4611      	mov	r1, r2
 8008464:	461a      	mov	r2, r3
 8008466:	f000 f805 	bl	8008474 <pubsub_multiple_listener_handle_one_timeout>
 800846a:	4603      	mov	r3, r0
}
 800846c:	4618      	mov	r0, r3
 800846e:	3708      	adds	r7, #8
 8008470:	46bd      	mov	sp, r7
 8008472:	bd80      	pop	{r7, pc}

08008474 <pubsub_multiple_listener_handle_one_timeout>:
=======
 80084a0:	b580      	push	{r7, lr}
 80084a2:	b082      	sub	sp, #8
 80084a4:	af00      	add	r7, sp, #0
 80084a6:	6078      	str	r0, [r7, #4]
 80084a8:	460b      	mov	r3, r1
 80084aa:	807b      	strh	r3, [r7, #2]
    return pubsub_multiple_listener_handle_one_timeout(1, &listener, timeout);
 80084ac:	1d3a      	adds	r2, r7, #4
 80084ae:	887b      	ldrh	r3, [r7, #2]
 80084b0:	2001      	movs	r0, #1
 80084b2:	4611      	mov	r1, r2
 80084b4:	461a      	mov	r2, r3
 80084b6:	f000 f805 	bl	80084c4 <pubsub_multiple_listener_handle_one_timeout>
 80084ba:	4603      	mov	r3, r0
}
 80084bc:	4618      	mov	r0, r3
 80084be:	3708      	adds	r7, #8
 80084c0:	46bd      	mov	sp, r7
 80084c2:	bd80      	pop	{r7, pc}

080084c4 <pubsub_multiple_listener_handle_one_timeout>:
>>>>>>> 752c83b... update binaries

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout);

bool pubsub_multiple_listener_handle_one_timeout(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
<<<<<<< HEAD
 8008474:	b580      	push	{r7, lr}
 8008476:	b088      	sub	sp, #32
 8008478:	af00      	add	r7, sp, #0
 800847a:	60f8      	str	r0, [r7, #12]
 800847c:	60b9      	str	r1, [r7, #8]
 800847e:	4613      	mov	r3, r2
 8008480:	80fb      	strh	r3, [r7, #6]
    chSysLock();
 8008482:	f7ff fe39 	bl	80080f8 <chSysLock>
    struct pubsub_listener_s* listener_with_message = pubsub_multiple_listener_wait_timeout_S(num_listeners, listeners, timeout);
 8008486:	88fb      	ldrh	r3, [r7, #6]
 8008488:	68f8      	ldr	r0, [r7, #12]
 800848a:	68b9      	ldr	r1, [r7, #8]
 800848c:	461a      	mov	r2, r3
 800848e:	f000 f843 	bl	8008518 <pubsub_multiple_listener_wait_timeout_S>
 8008492:	61f8      	str	r0, [r7, #28]

    if (listener_with_message) {
 8008494:	69fb      	ldr	r3, [r7, #28]
 8008496:	2b00      	cmp	r3, #0
 8008498:	d027      	beq.n	80084ea <pubsub_multiple_listener_handle_one_timeout+0x76>
        chMtxLockS(&listener_with_message->mtx);
 800849a:	69fb      	ldr	r3, [r7, #28]
 800849c:	3318      	adds	r3, #24
 800849e:	4618      	mov	r0, r3
 80084a0:	f002 f958 	bl	800a754 <chMtxLockS>
        chSysUnlock();
 80084a4:	f7ff fe30 	bl	8008108 <chSysUnlock>

        struct pubsub_message_s* message = listener_with_message->next_message;
 80084a8:	69fb      	ldr	r3, [r7, #28]
 80084aa:	685b      	ldr	r3, [r3, #4]
 80084ac:	61bb      	str	r3, [r7, #24]
        listener_with_message->next_message = message->next_in_topic;
 80084ae:	69bb      	ldr	r3, [r7, #24]
 80084b0:	685a      	ldr	r2, [r3, #4]
 80084b2:	69fb      	ldr	r3, [r7, #28]
 80084b4:	605a      	str	r2, [r3, #4]

        if (listener_with_message->handler_cb) {
 80084b6:	69fb      	ldr	r3, [r7, #28]
 80084b8:	68db      	ldr	r3, [r3, #12]
 80084ba:	2b00      	cmp	r3, #0
 80084bc:	d00e      	beq.n	80084dc <pubsub_multiple_listener_handle_one_timeout+0x68>
            size_t message_size = fifoallocator_get_block_size(message)-sizeof(struct pubsub_message_s);
 80084be:	69b8      	ldr	r0, [r7, #24]
 80084c0:	f7ff fda2 	bl	8008008 <fifoallocator_get_block_size>
 80084c4:	4603      	mov	r3, r0
 80084c6:	3b08      	subs	r3, #8
 80084c8:	617b      	str	r3, [r7, #20]

            listener_with_message->handler_cb(message_size, message->data, listener_with_message->handler_cb_ctx);
 80084ca:	69fb      	ldr	r3, [r7, #28]
 80084cc:	68db      	ldr	r3, [r3, #12]
 80084ce:	69ba      	ldr	r2, [r7, #24]
 80084d0:	f102 0108 	add.w	r1, r2, #8
 80084d4:	69fa      	ldr	r2, [r7, #28]
 80084d6:	6912      	ldr	r2, [r2, #16]
 80084d8:	6978      	ldr	r0, [r7, #20]
 80084da:	4798      	blx	r3
        }

        chMtxUnlock(&listener_with_message->mtx);
 80084dc:	69fb      	ldr	r3, [r7, #28]
 80084de:	3318      	adds	r3, #24
 80084e0:	4618      	mov	r0, r3
 80084e2:	f002 f9cd 	bl	800a880 <chMtxUnlock>
        return true;
 80084e6:	2301      	movs	r3, #1
 80084e8:	e002      	b.n	80084f0 <pubsub_multiple_listener_handle_one_timeout+0x7c>
    } else {
        chSysUnlock();
 80084ea:	f7ff fe0d 	bl	8008108 <chSysUnlock>
        return false;
 80084ee:	2300      	movs	r3, #0
    }
}
 80084f0:	4618      	mov	r0, r3
 80084f2:	3720      	adds	r7, #32
 80084f4:	46bd      	mov	sp, r7
 80084f6:	bd80      	pop	{r7, pc}

080084f8 <pubsub_listener_set_waiting_thread_reference>:
=======
 80084c4:	b580      	push	{r7, lr}
 80084c6:	b088      	sub	sp, #32
 80084c8:	af00      	add	r7, sp, #0
 80084ca:	60f8      	str	r0, [r7, #12]
 80084cc:	60b9      	str	r1, [r7, #8]
 80084ce:	4613      	mov	r3, r2
 80084d0:	80fb      	strh	r3, [r7, #6]
    chSysLock();
 80084d2:	f7ff fe39 	bl	8008148 <chSysLock>
    struct pubsub_listener_s* listener_with_message = pubsub_multiple_listener_wait_timeout_S(num_listeners, listeners, timeout);
 80084d6:	88fb      	ldrh	r3, [r7, #6]
 80084d8:	68f8      	ldr	r0, [r7, #12]
 80084da:	68b9      	ldr	r1, [r7, #8]
 80084dc:	461a      	mov	r2, r3
 80084de:	f000 f843 	bl	8008568 <pubsub_multiple_listener_wait_timeout_S>
 80084e2:	61f8      	str	r0, [r7, #28]

    if (listener_with_message) {
 80084e4:	69fb      	ldr	r3, [r7, #28]
 80084e6:	2b00      	cmp	r3, #0
 80084e8:	d027      	beq.n	800853a <pubsub_multiple_listener_handle_one_timeout+0x76>
        chMtxLockS(&listener_with_message->mtx);
 80084ea:	69fb      	ldr	r3, [r7, #28]
 80084ec:	3318      	adds	r3, #24
 80084ee:	4618      	mov	r0, r3
 80084f0:	f002 f974 	bl	800a7dc <chMtxLockS>
        chSysUnlock();
 80084f4:	f7ff fe30 	bl	8008158 <chSysUnlock>

        struct pubsub_message_s* message = listener_with_message->next_message;
 80084f8:	69fb      	ldr	r3, [r7, #28]
 80084fa:	685b      	ldr	r3, [r3, #4]
 80084fc:	61bb      	str	r3, [r7, #24]
        listener_with_message->next_message = message->next_in_topic;
 80084fe:	69bb      	ldr	r3, [r7, #24]
 8008500:	685a      	ldr	r2, [r3, #4]
 8008502:	69fb      	ldr	r3, [r7, #28]
 8008504:	605a      	str	r2, [r3, #4]

        if (listener_with_message->handler_cb) {
 8008506:	69fb      	ldr	r3, [r7, #28]
 8008508:	68db      	ldr	r3, [r3, #12]
 800850a:	2b00      	cmp	r3, #0
 800850c:	d00e      	beq.n	800852c <pubsub_multiple_listener_handle_one_timeout+0x68>
            size_t message_size = fifoallocator_get_block_size(message)-sizeof(struct pubsub_message_s);
 800850e:	69b8      	ldr	r0, [r7, #24]
 8008510:	f7ff fda2 	bl	8008058 <fifoallocator_get_block_size>
 8008514:	4603      	mov	r3, r0
 8008516:	3b08      	subs	r3, #8
 8008518:	617b      	str	r3, [r7, #20]

            listener_with_message->handler_cb(message_size, message->data, listener_with_message->handler_cb_ctx);
 800851a:	69fb      	ldr	r3, [r7, #28]
 800851c:	68db      	ldr	r3, [r3, #12]
 800851e:	69ba      	ldr	r2, [r7, #24]
 8008520:	f102 0108 	add.w	r1, r2, #8
 8008524:	69fa      	ldr	r2, [r7, #28]
 8008526:	6912      	ldr	r2, [r2, #16]
 8008528:	6978      	ldr	r0, [r7, #20]
 800852a:	4798      	blx	r3
        }

        chMtxUnlock(&listener_with_message->mtx);
 800852c:	69fb      	ldr	r3, [r7, #28]
 800852e:	3318      	adds	r3, #24
 8008530:	4618      	mov	r0, r3
 8008532:	f002 f9e9 	bl	800a908 <chMtxUnlock>
        return true;
 8008536:	2301      	movs	r3, #1
 8008538:	e002      	b.n	8008540 <pubsub_multiple_listener_handle_one_timeout+0x7c>
    } else {
        chSysUnlock();
 800853a:	f7ff fe0d 	bl	8008158 <chSysUnlock>
        return false;
 800853e:	2300      	movs	r3, #0
    }
}
 8008540:	4618      	mov	r0, r3
 8008542:	3720      	adds	r7, #32
 8008544:	46bd      	mov	sp, r7
 8008546:	bd80      	pop	{r7, pc}

08008548 <pubsub_listener_set_waiting_thread_reference>:
>>>>>>> 752c83b... update binaries
            elapsed = chVTTimeElapsedSinceX(start);
        }
    } while(elapsed < timeout);
}

void pubsub_listener_set_waiting_thread_reference(struct pubsub_listener_s* listener, thread_reference_t* trpp) {
<<<<<<< HEAD
 80084f8:	b480      	push	{r7}
 80084fa:	b083      	sub	sp, #12
 80084fc:	af00      	add	r7, sp, #0
 80084fe:	6078      	str	r0, [r7, #4]
 8008500:	6039      	str	r1, [r7, #0]
    if (!listener) {
 8008502:	687b      	ldr	r3, [r7, #4]
 8008504:	2b00      	cmp	r3, #0
 8008506:	d002      	beq.n	800850e <pubsub_listener_set_waiting_thread_reference+0x16>
=======
 8008548:	b480      	push	{r7}
 800854a:	b083      	sub	sp, #12
 800854c:	af00      	add	r7, sp, #0
 800854e:	6078      	str	r0, [r7, #4]
 8008550:	6039      	str	r1, [r7, #0]
    if (!listener) {
 8008552:	687b      	ldr	r3, [r7, #4]
 8008554:	2b00      	cmp	r3, #0
 8008556:	d002      	beq.n	800855e <pubsub_listener_set_waiting_thread_reference+0x16>
>>>>>>> 752c83b... update binaries
        return;
    }

    listener->waiting_thread_reference_ptr = trpp;
<<<<<<< HEAD
 8008508:	687b      	ldr	r3, [r7, #4]
 800850a:	683a      	ldr	r2, [r7, #0]
 800850c:	609a      	str	r2, [r3, #8]
}
 800850e:	370c      	adds	r7, #12
 8008510:	46bd      	mov	sp, r7
 8008512:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008516:	4770      	bx	lr

08008518 <pubsub_multiple_listener_wait_timeout_S>:

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
 8008518:	b580      	push	{r7, lr}
 800851a:	b08c      	sub	sp, #48	; 0x30
 800851c:	af00      	add	r7, sp, #0
 800851e:	60f8      	str	r0, [r7, #12]
 8008520:	60b9      	str	r1, [r7, #8]
 8008522:	4613      	mov	r3, r2
 8008524:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassS();
 8008526:	f002 fd2d 	bl	800af84 <chDbgCheckClassS>

    // Check for immediately available messages
    for (size_t i=0; i<num_listeners; i++) {
 800852a:	2300      	movs	r3, #0
 800852c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800852e:	e01a      	b.n	8008566 <pubsub_multiple_listener_wait_timeout_S+0x4e>
        if (listeners && listeners[i] && listeners[i]->next_message) {
 8008530:	68bb      	ldr	r3, [r7, #8]
 8008532:	2b00      	cmp	r3, #0
 8008534:	d014      	beq.n	8008560 <pubsub_multiple_listener_wait_timeout_S+0x48>
 8008536:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008538:	009b      	lsls	r3, r3, #2
 800853a:	68ba      	ldr	r2, [r7, #8]
 800853c:	4413      	add	r3, r2
 800853e:	681b      	ldr	r3, [r3, #0]
 8008540:	2b00      	cmp	r3, #0
 8008542:	d00d      	beq.n	8008560 <pubsub_multiple_listener_wait_timeout_S+0x48>
 8008544:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008546:	009b      	lsls	r3, r3, #2
 8008548:	68ba      	ldr	r2, [r7, #8]
 800854a:	4413      	add	r3, r2
 800854c:	681b      	ldr	r3, [r3, #0]
 800854e:	685b      	ldr	r3, [r3, #4]
 8008550:	2b00      	cmp	r3, #0
 8008552:	d005      	beq.n	8008560 <pubsub_multiple_listener_wait_timeout_S+0x48>
            return listeners[i];
 8008554:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008556:	009b      	lsls	r3, r3, #2
 8008558:	68ba      	ldr	r2, [r7, #8]
 800855a:	4413      	add	r3, r2
 800855c:	681b      	ldr	r3, [r3, #0]
 800855e:	e06b      	b.n	8008638 <pubsub_multiple_listener_wait_timeout_S+0x120>
=======
 8008558:	687b      	ldr	r3, [r7, #4]
 800855a:	683a      	ldr	r2, [r7, #0]
 800855c:	609a      	str	r2, [r3, #8]
}
 800855e:	370c      	adds	r7, #12
 8008560:	46bd      	mov	sp, r7
 8008562:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008566:	4770      	bx	lr

08008568 <pubsub_multiple_listener_wait_timeout_S>:

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
 8008568:	b580      	push	{r7, lr}
 800856a:	b08c      	sub	sp, #48	; 0x30
 800856c:	af00      	add	r7, sp, #0
 800856e:	60f8      	str	r0, [r7, #12]
 8008570:	60b9      	str	r1, [r7, #8]
 8008572:	4613      	mov	r3, r2
 8008574:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassS();
 8008576:	f002 fd49 	bl	800b00c <chDbgCheckClassS>

    // Check for immediately available messages
    for (size_t i=0; i<num_listeners; i++) {
 800857a:	2300      	movs	r3, #0
 800857c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800857e:	e01a      	b.n	80085b6 <pubsub_multiple_listener_wait_timeout_S+0x4e>
        if (listeners && listeners[i] && listeners[i]->next_message) {
 8008580:	68bb      	ldr	r3, [r7, #8]
 8008582:	2b00      	cmp	r3, #0
 8008584:	d014      	beq.n	80085b0 <pubsub_multiple_listener_wait_timeout_S+0x48>
 8008586:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008588:	009b      	lsls	r3, r3, #2
 800858a:	68ba      	ldr	r2, [r7, #8]
 800858c:	4413      	add	r3, r2
 800858e:	681b      	ldr	r3, [r3, #0]
 8008590:	2b00      	cmp	r3, #0
 8008592:	d00d      	beq.n	80085b0 <pubsub_multiple_listener_wait_timeout_S+0x48>
 8008594:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008596:	009b      	lsls	r3, r3, #2
 8008598:	68ba      	ldr	r2, [r7, #8]
 800859a:	4413      	add	r3, r2
 800859c:	681b      	ldr	r3, [r3, #0]
 800859e:	685b      	ldr	r3, [r3, #4]
 80085a0:	2b00      	cmp	r3, #0
 80085a2:	d005      	beq.n	80085b0 <pubsub_multiple_listener_wait_timeout_S+0x48>
            return listeners[i];
 80085a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80085a6:	009b      	lsls	r3, r3, #2
 80085a8:	68ba      	ldr	r2, [r7, #8]
 80085aa:	4413      	add	r3, r2
 80085ac:	681b      	ldr	r3, [r3, #0]
 80085ae:	e06b      	b.n	8008688 <pubsub_multiple_listener_wait_timeout_S+0x120>
>>>>>>> 752c83b... update binaries

static struct pubsub_listener_s* pubsub_multiple_listener_wait_timeout_S(size_t num_listeners, struct pubsub_listener_s** listeners, systime_t timeout) {
    chDbgCheckClassS();

    // Check for immediately available messages
    for (size_t i=0; i<num_listeners; i++) {
<<<<<<< HEAD
 8008560:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008562:	3301      	adds	r3, #1
 8008564:	62fb      	str	r3, [r7, #44]	; 0x2c
 8008566:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008568:	68fb      	ldr	r3, [r7, #12]
 800856a:	429a      	cmp	r2, r3
 800856c:	d3e0      	bcc.n	8008530 <pubsub_multiple_listener_wait_timeout_S+0x18>
=======
 80085b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80085b2:	3301      	adds	r3, #1
 80085b4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80085b6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80085b8:	68fb      	ldr	r3, [r7, #12]
 80085ba:	429a      	cmp	r2, r3
 80085bc:	d3e0      	bcc.n	8008580 <pubsub_multiple_listener_wait_timeout_S+0x18>
>>>>>>> 752c83b... update binaries
        if (listeners && listeners[i] && listeners[i]->next_message) {
            return listeners[i];
        }
    }

    if (timeout == TIME_IMMEDIATE) {
<<<<<<< HEAD
 800856e:	88fb      	ldrh	r3, [r7, #6]
 8008570:	2b00      	cmp	r3, #0
 8008572:	d101      	bne.n	8008578 <pubsub_multiple_listener_wait_timeout_S+0x60>
        return NULL;
 8008574:	2300      	movs	r3, #0
 8008576:	e05f      	b.n	8008638 <pubsub_multiple_listener_wait_timeout_S+0x120>
=======
 80085be:	88fb      	ldrh	r3, [r7, #6]
 80085c0:	2b00      	cmp	r3, #0
 80085c2:	d101      	bne.n	80085c8 <pubsub_multiple_listener_wait_timeout_S+0x60>
        return NULL;
 80085c4:	2300      	movs	r3, #0
 80085c6:	e05f      	b.n	8008688 <pubsub_multiple_listener_wait_timeout_S+0x120>
>>>>>>> 752c83b... update binaries
    }

    // Point listeners' waiting thread references to our thread
    thread_reference_t trp = NULL;
<<<<<<< HEAD
 8008578:	2300      	movs	r3, #0
 800857a:	617b      	str	r3, [r7, #20]
    for (size_t i=0; i<num_listeners; i++) {
 800857c:	2300      	movs	r3, #0
 800857e:	62bb      	str	r3, [r7, #40]	; 0x28
 8008580:	e014      	b.n	80085ac <pubsub_multiple_listener_wait_timeout_S+0x94>
        if (listeners && listeners[i]) {
 8008582:	68bb      	ldr	r3, [r7, #8]
 8008584:	2b00      	cmp	r3, #0
 8008586:	d00e      	beq.n	80085a6 <pubsub_multiple_listener_wait_timeout_S+0x8e>
 8008588:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800858a:	009b      	lsls	r3, r3, #2
 800858c:	68ba      	ldr	r2, [r7, #8]
 800858e:	4413      	add	r3, r2
 8008590:	681b      	ldr	r3, [r3, #0]
 8008592:	2b00      	cmp	r3, #0
 8008594:	d007      	beq.n	80085a6 <pubsub_multiple_listener_wait_timeout_S+0x8e>
            listeners[i]->waiting_thread_reference_ptr = &trp;
 8008596:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008598:	009b      	lsls	r3, r3, #2
 800859a:	68ba      	ldr	r2, [r7, #8]
 800859c:	4413      	add	r3, r2
 800859e:	681b      	ldr	r3, [r3, #0]
 80085a0:	f107 0214 	add.w	r2, r7, #20
 80085a4:	609a      	str	r2, [r3, #8]
=======
 80085c8:	2300      	movs	r3, #0
 80085ca:	617b      	str	r3, [r7, #20]
    for (size_t i=0; i<num_listeners; i++) {
 80085cc:	2300      	movs	r3, #0
 80085ce:	62bb      	str	r3, [r7, #40]	; 0x28
 80085d0:	e014      	b.n	80085fc <pubsub_multiple_listener_wait_timeout_S+0x94>
        if (listeners && listeners[i]) {
 80085d2:	68bb      	ldr	r3, [r7, #8]
 80085d4:	2b00      	cmp	r3, #0
 80085d6:	d00e      	beq.n	80085f6 <pubsub_multiple_listener_wait_timeout_S+0x8e>
 80085d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80085da:	009b      	lsls	r3, r3, #2
 80085dc:	68ba      	ldr	r2, [r7, #8]
 80085de:	4413      	add	r3, r2
 80085e0:	681b      	ldr	r3, [r3, #0]
 80085e2:	2b00      	cmp	r3, #0
 80085e4:	d007      	beq.n	80085f6 <pubsub_multiple_listener_wait_timeout_S+0x8e>
            listeners[i]->waiting_thread_reference_ptr = &trp;
 80085e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80085e8:	009b      	lsls	r3, r3, #2
 80085ea:	68ba      	ldr	r2, [r7, #8]
 80085ec:	4413      	add	r3, r2
 80085ee:	681b      	ldr	r3, [r3, #0]
 80085f0:	f107 0214 	add.w	r2, r7, #20
 80085f4:	609a      	str	r2, [r3, #8]
>>>>>>> 752c83b... update binaries
        return NULL;
    }

    // Point listeners' waiting thread references to our thread
    thread_reference_t trp = NULL;
    for (size_t i=0; i<num_listeners; i++) {
<<<<<<< HEAD
 80085a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80085a8:	3301      	adds	r3, #1
 80085aa:	62bb      	str	r3, [r7, #40]	; 0x28
 80085ac:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80085ae:	68fb      	ldr	r3, [r7, #12]
 80085b0:	429a      	cmp	r2, r3
 80085b2:	d3e6      	bcc.n	8008582 <pubsub_multiple_listener_wait_timeout_S+0x6a>
=======
 80085f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80085f8:	3301      	adds	r3, #1
 80085fa:	62bb      	str	r3, [r7, #40]	; 0x28
 80085fc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80085fe:	68fb      	ldr	r3, [r7, #12]
 8008600:	429a      	cmp	r2, r3
 8008602:	d3e6      	bcc.n	80085d2 <pubsub_multiple_listener_wait_timeout_S+0x6a>
>>>>>>> 752c83b... update binaries
            listeners[i]->waiting_thread_reference_ptr = &trp;
        }
    }

    // Wait for a listener to wake us up
    msg_t message = chThdSuspendTimeoutS(&trp, timeout);
<<<<<<< HEAD
 80085b4:	f107 0214 	add.w	r2, r7, #20
 80085b8:	88fb      	ldrh	r3, [r7, #6]
 80085ba:	4610      	mov	r0, r2
 80085bc:	4619      	mov	r1, r3
 80085be:	f001 fee3 	bl	800a388 <chThdSuspendTimeoutS>
 80085c2:	61b8      	str	r0, [r7, #24]

    struct pubsub_listener_s* ret = NULL;
 80085c4:	2300      	movs	r3, #0
 80085c6:	627b      	str	r3, [r7, #36]	; 0x24
    if (message != MSG_TIMEOUT) {
 80085c8:	69bb      	ldr	r3, [r7, #24]
 80085ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 80085ce:	d017      	beq.n	8008600 <pubsub_multiple_listener_wait_timeout_S+0xe8>
        for (size_t i=0; i<num_listeners; i++) {
 80085d0:	2300      	movs	r3, #0
 80085d2:	623b      	str	r3, [r7, #32]
 80085d4:	e010      	b.n	80085f8 <pubsub_multiple_listener_wait_timeout_S+0xe0>
            if (listeners[i] == (void*)message) {
 80085d6:	6a3b      	ldr	r3, [r7, #32]
 80085d8:	009b      	lsls	r3, r3, #2
 80085da:	68ba      	ldr	r2, [r7, #8]
 80085dc:	4413      	add	r3, r2
 80085de:	681a      	ldr	r2, [r3, #0]
 80085e0:	69bb      	ldr	r3, [r7, #24]
 80085e2:	429a      	cmp	r2, r3
 80085e4:	d105      	bne.n	80085f2 <pubsub_multiple_listener_wait_timeout_S+0xda>
                ret = listeners[i];
 80085e6:	6a3b      	ldr	r3, [r7, #32]
 80085e8:	009b      	lsls	r3, r3, #2
 80085ea:	68ba      	ldr	r2, [r7, #8]
 80085ec:	4413      	add	r3, r2
 80085ee:	681b      	ldr	r3, [r3, #0]
 80085f0:	627b      	str	r3, [r7, #36]	; 0x24
=======
 8008604:	f107 0214 	add.w	r2, r7, #20
 8008608:	88fb      	ldrh	r3, [r7, #6]
 800860a:	4610      	mov	r0, r2
 800860c:	4619      	mov	r1, r3
 800860e:	f001 feff 	bl	800a410 <chThdSuspendTimeoutS>
 8008612:	61b8      	str	r0, [r7, #24]

    struct pubsub_listener_s* ret = NULL;
 8008614:	2300      	movs	r3, #0
 8008616:	627b      	str	r3, [r7, #36]	; 0x24
    if (message != MSG_TIMEOUT) {
 8008618:	69bb      	ldr	r3, [r7, #24]
 800861a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800861e:	d017      	beq.n	8008650 <pubsub_multiple_listener_wait_timeout_S+0xe8>
        for (size_t i=0; i<num_listeners; i++) {
 8008620:	2300      	movs	r3, #0
 8008622:	623b      	str	r3, [r7, #32]
 8008624:	e010      	b.n	8008648 <pubsub_multiple_listener_wait_timeout_S+0xe0>
            if (listeners[i] == (void*)message) {
 8008626:	6a3b      	ldr	r3, [r7, #32]
 8008628:	009b      	lsls	r3, r3, #2
 800862a:	68ba      	ldr	r2, [r7, #8]
 800862c:	4413      	add	r3, r2
 800862e:	681a      	ldr	r2, [r3, #0]
 8008630:	69bb      	ldr	r3, [r7, #24]
 8008632:	429a      	cmp	r2, r3
 8008634:	d105      	bne.n	8008642 <pubsub_multiple_listener_wait_timeout_S+0xda>
                ret = listeners[i];
 8008636:	6a3b      	ldr	r3, [r7, #32]
 8008638:	009b      	lsls	r3, r3, #2
 800863a:	68ba      	ldr	r2, [r7, #8]
 800863c:	4413      	add	r3, r2
 800863e:	681b      	ldr	r3, [r3, #0]
 8008640:	627b      	str	r3, [r7, #36]	; 0x24
>>>>>>> 752c83b... update binaries
    // Wait for a listener to wake us up
    msg_t message = chThdSuspendTimeoutS(&trp, timeout);

    struct pubsub_listener_s* ret = NULL;
    if (message != MSG_TIMEOUT) {
        for (size_t i=0; i<num_listeners; i++) {
<<<<<<< HEAD
 80085f2:	6a3b      	ldr	r3, [r7, #32]
 80085f4:	3301      	adds	r3, #1
 80085f6:	623b      	str	r3, [r7, #32]
 80085f8:	6a3a      	ldr	r2, [r7, #32]
 80085fa:	68fb      	ldr	r3, [r7, #12]
 80085fc:	429a      	cmp	r2, r3
 80085fe:	d3ea      	bcc.n	80085d6 <pubsub_multiple_listener_wait_timeout_S+0xbe>
=======
 8008642:	6a3b      	ldr	r3, [r7, #32]
 8008644:	3301      	adds	r3, #1
 8008646:	623b      	str	r3, [r7, #32]
 8008648:	6a3a      	ldr	r2, [r7, #32]
 800864a:	68fb      	ldr	r3, [r7, #12]
 800864c:	429a      	cmp	r2, r3
 800864e:	d3ea      	bcc.n	8008626 <pubsub_multiple_listener_wait_timeout_S+0xbe>
>>>>>>> 752c83b... update binaries
            }
        }
    }

    // Set listeners' waiting thread references back to NULL
    for (size_t i=0; i<num_listeners; i++) {
<<<<<<< HEAD
 8008600:	2300      	movs	r3, #0
 8008602:	61fb      	str	r3, [r7, #28]
 8008604:	e013      	b.n	800862e <pubsub_multiple_listener_wait_timeout_S+0x116>
        if (listeners && listeners[i]) {
 8008606:	68bb      	ldr	r3, [r7, #8]
 8008608:	2b00      	cmp	r3, #0
 800860a:	d00d      	beq.n	8008628 <pubsub_multiple_listener_wait_timeout_S+0x110>
 800860c:	69fb      	ldr	r3, [r7, #28]
 800860e:	009b      	lsls	r3, r3, #2
 8008610:	68ba      	ldr	r2, [r7, #8]
 8008612:	4413      	add	r3, r2
 8008614:	681b      	ldr	r3, [r3, #0]
 8008616:	2b00      	cmp	r3, #0
 8008618:	d006      	beq.n	8008628 <pubsub_multiple_listener_wait_timeout_S+0x110>
            listeners[i]->waiting_thread_reference_ptr = NULL;
 800861a:	69fb      	ldr	r3, [r7, #28]
 800861c:	009b      	lsls	r3, r3, #2
 800861e:	68ba      	ldr	r2, [r7, #8]
 8008620:	4413      	add	r3, r2
 8008622:	681b      	ldr	r3, [r3, #0]
 8008624:	2200      	movs	r2, #0
 8008626:	609a      	str	r2, [r3, #8]
=======
 8008650:	2300      	movs	r3, #0
 8008652:	61fb      	str	r3, [r7, #28]
 8008654:	e013      	b.n	800867e <pubsub_multiple_listener_wait_timeout_S+0x116>
        if (listeners && listeners[i]) {
 8008656:	68bb      	ldr	r3, [r7, #8]
 8008658:	2b00      	cmp	r3, #0
 800865a:	d00d      	beq.n	8008678 <pubsub_multiple_listener_wait_timeout_S+0x110>
 800865c:	69fb      	ldr	r3, [r7, #28]
 800865e:	009b      	lsls	r3, r3, #2
 8008660:	68ba      	ldr	r2, [r7, #8]
 8008662:	4413      	add	r3, r2
 8008664:	681b      	ldr	r3, [r3, #0]
 8008666:	2b00      	cmp	r3, #0
 8008668:	d006      	beq.n	8008678 <pubsub_multiple_listener_wait_timeout_S+0x110>
            listeners[i]->waiting_thread_reference_ptr = NULL;
 800866a:	69fb      	ldr	r3, [r7, #28]
 800866c:	009b      	lsls	r3, r3, #2
 800866e:	68ba      	ldr	r2, [r7, #8]
 8008670:	4413      	add	r3, r2
 8008672:	681b      	ldr	r3, [r3, #0]
 8008674:	2200      	movs	r2, #0
 8008676:	609a      	str	r2, [r3, #8]
>>>>>>> 752c83b... update binaries
            }
        }
    }

    // Set listeners' waiting thread references back to NULL
    for (size_t i=0; i<num_listeners; i++) {
<<<<<<< HEAD
 8008628:	69fb      	ldr	r3, [r7, #28]
 800862a:	3301      	adds	r3, #1
 800862c:	61fb      	str	r3, [r7, #28]
 800862e:	69fa      	ldr	r2, [r7, #28]
 8008630:	68fb      	ldr	r3, [r7, #12]
 8008632:	429a      	cmp	r2, r3
 8008634:	d3e7      	bcc.n	8008606 <pubsub_multiple_listener_wait_timeout_S+0xee>
=======
 8008678:	69fb      	ldr	r3, [r7, #28]
 800867a:	3301      	adds	r3, #1
 800867c:	61fb      	str	r3, [r7, #28]
 800867e:	69fa      	ldr	r2, [r7, #28]
 8008680:	68fb      	ldr	r3, [r7, #12]
 8008682:	429a      	cmp	r2, r3
 8008684:	d3e7      	bcc.n	8008656 <pubsub_multiple_listener_wait_timeout_S+0xee>
>>>>>>> 752c83b... update binaries
        if (listeners && listeners[i]) {
            listeners[i]->waiting_thread_reference_ptr = NULL;
        }
    }

    return ret;
<<<<<<< HEAD
 8008636:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8008638:	4618      	mov	r0, r3
 800863a:	3730      	adds	r7, #48	; 0x30
 800863c:	46bd      	mov	sp, r7
 800863e:	bd80      	pop	{r7, pc}

08008640 <port_lock.lto_priv.149>:
=======
 8008686:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8008688:	4618      	mov	r0, r3
 800868a:	3730      	adds	r7, #48	; 0x30
 800868c:	46bd      	mov	sp, r7
 800868e:	bd80      	pop	{r7, pc}

08008690 <port_lock.lto_priv.142>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 8008640:	b480      	push	{r7}
 8008642:	b083      	sub	sp, #12
 8008644:	af00      	add	r7, sp, #0
 8008646:	2320      	movs	r3, #32
 8008648:	607b      	str	r3, [r7, #4]
 800864a:	687b      	ldr	r3, [r7, #4]
 800864c:	f383 8811 	msr	BASEPRI, r3
=======
 8008690:	b480      	push	{r7}
 8008692:	b083      	sub	sp, #12
 8008694:	af00      	add	r7, sp, #0
 8008696:	2320      	movs	r3, #32
 8008698:	607b      	str	r3, [r7, #4]
 800869a:	687b      	ldr	r3, [r7, #4]
 800869c:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8008650:	370c      	adds	r7, #12
 8008652:	46bd      	mov	sp, r7
 8008654:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008658:	4770      	bx	lr
 800865a:	bf00      	nop

0800865c <port_unlock.lto_priv.147>:
=======
 80086a0:	370c      	adds	r7, #12
 80086a2:	46bd      	mov	sp, r7
 80086a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086a8:	4770      	bx	lr
 80086aa:	bf00      	nop

080086ac <port_unlock.lto_priv.140>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800865c:	b480      	push	{r7}
 800865e:	b083      	sub	sp, #12
 8008660:	af00      	add	r7, sp, #0
 8008662:	2300      	movs	r3, #0
 8008664:	607b      	str	r3, [r7, #4]
 8008666:	687b      	ldr	r3, [r7, #4]
 8008668:	f383 8811 	msr	BASEPRI, r3
=======
 80086ac:	b480      	push	{r7}
 80086ae:	b083      	sub	sp, #12
 80086b0:	af00      	add	r7, sp, #0
 80086b2:	2300      	movs	r3, #0
 80086b4:	607b      	str	r3, [r7, #4]
 80086b6:	687b      	ldr	r3, [r7, #4]
 80086b8:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800866c:	370c      	adds	r7, #12
 800866e:	46bd      	mov	sp, r7
 8008670:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008674:	4770      	bx	lr
 8008676:	bf00      	nop

08008678 <st_lld_get_counter.lto_priv.145>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 8008678:	b480      	push	{r7}
 800867a:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800867c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008680:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008682:	b29b      	uxth	r3, r3
}
 8008684:	4618      	mov	r0, r3
 8008686:	46bd      	mov	sp, r7
 8008688:	f85d 7b04 	ldr.w	r7, [sp], #4
 800868c:	4770      	bx	lr
 800868e:	bf00      	nop

08008690 <port_timer_get_time.lto_priv.142>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8008690:	b580      	push	{r7, lr}
 8008692:	af00      	add	r7, sp, #0

  return stGetCounter();
 8008694:	f7ff fff0 	bl	8008678 <st_lld_get_counter.lto_priv.145>
 8008698:	4603      	mov	r3, r0
}
 800869a:	4618      	mov	r0, r3
 800869c:	bd80      	pop	{r7, pc}
 800869e:	bf00      	nop

080086a0 <chSysLock.lto_priv.125>:
=======
 80086bc:	370c      	adds	r7, #12
 80086be:	46bd      	mov	sp, r7
 80086c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086c4:	4770      	bx	lr
 80086c6:	bf00      	nop

080086c8 <chSysLock.lto_priv.124>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 80086a0:	b580      	push	{r7, lr}
 80086a2:	af00      	add	r7, sp, #0

  port_lock();
 80086a4:	f7ff ffcc 	bl	8008640 <port_lock.lto_priv.149>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80086a8:	f002 fbca 	bl	800ae40 <_dbg_check_lock>
}
 80086ac:	bd80      	pop	{r7, pc}
 80086ae:	bf00      	nop

080086b0 <chSysUnlock.lto_priv.123>:
=======
 80086c8:	b580      	push	{r7, lr}
 80086ca:	af00      	add	r7, sp, #0

  port_lock();
 80086cc:	f7ff ffe0 	bl	8008690 <port_lock.lto_priv.142>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80086d0:	f002 fbfa 	bl	800aec8 <_dbg_check_lock>
}
 80086d4:	bd80      	pop	{r7, pc}
 80086d6:	bf00      	nop

080086d8 <chSysUnlock.lto_priv.122>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 80086b0:	b580      	push	{r7, lr}
 80086b2:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80086b4:	f002 fbda 	bl	800ae6c <_dbg_check_unlock>
=======
 80086d8:	b580      	push	{r7, lr}
 80086da:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80086dc:	f002 fc0a 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 80086b8:	4b09      	ldr	r3, [pc, #36]	; (80086e0 <chSysUnlock.lto_priv.123+0x30>)
 80086ba:	681b      	ldr	r3, [r3, #0]
 80086bc:	4a08      	ldr	r2, [pc, #32]	; (80086e0 <chSysUnlock.lto_priv.123+0x30>)
 80086be:	4293      	cmp	r3, r2
 80086c0:	d00a      	beq.n	80086d8 <chSysUnlock.lto_priv.123+0x28>
 80086c2:	4b07      	ldr	r3, [pc, #28]	; (80086e0 <chSysUnlock.lto_priv.123+0x30>)
 80086c4:	699b      	ldr	r3, [r3, #24]
 80086c6:	689a      	ldr	r2, [r3, #8]
 80086c8:	4b05      	ldr	r3, [pc, #20]	; (80086e0 <chSysUnlock.lto_priv.123+0x30>)
 80086ca:	681b      	ldr	r3, [r3, #0]
 80086cc:	689b      	ldr	r3, [r3, #8]
 80086ce:	429a      	cmp	r2, r3
 80086d0:	d202      	bcs.n	80086d8 <chSysUnlock.lto_priv.123+0x28>
 80086d2:	4804      	ldr	r0, [pc, #16]	; (80086e4 <chSysUnlock.lto_priv.123+0x34>)
 80086d4:	f002 fb66 	bl	800ada4 <chSysHalt>
=======
 80086e0:	4b09      	ldr	r3, [pc, #36]	; (8008708 <chSysUnlock.lto_priv.122+0x30>)
 80086e2:	681b      	ldr	r3, [r3, #0]
 80086e4:	4a08      	ldr	r2, [pc, #32]	; (8008708 <chSysUnlock.lto_priv.122+0x30>)
 80086e6:	4293      	cmp	r3, r2
 80086e8:	d00a      	beq.n	8008700 <chSysUnlock.lto_priv.122+0x28>
 80086ea:	4b07      	ldr	r3, [pc, #28]	; (8008708 <chSysUnlock.lto_priv.122+0x30>)
 80086ec:	699b      	ldr	r3, [r3, #24]
 80086ee:	689a      	ldr	r2, [r3, #8]
 80086f0:	4b05      	ldr	r3, [pc, #20]	; (8008708 <chSysUnlock.lto_priv.122+0x30>)
 80086f2:	681b      	ldr	r3, [r3, #0]
 80086f4:	689b      	ldr	r3, [r3, #8]
 80086f6:	429a      	cmp	r2, r3
 80086f8:	d202      	bcs.n	8008700 <chSysUnlock.lto_priv.122+0x28>
 80086fa:	4804      	ldr	r0, [pc, #16]	; (800870c <chSysUnlock.lto_priv.122+0x34>)
 80086fc:	f002 fb96 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 80086d8:	f7ff ffc0 	bl	800865c <port_unlock.lto_priv.147>
}
 80086dc:	bd80      	pop	{r7, pc}
 80086de:	bf00      	nop
 80086e0:	20001338 	.word	0x20001338
 80086e4:	0800eb98 	.word	0x0800eb98

080086e8 <chVTGetSystemTimeX.lto_priv.116>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80086e8:	b580      	push	{r7, lr}
 80086ea:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80086ec:	f7ff ffd0 	bl	8008690 <port_timer_get_time.lto_priv.142>
 80086f0:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80086f2:	4618      	mov	r0, r3
 80086f4:	bd80      	pop	{r7, pc}
 80086f6:	bf00      	nop

080086f8 <chThdGetSelfX.lto_priv.132>:
=======
 8008700:	f7ff ffd4 	bl	80086ac <port_unlock.lto_priv.140>
}
 8008704:	bd80      	pop	{r7, pc}
 8008706:	bf00      	nop
 8008708:	20001338 	.word	0x20001338
 800870c:	0800ec70 	.word	0x0800ec70

08008710 <chThdGetSelfX.lto_priv.131>:
>>>>>>> 752c83b... update binaries
  *
  * @return             A pointer to the current thread.
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {
<<<<<<< HEAD
 80086f8:	b480      	push	{r7}
 80086fa:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 80086fc:	4b03      	ldr	r3, [pc, #12]	; (800870c <chThdGetSelfX.lto_priv.132+0x14>)
 80086fe:	699b      	ldr	r3, [r3, #24]
}
 8008700:	4618      	mov	r0, r3
 8008702:	46bd      	mov	sp, r7
 8008704:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008708:	4770      	bx	lr
 800870a:	bf00      	nop
 800870c:	20001338 	.word	0x20001338

08008710 <chRegSetThreadName.lto_priv.133>:
=======
 8008710:	b480      	push	{r7}
 8008712:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 8008714:	4b03      	ldr	r3, [pc, #12]	; (8008724 <chThdGetSelfX.lto_priv.131+0x14>)
 8008716:	699b      	ldr	r3, [r3, #24]
}
 8008718:	4618      	mov	r0, r3
 800871a:	46bd      	mov	sp, r7
 800871c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008720:	4770      	bx	lr
 8008722:	bf00      	nop
 8008724:	20001338 	.word	0x20001338

08008728 <chRegSetThreadName.lto_priv.132>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
<<<<<<< HEAD
 8008710:	b480      	push	{r7}
 8008712:	b083      	sub	sp, #12
 8008714:	af00      	add	r7, sp, #0
 8008716:	6078      	str	r0, [r7, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8008718:	4b04      	ldr	r3, [pc, #16]	; (800872c <chRegSetThreadName.lto_priv.133+0x1c>)
 800871a:	699b      	ldr	r3, [r3, #24]
 800871c:	687a      	ldr	r2, [r7, #4]
 800871e:	619a      	str	r2, [r3, #24]
=======
 8008728:	b480      	push	{r7}
 800872a:	b083      	sub	sp, #12
 800872c:	af00      	add	r7, sp, #0
 800872e:	6078      	str	r0, [r7, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8008730:	4b04      	ldr	r3, [pc, #16]	; (8008744 <chRegSetThreadName.lto_priv.132+0x1c>)
 8008732:	699b      	ldr	r3, [r3, #24]
 8008734:	687a      	ldr	r2, [r7, #4]
 8008736:	619a      	str	r2, [r3, #24]
>>>>>>> 752c83b... update binaries
#else
  (void)name;
#endif
}
<<<<<<< HEAD
 8008720:	370c      	adds	r7, #12
 8008722:	46bd      	mov	sp, r7
 8008724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008728:	4770      	bx	lr
 800872a:	bf00      	nop
 800872c:	20001338 	.word	0x20001338

08008730 <chMBGetUsedCountI.lto_priv.131>:
=======
 8008738:	370c      	adds	r7, #12
 800873a:	46bd      	mov	sp, r7
 800873c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008740:	4770      	bx	lr
 8008742:	bf00      	nop
 8008744:	20001338 	.word	0x20001338

08008748 <chMBGetUsedCountI.lto_priv.130>:
>>>>>>> 752c83b... update binaries
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
<<<<<<< HEAD
 8008730:	b580      	push	{r7, lr}
 8008732:	b082      	sub	sp, #8
 8008734:	af00      	add	r7, sp, #0
 8008736:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 8008738:	f002 fc12 	bl	800af60 <chDbgCheckClassI>

  return mbp->cnt;
 800873c:	687b      	ldr	r3, [r7, #4]
 800873e:	691b      	ldr	r3, [r3, #16]
}
 8008740:	4618      	mov	r0, r3
 8008742:	3708      	adds	r7, #8
 8008744:	46bd      	mov	sp, r7
 8008746:	bd80      	pop	{r7, pc}

08008748 <chCoreAllocAligned>:
=======
 8008748:	b580      	push	{r7, lr}
 800874a:	b082      	sub	sp, #8
 800874c:	af00      	add	r7, sp, #0
 800874e:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 8008750:	f002 fc4a 	bl	800afe8 <chDbgCheckClassI>

  return mbp->cnt;
 8008754:	687b      	ldr	r3, [r7, #4]
 8008756:	691b      	ldr	r3, [r3, #16]
}
 8008758:	4618      	mov	r0, r3
 800875a:	3708      	adds	r7, #8
 800875c:	46bd      	mov	sp, r7
 800875e:	bd80      	pop	{r7, pc}

08008760 <chCoreAllocAligned>:
>>>>>>> 752c83b... update binaries
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
static inline void *chCoreAllocAligned(size_t size, unsigned align) {
<<<<<<< HEAD
 8008748:	b580      	push	{r7, lr}
 800874a:	b084      	sub	sp, #16
 800874c:	af00      	add	r7, sp, #0
 800874e:	6078      	str	r0, [r7, #4]
 8008750:	6039      	str	r1, [r7, #0]
  void *p;

  chSysLock();
 8008752:	f7ff ffa5 	bl	80086a0 <chSysLock.lto_priv.125>
  p = chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8008756:	6878      	ldr	r0, [r7, #4]
 8008758:	6839      	ldr	r1, [r7, #0]
 800875a:	2200      	movs	r2, #0
 800875c:	f001 f966 	bl	8009a2c <chCoreAllocAlignedWithOffsetI>
 8008760:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 8008762:	f7ff ffa5 	bl	80086b0 <chSysUnlock.lto_priv.123>

  return p;
 8008766:	68fb      	ldr	r3, [r7, #12]
}
 8008768:	4618      	mov	r0, r3
 800876a:	3710      	adds	r7, #16
 800876c:	46bd      	mov	sp, r7
 800876e:	bd80      	pop	{r7, pc}

08008770 <chCoreAllocI.lto_priv.135>:
=======
 8008760:	b580      	push	{r7, lr}
 8008762:	b084      	sub	sp, #16
 8008764:	af00      	add	r7, sp, #0
 8008766:	6078      	str	r0, [r7, #4]
 8008768:	6039      	str	r1, [r7, #0]
  void *p;

  chSysLock();
 800876a:	f7ff ffad 	bl	80086c8 <chSysLock.lto_priv.124>
  p = chCoreAllocAlignedWithOffsetI(size, align, 0U);
 800876e:	6878      	ldr	r0, [r7, #4]
 8008770:	6839      	ldr	r1, [r7, #0]
 8008772:	2200      	movs	r2, #0
 8008774:	f001 f99e 	bl	8009ab4 <chCoreAllocAlignedWithOffsetI>
 8008778:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 800877a:	f7ff ffad 	bl	80086d8 <chSysUnlock.lto_priv.122>

  return p;
 800877e:	68fb      	ldr	r3, [r7, #12]
}
 8008780:	4618      	mov	r0, r3
 8008782:	3710      	adds	r7, #16
 8008784:	46bd      	mov	sp, r7
 8008786:	bd80      	pop	{r7, pc}

08008788 <chCoreAllocI.lto_priv.134>:
>>>>>>> 752c83b... update binaries
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocI(size_t size) {
<<<<<<< HEAD
 8008770:	b580      	push	{r7, lr}
 8008772:	b082      	sub	sp, #8
 8008774:	af00      	add	r7, sp, #0
 8008776:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffsetI(size, PORT_NATURAL_ALIGN, 0U);
 8008778:	6878      	ldr	r0, [r7, #4]
 800877a:	2104      	movs	r1, #4
 800877c:	2200      	movs	r2, #0
 800877e:	f001 f955 	bl	8009a2c <chCoreAllocAlignedWithOffsetI>
 8008782:	4603      	mov	r3, r0
}
 8008784:	4618      	mov	r0, r3
 8008786:	3708      	adds	r7, #8
 8008788:	46bd      	mov	sp, r7
 800878a:	bd80      	pop	{r7, pc}

0800878c <chPoolAddI.lto_priv.134>:
=======
 8008788:	b580      	push	{r7, lr}
 800878a:	b082      	sub	sp, #8
 800878c:	af00      	add	r7, sp, #0
 800878e:	6078      	str	r0, [r7, #4]

  return chCoreAllocAlignedWithOffsetI(size, PORT_NATURAL_ALIGN, 0U);
 8008790:	6878      	ldr	r0, [r7, #4]
 8008792:	2104      	movs	r1, #4
 8008794:	2200      	movs	r2, #0
 8008796:	f001 f98d 	bl	8009ab4 <chCoreAllocAlignedWithOffsetI>
 800879a:	4603      	mov	r3, r0
}
 800879c:	4618      	mov	r0, r3
 800879e:	3708      	adds	r7, #8
 80087a0:	46bd      	mov	sp, r7
 80087a2:	bd80      	pop	{r7, pc}

080087a4 <chPoolAddI.lto_priv.133>:
>>>>>>> 752c83b... update binaries
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @iclass
 */
static inline void chPoolAddI(memory_pool_t *mp, void *objp) {
<<<<<<< HEAD
 800878c:	b580      	push	{r7, lr}
 800878e:	b082      	sub	sp, #8
 8008790:	af00      	add	r7, sp, #0
 8008792:	6078      	str	r0, [r7, #4]
 8008794:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 8008796:	f002 fbe3 	bl	800af60 <chDbgCheckClassI>

  chPoolFreeI(mp, objp);
 800879a:	6878      	ldr	r0, [r7, #4]
 800879c:	6839      	ldr	r1, [r7, #0]
 800879e:	f001 fa7b 	bl	8009c98 <chPoolFreeI>
}
 80087a2:	3708      	adds	r7, #8
 80087a4:	46bd      	mov	sp, r7
 80087a6:	bd80      	pop	{r7, pc}

080087a8 <worker_thread_init>:
=======
 80087a4:	b580      	push	{r7, lr}
 80087a6:	b082      	sub	sp, #8
 80087a8:	af00      	add	r7, sp, #0
 80087aa:	6078      	str	r0, [r7, #4]
 80087ac:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 80087ae:	f002 fc1b 	bl	800afe8 <chDbgCheckClassI>

  chPoolFreeI(mp, objp);
 80087b2:	6878      	ldr	r0, [r7, #4]
 80087b4:	6839      	ldr	r1, [r7, #0]
 80087b6:	f001 fab3 	bl	8009d20 <chPoolFreeI>
}
 80087ba:	3708      	adds	r7, #8
 80087bc:	46bd      	mov	sp, r7
 80087be:	bd80      	pop	{r7, pc}

080087c0 <worker_thread_init>:
>>>>>>> 752c83b... update binaries
static bool worker_thread_listener_task_is_registered_I(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task);
static bool worker_thread_listener_task_is_registered(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* check_task);
static bool worker_thread_get_any_listener_task_due_I(struct worker_thread_s* worker_thread);
#endif

void worker_thread_init(struct worker_thread_s* worker_thread, const char* name, tprio_t priority) {
<<<<<<< HEAD
 80087a8:	b580      	push	{r7, lr}
 80087aa:	b084      	sub	sp, #16
 80087ac:	af00      	add	r7, sp, #0
 80087ae:	60f8      	str	r0, [r7, #12]
 80087b0:	60b9      	str	r1, [r7, #8]
 80087b2:	607a      	str	r2, [r7, #4]
    chDbgCheck(worker_thread != NULL);
 80087b4:	68fb      	ldr	r3, [r7, #12]
 80087b6:	2b00      	cmp	r3, #0
 80087b8:	d102      	bne.n	80087c0 <worker_thread_init+0x18>
 80087ba:	480d      	ldr	r0, [pc, #52]	; (80087f0 <worker_thread_init+0x48>)
 80087bc:	f002 faf2 	bl	800ada4 <chSysHalt>

    worker_thread->name = name;
 80087c0:	68fb      	ldr	r3, [r7, #12]
 80087c2:	68ba      	ldr	r2, [r7, #8]
 80087c4:	601a      	str	r2, [r3, #0]
    worker_thread->priority = priority;
 80087c6:	68fb      	ldr	r3, [r7, #12]
 80087c8:	687a      	ldr	r2, [r7, #4]
 80087ca:	605a      	str	r2, [r3, #4]

    worker_thread->timer_task_list_head = NULL;
 80087cc:	68fb      	ldr	r3, [r7, #12]
 80087ce:	2200      	movs	r2, #0
 80087d0:	611a      	str	r2, [r3, #16]
#ifdef MODULE_PUBSUB_ENABLED
    worker_thread->listener_task_list_head = NULL;
 80087d2:	68fb      	ldr	r3, [r7, #12]
 80087d4:	2200      	movs	r2, #0
 80087d6:	615a      	str	r2, [r3, #20]
    worker_thread->publisher_task_list_head = NULL;
 80087d8:	68fb      	ldr	r3, [r7, #12]
 80087da:	2200      	movs	r2, #0
 80087dc:	619a      	str	r2, [r3, #24]
#endif

    worker_thread->thread = NULL;
 80087de:	68fb      	ldr	r3, [r7, #12]
 80087e0:	2200      	movs	r2, #0
 80087e2:	609a      	str	r2, [r3, #8]
    worker_thread->suspend_trp = NULL;
 80087e4:	68fb      	ldr	r3, [r7, #12]
 80087e6:	2200      	movs	r2, #0
 80087e8:	60da      	str	r2, [r3, #12]
}
 80087ea:	3710      	adds	r7, #16
 80087ec:	46bd      	mov	sp, r7
 80087ee:	bd80      	pop	{r7, pc}
 80087f0:	0800eb70 	.word	0x0800eb70

080087f4 <worker_thread_start>:

void worker_thread_start(struct worker_thread_s* worker_thread, size_t stack_size) {
 80087f4:	b580      	push	{r7, lr}
 80087f6:	b08a      	sub	sp, #40	; 0x28
 80087f8:	af00      	add	r7, sp, #0
 80087fa:	6078      	str	r0, [r7, #4]
 80087fc:	6039      	str	r1, [r7, #0]
    chDbgCheck(worker_thread != NULL);
 80087fe:	687b      	ldr	r3, [r7, #4]
 8008800:	2b00      	cmp	r3, #0
 8008802:	d102      	bne.n	800880a <worker_thread_start+0x16>
 8008804:	4818      	ldr	r0, [pc, #96]	; (8008868 <worker_thread_start+0x74>)
 8008806:	f002 facd 	bl	800ada4 <chSysHalt>

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
 800880a:	683b      	ldr	r3, [r7, #0]
 800880c:	33c3      	adds	r3, #195	; 0xc3
 800880e:	f023 0307 	bic.w	r3, r3, #7
 8008812:	4618      	mov	r0, r3
 8008814:	2108      	movs	r1, #8
 8008816:	f7ff ff97 	bl	8008748 <chCoreAllocAligned>
 800881a:	6278      	str	r0, [r7, #36]	; 0x24
    chDbgCheck(working_area != NULL);
 800881c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800881e:	2b00      	cmp	r3, #0
 8008820:	d102      	bne.n	8008828 <worker_thread_start+0x34>
 8008822:	4811      	ldr	r0, [pc, #68]	; (8008868 <worker_thread_start+0x74>)
 8008824:	f002 fabe 	bl	800ada4 <chSysHalt>
    
    const thread_descriptor_t thread_descriptor = {
        worker_thread->name,
 8008828:	687b      	ldr	r3, [r7, #4]
 800882a:	681b      	ldr	r3, [r3, #0]
=======
 80087c0:	b580      	push	{r7, lr}
 80087c2:	b084      	sub	sp, #16
 80087c4:	af00      	add	r7, sp, #0
 80087c6:	60f8      	str	r0, [r7, #12]
 80087c8:	60b9      	str	r1, [r7, #8]
 80087ca:	607a      	str	r2, [r7, #4]
    chDbgCheck(worker_thread != NULL);
 80087cc:	68fb      	ldr	r3, [r7, #12]
 80087ce:	2b00      	cmp	r3, #0
 80087d0:	d102      	bne.n	80087d8 <worker_thread_init+0x18>
 80087d2:	480d      	ldr	r0, [pc, #52]	; (8008808 <worker_thread_init+0x48>)
 80087d4:	f002 fb2a 	bl	800ae2c <chSysHalt>

    worker_thread->name = name;
 80087d8:	68fb      	ldr	r3, [r7, #12]
 80087da:	68ba      	ldr	r2, [r7, #8]
 80087dc:	601a      	str	r2, [r3, #0]
    worker_thread->priority = priority;
 80087de:	68fb      	ldr	r3, [r7, #12]
 80087e0:	687a      	ldr	r2, [r7, #4]
 80087e2:	605a      	str	r2, [r3, #4]

    worker_thread->timer_task_list_head = NULL;
 80087e4:	68fb      	ldr	r3, [r7, #12]
 80087e6:	2200      	movs	r2, #0
 80087e8:	611a      	str	r2, [r3, #16]
#ifdef MODULE_PUBSUB_ENABLED
    worker_thread->listener_task_list_head = NULL;
 80087ea:	68fb      	ldr	r3, [r7, #12]
 80087ec:	2200      	movs	r2, #0
 80087ee:	615a      	str	r2, [r3, #20]
    worker_thread->publisher_task_list_head = NULL;
 80087f0:	68fb      	ldr	r3, [r7, #12]
 80087f2:	2200      	movs	r2, #0
 80087f4:	619a      	str	r2, [r3, #24]
#endif

    worker_thread->thread = NULL;
 80087f6:	68fb      	ldr	r3, [r7, #12]
 80087f8:	2200      	movs	r2, #0
 80087fa:	609a      	str	r2, [r3, #8]
    worker_thread->suspend_trp = NULL;
 80087fc:	68fb      	ldr	r3, [r7, #12]
 80087fe:	2200      	movs	r2, #0
 8008800:	60da      	str	r2, [r3, #12]
}
 8008802:	3710      	adds	r7, #16
 8008804:	46bd      	mov	sp, r7
 8008806:	bd80      	pop	{r7, pc}
 8008808:	0800ec48 	.word	0x0800ec48

0800880c <worker_thread_start>:

void worker_thread_start(struct worker_thread_s* worker_thread, size_t stack_size) {
 800880c:	b580      	push	{r7, lr}
 800880e:	b08a      	sub	sp, #40	; 0x28
 8008810:	af00      	add	r7, sp, #0
 8008812:	6078      	str	r0, [r7, #4]
 8008814:	6039      	str	r1, [r7, #0]
    chDbgCheck(worker_thread != NULL);
 8008816:	687b      	ldr	r3, [r7, #4]
 8008818:	2b00      	cmp	r3, #0
 800881a:	d102      	bne.n	8008822 <worker_thread_start+0x16>
 800881c:	4818      	ldr	r0, [pc, #96]	; (8008880 <worker_thread_start+0x74>)
 800881e:	f002 fb05 	bl	800ae2c <chSysHalt>

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
 8008822:	683b      	ldr	r3, [r7, #0]
 8008824:	33c3      	adds	r3, #195	; 0xc3
 8008826:	f023 0307 	bic.w	r3, r3, #7
 800882a:	4618      	mov	r0, r3
 800882c:	2108      	movs	r1, #8
 800882e:	f7ff ff97 	bl	8008760 <chCoreAllocAligned>
 8008832:	6278      	str	r0, [r7, #36]	; 0x24
    chDbgCheck(working_area != NULL);
 8008834:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008836:	2b00      	cmp	r3, #0
 8008838:	d102      	bne.n	8008840 <worker_thread_start+0x34>
 800883a:	4811      	ldr	r0, [pc, #68]	; (8008880 <worker_thread_start+0x74>)
 800883c:	f002 faf6 	bl	800ae2c <chSysHalt>
    
    const thread_descriptor_t thread_descriptor = {
        worker_thread->name,
 8008840:	687b      	ldr	r3, [r7, #4]
 8008842:	681b      	ldr	r3, [r3, #0]
>>>>>>> 752c83b... update binaries
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
<<<<<<< HEAD
 800882c:	60fb      	str	r3, [r7, #12]
 800882e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008830:	613b      	str	r3, [r7, #16]
        worker_thread->name,
        THD_WORKING_AREA_BASE(working_area),
        THD_WORKING_AREA_BASE(working_area) + THD_WORKING_AREA_SIZE(stack_size)/sizeof(stkalign_t),
 8008832:	683b      	ldr	r3, [r7, #0]
 8008834:	33c3      	adds	r3, #195	; 0xc3
 8008836:	f023 0307 	bic.w	r3, r3, #7
 800883a:	08db      	lsrs	r3, r3, #3
 800883c:	00db      	lsls	r3, r3, #3
 800883e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008840:	4413      	add	r3, r2
=======
 8008844:	60fb      	str	r3, [r7, #12]
 8008846:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008848:	613b      	str	r3, [r7, #16]
        worker_thread->name,
        THD_WORKING_AREA_BASE(working_area),
        THD_WORKING_AREA_BASE(working_area) + THD_WORKING_AREA_SIZE(stack_size)/sizeof(stkalign_t),
 800884a:	683b      	ldr	r3, [r7, #0]
 800884c:	33c3      	adds	r3, #195	; 0xc3
 800884e:	f023 0307 	bic.w	r3, r3, #7
 8008852:	08db      	lsrs	r3, r3, #3
 8008854:	00db      	lsls	r3, r3, #3
 8008856:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008858:	4413      	add	r3, r2
>>>>>>> 752c83b... update binaries
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
<<<<<<< HEAD
 8008842:	617b      	str	r3, [r7, #20]
=======
 800885a:	617b      	str	r3, [r7, #20]
>>>>>>> 752c83b... update binaries
        worker_thread->name,
        THD_WORKING_AREA_BASE(working_area),
        THD_WORKING_AREA_BASE(working_area) + THD_WORKING_AREA_SIZE(stack_size)/sizeof(stkalign_t),
        worker_thread->priority,
<<<<<<< HEAD
 8008844:	687b      	ldr	r3, [r7, #4]
 8008846:	685b      	ldr	r3, [r3, #4]
=======
 800885c:	687b      	ldr	r3, [r7, #4]
 800885e:	685b      	ldr	r3, [r3, #4]
>>>>>>> 752c83b... update binaries
    chDbgCheck(worker_thread != NULL);

    void* working_area = chCoreAllocAligned(THD_WORKING_AREA_SIZE(stack_size), PORT_WORKING_AREA_ALIGN);
    chDbgCheck(working_area != NULL);
    
    const thread_descriptor_t thread_descriptor = {
<<<<<<< HEAD
 8008848:	61bb      	str	r3, [r7, #24]
 800884a:	4b08      	ldr	r3, [pc, #32]	; (800886c <worker_thread_start+0x78>)
 800884c:	61fb      	str	r3, [r7, #28]
 800884e:	687b      	ldr	r3, [r7, #4]
 8008850:	623b      	str	r3, [r7, #32]
=======
 8008860:	61bb      	str	r3, [r7, #24]
 8008862:	4b08      	ldr	r3, [pc, #32]	; (8008884 <worker_thread_start+0x78>)
 8008864:	61fb      	str	r3, [r7, #28]
 8008866:	687b      	ldr	r3, [r7, #4]
 8008868:	623b      	str	r3, [r7, #32]
>>>>>>> 752c83b... update binaries
        worker_thread->priority,
        worker_thread_func,
        worker_thread
    };
    
    worker_thread->thread = chThdCreate(&thread_descriptor);
<<<<<<< HEAD
 8008852:	f107 030c 	add.w	r3, r7, #12
 8008856:	4618      	mov	r0, r3
 8008858:	f003 f96e 	bl	800bb38 <chThdCreate>
 800885c:	4602      	mov	r2, r0
 800885e:	687b      	ldr	r3, [r7, #4]
 8008860:	609a      	str	r2, [r3, #8]
}
 8008862:	3728      	adds	r7, #40	; 0x28
 8008864:	46bd      	mov	sp, r7
 8008866:	bd80      	pop	{r7, pc}
 8008868:	0800eb84 	.word	0x0800eb84
 800886c:	08006b25 	.word	0x08006b25

08008870 <_worker_thread_add_timer_task_no_wake_I>:

static void _worker_thread_add_timer_task_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, timer_task_handler_func_ptr task_func, void* ctx, systime_t timer_expiration_ticks, bool auto_repeat) {
 8008870:	b590      	push	{r4, r7, lr}
 8008872:	b087      	sub	sp, #28
 8008874:	af02      	add	r7, sp, #8
 8008876:	60f8      	str	r0, [r7, #12]
 8008878:	60b9      	str	r1, [r7, #8]
 800887a:	607a      	str	r2, [r7, #4]
 800887c:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 800887e:	f002 fb6f 	bl	800af60 <chDbgCheckClassI>

    worker_thread_init_timer_task(task, chVTGetSystemTimeX(), timer_expiration_ticks, auto_repeat, task_func, ctx);
 8008882:	f7ff ff31 	bl	80086e8 <chVTGetSystemTimeX.lto_priv.116>
 8008886:	4603      	mov	r3, r0
 8008888:	4619      	mov	r1, r3
 800888a:	8c3a      	ldrh	r2, [r7, #32]
 800888c:	f897 4024 	ldrb.w	r4, [r7, #36]	; 0x24
 8008890:	687b      	ldr	r3, [r7, #4]
 8008892:	9300      	str	r3, [sp, #0]
 8008894:	683b      	ldr	r3, [r7, #0]
 8008896:	9301      	str	r3, [sp, #4]
 8008898:	68b8      	ldr	r0, [r7, #8]
 800889a:	4623      	mov	r3, r4
 800889c:	f7fe f96c 	bl	8006b78 <worker_thread_init_timer_task.lto_priv.164>
    worker_thread_insert_timer_task_I(worker_thread, task);
 80088a0:	68f8      	ldr	r0, [r7, #12]
 80088a2:	68b9      	ldr	r1, [r7, #8]
 80088a4:	f7fe f9a6 	bl	8006bf4 <worker_thread_insert_timer_task_I.lto_priv.163>
}
 80088a8:	3714      	adds	r7, #20
 80088aa:	46bd      	mov	sp, r7
 80088ac:	bd90      	pop	{r4, r7, pc}
 80088ae:	bf00      	nop

080088b0 <worker_thread_add_timer_task>:
=======
 800886a:	f107 030c 	add.w	r3, r7, #12
 800886e:	4618      	mov	r0, r3
 8008870:	f003 f9a6 	bl	800bbc0 <chThdCreate>
 8008874:	4602      	mov	r2, r0
 8008876:	687b      	ldr	r3, [r7, #4]
 8008878:	609a      	str	r2, [r3, #8]
}
 800887a:	3728      	adds	r7, #40	; 0x28
 800887c:	46bd      	mov	sp, r7
 800887e:	bd80      	pop	{r7, pc}
 8008880:	0800ec5c 	.word	0x0800ec5c
 8008884:	08006b59 	.word	0x08006b59

08008888 <_worker_thread_add_timer_task_no_wake_I>:

static void _worker_thread_add_timer_task_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, timer_task_handler_func_ptr task_func, void* ctx, uint32_t timer_expiration_millis, bool auto_repeat) {
 8008888:	b590      	push	{r4, r7, lr}
 800888a:	b087      	sub	sp, #28
 800888c:	af02      	add	r7, sp, #8
 800888e:	60f8      	str	r0, [r7, #12]
 8008890:	60b9      	str	r1, [r7, #8]
 8008892:	607a      	str	r2, [r7, #4]
 8008894:	603b      	str	r3, [r7, #0]
    chDbgCheckClassI();
 8008896:	f002 fba7 	bl	800afe8 <chDbgCheckClassI>

    worker_thread_init_timer_task(task, millis(), timer_expiration_millis, auto_repeat, task_func, ctx);
 800889a:	f7ff fa07 	bl	8007cac <millis>
 800889e:	4602      	mov	r2, r0
 80088a0:	f897 4024 	ldrb.w	r4, [r7, #36]	; 0x24
 80088a4:	687b      	ldr	r3, [r7, #4]
 80088a6:	9300      	str	r3, [sp, #0]
 80088a8:	683b      	ldr	r3, [r7, #0]
 80088aa:	9301      	str	r3, [sp, #4]
 80088ac:	68b8      	ldr	r0, [r7, #8]
 80088ae:	4611      	mov	r1, r2
 80088b0:	6a3a      	ldr	r2, [r7, #32]
 80088b2:	4623      	mov	r3, r4
 80088b4:	f7fe f97a 	bl	8006bac <worker_thread_init_timer_task.lto_priv.161>
    worker_thread_insert_timer_task_I(worker_thread, task);
 80088b8:	68f8      	ldr	r0, [r7, #12]
 80088ba:	68b9      	ldr	r1, [r7, #8]
 80088bc:	f7fe f9ae 	bl	8006c1c <worker_thread_insert_timer_task_I.lto_priv.160>
}
 80088c0:	3714      	adds	r7, #20
 80088c2:	46bd      	mov	sp, r7
 80088c4:	bd90      	pop	{r4, r7, pc}
 80088c6:	bf00      	nop

080088c8 <worker_thread_add_timer_task>:
>>>>>>> 752c83b... update binaries

    // Wake worker thread to process tasks
    worker_thread_wake_I(worker_thread);
}

void worker_thread_add_timer_task(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, timer_task_handler_func_ptr task_func, void* ctx, systime_t timer_expiration_ticks, bool auto_repeat) {
<<<<<<< HEAD
 80088b0:	b580      	push	{r7, lr}
 80088b2:	b086      	sub	sp, #24
 80088b4:	af02      	add	r7, sp, #8
 80088b6:	60f8      	str	r0, [r7, #12]
 80088b8:	60b9      	str	r1, [r7, #8]
 80088ba:	607a      	str	r2, [r7, #4]
 80088bc:	603b      	str	r3, [r7, #0]
    chSysLock();
 80088be:	f7ff feef 	bl	80086a0 <chSysLock.lto_priv.125>
    _worker_thread_add_timer_task_no_wake_I(worker_thread, task, task_func, ctx, timer_expiration_ticks, auto_repeat);
 80088c2:	8b3b      	ldrh	r3, [r7, #24]
 80088c4:	9300      	str	r3, [sp, #0]
 80088c6:	7f3b      	ldrb	r3, [r7, #28]
 80088c8:	9301      	str	r3, [sp, #4]
 80088ca:	68f8      	ldr	r0, [r7, #12]
 80088cc:	68b9      	ldr	r1, [r7, #8]
 80088ce:	687a      	ldr	r2, [r7, #4]
 80088d0:	683b      	ldr	r3, [r7, #0]
 80088d2:	f7ff ffcd 	bl	8008870 <_worker_thread_add_timer_task_no_wake_I>
    chSysUnlock();
 80088d6:	f7ff feeb 	bl	80086b0 <chSysUnlock.lto_priv.123>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 80088da:	68f8      	ldr	r0, [r7, #12]
 80088dc:	f7fe f93e 	bl	8006b5c <worker_thread_wake.lto_priv.160>
}
 80088e0:	3710      	adds	r7, #16
 80088e2:	46bd      	mov	sp, r7
 80088e4:	bd80      	pop	{r7, pc}
 80088e6:	bf00      	nop

080088e8 <_worker_thread_timer_task_reschedule_no_wake_I>:

static void _worker_thread_timer_task_reschedule_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 80088e8:	b580      	push	{r7, lr}
 80088ea:	b086      	sub	sp, #24
 80088ec:	af00      	add	r7, sp, #0
 80088ee:	60f8      	str	r0, [r7, #12]
 80088f0:	60b9      	str	r1, [r7, #8]
 80088f2:	4613      	mov	r3, r2
 80088f4:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassI();
 80088f6:	f002 fb33 	bl	800af60 <chDbgCheckClassI>

    systime_t t_now = chVTGetSystemTimeX();
 80088fa:	f7ff fef5 	bl	80086e8 <chVTGetSystemTimeX.lto_priv.116>
 80088fe:	4603      	mov	r3, r0
 8008900:	82fb      	strh	r3, [r7, #22]

    worker_thread_remove_timer_task_I(worker_thread, task);
 8008902:	68f8      	ldr	r0, [r7, #12]
 8008904:	68b9      	ldr	r1, [r7, #8]
 8008906:	f000 f83b 	bl	8008980 <worker_thread_remove_timer_task_I>

    task->timer_expiration_ticks = timer_expiration_ticks;
 800890a:	68bb      	ldr	r3, [r7, #8]
 800890c:	88fa      	ldrh	r2, [r7, #6]
 800890e:	811a      	strh	r2, [r3, #8]
    task->timer_begin_systime = t_now;
 8008910:	68bb      	ldr	r3, [r7, #8]
 8008912:	8afa      	ldrh	r2, [r7, #22]
 8008914:	815a      	strh	r2, [r3, #10]

    worker_thread_insert_timer_task_I(worker_thread, task);
 8008916:	68f8      	ldr	r0, [r7, #12]
 8008918:	68b9      	ldr	r1, [r7, #8]
 800891a:	f7fe f96b 	bl	8006bf4 <worker_thread_insert_timer_task_I.lto_priv.163>
}
 800891e:	3718      	adds	r7, #24
 8008920:	46bd      	mov	sp, r7
 8008922:	bd80      	pop	{r7, pc}

08008924 <worker_thread_timer_task_reschedule_I>:

void worker_thread_timer_task_reschedule_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 8008924:	b580      	push	{r7, lr}
 8008926:	b084      	sub	sp, #16
 8008928:	af00      	add	r7, sp, #0
 800892a:	60f8      	str	r0, [r7, #12]
 800892c:	60b9      	str	r1, [r7, #8]
 800892e:	4613      	mov	r3, r2
 8008930:	80fb      	strh	r3, [r7, #6]
    chDbgCheckClassI();
 8008932:	f002 fb15 	bl	800af60 <chDbgCheckClassI>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_ticks);
 8008936:	88fb      	ldrh	r3, [r7, #6]
 8008938:	68f8      	ldr	r0, [r7, #12]
 800893a:	68b9      	ldr	r1, [r7, #8]
 800893c:	461a      	mov	r2, r3
 800893e:	f7ff ffd3 	bl	80088e8 <_worker_thread_timer_task_reschedule_no_wake_I>

    // Wake worker thread to process tasks
    worker_thread_wake_I(worker_thread);
 8008942:	68f8      	ldr	r0, [r7, #12]
 8008944:	f7fe f8fa 	bl	8006b3c <worker_thread_wake_I.lto_priv.162>
}
 8008948:	3710      	adds	r7, #16
 800894a:	46bd      	mov	sp, r7
 800894c:	bd80      	pop	{r7, pc}
 800894e:	bf00      	nop

08008950 <worker_thread_timer_task_reschedule>:

void worker_thread_timer_task_reschedule(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, systime_t timer_expiration_ticks) {
 8008950:	b580      	push	{r7, lr}
 8008952:	b084      	sub	sp, #16
 8008954:	af00      	add	r7, sp, #0
 8008956:	60f8      	str	r0, [r7, #12]
 8008958:	60b9      	str	r1, [r7, #8]
 800895a:	4613      	mov	r3, r2
 800895c:	80fb      	strh	r3, [r7, #6]
    chSysLock();
 800895e:	f7ff fe9f 	bl	80086a0 <chSysLock.lto_priv.125>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_ticks);
 8008962:	88fb      	ldrh	r3, [r7, #6]
 8008964:	68f8      	ldr	r0, [r7, #12]
 8008966:	68b9      	ldr	r1, [r7, #8]
 8008968:	461a      	mov	r2, r3
 800896a:	f7ff ffbd 	bl	80088e8 <_worker_thread_timer_task_reschedule_no_wake_I>
    chSysUnlock();
 800896e:	f7ff fe9f 	bl	80086b0 <chSysUnlock.lto_priv.123>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8008972:	68f8      	ldr	r0, [r7, #12]
 8008974:	f7fe f8f2 	bl	8006b5c <worker_thread_wake.lto_priv.160>
}
 8008978:	3710      	adds	r7, #16
 800897a:	46bd      	mov	sp, r7
 800897c:	bd80      	pop	{r7, pc}
 800897e:	bf00      	nop

08008980 <worker_thread_remove_timer_task_I>:

void worker_thread_remove_timer_task_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 8008980:	b580      	push	{r7, lr}
 8008982:	b084      	sub	sp, #16
 8008984:	af00      	add	r7, sp, #0
 8008986:	6078      	str	r0, [r7, #4]
 8008988:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 800898a:	f002 fae9 	bl	800af60 <chDbgCheckClassI>
    LINKED_LIST_REMOVE(struct worker_thread_timer_task_s, worker_thread->timer_task_list_head, task);
 800898e:	687b      	ldr	r3, [r7, #4]
 8008990:	3310      	adds	r3, #16
 8008992:	60fb      	str	r3, [r7, #12]
 8008994:	e003      	b.n	800899e <worker_thread_remove_timer_task_I+0x1e>
 8008996:	68fb      	ldr	r3, [r7, #12]
 8008998:	681b      	ldr	r3, [r3, #0]
 800899a:	3310      	adds	r3, #16
 800899c:	60fb      	str	r3, [r7, #12]
 800899e:	68fb      	ldr	r3, [r7, #12]
 80089a0:	681b      	ldr	r3, [r3, #0]
 80089a2:	2b00      	cmp	r3, #0
 80089a4:	d004      	beq.n	80089b0 <worker_thread_remove_timer_task_I+0x30>
 80089a6:	68fb      	ldr	r3, [r7, #12]
 80089a8:	681a      	ldr	r2, [r3, #0]
 80089aa:	683b      	ldr	r3, [r7, #0]
 80089ac:	429a      	cmp	r2, r3
 80089ae:	d1f2      	bne.n	8008996 <worker_thread_remove_timer_task_I+0x16>
 80089b0:	68fb      	ldr	r3, [r7, #12]
 80089b2:	681b      	ldr	r3, [r3, #0]
 80089b4:	2b00      	cmp	r3, #0
 80089b6:	d004      	beq.n	80089c2 <worker_thread_remove_timer_task_I+0x42>
 80089b8:	68fb      	ldr	r3, [r7, #12]
 80089ba:	681b      	ldr	r3, [r3, #0]
 80089bc:	691a      	ldr	r2, [r3, #16]
 80089be:	68fb      	ldr	r3, [r7, #12]
 80089c0:	601a      	str	r2, [r3, #0]
}
 80089c2:	3710      	adds	r7, #16
 80089c4:	46bd      	mov	sp, r7
 80089c6:	bd80      	pop	{r7, pc}

080089c8 <worker_thread_remove_timer_task>:

void worker_thread_remove_timer_task(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 80089c8:	b580      	push	{r7, lr}
 80089ca:	b082      	sub	sp, #8
 80089cc:	af00      	add	r7, sp, #0
 80089ce:	6078      	str	r0, [r7, #4]
 80089d0:	6039      	str	r1, [r7, #0]
    chSysLock();
 80089d2:	f7ff fe65 	bl	80086a0 <chSysLock.lto_priv.125>
    worker_thread_remove_timer_task_I(worker_thread, task);
 80089d6:	6878      	ldr	r0, [r7, #4]
 80089d8:	6839      	ldr	r1, [r7, #0]
 80089da:	f7ff ffd1 	bl	8008980 <worker_thread_remove_timer_task_I>
    chSysUnlock();
 80089de:	f7ff fe67 	bl	80086b0 <chSysUnlock.lto_priv.123>
}
 80089e2:	3708      	adds	r7, #8
 80089e4:	46bd      	mov	sp, r7
 80089e6:	bd80      	pop	{r7, pc}

080089e8 <worker_thread_task_get_user_context>:

void* worker_thread_task_get_user_context(struct worker_thread_timer_task_s* task) {
 80089e8:	b480      	push	{r7}
 80089ea:	b083      	sub	sp, #12
 80089ec:	af00      	add	r7, sp, #0
 80089ee:	6078      	str	r0, [r7, #4]
    if (!task) {
 80089f0:	687b      	ldr	r3, [r7, #4]
 80089f2:	2b00      	cmp	r3, #0
 80089f4:	d101      	bne.n	80089fa <worker_thread_task_get_user_context+0x12>
        return NULL;
 80089f6:	2300      	movs	r3, #0
 80089f8:	e001      	b.n	80089fe <worker_thread_task_get_user_context+0x16>
    }

    return task->ctx;
 80089fa:	687b      	ldr	r3, [r7, #4]
 80089fc:	685b      	ldr	r3, [r3, #4]
}
 80089fe:	4618      	mov	r0, r3
 8008a00:	370c      	adds	r7, #12
 8008a02:	46bd      	mov	sp, r7
 8008a04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a08:	4770      	bx	lr
 8008a0a:	bf00      	nop

08008a0c <worker_thread_add_listener_task>:

#ifdef MODULE_PUBSUB_ENABLED
void worker_thread_add_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 8008a0c:	b580      	push	{r7, lr}
 8008a0e:	b086      	sub	sp, #24
 8008a10:	af00      	add	r7, sp, #0
 8008a12:	60f8      	str	r0, [r7, #12]
 8008a14:	60b9      	str	r1, [r7, #8]
 8008a16:	607a      	str	r2, [r7, #4]
 8008a18:	603b      	str	r3, [r7, #0]
    chDbgCheck(!worker_thread_listener_task_is_registered(worker_thread, task));
 8008a1a:	68f8      	ldr	r0, [r7, #12]
 8008a1c:	68b9      	ldr	r1, [r7, #8]
 8008a1e:	f7fe f9ab 	bl	8006d78 <worker_thread_listener_task_is_registered.lto_priv.161>
 8008a22:	4603      	mov	r3, r0
 8008a24:	2b00      	cmp	r3, #0
 8008a26:	d002      	beq.n	8008a2e <worker_thread_add_listener_task+0x22>
 8008a28:	4816      	ldr	r0, [pc, #88]	; (8008a84 <worker_thread_add_listener_task+0x78>)
 8008a2a:	f002 f9bb 	bl	800ada4 <chSysHalt>

    pubsub_listener_init_and_register(&task->listener, topic, handler_cb, handler_cb_ctx);
 8008a2e:	68bb      	ldr	r3, [r7, #8]
 8008a30:	4618      	mov	r0, r3
 8008a32:	6879      	ldr	r1, [r7, #4]
 8008a34:	683a      	ldr	r2, [r7, #0]
 8008a36:	6a3b      	ldr	r3, [r7, #32]
 8008a38:	f7ff fbb6 	bl	80081a8 <pubsub_listener_init_and_register>
    pubsub_listener_set_waiting_thread_reference(&task->listener, &worker_thread->suspend_trp);
 8008a3c:	68ba      	ldr	r2, [r7, #8]
 8008a3e:	68fb      	ldr	r3, [r7, #12]
 8008a40:	330c      	adds	r3, #12
 8008a42:	4610      	mov	r0, r2
 8008a44:	4619      	mov	r1, r3
 8008a46:	f7ff fd57 	bl	80084f8 <pubsub_listener_set_waiting_thread_reference>

    chSysLock();
 8008a4a:	f7ff fe29 	bl	80086a0 <chSysLock.lto_priv.125>
    LINKED_LIST_APPEND(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
 8008a4e:	68bb      	ldr	r3, [r7, #8]
 8008a50:	2200      	movs	r2, #0
 8008a52:	631a      	str	r2, [r3, #48]	; 0x30
 8008a54:	68fb      	ldr	r3, [r7, #12]
 8008a56:	3314      	adds	r3, #20
 8008a58:	617b      	str	r3, [r7, #20]
 8008a5a:	e003      	b.n	8008a64 <worker_thread_add_listener_task+0x58>
 8008a5c:	697b      	ldr	r3, [r7, #20]
 8008a5e:	681b      	ldr	r3, [r3, #0]
 8008a60:	3330      	adds	r3, #48	; 0x30
 8008a62:	617b      	str	r3, [r7, #20]
 8008a64:	697b      	ldr	r3, [r7, #20]
 8008a66:	681b      	ldr	r3, [r3, #0]
 8008a68:	2b00      	cmp	r3, #0
 8008a6a:	d1f7      	bne.n	8008a5c <worker_thread_add_listener_task+0x50>
 8008a6c:	697b      	ldr	r3, [r7, #20]
 8008a6e:	68ba      	ldr	r2, [r7, #8]
 8008a70:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008a72:	f7ff fe1d 	bl	80086b0 <chSysUnlock.lto_priv.123>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8008a76:	68f8      	ldr	r0, [r7, #12]
 8008a78:	f7fe f870 	bl	8006b5c <worker_thread_wake.lto_priv.160>
}
 8008a7c:	3718      	adds	r7, #24
 8008a7e:	46bd      	mov	sp, r7
 8008a80:	bd80      	pop	{r7, pc}
 8008a82:	bf00      	nop
 8008a84:	0800eba4 	.word	0x0800eba4

08008a88 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8008a88:	b580      	push	{r7, lr}
 8008a8a:	b084      	sub	sp, #16
 8008a8c:	af00      	add	r7, sp, #0
 8008a8e:	6078      	str	r0, [r7, #4]
 8008a90:	460b      	mov	r3, r1
 8008a92:	70fb      	strb	r3, [r7, #3]
 8008a94:	4613      	mov	r3, r2
 8008a96:	803b      	strh	r3, [r7, #0]

  osalSysLock();
 8008a98:	f001 fa2a 	bl	8009ef0 <osalSysLock.lto_priv.197>
 8008a9c:	e00d      	b.n	8008aba <oqPutTimeout+0x32>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8008a9e:	687a      	ldr	r2, [r7, #4]
 8008aa0:	883b      	ldrh	r3, [r7, #0]
 8008aa2:	4610      	mov	r0, r2
 8008aa4:	4619      	mov	r1, r3
 8008aa6:	f001 fa41 	bl	8009f2c <osalThreadEnqueueTimeoutS.lto_priv.202>
 8008aaa:	60f8      	str	r0, [r7, #12]
    if (msg < MSG_OK) {
 8008aac:	68fb      	ldr	r3, [r7, #12]
 8008aae:	2b00      	cmp	r3, #0
 8008ab0:	da03      	bge.n	8008aba <oqPutTimeout+0x32>
      osalSysUnlock();
 8008ab2:	f001 fa23 	bl	8009efc <osalSysUnlock.lto_priv.195>
      return msg;
 8008ab6:	68fb      	ldr	r3, [r7, #12]
 8008ab8:	e024      	b.n	8008b04 <oqPutTimeout+0x7c>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8008aba:	687b      	ldr	r3, [r7, #4]
 8008abc:	689b      	ldr	r3, [r3, #8]
 8008abe:	2b00      	cmp	r3, #0
 8008ac0:	d0ed      	beq.n	8008a9e <oqPutTimeout+0x16>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8008ac2:	687b      	ldr	r3, [r7, #4]
 8008ac4:	689b      	ldr	r3, [r3, #8]
 8008ac6:	1e5a      	subs	r2, r3, #1
 8008ac8:	687b      	ldr	r3, [r7, #4]
 8008aca:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8008acc:	687b      	ldr	r3, [r7, #4]
 8008ace:	695b      	ldr	r3, [r3, #20]
 8008ad0:	1c59      	adds	r1, r3, #1
 8008ad2:	687a      	ldr	r2, [r7, #4]
 8008ad4:	6151      	str	r1, [r2, #20]
 8008ad6:	78fa      	ldrb	r2, [r7, #3]
 8008ad8:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8008ada:	687b      	ldr	r3, [r7, #4]
 8008adc:	695a      	ldr	r2, [r3, #20]
 8008ade:	687b      	ldr	r3, [r7, #4]
 8008ae0:	691b      	ldr	r3, [r3, #16]
 8008ae2:	429a      	cmp	r2, r3
 8008ae4:	d303      	bcc.n	8008aee <oqPutTimeout+0x66>
    oqp->q_wrptr = oqp->q_buffer;
 8008ae6:	687b      	ldr	r3, [r7, #4]
 8008ae8:	68da      	ldr	r2, [r3, #12]
 8008aea:	687b      	ldr	r3, [r7, #4]
 8008aec:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8008aee:	687b      	ldr	r3, [r7, #4]
 8008af0:	69db      	ldr	r3, [r3, #28]
 8008af2:	2b00      	cmp	r3, #0
 8008af4:	d003      	beq.n	8008afe <oqPutTimeout+0x76>
    oqp->q_notify(oqp);
 8008af6:	687b      	ldr	r3, [r7, #4]
 8008af8:	69db      	ldr	r3, [r3, #28]
 8008afa:	6878      	ldr	r0, [r7, #4]
 8008afc:	4798      	blx	r3
  }

  osalSysUnlock();
 8008afe:	f001 f9fd 	bl	8009efc <osalSysUnlock.lto_priv.195>

  return MSG_OK;
 8008b02:	2300      	movs	r3, #0
}
 8008b04:	4618      	mov	r0, r3
 8008b06:	3710      	adds	r7, #16
 8008b08:	46bd      	mov	sp, r7
 8008b0a:	bd80      	pop	{r7, pc}

08008b0c <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8008b0c:	b580      	push	{r7, lr}
 8008b0e:	b084      	sub	sp, #16
 8008b10:	af00      	add	r7, sp, #0
 8008b12:	6078      	str	r0, [r7, #4]
  uint8_t b;

  osalDbgCheckClassI();
 8008b14:	f002 fa24 	bl	800af60 <chDbgCheckClassI>

  if (oqIsEmptyI(oqp)) {
 8008b18:	687b      	ldr	r3, [r7, #4]
 8008b1a:	695a      	ldr	r2, [r3, #20]
 8008b1c:	687b      	ldr	r3, [r7, #4]
 8008b1e:	699b      	ldr	r3, [r3, #24]
 8008b20:	429a      	cmp	r2, r3
 8008b22:	d105      	bne.n	8008b30 <oqGetI+0x24>
 8008b24:	687b      	ldr	r3, [r7, #4]
 8008b26:	689b      	ldr	r3, [r3, #8]
 8008b28:	2b00      	cmp	r3, #0
 8008b2a:	d001      	beq.n	8008b30 <oqGetI+0x24>
 8008b2c:	2301      	movs	r3, #1
 8008b2e:	e000      	b.n	8008b32 <oqGetI+0x26>
 8008b30:	2300      	movs	r3, #0
 8008b32:	f003 0301 	and.w	r3, r3, #1
 8008b36:	b2db      	uxtb	r3, r3
 8008b38:	2b00      	cmp	r3, #0
 8008b3a:	d002      	beq.n	8008b42 <oqGetI+0x36>
    return MSG_TIMEOUT;
 8008b3c:	f04f 33ff 	mov.w	r3, #4294967295
 8008b40:	e01b      	b.n	8008b7a <oqGetI+0x6e>
  }

  oqp->q_counter++;
 8008b42:	687b      	ldr	r3, [r7, #4]
 8008b44:	689b      	ldr	r3, [r3, #8]
 8008b46:	1c5a      	adds	r2, r3, #1
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8008b4c:	687b      	ldr	r3, [r7, #4]
 8008b4e:	699b      	ldr	r3, [r3, #24]
 8008b50:	1c59      	adds	r1, r3, #1
 8008b52:	687a      	ldr	r2, [r7, #4]
 8008b54:	6191      	str	r1, [r2, #24]
 8008b56:	781b      	ldrb	r3, [r3, #0]
 8008b58:	73fb      	strb	r3, [r7, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8008b5a:	687b      	ldr	r3, [r7, #4]
 8008b5c:	699a      	ldr	r2, [r3, #24]
 8008b5e:	687b      	ldr	r3, [r7, #4]
 8008b60:	691b      	ldr	r3, [r3, #16]
 8008b62:	429a      	cmp	r2, r3
 8008b64:	d303      	bcc.n	8008b6e <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 8008b66:	687b      	ldr	r3, [r7, #4]
 8008b68:	68da      	ldr	r2, [r3, #12]
 8008b6a:	687b      	ldr	r3, [r7, #4]
 8008b6c:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8008b6e:	687b      	ldr	r3, [r7, #4]
 8008b70:	4618      	mov	r0, r3
 8008b72:	2100      	movs	r1, #0
 8008b74:	f001 f9ea 	bl	8009f4c <osalThreadDequeueNextI.lto_priv.204>

  return (msg_t)b;
 8008b78:	7bfb      	ldrb	r3, [r7, #15]
}
 8008b7a:	4618      	mov	r0, r3
 8008b7c:	3710      	adds	r7, #16
 8008b7e:	46bd      	mov	sp, r7
 8008b80:	bd80      	pop	{r7, pc}
 8008b82:	bf00      	nop

08008b84 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8008b84:	b580      	push	{r7, lr}
 8008b86:	b088      	sub	sp, #32
 8008b88:	af00      	add	r7, sp, #0
 8008b8a:	60f8      	str	r0, [r7, #12]
 8008b8c:	60b9      	str	r1, [r7, #8]
 8008b8e:	607a      	str	r2, [r7, #4]
 8008b90:	807b      	strh	r3, [r7, #2]
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8008b92:	68fb      	ldr	r3, [r7, #12]
 8008b94:	69db      	ldr	r3, [r3, #28]
 8008b96:	617b      	str	r3, [r7, #20]
  size_t w = 0;
 8008b98:	2300      	movs	r3, #0
 8008b9a:	61fb      	str	r3, [r7, #28]

  osalDbgCheck(n > 0U);
 8008b9c:	687b      	ldr	r3, [r7, #4]
 8008b9e:	2b00      	cmp	r3, #0
 8008ba0:	d102      	bne.n	8008ba8 <oqWriteTimeout+0x24>
 8008ba2:	4838      	ldr	r0, [pc, #224]	; (8008c84 <oqWriteTimeout+0x100>)
 8008ba4:	f002 f8fe 	bl	800ada4 <chSysHalt>

  osalSysLock();
 8008ba8:	f001 f9a2 	bl	8009ef0 <osalSysLock.lto_priv.197>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8008bac:	f001 f9ac 	bl	8009f08 <osalOsGetSystemTimeX.lto_priv.203>
 8008bb0:	4603      	mov	r3, r0
 8008bb2:	461a      	mov	r2, r3
 8008bb4:	887b      	ldrh	r3, [r7, #2]
 8008bb6:	4413      	add	r3, r2
 8008bb8:	827b      	strh	r3, [r7, #18]
 8008bba:	e02c      	b.n	8008c16 <oqWriteTimeout+0x92>
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8008bbc:	887b      	ldrh	r3, [r7, #2]
 8008bbe:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008bc2:	4293      	cmp	r3, r2
 8008bc4:	d002      	beq.n	8008bcc <oqWriteTimeout+0x48>
 8008bc6:	887b      	ldrh	r3, [r7, #2]
 8008bc8:	2b00      	cmp	r3, #0
 8008bca:	d107      	bne.n	8008bdc <oqWriteTimeout+0x58>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8008bcc:	68fa      	ldr	r2, [r7, #12]
 8008bce:	887b      	ldrh	r3, [r7, #2]
 8008bd0:	4610      	mov	r0, r2
 8008bd2:	4619      	mov	r1, r3
 8008bd4:	f001 f9aa 	bl	8009f2c <osalThreadEnqueueTimeoutS.lto_priv.202>
 8008bd8:	61b8      	str	r0, [r7, #24]
 8008bda:	e015      	b.n	8008c08 <oqWriteTimeout+0x84>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8008bdc:	f001 f994 	bl	8009f08 <osalOsGetSystemTimeX.lto_priv.203>
 8008be0:	4603      	mov	r3, r0
 8008be2:	461a      	mov	r2, r3
 8008be4:	8a7b      	ldrh	r3, [r7, #18]
 8008be6:	1a9b      	subs	r3, r3, r2
 8008be8:	823b      	strh	r3, [r7, #16]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8008bea:	8a3a      	ldrh	r2, [r7, #16]
 8008bec:	887b      	ldrh	r3, [r7, #2]
 8008bee:	429a      	cmp	r2, r3
 8008bf0:	d903      	bls.n	8008bfa <oqWriteTimeout+0x76>
          osalSysUnlock();
 8008bf2:	f001 f983 	bl	8009efc <osalSysUnlock.lto_priv.195>
          return w;
 8008bf6:	69fb      	ldr	r3, [r7, #28]
 8008bf8:	e040      	b.n	8008c7c <oqWriteTimeout+0xf8>
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
 8008bfa:	68fa      	ldr	r2, [r7, #12]
 8008bfc:	8a3b      	ldrh	r3, [r7, #16]
 8008bfe:	4610      	mov	r0, r2
 8008c00:	4619      	mov	r1, r3
 8008c02:	f001 f993 	bl	8009f2c <osalThreadEnqueueTimeoutS.lto_priv.202>
 8008c06:	61b8      	str	r0, [r7, #24]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8008c08:	69bb      	ldr	r3, [r7, #24]
 8008c0a:	2b00      	cmp	r3, #0
 8008c0c:	d003      	beq.n	8008c16 <oqWriteTimeout+0x92>
        osalSysUnlock();
 8008c0e:	f001 f975 	bl	8009efc <osalSysUnlock.lto_priv.195>
        return w;
 8008c12:	69fb      	ldr	r3, [r7, #28]
 8008c14:	e032      	b.n	8008c7c <oqWriteTimeout+0xf8>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8008c16:	68fb      	ldr	r3, [r7, #12]
 8008c18:	689b      	ldr	r3, [r3, #8]
 8008c1a:	2b00      	cmp	r3, #0
 8008c1c:	d0ce      	beq.n	8008bbc <oqWriteTimeout+0x38>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8008c1e:	68fb      	ldr	r3, [r7, #12]
 8008c20:	689b      	ldr	r3, [r3, #8]
 8008c22:	1e5a      	subs	r2, r3, #1
 8008c24:	68fb      	ldr	r3, [r7, #12]
 8008c26:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 8008c28:	68fb      	ldr	r3, [r7, #12]
 8008c2a:	695b      	ldr	r3, [r3, #20]
 8008c2c:	1c59      	adds	r1, r3, #1
 8008c2e:	68fa      	ldr	r2, [r7, #12]
 8008c30:	6151      	str	r1, [r2, #20]
 8008c32:	68ba      	ldr	r2, [r7, #8]
 8008c34:	1c51      	adds	r1, r2, #1
 8008c36:	60b9      	str	r1, [r7, #8]
 8008c38:	7812      	ldrb	r2, [r2, #0]
 8008c3a:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8008c3c:	68fb      	ldr	r3, [r7, #12]
 8008c3e:	695a      	ldr	r2, [r3, #20]
 8008c40:	68fb      	ldr	r3, [r7, #12]
 8008c42:	691b      	ldr	r3, [r3, #16]
 8008c44:	429a      	cmp	r2, r3
 8008c46:	d303      	bcc.n	8008c50 <oqWriteTimeout+0xcc>
      oqp->q_wrptr = oqp->q_buffer;
 8008c48:	68fb      	ldr	r3, [r7, #12]
 8008c4a:	68da      	ldr	r2, [r3, #12]
 8008c4c:	68fb      	ldr	r3, [r7, #12]
 8008c4e:	615a      	str	r2, [r3, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8008c50:	697b      	ldr	r3, [r7, #20]
 8008c52:	2b00      	cmp	r3, #0
 8008c54:	d002      	beq.n	8008c5c <oqWriteTimeout+0xd8>
      nfy(oqp);
 8008c56:	697b      	ldr	r3, [r7, #20]
 8008c58:	68f8      	ldr	r0, [r7, #12]
 8008c5a:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8008c5c:	f001 f94e 	bl	8009efc <osalSysUnlock.lto_priv.195>

    w++;
 8008c60:	69fb      	ldr	r3, [r7, #28]
 8008c62:	3301      	adds	r3, #1
 8008c64:	61fb      	str	r3, [r7, #28]
    if (--n == 0U) {
 8008c66:	687b      	ldr	r3, [r7, #4]
 8008c68:	3b01      	subs	r3, #1
 8008c6a:	607b      	str	r3, [r7, #4]
 8008c6c:	687b      	ldr	r3, [r7, #4]
 8008c6e:	2b00      	cmp	r3, #0
 8008c70:	d101      	bne.n	8008c76 <oqWriteTimeout+0xf2>
      return w;
 8008c72:	69fb      	ldr	r3, [r7, #28]
 8008c74:	e002      	b.n	8008c7c <oqWriteTimeout+0xf8>
    }

    osalSysLock();
 8008c76:	f001 f93b 	bl	8009ef0 <osalSysLock.lto_priv.197>
 8008c7a:	e7cc      	b.n	8008c16 <oqWriteTimeout+0x92>
  }
}
 8008c7c:	4618      	mov	r0, r3
 8008c7e:	3720      	adds	r7, #32
 8008c80:	46bd      	mov	sp, r7
 8008c82:	bd80      	pop	{r7, pc}
 8008c84:	0800eab4 	.word	0x0800eab4

08008c88 <port_lock.lto_priv.184>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008c88:	b480      	push	{r7}
 8008c8a:	b083      	sub	sp, #12
 8008c8c:	af00      	add	r7, sp, #0
 8008c8e:	2320      	movs	r3, #32
 8008c90:	607b      	str	r3, [r7, #4]
 8008c92:	687b      	ldr	r3, [r7, #4]
 8008c94:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008c98:	370c      	adds	r7, #12
 8008c9a:	46bd      	mov	sp, r7
 8008c9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ca0:	4770      	bx	lr
 8008ca2:	bf00      	nop

08008ca4 <port_unlock.lto_priv.181>:
=======
 80088c8:	b580      	push	{r7, lr}
 80088ca:	b088      	sub	sp, #32
 80088cc:	af02      	add	r7, sp, #8
 80088ce:	60f8      	str	r0, [r7, #12]
 80088d0:	60b9      	str	r1, [r7, #8]
 80088d2:	607a      	str	r2, [r7, #4]
 80088d4:	603b      	str	r3, [r7, #0]
    uint32_t timer_expiration_millis = ST2MS(timer_expiration_ticks);
 80088d6:	8c3b      	ldrh	r3, [r7, #32]
 80088d8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80088dc:	fb02 f303 	mul.w	r3, r2, r3
 80088e0:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 80088e4:	330f      	adds	r3, #15
 80088e6:	4a0d      	ldr	r2, [pc, #52]	; (800891c <worker_thread_add_timer_task+0x54>)
 80088e8:	fba2 2303 	umull	r2, r3, r2, r3
 80088ec:	0b5b      	lsrs	r3, r3, #13
 80088ee:	617b      	str	r3, [r7, #20]
    chSysLock();
 80088f0:	f7ff feea 	bl	80086c8 <chSysLock.lto_priv.124>
    _worker_thread_add_timer_task_no_wake_I(worker_thread, task, task_func, ctx, timer_expiration_millis, auto_repeat);
 80088f4:	697b      	ldr	r3, [r7, #20]
 80088f6:	9300      	str	r3, [sp, #0]
 80088f8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 80088fc:	9301      	str	r3, [sp, #4]
 80088fe:	68f8      	ldr	r0, [r7, #12]
 8008900:	68b9      	ldr	r1, [r7, #8]
 8008902:	687a      	ldr	r2, [r7, #4]
 8008904:	683b      	ldr	r3, [r7, #0]
 8008906:	f7ff ffbf 	bl	8008888 <_worker_thread_add_timer_task_no_wake_I>
    chSysUnlock();
 800890a:	f7ff fee5 	bl	80086d8 <chSysUnlock.lto_priv.122>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 800890e:	68f8      	ldr	r0, [r7, #12]
 8008910:	f7fe f93e 	bl	8006b90 <worker_thread_wake.lto_priv.157>
}
 8008914:	3718      	adds	r7, #24
 8008916:	46bd      	mov	sp, r7
 8008918:	bd80      	pop	{r7, pc}
 800891a:	bf00      	nop
 800891c:	d1b71759 	.word	0xd1b71759

08008920 <_worker_thread_timer_task_reschedule_no_wake_I>:

static void _worker_thread_timer_task_reschedule_no_wake_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, uint32_t timer_expiration_millis) {
 8008920:	b580      	push	{r7, lr}
 8008922:	b086      	sub	sp, #24
 8008924:	af00      	add	r7, sp, #0
 8008926:	60f8      	str	r0, [r7, #12]
 8008928:	60b9      	str	r1, [r7, #8]
 800892a:	607a      	str	r2, [r7, #4]
    chDbgCheckClassI();
 800892c:	f002 fb5c 	bl	800afe8 <chDbgCheckClassI>

    systime_t t_now = millis();
 8008930:	f7ff f9bc 	bl	8007cac <millis>
 8008934:	4603      	mov	r3, r0
 8008936:	82fb      	strh	r3, [r7, #22]

    worker_thread_remove_timer_task_I(worker_thread, task);
 8008938:	68f8      	ldr	r0, [r7, #12]
 800893a:	68b9      	ldr	r1, [r7, #8]
 800893c:	f000 f838 	bl	80089b0 <worker_thread_remove_timer_task_I>

    task->timer_expiration_millis = timer_expiration_millis;
 8008940:	68bb      	ldr	r3, [r7, #8]
 8008942:	687a      	ldr	r2, [r7, #4]
 8008944:	609a      	str	r2, [r3, #8]
    task->timer_begin_millis = t_now;
 8008946:	8afa      	ldrh	r2, [r7, #22]
 8008948:	68bb      	ldr	r3, [r7, #8]
 800894a:	60da      	str	r2, [r3, #12]

    worker_thread_insert_timer_task_I(worker_thread, task);
 800894c:	68f8      	ldr	r0, [r7, #12]
 800894e:	68b9      	ldr	r1, [r7, #8]
 8008950:	f7fe f964 	bl	8006c1c <worker_thread_insert_timer_task_I.lto_priv.160>
}
 8008954:	3718      	adds	r7, #24
 8008956:	46bd      	mov	sp, r7
 8008958:	bd80      	pop	{r7, pc}
 800895a:	bf00      	nop

0800895c <worker_thread_timer_task_reschedule_I>:

void worker_thread_timer_task_reschedule_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, uint32_t timer_expiration_millis) {
 800895c:	b580      	push	{r7, lr}
 800895e:	b084      	sub	sp, #16
 8008960:	af00      	add	r7, sp, #0
 8008962:	60f8      	str	r0, [r7, #12]
 8008964:	60b9      	str	r1, [r7, #8]
 8008966:	607a      	str	r2, [r7, #4]
    chDbgCheckClassI();
 8008968:	f002 fb3e 	bl	800afe8 <chDbgCheckClassI>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_millis);
 800896c:	68f8      	ldr	r0, [r7, #12]
 800896e:	68b9      	ldr	r1, [r7, #8]
 8008970:	687a      	ldr	r2, [r7, #4]
 8008972:	f7ff ffd5 	bl	8008920 <_worker_thread_timer_task_reschedule_no_wake_I>

    // Wake worker thread to process tasks
    worker_thread_wake_I(worker_thread);
 8008976:	68f8      	ldr	r0, [r7, #12]
 8008978:	f7fe f8fa 	bl	8006b70 <worker_thread_wake_I.lto_priv.159>
}
 800897c:	3710      	adds	r7, #16
 800897e:	46bd      	mov	sp, r7
 8008980:	bd80      	pop	{r7, pc}
 8008982:	bf00      	nop

08008984 <worker_thread_timer_task_reschedule>:

void worker_thread_timer_task_reschedule(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task, uint32_t timer_expiration_millis) {
 8008984:	b580      	push	{r7, lr}
 8008986:	b084      	sub	sp, #16
 8008988:	af00      	add	r7, sp, #0
 800898a:	60f8      	str	r0, [r7, #12]
 800898c:	60b9      	str	r1, [r7, #8]
 800898e:	607a      	str	r2, [r7, #4]
    chSysLock();
 8008990:	f7ff fe9a 	bl	80086c8 <chSysLock.lto_priv.124>
    _worker_thread_timer_task_reschedule_no_wake_I(worker_thread, task, timer_expiration_millis);
 8008994:	68f8      	ldr	r0, [r7, #12]
 8008996:	68b9      	ldr	r1, [r7, #8]
 8008998:	687a      	ldr	r2, [r7, #4]
 800899a:	f7ff ffc1 	bl	8008920 <_worker_thread_timer_task_reschedule_no_wake_I>
    chSysUnlock();
 800899e:	f7ff fe9b 	bl	80086d8 <chSysUnlock.lto_priv.122>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 80089a2:	68f8      	ldr	r0, [r7, #12]
 80089a4:	f7fe f8f4 	bl	8006b90 <worker_thread_wake.lto_priv.157>
}
 80089a8:	3710      	adds	r7, #16
 80089aa:	46bd      	mov	sp, r7
 80089ac:	bd80      	pop	{r7, pc}
 80089ae:	bf00      	nop

080089b0 <worker_thread_remove_timer_task_I>:

void worker_thread_remove_timer_task_I(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 80089b0:	b580      	push	{r7, lr}
 80089b2:	b084      	sub	sp, #16
 80089b4:	af00      	add	r7, sp, #0
 80089b6:	6078      	str	r0, [r7, #4]
 80089b8:	6039      	str	r1, [r7, #0]
    chDbgCheckClassI();
 80089ba:	f002 fb15 	bl	800afe8 <chDbgCheckClassI>
    LINKED_LIST_REMOVE(struct worker_thread_timer_task_s, worker_thread->timer_task_list_head, task);
 80089be:	687b      	ldr	r3, [r7, #4]
 80089c0:	3310      	adds	r3, #16
 80089c2:	60fb      	str	r3, [r7, #12]
 80089c4:	e003      	b.n	80089ce <worker_thread_remove_timer_task_I+0x1e>
 80089c6:	68fb      	ldr	r3, [r7, #12]
 80089c8:	681b      	ldr	r3, [r3, #0]
 80089ca:	3314      	adds	r3, #20
 80089cc:	60fb      	str	r3, [r7, #12]
 80089ce:	68fb      	ldr	r3, [r7, #12]
 80089d0:	681b      	ldr	r3, [r3, #0]
 80089d2:	2b00      	cmp	r3, #0
 80089d4:	d004      	beq.n	80089e0 <worker_thread_remove_timer_task_I+0x30>
 80089d6:	68fb      	ldr	r3, [r7, #12]
 80089d8:	681a      	ldr	r2, [r3, #0]
 80089da:	683b      	ldr	r3, [r7, #0]
 80089dc:	429a      	cmp	r2, r3
 80089de:	d1f2      	bne.n	80089c6 <worker_thread_remove_timer_task_I+0x16>
 80089e0:	68fb      	ldr	r3, [r7, #12]
 80089e2:	681b      	ldr	r3, [r3, #0]
 80089e4:	2b00      	cmp	r3, #0
 80089e6:	d004      	beq.n	80089f2 <worker_thread_remove_timer_task_I+0x42>
 80089e8:	68fb      	ldr	r3, [r7, #12]
 80089ea:	681b      	ldr	r3, [r3, #0]
 80089ec:	695a      	ldr	r2, [r3, #20]
 80089ee:	68fb      	ldr	r3, [r7, #12]
 80089f0:	601a      	str	r2, [r3, #0]
}
 80089f2:	3710      	adds	r7, #16
 80089f4:	46bd      	mov	sp, r7
 80089f6:	bd80      	pop	{r7, pc}

080089f8 <worker_thread_remove_timer_task>:

void worker_thread_remove_timer_task(struct worker_thread_s* worker_thread, struct worker_thread_timer_task_s* task) {
 80089f8:	b580      	push	{r7, lr}
 80089fa:	b082      	sub	sp, #8
 80089fc:	af00      	add	r7, sp, #0
 80089fe:	6078      	str	r0, [r7, #4]
 8008a00:	6039      	str	r1, [r7, #0]
    chSysLock();
 8008a02:	f7ff fe61 	bl	80086c8 <chSysLock.lto_priv.124>
    worker_thread_remove_timer_task_I(worker_thread, task);
 8008a06:	6878      	ldr	r0, [r7, #4]
 8008a08:	6839      	ldr	r1, [r7, #0]
 8008a0a:	f7ff ffd1 	bl	80089b0 <worker_thread_remove_timer_task_I>
    chSysUnlock();
 8008a0e:	f7ff fe63 	bl	80086d8 <chSysUnlock.lto_priv.122>
}
 8008a12:	3708      	adds	r7, #8
 8008a14:	46bd      	mov	sp, r7
 8008a16:	bd80      	pop	{r7, pc}

08008a18 <worker_thread_task_get_user_context>:

void* worker_thread_task_get_user_context(struct worker_thread_timer_task_s* task) {
 8008a18:	b480      	push	{r7}
 8008a1a:	b083      	sub	sp, #12
 8008a1c:	af00      	add	r7, sp, #0
 8008a1e:	6078      	str	r0, [r7, #4]
    if (!task) {
 8008a20:	687b      	ldr	r3, [r7, #4]
 8008a22:	2b00      	cmp	r3, #0
 8008a24:	d101      	bne.n	8008a2a <worker_thread_task_get_user_context+0x12>
        return NULL;
 8008a26:	2300      	movs	r3, #0
 8008a28:	e001      	b.n	8008a2e <worker_thread_task_get_user_context+0x16>
    }

    return task->ctx;
 8008a2a:	687b      	ldr	r3, [r7, #4]
 8008a2c:	685b      	ldr	r3, [r3, #4]
}
 8008a2e:	4618      	mov	r0, r3
 8008a30:	370c      	adds	r7, #12
 8008a32:	46bd      	mov	sp, r7
 8008a34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a38:	4770      	bx	lr
 8008a3a:	bf00      	nop

08008a3c <worker_thread_add_listener_task>:

#ifdef MODULE_PUBSUB_ENABLED
void worker_thread_add_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task, struct pubsub_topic_s* topic, pubsub_message_handler_func_ptr handler_cb, void* handler_cb_ctx) {
 8008a3c:	b580      	push	{r7, lr}
 8008a3e:	b086      	sub	sp, #24
 8008a40:	af00      	add	r7, sp, #0
 8008a42:	60f8      	str	r0, [r7, #12]
 8008a44:	60b9      	str	r1, [r7, #8]
 8008a46:	607a      	str	r2, [r7, #4]
 8008a48:	603b      	str	r3, [r7, #0]
    chDbgCheck(!worker_thread_listener_task_is_registered(worker_thread, task));
 8008a4a:	68f8      	ldr	r0, [r7, #12]
 8008a4c:	68b9      	ldr	r1, [r7, #8]
 8008a4e:	f7fe f9a1 	bl	8006d94 <worker_thread_listener_task_is_registered.lto_priv.158>
 8008a52:	4603      	mov	r3, r0
 8008a54:	2b00      	cmp	r3, #0
 8008a56:	d002      	beq.n	8008a5e <worker_thread_add_listener_task+0x22>
 8008a58:	4816      	ldr	r0, [pc, #88]	; (8008ab4 <worker_thread_add_listener_task+0x78>)
 8008a5a:	f002 f9e7 	bl	800ae2c <chSysHalt>

    pubsub_listener_init_and_register(&task->listener, topic, handler_cb, handler_cb_ctx);
 8008a5e:	68bb      	ldr	r3, [r7, #8]
 8008a60:	4618      	mov	r0, r3
 8008a62:	6879      	ldr	r1, [r7, #4]
 8008a64:	683a      	ldr	r2, [r7, #0]
 8008a66:	6a3b      	ldr	r3, [r7, #32]
 8008a68:	f7ff fbc6 	bl	80081f8 <pubsub_listener_init_and_register>
    pubsub_listener_set_waiting_thread_reference(&task->listener, &worker_thread->suspend_trp);
 8008a6c:	68ba      	ldr	r2, [r7, #8]
 8008a6e:	68fb      	ldr	r3, [r7, #12]
 8008a70:	330c      	adds	r3, #12
 8008a72:	4610      	mov	r0, r2
 8008a74:	4619      	mov	r1, r3
 8008a76:	f7ff fd67 	bl	8008548 <pubsub_listener_set_waiting_thread_reference>

    chSysLock();
 8008a7a:	f7ff fe25 	bl	80086c8 <chSysLock.lto_priv.124>
    LINKED_LIST_APPEND(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
 8008a7e:	68bb      	ldr	r3, [r7, #8]
 8008a80:	2200      	movs	r2, #0
 8008a82:	631a      	str	r2, [r3, #48]	; 0x30
 8008a84:	68fb      	ldr	r3, [r7, #12]
 8008a86:	3314      	adds	r3, #20
 8008a88:	617b      	str	r3, [r7, #20]
 8008a8a:	e003      	b.n	8008a94 <worker_thread_add_listener_task+0x58>
 8008a8c:	697b      	ldr	r3, [r7, #20]
 8008a8e:	681b      	ldr	r3, [r3, #0]
 8008a90:	3330      	adds	r3, #48	; 0x30
 8008a92:	617b      	str	r3, [r7, #20]
 8008a94:	697b      	ldr	r3, [r7, #20]
 8008a96:	681b      	ldr	r3, [r3, #0]
 8008a98:	2b00      	cmp	r3, #0
 8008a9a:	d1f7      	bne.n	8008a8c <worker_thread_add_listener_task+0x50>
 8008a9c:	697b      	ldr	r3, [r7, #20]
 8008a9e:	68ba      	ldr	r2, [r7, #8]
 8008aa0:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008aa2:	f7ff fe19 	bl	80086d8 <chSysUnlock.lto_priv.122>

    // Wake worker thread to process tasks
    worker_thread_wake(worker_thread);
 8008aa6:	68f8      	ldr	r0, [r7, #12]
 8008aa8:	f7fe f872 	bl	8006b90 <worker_thread_wake.lto_priv.157>
}
 8008aac:	3718      	adds	r7, #24
 8008aae:	46bd      	mov	sp, r7
 8008ab0:	bd80      	pop	{r7, pc}
 8008ab2:	bf00      	nop
 8008ab4:	0800ec7c 	.word	0x0800ec7c

08008ab8 <worker_thread_remove_listener_task>:

void worker_thread_remove_listener_task(struct worker_thread_s* worker_thread, struct worker_thread_listener_task_s* task) {
 8008ab8:	b580      	push	{r7, lr}
 8008aba:	b084      	sub	sp, #16
 8008abc:	af00      	add	r7, sp, #0
 8008abe:	6078      	str	r0, [r7, #4]
 8008ac0:	6039      	str	r1, [r7, #0]
    pubsub_listener_unregister(&task->listener);
 8008ac2:	683b      	ldr	r3, [r7, #0]
 8008ac4:	4618      	mov	r0, r3
 8008ac6:	f7ff fbdb 	bl	8008280 <pubsub_listener_unregister>

    chSysLock();
 8008aca:	f7ff fdfd 	bl	80086c8 <chSysLock.lto_priv.124>
    LINKED_LIST_REMOVE(struct worker_thread_listener_task_s, worker_thread->listener_task_list_head, task);
 8008ace:	687b      	ldr	r3, [r7, #4]
 8008ad0:	3314      	adds	r3, #20
 8008ad2:	60fb      	str	r3, [r7, #12]
 8008ad4:	e003      	b.n	8008ade <worker_thread_remove_listener_task+0x26>
 8008ad6:	68fb      	ldr	r3, [r7, #12]
 8008ad8:	681b      	ldr	r3, [r3, #0]
 8008ada:	3330      	adds	r3, #48	; 0x30
 8008adc:	60fb      	str	r3, [r7, #12]
 8008ade:	68fb      	ldr	r3, [r7, #12]
 8008ae0:	681b      	ldr	r3, [r3, #0]
 8008ae2:	2b00      	cmp	r3, #0
 8008ae4:	d004      	beq.n	8008af0 <worker_thread_remove_listener_task+0x38>
 8008ae6:	68fb      	ldr	r3, [r7, #12]
 8008ae8:	681a      	ldr	r2, [r3, #0]
 8008aea:	683b      	ldr	r3, [r7, #0]
 8008aec:	429a      	cmp	r2, r3
 8008aee:	d1f2      	bne.n	8008ad6 <worker_thread_remove_listener_task+0x1e>
 8008af0:	68fb      	ldr	r3, [r7, #12]
 8008af2:	681b      	ldr	r3, [r3, #0]
 8008af4:	2b00      	cmp	r3, #0
 8008af6:	d004      	beq.n	8008b02 <worker_thread_remove_listener_task+0x4a>
 8008af8:	68fb      	ldr	r3, [r7, #12]
 8008afa:	681b      	ldr	r3, [r3, #0]
 8008afc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008afe:	68fb      	ldr	r3, [r7, #12]
 8008b00:	601a      	str	r2, [r3, #0]
    chSysUnlock();
 8008b02:	f7ff fde9 	bl	80086d8 <chSysUnlock.lto_priv.122>
}
 8008b06:	3710      	adds	r7, #16
 8008b08:	46bd      	mov	sp, r7
 8008b0a:	bd80      	pop	{r7, pc}

08008b0c <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8008b0c:	b580      	push	{r7, lr}
 8008b0e:	b084      	sub	sp, #16
 8008b10:	af00      	add	r7, sp, #0
 8008b12:	6078      	str	r0, [r7, #4]
 8008b14:	460b      	mov	r3, r1
 8008b16:	70fb      	strb	r3, [r7, #3]
 8008b18:	4613      	mov	r3, r2
 8008b1a:	803b      	strh	r3, [r7, #0]

  osalSysLock();
 8008b1c:	f001 fa2c 	bl	8009f78 <osalSysLock.lto_priv.194>
 8008b20:	e00d      	b.n	8008b3e <oqPutTimeout+0x32>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8008b22:	687a      	ldr	r2, [r7, #4]
 8008b24:	883b      	ldrh	r3, [r7, #0]
 8008b26:	4610      	mov	r0, r2
 8008b28:	4619      	mov	r1, r3
 8008b2a:	f001 fa43 	bl	8009fb4 <osalThreadEnqueueTimeoutS.lto_priv.199>
 8008b2e:	60f8      	str	r0, [r7, #12]
    if (msg < MSG_OK) {
 8008b30:	68fb      	ldr	r3, [r7, #12]
 8008b32:	2b00      	cmp	r3, #0
 8008b34:	da03      	bge.n	8008b3e <oqPutTimeout+0x32>
      osalSysUnlock();
 8008b36:	f001 fa25 	bl	8009f84 <osalSysUnlock.lto_priv.192>
      return msg;
 8008b3a:	68fb      	ldr	r3, [r7, #12]
 8008b3c:	e024      	b.n	8008b88 <oqPutTimeout+0x7c>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8008b3e:	687b      	ldr	r3, [r7, #4]
 8008b40:	689b      	ldr	r3, [r3, #8]
 8008b42:	2b00      	cmp	r3, #0
 8008b44:	d0ed      	beq.n	8008b22 <oqPutTimeout+0x16>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8008b46:	687b      	ldr	r3, [r7, #4]
 8008b48:	689b      	ldr	r3, [r3, #8]
 8008b4a:	1e5a      	subs	r2, r3, #1
 8008b4c:	687b      	ldr	r3, [r7, #4]
 8008b4e:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8008b50:	687b      	ldr	r3, [r7, #4]
 8008b52:	695b      	ldr	r3, [r3, #20]
 8008b54:	1c59      	adds	r1, r3, #1
 8008b56:	687a      	ldr	r2, [r7, #4]
 8008b58:	6151      	str	r1, [r2, #20]
 8008b5a:	78fa      	ldrb	r2, [r7, #3]
 8008b5c:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8008b5e:	687b      	ldr	r3, [r7, #4]
 8008b60:	695a      	ldr	r2, [r3, #20]
 8008b62:	687b      	ldr	r3, [r7, #4]
 8008b64:	691b      	ldr	r3, [r3, #16]
 8008b66:	429a      	cmp	r2, r3
 8008b68:	d303      	bcc.n	8008b72 <oqPutTimeout+0x66>
    oqp->q_wrptr = oqp->q_buffer;
 8008b6a:	687b      	ldr	r3, [r7, #4]
 8008b6c:	68da      	ldr	r2, [r3, #12]
 8008b6e:	687b      	ldr	r3, [r7, #4]
 8008b70:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8008b72:	687b      	ldr	r3, [r7, #4]
 8008b74:	69db      	ldr	r3, [r3, #28]
 8008b76:	2b00      	cmp	r3, #0
 8008b78:	d003      	beq.n	8008b82 <oqPutTimeout+0x76>
    oqp->q_notify(oqp);
 8008b7a:	687b      	ldr	r3, [r7, #4]
 8008b7c:	69db      	ldr	r3, [r3, #28]
 8008b7e:	6878      	ldr	r0, [r7, #4]
 8008b80:	4798      	blx	r3
  }

  osalSysUnlock();
 8008b82:	f001 f9ff 	bl	8009f84 <osalSysUnlock.lto_priv.192>

  return MSG_OK;
 8008b86:	2300      	movs	r3, #0
}
 8008b88:	4618      	mov	r0, r3
 8008b8a:	3710      	adds	r7, #16
 8008b8c:	46bd      	mov	sp, r7
 8008b8e:	bd80      	pop	{r7, pc}

08008b90 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8008b90:	b580      	push	{r7, lr}
 8008b92:	b084      	sub	sp, #16
 8008b94:	af00      	add	r7, sp, #0
 8008b96:	6078      	str	r0, [r7, #4]
  uint8_t b;

  osalDbgCheckClassI();
 8008b98:	f002 fa26 	bl	800afe8 <chDbgCheckClassI>

  if (oqIsEmptyI(oqp)) {
 8008b9c:	687b      	ldr	r3, [r7, #4]
 8008b9e:	695a      	ldr	r2, [r3, #20]
 8008ba0:	687b      	ldr	r3, [r7, #4]
 8008ba2:	699b      	ldr	r3, [r3, #24]
 8008ba4:	429a      	cmp	r2, r3
 8008ba6:	d105      	bne.n	8008bb4 <oqGetI+0x24>
 8008ba8:	687b      	ldr	r3, [r7, #4]
 8008baa:	689b      	ldr	r3, [r3, #8]
 8008bac:	2b00      	cmp	r3, #0
 8008bae:	d001      	beq.n	8008bb4 <oqGetI+0x24>
 8008bb0:	2301      	movs	r3, #1
 8008bb2:	e000      	b.n	8008bb6 <oqGetI+0x26>
 8008bb4:	2300      	movs	r3, #0
 8008bb6:	f003 0301 	and.w	r3, r3, #1
 8008bba:	b2db      	uxtb	r3, r3
 8008bbc:	2b00      	cmp	r3, #0
 8008bbe:	d002      	beq.n	8008bc6 <oqGetI+0x36>
    return MSG_TIMEOUT;
 8008bc0:	f04f 33ff 	mov.w	r3, #4294967295
 8008bc4:	e01b      	b.n	8008bfe <oqGetI+0x6e>
  }

  oqp->q_counter++;
 8008bc6:	687b      	ldr	r3, [r7, #4]
 8008bc8:	689b      	ldr	r3, [r3, #8]
 8008bca:	1c5a      	adds	r2, r3, #1
 8008bcc:	687b      	ldr	r3, [r7, #4]
 8008bce:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8008bd0:	687b      	ldr	r3, [r7, #4]
 8008bd2:	699b      	ldr	r3, [r3, #24]
 8008bd4:	1c59      	adds	r1, r3, #1
 8008bd6:	687a      	ldr	r2, [r7, #4]
 8008bd8:	6191      	str	r1, [r2, #24]
 8008bda:	781b      	ldrb	r3, [r3, #0]
 8008bdc:	73fb      	strb	r3, [r7, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8008bde:	687b      	ldr	r3, [r7, #4]
 8008be0:	699a      	ldr	r2, [r3, #24]
 8008be2:	687b      	ldr	r3, [r7, #4]
 8008be4:	691b      	ldr	r3, [r3, #16]
 8008be6:	429a      	cmp	r2, r3
 8008be8:	d303      	bcc.n	8008bf2 <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 8008bea:	687b      	ldr	r3, [r7, #4]
 8008bec:	68da      	ldr	r2, [r3, #12]
 8008bee:	687b      	ldr	r3, [r7, #4]
 8008bf0:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8008bf2:	687b      	ldr	r3, [r7, #4]
 8008bf4:	4618      	mov	r0, r3
 8008bf6:	2100      	movs	r1, #0
 8008bf8:	f001 f9ec 	bl	8009fd4 <osalThreadDequeueNextI.lto_priv.201>

  return (msg_t)b;
 8008bfc:	7bfb      	ldrb	r3, [r7, #15]
}
 8008bfe:	4618      	mov	r0, r3
 8008c00:	3710      	adds	r7, #16
 8008c02:	46bd      	mov	sp, r7
 8008c04:	bd80      	pop	{r7, pc}
 8008c06:	bf00      	nop

08008c08 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8008c08:	b580      	push	{r7, lr}
 8008c0a:	b088      	sub	sp, #32
 8008c0c:	af00      	add	r7, sp, #0
 8008c0e:	60f8      	str	r0, [r7, #12]
 8008c10:	60b9      	str	r1, [r7, #8]
 8008c12:	607a      	str	r2, [r7, #4]
 8008c14:	807b      	strh	r3, [r7, #2]
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8008c16:	68fb      	ldr	r3, [r7, #12]
 8008c18:	69db      	ldr	r3, [r3, #28]
 8008c1a:	617b      	str	r3, [r7, #20]
  size_t w = 0;
 8008c1c:	2300      	movs	r3, #0
 8008c1e:	61fb      	str	r3, [r7, #28]

  osalDbgCheck(n > 0U);
 8008c20:	687b      	ldr	r3, [r7, #4]
 8008c22:	2b00      	cmp	r3, #0
 8008c24:	d102      	bne.n	8008c2c <oqWriteTimeout+0x24>
 8008c26:	4838      	ldr	r0, [pc, #224]	; (8008d08 <oqWriteTimeout+0x100>)
 8008c28:	f002 f900 	bl	800ae2c <chSysHalt>

  osalSysLock();
 8008c2c:	f001 f9a4 	bl	8009f78 <osalSysLock.lto_priv.194>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8008c30:	f001 f9ae 	bl	8009f90 <osalOsGetSystemTimeX.lto_priv.200>
 8008c34:	4603      	mov	r3, r0
 8008c36:	461a      	mov	r2, r3
 8008c38:	887b      	ldrh	r3, [r7, #2]
 8008c3a:	4413      	add	r3, r2
 8008c3c:	827b      	strh	r3, [r7, #18]
 8008c3e:	e02c      	b.n	8008c9a <oqWriteTimeout+0x92>
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8008c40:	887b      	ldrh	r3, [r7, #2]
 8008c42:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008c46:	4293      	cmp	r3, r2
 8008c48:	d002      	beq.n	8008c50 <oqWriteTimeout+0x48>
 8008c4a:	887b      	ldrh	r3, [r7, #2]
 8008c4c:	2b00      	cmp	r3, #0
 8008c4e:	d107      	bne.n	8008c60 <oqWriteTimeout+0x58>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8008c50:	68fa      	ldr	r2, [r7, #12]
 8008c52:	887b      	ldrh	r3, [r7, #2]
 8008c54:	4610      	mov	r0, r2
 8008c56:	4619      	mov	r1, r3
 8008c58:	f001 f9ac 	bl	8009fb4 <osalThreadEnqueueTimeoutS.lto_priv.199>
 8008c5c:	61b8      	str	r0, [r7, #24]
 8008c5e:	e015      	b.n	8008c8c <oqWriteTimeout+0x84>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8008c60:	f001 f996 	bl	8009f90 <osalOsGetSystemTimeX.lto_priv.200>
 8008c64:	4603      	mov	r3, r0
 8008c66:	461a      	mov	r2, r3
 8008c68:	8a7b      	ldrh	r3, [r7, #18]
 8008c6a:	1a9b      	subs	r3, r3, r2
 8008c6c:	823b      	strh	r3, [r7, #16]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8008c6e:	8a3a      	ldrh	r2, [r7, #16]
 8008c70:	887b      	ldrh	r3, [r7, #2]
 8008c72:	429a      	cmp	r2, r3
 8008c74:	d903      	bls.n	8008c7e <oqWriteTimeout+0x76>
          osalSysUnlock();
 8008c76:	f001 f985 	bl	8009f84 <osalSysUnlock.lto_priv.192>
          return w;
 8008c7a:	69fb      	ldr	r3, [r7, #28]
 8008c7c:	e040      	b.n	8008d00 <oqWriteTimeout+0xf8>
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
 8008c7e:	68fa      	ldr	r2, [r7, #12]
 8008c80:	8a3b      	ldrh	r3, [r7, #16]
 8008c82:	4610      	mov	r0, r2
 8008c84:	4619      	mov	r1, r3
 8008c86:	f001 f995 	bl	8009fb4 <osalThreadEnqueueTimeoutS.lto_priv.199>
 8008c8a:	61b8      	str	r0, [r7, #24]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8008c8c:	69bb      	ldr	r3, [r7, #24]
 8008c8e:	2b00      	cmp	r3, #0
 8008c90:	d003      	beq.n	8008c9a <oqWriteTimeout+0x92>
        osalSysUnlock();
 8008c92:	f001 f977 	bl	8009f84 <osalSysUnlock.lto_priv.192>
        return w;
 8008c96:	69fb      	ldr	r3, [r7, #28]
 8008c98:	e032      	b.n	8008d00 <oqWriteTimeout+0xf8>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8008c9a:	68fb      	ldr	r3, [r7, #12]
 8008c9c:	689b      	ldr	r3, [r3, #8]
 8008c9e:	2b00      	cmp	r3, #0
 8008ca0:	d0ce      	beq.n	8008c40 <oqWriteTimeout+0x38>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8008ca2:	68fb      	ldr	r3, [r7, #12]
 8008ca4:	689b      	ldr	r3, [r3, #8]
 8008ca6:	1e5a      	subs	r2, r3, #1
 8008ca8:	68fb      	ldr	r3, [r7, #12]
 8008caa:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 8008cac:	68fb      	ldr	r3, [r7, #12]
 8008cae:	695b      	ldr	r3, [r3, #20]
 8008cb0:	1c59      	adds	r1, r3, #1
 8008cb2:	68fa      	ldr	r2, [r7, #12]
 8008cb4:	6151      	str	r1, [r2, #20]
 8008cb6:	68ba      	ldr	r2, [r7, #8]
 8008cb8:	1c51      	adds	r1, r2, #1
 8008cba:	60b9      	str	r1, [r7, #8]
 8008cbc:	7812      	ldrb	r2, [r2, #0]
 8008cbe:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8008cc0:	68fb      	ldr	r3, [r7, #12]
 8008cc2:	695a      	ldr	r2, [r3, #20]
 8008cc4:	68fb      	ldr	r3, [r7, #12]
 8008cc6:	691b      	ldr	r3, [r3, #16]
 8008cc8:	429a      	cmp	r2, r3
 8008cca:	d303      	bcc.n	8008cd4 <oqWriteTimeout+0xcc>
      oqp->q_wrptr = oqp->q_buffer;
 8008ccc:	68fb      	ldr	r3, [r7, #12]
 8008cce:	68da      	ldr	r2, [r3, #12]
 8008cd0:	68fb      	ldr	r3, [r7, #12]
 8008cd2:	615a      	str	r2, [r3, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8008cd4:	697b      	ldr	r3, [r7, #20]
 8008cd6:	2b00      	cmp	r3, #0
 8008cd8:	d002      	beq.n	8008ce0 <oqWriteTimeout+0xd8>
      nfy(oqp);
 8008cda:	697b      	ldr	r3, [r7, #20]
 8008cdc:	68f8      	ldr	r0, [r7, #12]
 8008cde:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8008ce0:	f001 f950 	bl	8009f84 <osalSysUnlock.lto_priv.192>

    w++;
 8008ce4:	69fb      	ldr	r3, [r7, #28]
 8008ce6:	3301      	adds	r3, #1
 8008ce8:	61fb      	str	r3, [r7, #28]
    if (--n == 0U) {
 8008cea:	687b      	ldr	r3, [r7, #4]
 8008cec:	3b01      	subs	r3, #1
 8008cee:	607b      	str	r3, [r7, #4]
 8008cf0:	687b      	ldr	r3, [r7, #4]
 8008cf2:	2b00      	cmp	r3, #0
 8008cf4:	d101      	bne.n	8008cfa <oqWriteTimeout+0xf2>
      return w;
 8008cf6:	69fb      	ldr	r3, [r7, #28]
 8008cf8:	e002      	b.n	8008d00 <oqWriteTimeout+0xf8>
    }

    osalSysLock();
 8008cfa:	f001 f93d 	bl	8009f78 <osalSysLock.lto_priv.194>
 8008cfe:	e7cc      	b.n	8008c9a <oqWriteTimeout+0x92>
  }
}
 8008d00:	4618      	mov	r0, r3
 8008d02:	3720      	adds	r7, #32
 8008d04:	46bd      	mov	sp, r7
 8008d06:	bd80      	pop	{r7, pc}
 8008d08:	0800eb8c 	.word	0x0800eb8c

08008d0c <port_lock.lto_priv.181>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008d0c:	b480      	push	{r7}
 8008d0e:	b083      	sub	sp, #12
 8008d10:	af00      	add	r7, sp, #0
 8008d12:	2320      	movs	r3, #32
 8008d14:	607b      	str	r3, [r7, #4]
 8008d16:	687b      	ldr	r3, [r7, #4]
 8008d18:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008d1c:	370c      	adds	r7, #12
 8008d1e:	46bd      	mov	sp, r7
 8008d20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d24:	4770      	bx	lr
 8008d26:	bf00      	nop

08008d28 <port_unlock.lto_priv.178>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 8008ca4:	b480      	push	{r7}
 8008ca6:	b083      	sub	sp, #12
 8008ca8:	af00      	add	r7, sp, #0
 8008caa:	2300      	movs	r3, #0
 8008cac:	607b      	str	r3, [r7, #4]
 8008cae:	687b      	ldr	r3, [r7, #4]
 8008cb0:	f383 8811 	msr	BASEPRI, r3
=======
 8008d28:	b480      	push	{r7}
 8008d2a:	b083      	sub	sp, #12
 8008d2c:	af00      	add	r7, sp, #0
 8008d2e:	2300      	movs	r3, #0
 8008d30:	607b      	str	r3, [r7, #4]
 8008d32:	687b      	ldr	r3, [r7, #4]
 8008d34:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8008cb4:	370c      	adds	r7, #12
 8008cb6:	46bd      	mov	sp, r7
 8008cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008cbc:	4770      	bx	lr
 8008cbe:	bf00      	nop

08008cc0 <chSysLock>:
=======
 8008d38:	370c      	adds	r7, #12
 8008d3a:	46bd      	mov	sp, r7
 8008d3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d40:	4770      	bx	lr
 8008d42:	bf00      	nop

08008d44 <chSysLock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 8008cc0:	b580      	push	{r7, lr}
 8008cc2:	af00      	add	r7, sp, #0

  port_lock();
 8008cc4:	f7ff ffe0 	bl	8008c88 <port_lock.lto_priv.184>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8008cc8:	f002 f8ba 	bl	800ae40 <_dbg_check_lock>
}
 8008ccc:	bd80      	pop	{r7, pc}
 8008cce:	bf00      	nop

08008cd0 <chSysUnlock>:
=======
 8008d44:	b580      	push	{r7, lr}
 8008d46:	af00      	add	r7, sp, #0

  port_lock();
 8008d48:	f7ff ffe0 	bl	8008d0c <port_lock.lto_priv.181>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8008d4c:	f002 f8bc 	bl	800aec8 <_dbg_check_lock>
}
 8008d50:	bd80      	pop	{r7, pc}
 8008d52:	bf00      	nop

08008d54 <chSysUnlock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 8008cd0:	b580      	push	{r7, lr}
 8008cd2:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8008cd4:	f002 f8ca 	bl	800ae6c <_dbg_check_unlock>
=======
 8008d54:	b580      	push	{r7, lr}
 8008d56:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8008d58:	f002 f8cc 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 8008cd8:	4b09      	ldr	r3, [pc, #36]	; (8008d00 <chSysUnlock+0x30>)
 8008cda:	681b      	ldr	r3, [r3, #0]
 8008cdc:	4a08      	ldr	r2, [pc, #32]	; (8008d00 <chSysUnlock+0x30>)
 8008cde:	4293      	cmp	r3, r2
 8008ce0:	d00a      	beq.n	8008cf8 <chSysUnlock+0x28>
 8008ce2:	4b07      	ldr	r3, [pc, #28]	; (8008d00 <chSysUnlock+0x30>)
 8008ce4:	699b      	ldr	r3, [r3, #24]
 8008ce6:	689a      	ldr	r2, [r3, #8]
 8008ce8:	4b05      	ldr	r3, [pc, #20]	; (8008d00 <chSysUnlock+0x30>)
 8008cea:	681b      	ldr	r3, [r3, #0]
 8008cec:	689b      	ldr	r3, [r3, #8]
 8008cee:	429a      	cmp	r2, r3
 8008cf0:	d202      	bcs.n	8008cf8 <chSysUnlock+0x28>
 8008cf2:	4804      	ldr	r0, [pc, #16]	; (8008d04 <chSysUnlock+0x34>)
 8008cf4:	f002 f856 	bl	800ada4 <chSysHalt>
=======
 8008d5c:	4b09      	ldr	r3, [pc, #36]	; (8008d84 <chSysUnlock+0x30>)
 8008d5e:	681b      	ldr	r3, [r3, #0]
 8008d60:	4a08      	ldr	r2, [pc, #32]	; (8008d84 <chSysUnlock+0x30>)
 8008d62:	4293      	cmp	r3, r2
 8008d64:	d00a      	beq.n	8008d7c <chSysUnlock+0x28>
 8008d66:	4b07      	ldr	r3, [pc, #28]	; (8008d84 <chSysUnlock+0x30>)
 8008d68:	699b      	ldr	r3, [r3, #24]
 8008d6a:	689a      	ldr	r2, [r3, #8]
 8008d6c:	4b05      	ldr	r3, [pc, #20]	; (8008d84 <chSysUnlock+0x30>)
 8008d6e:	681b      	ldr	r3, [r3, #0]
 8008d70:	689b      	ldr	r3, [r3, #8]
 8008d72:	429a      	cmp	r2, r3
 8008d74:	d202      	bcs.n	8008d7c <chSysUnlock+0x28>
 8008d76:	4804      	ldr	r0, [pc, #16]	; (8008d88 <chSysUnlock+0x34>)
 8008d78:	f002 f858 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 8008cf8:	f7ff ffd4 	bl	8008ca4 <port_unlock.lto_priv.181>
}
 8008cfc:	bd80      	pop	{r7, pc}
 8008cfe:	bf00      	nop
 8008d00:	20001338 	.word	0x20001338
 8008d04:	0800eaec 	.word	0x0800eaec

08008d08 <osalSysLock.lto_priv.198>:
=======
 8008d7c:	f7ff ffd4 	bl	8008d28 <port_unlock.lto_priv.178>
}
 8008d80:	bd80      	pop	{r7, pc}
 8008d82:	bf00      	nop
 8008d84:	20001338 	.word	0x20001338
 8008d88:	0800ebc4 	.word	0x0800ebc4

08008d8c <osalSysLock.lto_priv.195>:
>>>>>>> 752c83b... update binaries
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
<<<<<<< HEAD
 8008d08:	b580      	push	{r7, lr}
 8008d0a:	af00      	add	r7, sp, #0

  chSysLock();
 8008d0c:	f7ff ffd8 	bl	8008cc0 <chSysLock>
}
 8008d10:	bd80      	pop	{r7, pc}
 8008d12:	bf00      	nop

08008d14 <osalSysUnlock.lto_priv.196>:
=======
 8008d8c:	b580      	push	{r7, lr}
 8008d8e:	af00      	add	r7, sp, #0

  chSysLock();
 8008d90:	f7ff ffd8 	bl	8008d44 <chSysLock>
}
 8008d94:	bd80      	pop	{r7, pc}
 8008d96:	bf00      	nop

08008d98 <osalSysUnlock.lto_priv.193>:
>>>>>>> 752c83b... update binaries
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
<<<<<<< HEAD
 8008d14:	b580      	push	{r7, lr}
 8008d16:	af00      	add	r7, sp, #0

  chSysUnlock();
 8008d18:	f7ff ffda 	bl	8008cd0 <chSysUnlock>
}
 8008d1c:	bd80      	pop	{r7, pc}
 8008d1e:	bf00      	nop

08008d20 <osalEventObjectInit>:
=======
 8008d98:	b580      	push	{r7, lr}
 8008d9a:	af00      	add	r7, sp, #0

  chSysUnlock();
 8008d9c:	f7ff ffda 	bl	8008d54 <chSysUnlock>
}
 8008da0:	bd80      	pop	{r7, pc}
 8008da2:	bf00      	nop

08008da4 <osalEventObjectInit>:
>>>>>>> 752c83b... update binaries
static inline void osalEventObjectInit(event_source_t *esp) {

  chEvtObjectInit(esp);
}
#else
static inline void osalEventObjectInit(event_source_t *esp) {
<<<<<<< HEAD
 8008d20:	b480      	push	{r7}
 8008d22:	b083      	sub	sp, #12
 8008d24:	af00      	add	r7, sp, #0
 8008d26:	6078      	str	r0, [r7, #4]

  esp->flags = 0;
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	2200      	movs	r2, #0
 8008d2c:	601a      	str	r2, [r3, #0]
}
 8008d2e:	370c      	adds	r7, #12
 8008d30:	46bd      	mov	sp, r7
 8008d32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d36:	4770      	bx	lr

08008d38 <osalEventBroadcastFlagsI.lto_priv.167>:
=======
 8008da4:	b480      	push	{r7}
 8008da6:	b083      	sub	sp, #12
 8008da8:	af00      	add	r7, sp, #0
 8008daa:	6078      	str	r0, [r7, #4]

  esp->flags = 0;
 8008dac:	687b      	ldr	r3, [r7, #4]
 8008dae:	2200      	movs	r2, #0
 8008db0:	601a      	str	r2, [r3, #0]
}
 8008db2:	370c      	adds	r7, #12
 8008db4:	46bd      	mov	sp, r7
 8008db6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008dba:	4770      	bx	lr

08008dbc <osalEventBroadcastFlagsI.lto_priv.164>:
>>>>>>> 752c83b... update binaries

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
<<<<<<< HEAD
 8008d38:	b480      	push	{r7}
 8008d3a:	b083      	sub	sp, #12
 8008d3c:	af00      	add	r7, sp, #0
 8008d3e:	6078      	str	r0, [r7, #4]
 8008d40:	6039      	str	r1, [r7, #0]

  esp->flags |= flags;
 8008d42:	687b      	ldr	r3, [r7, #4]
 8008d44:	681a      	ldr	r2, [r3, #0]
 8008d46:	683b      	ldr	r3, [r7, #0]
 8008d48:	431a      	orrs	r2, r3
 8008d4a:	687b      	ldr	r3, [r7, #4]
 8008d4c:	601a      	str	r2, [r3, #0]
}
 8008d4e:	370c      	adds	r7, #12
 8008d50:	46bd      	mov	sp, r7
 8008d52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d56:	4770      	bx	lr

08008d58 <_write.lto_priv.26>:
=======
 8008dbc:	b480      	push	{r7}
 8008dbe:	b083      	sub	sp, #12
 8008dc0:	af00      	add	r7, sp, #0
 8008dc2:	6078      	str	r0, [r7, #4]
 8008dc4:	6039      	str	r1, [r7, #0]

  esp->flags |= flags;
 8008dc6:	687b      	ldr	r3, [r7, #4]
 8008dc8:	681a      	ldr	r2, [r3, #0]
 8008dca:	683b      	ldr	r3, [r7, #0]
 8008dcc:	431a      	orrs	r2, r3
 8008dce:	687b      	ldr	r3, [r7, #4]
 8008dd0:	601a      	str	r2, [r3, #0]
}
 8008dd2:	370c      	adds	r7, #12
 8008dd4:	46bd      	mov	sp, r7
 8008dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008dda:	4770      	bx	lr

08008ddc <_write.lto_priv.26>:
>>>>>>> 752c83b... update binaries
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
<<<<<<< HEAD
 8008d58:	b580      	push	{r7, lr}
 8008d5a:	b084      	sub	sp, #16
 8008d5c:	af00      	add	r7, sp, #0
 8008d5e:	60f8      	str	r0, [r7, #12]
 8008d60:	60b9      	str	r1, [r7, #8]
 8008d62:	607a      	str	r2, [r7, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8008d64:	68fb      	ldr	r3, [r7, #12]
 8008d66:	3330      	adds	r3, #48	; 0x30
 8008d68:	4618      	mov	r0, r3
 8008d6a:	68b9      	ldr	r1, [r7, #8]
 8008d6c:	687a      	ldr	r2, [r7, #4]
 8008d6e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008d72:	f7ff ff07 	bl	8008b84 <oqWriteTimeout>
 8008d76:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 8008d78:	4618      	mov	r0, r3
 8008d7a:	3710      	adds	r7, #16
 8008d7c:	46bd      	mov	sp, r7
 8008d7e:	bd80      	pop	{r7, pc}

08008d80 <_read.lto_priv.27>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8008d80:	b580      	push	{r7, lr}
 8008d82:	b084      	sub	sp, #16
 8008d84:	af00      	add	r7, sp, #0
 8008d86:	60f8      	str	r0, [r7, #12]
 8008d88:	60b9      	str	r1, [r7, #8]
 8008d8a:	607a      	str	r2, [r7, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8008d8c:	68fb      	ldr	r3, [r7, #12]
 8008d8e:	330c      	adds	r3, #12
 8008d90:	4618      	mov	r0, r3
 8008d92:	68b9      	ldr	r1, [r7, #8]
 8008d94:	687a      	ldr	r2, [r7, #4]
 8008d96:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008d9a:	f001 f987 	bl	800a0ac <iqReadTimeout>
 8008d9e:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 8008da0:	4618      	mov	r0, r3
 8008da2:	3710      	adds	r7, #16
 8008da4:	46bd      	mov	sp, r7
 8008da6:	bd80      	pop	{r7, pc}

08008da8 <_put.lto_priv.5>:

static msg_t _put(void *ip, uint8_t b) {
 8008da8:	b580      	push	{r7, lr}
 8008daa:	b082      	sub	sp, #8
 8008dac:	af00      	add	r7, sp, #0
 8008dae:	6078      	str	r0, [r7, #4]
 8008db0:	460b      	mov	r3, r1
 8008db2:	70fb      	strb	r3, [r7, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8008db4:	687b      	ldr	r3, [r7, #4]
 8008db6:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8008dba:	78fb      	ldrb	r3, [r7, #3]
 8008dbc:	4610      	mov	r0, r2
 8008dbe:	4619      	mov	r1, r3
 8008dc0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008dc4:	f7ff fe60 	bl	8008a88 <oqPutTimeout>
 8008dc8:	4603      	mov	r3, r0
}
 8008dca:	4618      	mov	r0, r3
 8008dcc:	3708      	adds	r7, #8
 8008dce:	46bd      	mov	sp, r7
 8008dd0:	bd80      	pop	{r7, pc}
 8008dd2:	bf00      	nop

08008dd4 <_get.lto_priv.3>:

static msg_t _get(void *ip) {
 8008dd4:	b580      	push	{r7, lr}
 8008dd6:	b082      	sub	sp, #8
 8008dd8:	af00      	add	r7, sp, #0
 8008dda:	6078      	str	r0, [r7, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8008ddc:	687b      	ldr	r3, [r7, #4]
 8008dde:	330c      	adds	r3, #12
 8008de0:	4618      	mov	r0, r3
 8008de2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008de6:	f001 f921 	bl	800a02c <iqGetTimeout>
 8008dea:	4603      	mov	r3, r0
}
 8008dec:	4618      	mov	r0, r3
 8008dee:	3708      	adds	r7, #8
 8008df0:	46bd      	mov	sp, r7
 8008df2:	bd80      	pop	{r7, pc}

08008df4 <_putt.lto_priv.28>:

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8008df4:	b580      	push	{r7, lr}
 8008df6:	b082      	sub	sp, #8
 8008df8:	af00      	add	r7, sp, #0
 8008dfa:	6078      	str	r0, [r7, #4]
 8008dfc:	460b      	mov	r3, r1
 8008dfe:	70fb      	strb	r3, [r7, #3]
 8008e00:	4613      	mov	r3, r2
 8008e02:	803b      	strh	r3, [r7, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8008e04:	687b      	ldr	r3, [r7, #4]
 8008e06:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8008e0a:	78fa      	ldrb	r2, [r7, #3]
 8008e0c:	883b      	ldrh	r3, [r7, #0]
 8008e0e:	4608      	mov	r0, r1
 8008e10:	4611      	mov	r1, r2
 8008e12:	461a      	mov	r2, r3
 8008e14:	f7ff fe38 	bl	8008a88 <oqPutTimeout>
 8008e18:	4603      	mov	r3, r0
}
 8008e1a:	4618      	mov	r0, r3
 8008e1c:	3708      	adds	r7, #8
 8008e1e:	46bd      	mov	sp, r7
 8008e20:	bd80      	pop	{r7, pc}
 8008e22:	bf00      	nop

08008e24 <_gett.lto_priv.29>:

static msg_t _gett(void *ip, systime_t timeout) {
 8008e24:	b580      	push	{r7, lr}
 8008e26:	b082      	sub	sp, #8
 8008e28:	af00      	add	r7, sp, #0
 8008e2a:	6078      	str	r0, [r7, #4]
 8008e2c:	460b      	mov	r3, r1
 8008e2e:	807b      	strh	r3, [r7, #2]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8008e30:	687b      	ldr	r3, [r7, #4]
 8008e32:	f103 020c 	add.w	r2, r3, #12
 8008e36:	887b      	ldrh	r3, [r7, #2]
 8008e38:	4610      	mov	r0, r2
 8008e3a:	4619      	mov	r1, r3
 8008e3c:	f001 f8f6 	bl	800a02c <iqGetTimeout>
 8008e40:	4603      	mov	r3, r0
}
 8008e42:	4618      	mov	r0, r3
 8008e44:	3708      	adds	r7, #8
 8008e46:	46bd      	mov	sp, r7
 8008e48:	bd80      	pop	{r7, pc}
 8008e4a:	bf00      	nop

08008e4c <_writet.lto_priv.30>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8008e4c:	b580      	push	{r7, lr}
 8008e4e:	b084      	sub	sp, #16
 8008e50:	af00      	add	r7, sp, #0
 8008e52:	60f8      	str	r0, [r7, #12]
 8008e54:	60b9      	str	r1, [r7, #8]
 8008e56:	607a      	str	r2, [r7, #4]
 8008e58:	807b      	strh	r3, [r7, #2]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8008e5a:	68fb      	ldr	r3, [r7, #12]
 8008e5c:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8008e60:	887b      	ldrh	r3, [r7, #2]
 8008e62:	4610      	mov	r0, r2
 8008e64:	68b9      	ldr	r1, [r7, #8]
 8008e66:	687a      	ldr	r2, [r7, #4]
 8008e68:	f7ff fe8c 	bl	8008b84 <oqWriteTimeout>
 8008e6c:	4603      	mov	r3, r0
}
 8008e6e:	4618      	mov	r0, r3
 8008e70:	3710      	adds	r7, #16
 8008e72:	46bd      	mov	sp, r7
 8008e74:	bd80      	pop	{r7, pc}
 8008e76:	bf00      	nop

08008e78 <_readt.lto_priv.31>:

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8008e78:	b580      	push	{r7, lr}
 8008e7a:	b084      	sub	sp, #16
 8008e7c:	af00      	add	r7, sp, #0
 8008e7e:	60f8      	str	r0, [r7, #12]
 8008e80:	60b9      	str	r1, [r7, #8]
 8008e82:	607a      	str	r2, [r7, #4]
 8008e84:	807b      	strh	r3, [r7, #2]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8008e86:	68fb      	ldr	r3, [r7, #12]
 8008e88:	f103 020c 	add.w	r2, r3, #12
 8008e8c:	887b      	ldrh	r3, [r7, #2]
 8008e8e:	4610      	mov	r0, r2
 8008e90:	68b9      	ldr	r1, [r7, #8]
 8008e92:	687a      	ldr	r2, [r7, #4]
 8008e94:	f001 f90a 	bl	800a0ac <iqReadTimeout>
 8008e98:	4603      	mov	r3, r0
}
 8008e9a:	4618      	mov	r0, r3
 8008e9c:	3710      	adds	r7, #16
 8008e9e:	46bd      	mov	sp, r7
 8008ea0:	bd80      	pop	{r7, pc}
 8008ea2:	bf00      	nop

08008ea4 <sdInit>:
=======
 8008ddc:	b580      	push	{r7, lr}
 8008dde:	b084      	sub	sp, #16
 8008de0:	af00      	add	r7, sp, #0
 8008de2:	60f8      	str	r0, [r7, #12]
 8008de4:	60b9      	str	r1, [r7, #8]
 8008de6:	607a      	str	r2, [r7, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8008de8:	68fb      	ldr	r3, [r7, #12]
 8008dea:	3330      	adds	r3, #48	; 0x30
 8008dec:	4618      	mov	r0, r3
 8008dee:	68b9      	ldr	r1, [r7, #8]
 8008df0:	687a      	ldr	r2, [r7, #4]
 8008df2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008df6:	f7ff ff07 	bl	8008c08 <oqWriteTimeout>
 8008dfa:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 8008dfc:	4618      	mov	r0, r3
 8008dfe:	3710      	adds	r7, #16
 8008e00:	46bd      	mov	sp, r7
 8008e02:	bd80      	pop	{r7, pc}

08008e04 <_read.lto_priv.27>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8008e04:	b580      	push	{r7, lr}
 8008e06:	b084      	sub	sp, #16
 8008e08:	af00      	add	r7, sp, #0
 8008e0a:	60f8      	str	r0, [r7, #12]
 8008e0c:	60b9      	str	r1, [r7, #8]
 8008e0e:	607a      	str	r2, [r7, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8008e10:	68fb      	ldr	r3, [r7, #12]
 8008e12:	330c      	adds	r3, #12
 8008e14:	4618      	mov	r0, r3
 8008e16:	68b9      	ldr	r1, [r7, #8]
 8008e18:	687a      	ldr	r2, [r7, #4]
 8008e1a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008e1e:	f001 f989 	bl	800a134 <iqReadTimeout>
 8008e22:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 8008e24:	4618      	mov	r0, r3
 8008e26:	3710      	adds	r7, #16
 8008e28:	46bd      	mov	sp, r7
 8008e2a:	bd80      	pop	{r7, pc}

08008e2c <_put.lto_priv.5>:

static msg_t _put(void *ip, uint8_t b) {
 8008e2c:	b580      	push	{r7, lr}
 8008e2e:	b082      	sub	sp, #8
 8008e30:	af00      	add	r7, sp, #0
 8008e32:	6078      	str	r0, [r7, #4]
 8008e34:	460b      	mov	r3, r1
 8008e36:	70fb      	strb	r3, [r7, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8008e38:	687b      	ldr	r3, [r7, #4]
 8008e3a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8008e3e:	78fb      	ldrb	r3, [r7, #3]
 8008e40:	4610      	mov	r0, r2
 8008e42:	4619      	mov	r1, r3
 8008e44:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008e48:	f7ff fe60 	bl	8008b0c <oqPutTimeout>
 8008e4c:	4603      	mov	r3, r0
}
 8008e4e:	4618      	mov	r0, r3
 8008e50:	3708      	adds	r7, #8
 8008e52:	46bd      	mov	sp, r7
 8008e54:	bd80      	pop	{r7, pc}
 8008e56:	bf00      	nop

08008e58 <_get.lto_priv.3>:

static msg_t _get(void *ip) {
 8008e58:	b580      	push	{r7, lr}
 8008e5a:	b082      	sub	sp, #8
 8008e5c:	af00      	add	r7, sp, #0
 8008e5e:	6078      	str	r0, [r7, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8008e60:	687b      	ldr	r3, [r7, #4]
 8008e62:	330c      	adds	r3, #12
 8008e64:	4618      	mov	r0, r3
 8008e66:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008e6a:	f001 f923 	bl	800a0b4 <iqGetTimeout>
 8008e6e:	4603      	mov	r3, r0
}
 8008e70:	4618      	mov	r0, r3
 8008e72:	3708      	adds	r7, #8
 8008e74:	46bd      	mov	sp, r7
 8008e76:	bd80      	pop	{r7, pc}

08008e78 <_putt.lto_priv.28>:

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8008e78:	b580      	push	{r7, lr}
 8008e7a:	b082      	sub	sp, #8
 8008e7c:	af00      	add	r7, sp, #0
 8008e7e:	6078      	str	r0, [r7, #4]
 8008e80:	460b      	mov	r3, r1
 8008e82:	70fb      	strb	r3, [r7, #3]
 8008e84:	4613      	mov	r3, r2
 8008e86:	803b      	strh	r3, [r7, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8008e88:	687b      	ldr	r3, [r7, #4]
 8008e8a:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8008e8e:	78fa      	ldrb	r2, [r7, #3]
 8008e90:	883b      	ldrh	r3, [r7, #0]
 8008e92:	4608      	mov	r0, r1
 8008e94:	4611      	mov	r1, r2
 8008e96:	461a      	mov	r2, r3
 8008e98:	f7ff fe38 	bl	8008b0c <oqPutTimeout>
 8008e9c:	4603      	mov	r3, r0
}
 8008e9e:	4618      	mov	r0, r3
 8008ea0:	3708      	adds	r7, #8
 8008ea2:	46bd      	mov	sp, r7
 8008ea4:	bd80      	pop	{r7, pc}
 8008ea6:	bf00      	nop

08008ea8 <_gett.lto_priv.29>:

static msg_t _gett(void *ip, systime_t timeout) {
 8008ea8:	b580      	push	{r7, lr}
 8008eaa:	b082      	sub	sp, #8
 8008eac:	af00      	add	r7, sp, #0
 8008eae:	6078      	str	r0, [r7, #4]
 8008eb0:	460b      	mov	r3, r1
 8008eb2:	807b      	strh	r3, [r7, #2]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8008eb4:	687b      	ldr	r3, [r7, #4]
 8008eb6:	f103 020c 	add.w	r2, r3, #12
 8008eba:	887b      	ldrh	r3, [r7, #2]
 8008ebc:	4610      	mov	r0, r2
 8008ebe:	4619      	mov	r1, r3
 8008ec0:	f001 f8f8 	bl	800a0b4 <iqGetTimeout>
 8008ec4:	4603      	mov	r3, r0
}
 8008ec6:	4618      	mov	r0, r3
 8008ec8:	3708      	adds	r7, #8
 8008eca:	46bd      	mov	sp, r7
 8008ecc:	bd80      	pop	{r7, pc}
 8008ece:	bf00      	nop

08008ed0 <_writet.lto_priv.30>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8008ed0:	b580      	push	{r7, lr}
 8008ed2:	b084      	sub	sp, #16
 8008ed4:	af00      	add	r7, sp, #0
 8008ed6:	60f8      	str	r0, [r7, #12]
 8008ed8:	60b9      	str	r1, [r7, #8]
 8008eda:	607a      	str	r2, [r7, #4]
 8008edc:	807b      	strh	r3, [r7, #2]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8008ede:	68fb      	ldr	r3, [r7, #12]
 8008ee0:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8008ee4:	887b      	ldrh	r3, [r7, #2]
 8008ee6:	4610      	mov	r0, r2
 8008ee8:	68b9      	ldr	r1, [r7, #8]
 8008eea:	687a      	ldr	r2, [r7, #4]
 8008eec:	f7ff fe8c 	bl	8008c08 <oqWriteTimeout>
 8008ef0:	4603      	mov	r3, r0
}
 8008ef2:	4618      	mov	r0, r3
 8008ef4:	3710      	adds	r7, #16
 8008ef6:	46bd      	mov	sp, r7
 8008ef8:	bd80      	pop	{r7, pc}
 8008efa:	bf00      	nop

08008efc <_readt.lto_priv.31>:

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8008efc:	b580      	push	{r7, lr}
 8008efe:	b084      	sub	sp, #16
 8008f00:	af00      	add	r7, sp, #0
 8008f02:	60f8      	str	r0, [r7, #12]
 8008f04:	60b9      	str	r1, [r7, #8]
 8008f06:	607a      	str	r2, [r7, #4]
 8008f08:	807b      	strh	r3, [r7, #2]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8008f0a:	68fb      	ldr	r3, [r7, #12]
 8008f0c:	f103 020c 	add.w	r2, r3, #12
 8008f10:	887b      	ldrh	r3, [r7, #2]
 8008f12:	4610      	mov	r0, r2
 8008f14:	68b9      	ldr	r1, [r7, #8]
 8008f16:	687a      	ldr	r2, [r7, #4]
 8008f18:	f001 f90c 	bl	800a134 <iqReadTimeout>
 8008f1c:	4603      	mov	r3, r0
}
 8008f1e:	4618      	mov	r0, r3
 8008f20:	3710      	adds	r7, #16
 8008f22:	46bd      	mov	sp, r7
 8008f24:	bd80      	pop	{r7, pc}
 8008f26:	bf00      	nop

08008f28 <sdInit>:
>>>>>>> 752c83b... update binaries
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
<<<<<<< HEAD
 8008ea4:	b580      	push	{r7, lr}
 8008ea6:	af00      	add	r7, sp, #0

  sd_lld_init();
 8008ea8:	f000 fc68 	bl	800977c <sd_lld_init>
}
 8008eac:	bd80      	pop	{r7, pc}
 8008eae:	bf00      	nop

08008eb0 <sdObjectInit>:
=======
 8008f28:	b580      	push	{r7, lr}
 8008f2a:	af00      	add	r7, sp, #0

  sd_lld_init();
 8008f2c:	f000 fc68 	bl	8009800 <sd_lld_init>
}
 8008f30:	bd80      	pop	{r7, pc}
 8008f32:	bf00      	nop

08008f34 <sdObjectInit>:
>>>>>>> 752c83b... update binaries
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
<<<<<<< HEAD
 8008eb0:	b580      	push	{r7, lr}
 8008eb2:	b086      	sub	sp, #24
 8008eb4:	af02      	add	r7, sp, #8
 8008eb6:	60f8      	str	r0, [r7, #12]
 8008eb8:	60b9      	str	r1, [r7, #8]
 8008eba:	607a      	str	r2, [r7, #4]

  sdp->vmt = &vmt;
 8008ebc:	68fb      	ldr	r3, [r7, #12]
 8008ebe:	4a14      	ldr	r2, [pc, #80]	; (8008f10 <sdObjectInit+0x60>)
 8008ec0:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8008ec2:	68fb      	ldr	r3, [r7, #12]
 8008ec4:	3304      	adds	r3, #4
 8008ec6:	4618      	mov	r0, r3
 8008ec8:	f7ff ff2a 	bl	8008d20 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8008ecc:	68fb      	ldr	r3, [r7, #12]
 8008ece:	2201      	movs	r2, #1
 8008ed0:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8008ed2:	68fb      	ldr	r3, [r7, #12]
 8008ed4:	f103 010c 	add.w	r1, r3, #12
 8008ed8:	68fb      	ldr	r3, [r7, #12]
 8008eda:	f103 0254 	add.w	r2, r3, #84	; 0x54
 8008ede:	68fb      	ldr	r3, [r7, #12]
 8008ee0:	9300      	str	r3, [sp, #0]
 8008ee2:	4608      	mov	r0, r1
 8008ee4:	4611      	mov	r1, r2
 8008ee6:	2210      	movs	r2, #16
 8008ee8:	68bb      	ldr	r3, [r7, #8]
 8008eea:	f001 f83b 	bl	8009f64 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8008eee:	68fb      	ldr	r3, [r7, #12]
 8008ef0:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8008ef4:	68fb      	ldr	r3, [r7, #12]
 8008ef6:	f103 0264 	add.w	r2, r3, #100	; 0x64
 8008efa:	68fb      	ldr	r3, [r7, #12]
 8008efc:	9300      	str	r3, [sp, #0]
 8008efe:	4608      	mov	r0, r1
 8008f00:	4611      	mov	r1, r2
 8008f02:	2210      	movs	r2, #16
 8008f04:	687b      	ldr	r3, [r7, #4]
 8008f06:	f001 f953 	bl	800a1b0 <oqObjectInit>
}
 8008f0a:	3710      	adds	r7, #16
 8008f0c:	46bd      	mov	sp, r7
 8008f0e:	bd80      	pop	{r7, pc}
 8008f10:	0800eac4 	.word	0x0800eac4

08008f14 <sdStart>:
=======
 8008f34:	b580      	push	{r7, lr}
 8008f36:	b086      	sub	sp, #24
 8008f38:	af02      	add	r7, sp, #8
 8008f3a:	60f8      	str	r0, [r7, #12]
 8008f3c:	60b9      	str	r1, [r7, #8]
 8008f3e:	607a      	str	r2, [r7, #4]

  sdp->vmt = &vmt;
 8008f40:	68fb      	ldr	r3, [r7, #12]
 8008f42:	4a14      	ldr	r2, [pc, #80]	; (8008f94 <sdObjectInit+0x60>)
 8008f44:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8008f46:	68fb      	ldr	r3, [r7, #12]
 8008f48:	3304      	adds	r3, #4
 8008f4a:	4618      	mov	r0, r3
 8008f4c:	f7ff ff2a 	bl	8008da4 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8008f50:	68fb      	ldr	r3, [r7, #12]
 8008f52:	2201      	movs	r2, #1
 8008f54:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8008f56:	68fb      	ldr	r3, [r7, #12]
 8008f58:	f103 010c 	add.w	r1, r3, #12
 8008f5c:	68fb      	ldr	r3, [r7, #12]
 8008f5e:	f103 0254 	add.w	r2, r3, #84	; 0x54
 8008f62:	68fb      	ldr	r3, [r7, #12]
 8008f64:	9300      	str	r3, [sp, #0]
 8008f66:	4608      	mov	r0, r1
 8008f68:	4611      	mov	r1, r2
 8008f6a:	2210      	movs	r2, #16
 8008f6c:	68bb      	ldr	r3, [r7, #8]
 8008f6e:	f001 f83d 	bl	8009fec <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8008f72:	68fb      	ldr	r3, [r7, #12]
 8008f74:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8008f78:	68fb      	ldr	r3, [r7, #12]
 8008f7a:	f103 0264 	add.w	r2, r3, #100	; 0x64
 8008f7e:	68fb      	ldr	r3, [r7, #12]
 8008f80:	9300      	str	r3, [sp, #0]
 8008f82:	4608      	mov	r0, r1
 8008f84:	4611      	mov	r1, r2
 8008f86:	2210      	movs	r2, #16
 8008f88:	687b      	ldr	r3, [r7, #4]
 8008f8a:	f001 f955 	bl	800a238 <oqObjectInit>
}
 8008f8e:	3710      	adds	r7, #16
 8008f90:	46bd      	mov	sp, r7
 8008f92:	bd80      	pop	{r7, pc}
 8008f94:	0800eb9c 	.word	0x0800eb9c

08008f98 <sdStart>:
>>>>>>> 752c83b... update binaries
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
<<<<<<< HEAD
 8008f14:	b580      	push	{r7, lr}
 8008f16:	b082      	sub	sp, #8
 8008f18:	af00      	add	r7, sp, #0
 8008f1a:	6078      	str	r0, [r7, #4]
 8008f1c:	6039      	str	r1, [r7, #0]

  osalDbgCheck(sdp != NULL);
 8008f1e:	687b      	ldr	r3, [r7, #4]
 8008f20:	2b00      	cmp	r3, #0
 8008f22:	d102      	bne.n	8008f2a <sdStart+0x16>
 8008f24:	480d      	ldr	r0, [pc, #52]	; (8008f5c <sdStart+0x48>)
 8008f26:	f001 ff3d 	bl	800ada4 <chSysHalt>

  osalSysLock();
 8008f2a:	f7ff feed 	bl	8008d08 <osalSysLock.lto_priv.198>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8008f2e:	687b      	ldr	r3, [r7, #4]
 8008f30:	7a1b      	ldrb	r3, [r3, #8]
 8008f32:	2b01      	cmp	r3, #1
 8008f34:	d006      	beq.n	8008f44 <sdStart+0x30>
 8008f36:	687b      	ldr	r3, [r7, #4]
 8008f38:	7a1b      	ldrb	r3, [r3, #8]
 8008f3a:	2b02      	cmp	r3, #2
 8008f3c:	d002      	beq.n	8008f44 <sdStart+0x30>
 8008f3e:	4807      	ldr	r0, [pc, #28]	; (8008f5c <sdStart+0x48>)
 8008f40:	f001 ff30 	bl	800ada4 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
 8008f44:	6878      	ldr	r0, [r7, #4]
 8008f46:	6839      	ldr	r1, [r7, #0]
 8008f48:	f000 fc2a 	bl	80097a0 <sd_lld_start>
  sdp->state = SD_READY;
 8008f4c:	687b      	ldr	r3, [r7, #4]
 8008f4e:	2202      	movs	r2, #2
 8008f50:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8008f52:	f7ff fedf 	bl	8008d14 <osalSysUnlock.lto_priv.196>
}
 8008f56:	3708      	adds	r7, #8
 8008f58:	46bd      	mov	sp, r7
 8008f5a:	bd80      	pop	{r7, pc}
 8008f5c:	0800eae4 	.word	0x0800eae4

08008f60 <sdIncomingDataI>:
=======
 8008f98:	b580      	push	{r7, lr}
 8008f9a:	b082      	sub	sp, #8
 8008f9c:	af00      	add	r7, sp, #0
 8008f9e:	6078      	str	r0, [r7, #4]
 8008fa0:	6039      	str	r1, [r7, #0]

  osalDbgCheck(sdp != NULL);
 8008fa2:	687b      	ldr	r3, [r7, #4]
 8008fa4:	2b00      	cmp	r3, #0
 8008fa6:	d102      	bne.n	8008fae <sdStart+0x16>
 8008fa8:	480d      	ldr	r0, [pc, #52]	; (8008fe0 <sdStart+0x48>)
 8008faa:	f001 ff3f 	bl	800ae2c <chSysHalt>

  osalSysLock();
 8008fae:	f7ff feed 	bl	8008d8c <osalSysLock.lto_priv.195>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8008fb2:	687b      	ldr	r3, [r7, #4]
 8008fb4:	7a1b      	ldrb	r3, [r3, #8]
 8008fb6:	2b01      	cmp	r3, #1
 8008fb8:	d006      	beq.n	8008fc8 <sdStart+0x30>
 8008fba:	687b      	ldr	r3, [r7, #4]
 8008fbc:	7a1b      	ldrb	r3, [r3, #8]
 8008fbe:	2b02      	cmp	r3, #2
 8008fc0:	d002      	beq.n	8008fc8 <sdStart+0x30>
 8008fc2:	4807      	ldr	r0, [pc, #28]	; (8008fe0 <sdStart+0x48>)
 8008fc4:	f001 ff32 	bl	800ae2c <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
 8008fc8:	6878      	ldr	r0, [r7, #4]
 8008fca:	6839      	ldr	r1, [r7, #0]
 8008fcc:	f000 fc2a 	bl	8009824 <sd_lld_start>
  sdp->state = SD_READY;
 8008fd0:	687b      	ldr	r3, [r7, #4]
 8008fd2:	2202      	movs	r2, #2
 8008fd4:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8008fd6:	f7ff fedf 	bl	8008d98 <osalSysUnlock.lto_priv.193>
}
 8008fda:	3708      	adds	r7, #8
 8008fdc:	46bd      	mov	sp, r7
 8008fde:	bd80      	pop	{r7, pc}
 8008fe0:	0800ebbc 	.word	0x0800ebbc

08008fe4 <sdIncomingDataI>:
>>>>>>> 752c83b... update binaries
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
<<<<<<< HEAD
 8008f60:	b580      	push	{r7, lr}
 8008f62:	b082      	sub	sp, #8
 8008f64:	af00      	add	r7, sp, #0
 8008f66:	6078      	str	r0, [r7, #4]
 8008f68:	460b      	mov	r3, r1
 8008f6a:	70fb      	strb	r3, [r7, #3]

  osalDbgCheckClassI();
 8008f6c:	f001 fff8 	bl	800af60 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8008f70:	687b      	ldr	r3, [r7, #4]
 8008f72:	2b00      	cmp	r3, #0
 8008f74:	d102      	bne.n	8008f7c <sdIncomingDataI+0x1c>
 8008f76:	4811      	ldr	r0, [pc, #68]	; (8008fbc <sdIncomingDataI+0x5c>)
 8008f78:	f001 ff14 	bl	800ada4 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 8008f7c:	687b      	ldr	r3, [r7, #4]
 8008f7e:	695b      	ldr	r3, [r3, #20]
 8008f80:	2b00      	cmp	r3, #0
 8008f82:	d105      	bne.n	8008f90 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8008f84:	687b      	ldr	r3, [r7, #4]
 8008f86:	3304      	adds	r3, #4
 8008f88:	4618      	mov	r0, r3
 8008f8a:	2104      	movs	r1, #4
 8008f8c:	f7ff fed4 	bl	8008d38 <osalEventBroadcastFlagsI.lto_priv.167>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8008f90:	687b      	ldr	r3, [r7, #4]
 8008f92:	f103 020c 	add.w	r2, r3, #12
 8008f96:	78fb      	ldrb	r3, [r7, #3]
 8008f98:	4610      	mov	r0, r2
 8008f9a:	4619      	mov	r1, r3
 8008f9c:	f001 f808 	bl	8009fb0 <iqPutI>
 8008fa0:	4603      	mov	r3, r0
 8008fa2:	2b00      	cmp	r3, #0
 8008fa4:	da06      	bge.n	8008fb4 <sdIncomingDataI+0x54>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8008fa6:	687b      	ldr	r3, [r7, #4]
 8008fa8:	3304      	adds	r3, #4
 8008faa:	4618      	mov	r0, r3
 8008fac:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008fb0:	f7ff fec2 	bl	8008d38 <osalEventBroadcastFlagsI.lto_priv.167>
}
 8008fb4:	3708      	adds	r7, #8
 8008fb6:	46bd      	mov	sp, r7
 8008fb8:	bd80      	pop	{r7, pc}
 8008fba:	bf00      	nop
 8008fbc:	0800eaf8 	.word	0x0800eaf8

08008fc0 <st_lld_start_alarm>:
=======
 8008fe4:	b580      	push	{r7, lr}
 8008fe6:	b082      	sub	sp, #8
 8008fe8:	af00      	add	r7, sp, #0
 8008fea:	6078      	str	r0, [r7, #4]
 8008fec:	460b      	mov	r3, r1
 8008fee:	70fb      	strb	r3, [r7, #3]

  osalDbgCheckClassI();
 8008ff0:	f001 fffa 	bl	800afe8 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8008ff4:	687b      	ldr	r3, [r7, #4]
 8008ff6:	2b00      	cmp	r3, #0
 8008ff8:	d102      	bne.n	8009000 <sdIncomingDataI+0x1c>
 8008ffa:	4811      	ldr	r0, [pc, #68]	; (8009040 <sdIncomingDataI+0x5c>)
 8008ffc:	f001 ff16 	bl	800ae2c <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 8009000:	687b      	ldr	r3, [r7, #4]
 8009002:	695b      	ldr	r3, [r3, #20]
 8009004:	2b00      	cmp	r3, #0
 8009006:	d105      	bne.n	8009014 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8009008:	687b      	ldr	r3, [r7, #4]
 800900a:	3304      	adds	r3, #4
 800900c:	4618      	mov	r0, r3
 800900e:	2104      	movs	r1, #4
 8009010:	f7ff fed4 	bl	8008dbc <osalEventBroadcastFlagsI.lto_priv.164>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8009014:	687b      	ldr	r3, [r7, #4]
 8009016:	f103 020c 	add.w	r2, r3, #12
 800901a:	78fb      	ldrb	r3, [r7, #3]
 800901c:	4610      	mov	r0, r2
 800901e:	4619      	mov	r1, r3
 8009020:	f001 f80a 	bl	800a038 <iqPutI>
 8009024:	4603      	mov	r3, r0
 8009026:	2b00      	cmp	r3, #0
 8009028:	da06      	bge.n	8009038 <sdIncomingDataI+0x54>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 800902a:	687b      	ldr	r3, [r7, #4]
 800902c:	3304      	adds	r3, #4
 800902e:	4618      	mov	r0, r3
 8009030:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8009034:	f7ff fec2 	bl	8008dbc <osalEventBroadcastFlagsI.lto_priv.164>
}
 8009038:	3708      	adds	r7, #8
 800903a:	46bd      	mov	sp, r7
 800903c:	bd80      	pop	{r7, pc}
 800903e:	bf00      	nop
 8009040:	0800ebd0 	.word	0x0800ebd0

08009044 <st_lld_start_alarm>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
<<<<<<< HEAD
 8008fc0:	b480      	push	{r7}
 8008fc2:	b083      	sub	sp, #12
 8008fc4:	af00      	add	r7, sp, #0
 8008fc6:	4603      	mov	r3, r0
 8008fc8:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8008fca:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8008fce:	88fb      	ldrh	r3, [r7, #6]
 8008fd0:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8008fd2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008fd6:	2200      	movs	r2, #0
 8008fd8:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8008fda:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008fde:	2202      	movs	r2, #2
 8008fe0:	60da      	str	r2, [r3, #12]
}
 8008fe2:	370c      	adds	r7, #12
 8008fe4:	46bd      	mov	sp, r7
 8008fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008fea:	4770      	bx	lr

08008fec <st_lld_stop_alarm>:
=======
 8009044:	b480      	push	{r7}
 8009046:	b083      	sub	sp, #12
 8009048:	af00      	add	r7, sp, #0
 800904a:	4603      	mov	r3, r0
 800904c:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800904e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8009052:	88fb      	ldrh	r3, [r7, #6]
 8009054:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8009056:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800905a:	2200      	movs	r2, #0
 800905c:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800905e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009062:	2202      	movs	r2, #2
 8009064:	60da      	str	r2, [r3, #12]
}
 8009066:	370c      	adds	r7, #12
 8009068:	46bd      	mov	sp, r7
 800906a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800906e:	4770      	bx	lr

08009070 <st_lld_stop_alarm>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {
<<<<<<< HEAD
 8008fec:	b480      	push	{r7}
 8008fee:	af00      	add	r7, sp, #0

  STM32_ST_TIM->DIER = 0;
 8008ff0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008ff4:	2200      	movs	r2, #0
 8008ff6:	60da      	str	r2, [r3, #12]
}
 8008ff8:	46bd      	mov	sp, r7
 8008ffa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ffe:	4770      	bx	lr

08009000 <st_lld_set_alarm>:
=======
 8009070:	b480      	push	{r7}
 8009072:	af00      	add	r7, sp, #0

  STM32_ST_TIM->DIER = 0;
 8009074:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009078:	2200      	movs	r2, #0
 800907a:	60da      	str	r2, [r3, #12]
}
 800907c:	46bd      	mov	sp, r7
 800907e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009082:	4770      	bx	lr

08009084 <st_lld_set_alarm>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
<<<<<<< HEAD
 8009000:	b480      	push	{r7}
 8009002:	b083      	sub	sp, #12
 8009004:	af00      	add	r7, sp, #0
 8009006:	4603      	mov	r3, r0
 8009008:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800900a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800900e:	88fb      	ldrh	r3, [r7, #6]
 8009010:	6353      	str	r3, [r2, #52]	; 0x34
}
 8009012:	370c      	adds	r7, #12
 8009014:	46bd      	mov	sp, r7
 8009016:	f85d 7b04 	ldr.w	r7, [sp], #4
 800901a:	4770      	bx	lr

0800901c <st_lld_is_alarm_active>:
=======
 8009084:	b480      	push	{r7}
 8009086:	b083      	sub	sp, #12
 8009088:	af00      	add	r7, sp, #0
 800908a:	4603      	mov	r3, r0
 800908c:	80fb      	strh	r3, [r7, #6]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800908e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8009092:	88fb      	ldrh	r3, [r7, #6]
 8009094:	6353      	str	r3, [r2, #52]	; 0x34
}
 8009096:	370c      	adds	r7, #12
 8009098:	46bd      	mov	sp, r7
 800909a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800909e:	4770      	bx	lr

080090a0 <st_lld_is_alarm_active>:
>>>>>>> 752c83b... update binaries
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {
<<<<<<< HEAD
 800901c:	b480      	push	{r7}
 800901e:	af00      	add	r7, sp, #0

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8009020:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009024:	68db      	ldr	r3, [r3, #12]
 8009026:	f003 0302 	and.w	r3, r3, #2
 800902a:	2b00      	cmp	r3, #0
 800902c:	bf14      	ite	ne
 800902e:	2301      	movne	r3, #1
 8009030:	2300      	moveq	r3, #0
 8009032:	b2db      	uxtb	r3, r3
}
 8009034:	4618      	mov	r0, r3
 8009036:	46bd      	mov	sp, r7
 8009038:	f85d 7b04 	ldr.w	r7, [sp], #4
 800903c:	4770      	bx	lr
 800903e:	bf00      	nop

08009040 <stInit>:
=======
 80090a0:	b480      	push	{r7}
 80090a2:	af00      	add	r7, sp, #0

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80090a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80090a8:	68db      	ldr	r3, [r3, #12]
 80090aa:	f003 0302 	and.w	r3, r3, #2
 80090ae:	2b00      	cmp	r3, #0
 80090b0:	bf14      	ite	ne
 80090b2:	2301      	movne	r3, #1
 80090b4:	2300      	moveq	r3, #0
 80090b6:	b2db      	uxtb	r3, r3
}
 80090b8:	4618      	mov	r0, r3
 80090ba:	46bd      	mov	sp, r7
 80090bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090c0:	4770      	bx	lr
 80090c2:	bf00      	nop

080090c4 <stInit>:
>>>>>>> 752c83b... update binaries
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
<<<<<<< HEAD
 8009040:	b580      	push	{r7, lr}
 8009042:	af00      	add	r7, sp, #0

  st_lld_init();
 8009044:	f000 f9c0 	bl	80093c8 <st_lld_init>
}
 8009048:	bd80      	pop	{r7, pc}
 800904a:	bf00      	nop

0800904c <stStartAlarm>:
=======
 80090c4:	b580      	push	{r7, lr}
 80090c6:	af00      	add	r7, sp, #0

  st_lld_init();
 80090c8:	f000 f9c0 	bl	800944c <st_lld_init>
}
 80090cc:	bd80      	pop	{r7, pc}
 80090ce:	bf00      	nop

080090d0 <stStartAlarm>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
<<<<<<< HEAD
 800904c:	b580      	push	{r7, lr}
 800904e:	b082      	sub	sp, #8
 8009050:	af00      	add	r7, sp, #0
 8009052:	4603      	mov	r3, r0
 8009054:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8009056:	f7ff ffe1 	bl	800901c <st_lld_is_alarm_active>
 800905a:	4603      	mov	r3, r0
 800905c:	2b00      	cmp	r3, #0
 800905e:	d002      	beq.n	8009066 <stStartAlarm+0x1a>
 8009060:	4804      	ldr	r0, [pc, #16]	; (8009074 <stStartAlarm+0x28>)
 8009062:	f001 fe9f 	bl	800ada4 <chSysHalt>

  st_lld_start_alarm(abstime);
 8009066:	88fb      	ldrh	r3, [r7, #6]
 8009068:	4618      	mov	r0, r3
 800906a:	f7ff ffa9 	bl	8008fc0 <st_lld_start_alarm>
}
 800906e:	3708      	adds	r7, #8
 8009070:	46bd      	mov	sp, r7
 8009072:	bd80      	pop	{r7, pc}
 8009074:	0800eb08 	.word	0x0800eb08

08009078 <stStopAlarm>:
=======
 80090d0:	b580      	push	{r7, lr}
 80090d2:	b082      	sub	sp, #8
 80090d4:	af00      	add	r7, sp, #0
 80090d6:	4603      	mov	r3, r0
 80090d8:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80090da:	f7ff ffe1 	bl	80090a0 <st_lld_is_alarm_active>
 80090de:	4603      	mov	r3, r0
 80090e0:	2b00      	cmp	r3, #0
 80090e2:	d002      	beq.n	80090ea <stStartAlarm+0x1a>
 80090e4:	4804      	ldr	r0, [pc, #16]	; (80090f8 <stStartAlarm+0x28>)
 80090e6:	f001 fea1 	bl	800ae2c <chSysHalt>

  st_lld_start_alarm(abstime);
 80090ea:	88fb      	ldrh	r3, [r7, #6]
 80090ec:	4618      	mov	r0, r3
 80090ee:	f7ff ffa9 	bl	8009044 <st_lld_start_alarm>
}
 80090f2:	3708      	adds	r7, #8
 80090f4:	46bd      	mov	sp, r7
 80090f6:	bd80      	pop	{r7, pc}
 80090f8:	0800ebe0 	.word	0x0800ebe0

080090fc <stStopAlarm>:
>>>>>>> 752c83b... update binaries
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
<<<<<<< HEAD
 8009078:	b580      	push	{r7, lr}
 800907a:	af00      	add	r7, sp, #0

  st_lld_stop_alarm();
 800907c:	f7ff ffb6 	bl	8008fec <st_lld_stop_alarm>
}
 8009080:	bd80      	pop	{r7, pc}
 8009082:	bf00      	nop

08009084 <stSetAlarm>:
=======
 80090fc:	b580      	push	{r7, lr}
 80090fe:	af00      	add	r7, sp, #0

  st_lld_stop_alarm();
 8009100:	f7ff ffb6 	bl	8009070 <st_lld_stop_alarm>
}
 8009104:	bd80      	pop	{r7, pc}
 8009106:	bf00      	nop

08009108 <stSetAlarm>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
<<<<<<< HEAD
 8009084:	b580      	push	{r7, lr}
 8009086:	b082      	sub	sp, #8
 8009088:	af00      	add	r7, sp, #0
 800908a:	4603      	mov	r3, r0
 800908c:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800908e:	f7ff ffc5 	bl	800901c <st_lld_is_alarm_active>
 8009092:	4603      	mov	r3, r0
 8009094:	f083 0301 	eor.w	r3, r3, #1
 8009098:	b2db      	uxtb	r3, r3
 800909a:	2b00      	cmp	r3, #0
 800909c:	d002      	beq.n	80090a4 <stSetAlarm+0x20>
 800909e:	4805      	ldr	r0, [pc, #20]	; (80090b4 <stSetAlarm+0x30>)
 80090a0:	f001 fe80 	bl	800ada4 <chSysHalt>

  st_lld_set_alarm(abstime);
 80090a4:	88fb      	ldrh	r3, [r7, #6]
 80090a6:	4618      	mov	r0, r3
 80090a8:	f7ff ffaa 	bl	8009000 <st_lld_set_alarm>
}
 80090ac:	3708      	adds	r7, #8
 80090ae:	46bd      	mov	sp, r7
 80090b0:	bd80      	pop	{r7, pc}
 80090b2:	bf00      	nop
 80090b4:	0800eb18 	.word	0x0800eb18

080090b8 <nvicEnableVector>:
=======
 8009108:	b580      	push	{r7, lr}
 800910a:	b082      	sub	sp, #8
 800910c:	af00      	add	r7, sp, #0
 800910e:	4603      	mov	r3, r0
 8009110:	80fb      	strh	r3, [r7, #6]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8009112:	f7ff ffc5 	bl	80090a0 <st_lld_is_alarm_active>
 8009116:	4603      	mov	r3, r0
 8009118:	f083 0301 	eor.w	r3, r3, #1
 800911c:	b2db      	uxtb	r3, r3
 800911e:	2b00      	cmp	r3, #0
 8009120:	d002      	beq.n	8009128 <stSetAlarm+0x20>
 8009122:	4805      	ldr	r0, [pc, #20]	; (8009138 <stSetAlarm+0x30>)
 8009124:	f001 fe82 	bl	800ae2c <chSysHalt>

  st_lld_set_alarm(abstime);
 8009128:	88fb      	ldrh	r3, [r7, #6]
 800912a:	4618      	mov	r0, r3
 800912c:	f7ff ffaa 	bl	8009084 <st_lld_set_alarm>
}
 8009130:	3708      	adds	r7, #8
 8009132:	46bd      	mov	sp, r7
 8009134:	bd80      	pop	{r7, pc}
 8009136:	bf00      	nop
 8009138:	0800ebf0 	.word	0x0800ebf0

0800913c <nvicEnableVector>:
>>>>>>> 752c83b... update binaries
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
<<<<<<< HEAD
 80090b8:	b480      	push	{r7}
 80090ba:	b083      	sub	sp, #12
 80090bc:	af00      	add	r7, sp, #0
 80090be:	6078      	str	r0, [r7, #4]
 80090c0:	6039      	str	r1, [r7, #0]
=======
 800913c:	b480      	push	{r7}
 800913e:	b083      	sub	sp, #12
 8009140:	af00      	add	r7, sp, #0
 8009142:	6078      	str	r0, [r7, #4]
 8009144:	6039      	str	r1, [r7, #0]
>>>>>>> 752c83b... update binaries

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
<<<<<<< HEAD
 80090c2:	4a13      	ldr	r2, [pc, #76]	; (8009110 <nvicEnableVector+0x58>)
 80090c4:	683b      	ldr	r3, [r7, #0]
 80090c6:	b2db      	uxtb	r3, r3
 80090c8:	011b      	lsls	r3, r3, #4
 80090ca:	b2d9      	uxtb	r1, r3
 80090cc:	687b      	ldr	r3, [r7, #4]
 80090ce:	4413      	add	r3, r2
 80090d0:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80090d4:	460a      	mov	r2, r1
 80090d6:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80090d8:	490d      	ldr	r1, [pc, #52]	; (8009110 <nvicEnableVector+0x58>)
 80090da:	687b      	ldr	r3, [r7, #4]
 80090dc:	095b      	lsrs	r3, r3, #5
 80090de:	687a      	ldr	r2, [r7, #4]
 80090e0:	f002 021f 	and.w	r2, r2, #31
 80090e4:	2001      	movs	r0, #1
 80090e6:	fa00 f202 	lsl.w	r2, r0, r2
 80090ea:	3360      	adds	r3, #96	; 0x60
 80090ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80090f0:	4907      	ldr	r1, [pc, #28]	; (8009110 <nvicEnableVector+0x58>)
 80090f2:	687b      	ldr	r3, [r7, #4]
 80090f4:	095b      	lsrs	r3, r3, #5
 80090f6:	687a      	ldr	r2, [r7, #4]
 80090f8:	f002 021f 	and.w	r2, r2, #31
 80090fc:	2001      	movs	r0, #1
 80090fe:	fa00 f202 	lsl.w	r2, r0, r2
 8009102:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8009106:	370c      	adds	r7, #12
 8009108:	46bd      	mov	sp, r7
 800910a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800910e:	4770      	bx	lr
 8009110:	e000e100 	.word	0xe000e100

08009114 <nvicDisableVector>:
=======
 8009146:	4a13      	ldr	r2, [pc, #76]	; (8009194 <nvicEnableVector+0x58>)
 8009148:	683b      	ldr	r3, [r7, #0]
 800914a:	b2db      	uxtb	r3, r3
 800914c:	011b      	lsls	r3, r3, #4
 800914e:	b2d9      	uxtb	r1, r3
 8009150:	687b      	ldr	r3, [r7, #4]
 8009152:	4413      	add	r3, r2
 8009154:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8009158:	460a      	mov	r2, r1
 800915a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800915c:	490d      	ldr	r1, [pc, #52]	; (8009194 <nvicEnableVector+0x58>)
 800915e:	687b      	ldr	r3, [r7, #4]
 8009160:	095b      	lsrs	r3, r3, #5
 8009162:	687a      	ldr	r2, [r7, #4]
 8009164:	f002 021f 	and.w	r2, r2, #31
 8009168:	2001      	movs	r0, #1
 800916a:	fa00 f202 	lsl.w	r2, r0, r2
 800916e:	3360      	adds	r3, #96	; 0x60
 8009170:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8009174:	4907      	ldr	r1, [pc, #28]	; (8009194 <nvicEnableVector+0x58>)
 8009176:	687b      	ldr	r3, [r7, #4]
 8009178:	095b      	lsrs	r3, r3, #5
 800917a:	687a      	ldr	r2, [r7, #4]
 800917c:	f002 021f 	and.w	r2, r2, #31
 8009180:	2001      	movs	r0, #1
 8009182:	fa00 f202 	lsl.w	r2, r0, r2
 8009186:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800918a:	370c      	adds	r7, #12
 800918c:	46bd      	mov	sp, r7
 800918e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009192:	4770      	bx	lr
 8009194:	e000e100 	.word	0xe000e100

08009198 <nvicDisableVector>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
<<<<<<< HEAD
 8009114:	b480      	push	{r7}
 8009116:	b083      	sub	sp, #12
 8009118:	af00      	add	r7, sp, #0
 800911a:	6078      	str	r0, [r7, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800911c:	490b      	ldr	r1, [pc, #44]	; (800914c <nvicDisableVector+0x38>)
 800911e:	687b      	ldr	r3, [r7, #4]
 8009120:	095b      	lsrs	r3, r3, #5
 8009122:	687a      	ldr	r2, [r7, #4]
 8009124:	f002 021f 	and.w	r2, r2, #31
 8009128:	2001      	movs	r0, #1
 800912a:	fa00 f202 	lsl.w	r2, r0, r2
 800912e:	3320      	adds	r3, #32
 8009130:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
=======
 8009198:	b480      	push	{r7}
 800919a:	b083      	sub	sp, #12
 800919c:	af00      	add	r7, sp, #0
 800919e:	6078      	str	r0, [r7, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80091a0:	490b      	ldr	r1, [pc, #44]	; (80091d0 <nvicDisableVector+0x38>)
 80091a2:	687b      	ldr	r3, [r7, #4]
 80091a4:	095b      	lsrs	r3, r3, #5
 80091a6:	687a      	ldr	r2, [r7, #4]
 80091a8:	f002 021f 	and.w	r2, r2, #31
 80091ac:	2001      	movs	r0, #1
 80091ae:	fa00 f202 	lsl.w	r2, r0, r2
 80091b2:	3320      	adds	r3, #32
 80091b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
>>>>>>> 752c83b... update binaries
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
<<<<<<< HEAD
 8009134:	4a05      	ldr	r2, [pc, #20]	; (800914c <nvicDisableVector+0x38>)
 8009136:	687b      	ldr	r3, [r7, #4]
 8009138:	4413      	add	r3, r2
 800913a:	f503 7340 	add.w	r3, r3, #768	; 0x300
 800913e:	2200      	movs	r2, #0
 8009140:	701a      	strb	r2, [r3, #0]
#endif
}
 8009142:	370c      	adds	r7, #12
 8009144:	46bd      	mov	sp, r7
 8009146:	f85d 7b04 	ldr.w	r7, [sp], #4
 800914a:	4770      	bx	lr
 800914c:	e000e100 	.word	0xe000e100

08009150 <hal_lld_backup_domain_init>:
=======
 80091b8:	4a05      	ldr	r2, [pc, #20]	; (80091d0 <nvicDisableVector+0x38>)
 80091ba:	687b      	ldr	r3, [r7, #4]
 80091bc:	4413      	add	r3, r2
 80091be:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80091c2:	2200      	movs	r2, #0
 80091c4:	701a      	strb	r2, [r3, #0]
#endif
}
 80091c6:	370c      	adds	r7, #12
 80091c8:	46bd      	mov	sp, r7
 80091ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091ce:	4770      	bx	lr
 80091d0:	e000e100 	.word	0xe000e100

080091d4 <hal_lld_backup_domain_init>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Initializes the backup domain.
 * @note    WARNING! Changing clock source impossible without resetting
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {
<<<<<<< HEAD
 8009150:	b480      	push	{r7}
 8009152:	af00      	add	r7, sp, #0

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8009154:	4a04      	ldr	r2, [pc, #16]	; (8009168 <hal_lld_backup_domain_init+0x18>)
 8009156:	4b04      	ldr	r3, [pc, #16]	; (8009168 <hal_lld_backup_domain_init+0x18>)
 8009158:	681b      	ldr	r3, [r3, #0]
 800915a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800915e:	6013      	str	r3, [r2, #0]
=======
 80091d4:	b480      	push	{r7}
 80091d6:	af00      	add	r7, sp, #0

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80091d8:	4a04      	ldr	r2, [pc, #16]	; (80091ec <hal_lld_backup_domain_init+0x18>)
 80091da:	4b04      	ldr	r3, [pc, #16]	; (80091ec <hal_lld_backup_domain_init+0x18>)
 80091dc:	681b      	ldr	r3, [r3, #0]
 80091de:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80091e2:	6013      	str	r3, [r2, #0]
>>>>>>> 752c83b... update binaries
    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
#endif /* HAL_USE_RTC */
}
<<<<<<< HEAD
 8009160:	46bd      	mov	sp, r7
 8009162:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009166:	4770      	bx	lr
 8009168:	40007000 	.word	0x40007000

0800916c <hal_lld_init>:
=======
 80091e4:	46bd      	mov	sp, r7
 80091e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091ea:	4770      	bx	lr
 80091ec:	40007000 	.word	0x40007000

080091f0 <hal_lld_init>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
<<<<<<< HEAD
 800916c:	b580      	push	{r7, lr}
 800916e:	af00      	add	r7, sp, #0

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8009170:	4b10      	ldr	r3, [pc, #64]	; (80091b4 <hal_lld_init+0x48>)
 8009172:	691b      	ldr	r3, [r3, #16]
 8009174:	4b0f      	ldr	r3, [pc, #60]	; (80091b4 <hal_lld_init+0x48>)
 8009176:	f04f 32ff 	mov.w	r2, #4294967295
 800917a:	611a      	str	r2, [r3, #16]
 800917c:	4b0d      	ldr	r3, [pc, #52]	; (80091b4 <hal_lld_init+0x48>)
 800917e:	2200      	movs	r2, #0
 8009180:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8009182:	4b0c      	ldr	r3, [pc, #48]	; (80091b4 <hal_lld_init+0x48>)
 8009184:	68db      	ldr	r3, [r3, #12]
 8009186:	4b0b      	ldr	r3, [pc, #44]	; (80091b4 <hal_lld_init+0x48>)
 8009188:	f04f 32ff 	mov.w	r2, #4294967295
 800918c:	60da      	str	r2, [r3, #12]
 800918e:	4b09      	ldr	r3, [pc, #36]	; (80091b4 <hal_lld_init+0x48>)
 8009190:	2200      	movs	r2, #0
 8009192:	60da      	str	r2, [r3, #12]
=======
 80091f0:	b580      	push	{r7, lr}
 80091f2:	af00      	add	r7, sp, #0

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 80091f4:	4b10      	ldr	r3, [pc, #64]	; (8009238 <hal_lld_init+0x48>)
 80091f6:	691b      	ldr	r3, [r3, #16]
 80091f8:	4b0f      	ldr	r3, [pc, #60]	; (8009238 <hal_lld_init+0x48>)
 80091fa:	f04f 32ff 	mov.w	r2, #4294967295
 80091fe:	611a      	str	r2, [r3, #16]
 8009200:	4b0d      	ldr	r3, [pc, #52]	; (8009238 <hal_lld_init+0x48>)
 8009202:	2200      	movs	r2, #0
 8009204:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8009206:	4b0c      	ldr	r3, [pc, #48]	; (8009238 <hal_lld_init+0x48>)
 8009208:	68db      	ldr	r3, [r3, #12]
 800920a:	4b0b      	ldr	r3, [pc, #44]	; (8009238 <hal_lld_init+0x48>)
 800920c:	f04f 32ff 	mov.w	r2, #4294967295
 8009210:	60da      	str	r2, [r3, #12]
 8009212:	4b09      	ldr	r3, [pc, #36]	; (8009238 <hal_lld_init+0x48>)
 8009214:	2200      	movs	r2, #0
 8009216:	60da      	str	r2, [r3, #12]
>>>>>>> 752c83b... update binaries

  /* PWR and BD clocks enabled.*/
  /*** these were false in framework ***/
  rccEnablePWRInterface(TRUE);
<<<<<<< HEAD
 8009194:	4a07      	ldr	r2, [pc, #28]	; (80091b4 <hal_lld_init+0x48>)
 8009196:	4b07      	ldr	r3, [pc, #28]	; (80091b4 <hal_lld_init+0x48>)
 8009198:	69db      	ldr	r3, [r3, #28]
 800919a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800919e:	61d3      	str	r3, [r2, #28]
  rccEnableBKPInterface(TRUE);
 80091a0:	4a04      	ldr	r2, [pc, #16]	; (80091b4 <hal_lld_init+0x48>)
 80091a2:	4b04      	ldr	r3, [pc, #16]	; (80091b4 <hal_lld_init+0x48>)
 80091a4:	69db      	ldr	r3, [r3, #28]
 80091a6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80091aa:	61d3      	str	r3, [r2, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80091ac:	f7ff ffd0 	bl	8009150 <hal_lld_backup_domain_init>
=======
 8009218:	4a07      	ldr	r2, [pc, #28]	; (8009238 <hal_lld_init+0x48>)
 800921a:	4b07      	ldr	r3, [pc, #28]	; (8009238 <hal_lld_init+0x48>)
 800921c:	69db      	ldr	r3, [r3, #28]
 800921e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009222:	61d3      	str	r3, [r2, #28]
  rccEnableBKPInterface(TRUE);
 8009224:	4a04      	ldr	r2, [pc, #16]	; (8009238 <hal_lld_init+0x48>)
 8009226:	4b04      	ldr	r3, [pc, #16]	; (8009238 <hal_lld_init+0x48>)
 8009228:	69db      	ldr	r3, [r3, #28]
 800922a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800922e:	61d3      	str	r3, [r2, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8009230:	f7ff ffd0 	bl	80091d4 <hal_lld_backup_domain_init>
>>>>>>> 752c83b... update binaries

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
<<<<<<< HEAD
 80091b0:	bd80      	pop	{r7, pc}
 80091b2:	bf00      	nop
 80091b4:	40021000 	.word	0x40021000

080091b8 <stm32_clock_init>:
=======
 8009234:	bd80      	pop	{r7, pc}
 8009236:	bf00      	nop
 8009238:	40021000 	.word	0x40021000

0800923c <stm32_clock_init>:
>>>>>>> 752c83b... update binaries
    defined(STM32F10X_HD) || defined(STM32F10X_XL) ||                       \
    defined(__DOXYGEN__)
/*
 * Clocks initialization for all sub-families except CL.
 */
void stm32_clock_init(void) {
<<<<<<< HEAD
 80091b8:	b480      	push	{r7}
 80091ba:	af00      	add	r7, sp, #0
=======
 800923c:	b480      	push	{r7}
 800923e:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
<<<<<<< HEAD
 80091bc:	4a27      	ldr	r2, [pc, #156]	; (800925c <stm32_clock_init+0xa4>)
 80091be:	4b27      	ldr	r3, [pc, #156]	; (800925c <stm32_clock_init+0xa4>)
 80091c0:	681b      	ldr	r3, [r3, #0]
 80091c2:	f043 0301 	orr.w	r3, r3, #1
 80091c6:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80091c8:	4b24      	ldr	r3, [pc, #144]	; (800925c <stm32_clock_init+0xa4>)
 80091ca:	681b      	ldr	r3, [r3, #0]
 80091cc:	f003 0302 	and.w	r3, r3, #2
 80091d0:	2b00      	cmp	r3, #0
 80091d2:	d0f9      	beq.n	80091c8 <stm32_clock_init+0x10>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80091d4:	4a21      	ldr	r2, [pc, #132]	; (800925c <stm32_clock_init+0xa4>)
 80091d6:	4b21      	ldr	r3, [pc, #132]	; (800925c <stm32_clock_init+0xa4>)
 80091d8:	681b      	ldr	r3, [r3, #0]
 80091da:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 80091de:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80091e0:	4b1e      	ldr	r3, [pc, #120]	; (800925c <stm32_clock_init+0xa4>)
 80091e2:	2200      	movs	r2, #0
 80091e4:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80091e6:	4b1d      	ldr	r3, [pc, #116]	; (800925c <stm32_clock_init+0xa4>)
 80091e8:	685b      	ldr	r3, [r3, #4]
 80091ea:	f003 030c 	and.w	r3, r3, #12
 80091ee:	2b00      	cmp	r3, #0
 80091f0:	d1f9      	bne.n	80091e6 <stm32_clock_init+0x2e>
=======
 8009240:	4a27      	ldr	r2, [pc, #156]	; (80092e0 <stm32_clock_init+0xa4>)
 8009242:	4b27      	ldr	r3, [pc, #156]	; (80092e0 <stm32_clock_init+0xa4>)
 8009244:	681b      	ldr	r3, [r3, #0]
 8009246:	f043 0301 	orr.w	r3, r3, #1
 800924a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800924c:	4b24      	ldr	r3, [pc, #144]	; (80092e0 <stm32_clock_init+0xa4>)
 800924e:	681b      	ldr	r3, [r3, #0]
 8009250:	f003 0302 	and.w	r3, r3, #2
 8009254:	2b00      	cmp	r3, #0
 8009256:	d0f9      	beq.n	800924c <stm32_clock_init+0x10>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8009258:	4a21      	ldr	r2, [pc, #132]	; (80092e0 <stm32_clock_init+0xa4>)
 800925a:	4b21      	ldr	r3, [pc, #132]	; (80092e0 <stm32_clock_init+0xa4>)
 800925c:	681b      	ldr	r3, [r3, #0]
 800925e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8009262:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8009264:	4b1e      	ldr	r3, [pc, #120]	; (80092e0 <stm32_clock_init+0xa4>)
 8009266:	2200      	movs	r2, #0
 8009268:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800926a:	4b1d      	ldr	r3, [pc, #116]	; (80092e0 <stm32_clock_init+0xa4>)
 800926c:	685b      	ldr	r3, [r3, #4]
 800926e:	f003 030c 	and.w	r3, r3, #12
 8009272:	2b00      	cmp	r3, #0
 8009274:	d1f9      	bne.n	800926a <stm32_clock_init+0x2e>
>>>>>>> 752c83b... update binaries
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
<<<<<<< HEAD
 80091f2:	4a1a      	ldr	r2, [pc, #104]	; (800925c <stm32_clock_init+0xa4>)
 80091f4:	4b19      	ldr	r3, [pc, #100]	; (800925c <stm32_clock_init+0xa4>)
 80091f6:	681b      	ldr	r3, [r3, #0]
 80091f8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80091fc:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80091fe:	4b17      	ldr	r3, [pc, #92]	; (800925c <stm32_clock_init+0xa4>)
 8009200:	681b      	ldr	r3, [r3, #0]
 8009202:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009206:	2b00      	cmp	r3, #0
 8009208:	d0f9      	beq.n	80091fe <stm32_clock_init+0x46>
=======
 8009276:	4a1a      	ldr	r2, [pc, #104]	; (80092e0 <stm32_clock_init+0xa4>)
 8009278:	4b19      	ldr	r3, [pc, #100]	; (80092e0 <stm32_clock_init+0xa4>)
 800927a:	681b      	ldr	r3, [r3, #0]
 800927c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009280:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8009282:	4b17      	ldr	r3, [pc, #92]	; (80092e0 <stm32_clock_init+0xa4>)
 8009284:	681b      	ldr	r3, [r3, #0]
 8009286:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800928a:	2b00      	cmp	r3, #0
 800928c:	d0f9      	beq.n	8009282 <stm32_clock_init+0x46>
>>>>>>> 752c83b... update binaries
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
<<<<<<< HEAD
 800920a:	4a14      	ldr	r2, [pc, #80]	; (800925c <stm32_clock_init+0xa4>)
 800920c:	4b13      	ldr	r3, [pc, #76]	; (800925c <stm32_clock_init+0xa4>)
 800920e:	685b      	ldr	r3, [r3, #4]
 8009210:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 8009214:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 8009216:	4a11      	ldr	r2, [pc, #68]	; (800925c <stm32_clock_init+0xa4>)
 8009218:	4b10      	ldr	r3, [pc, #64]	; (800925c <stm32_clock_init+0xa4>)
 800921a:	681b      	ldr	r3, [r3, #0]
 800921c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8009220:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8009222:	4b0e      	ldr	r3, [pc, #56]	; (800925c <stm32_clock_init+0xa4>)
 8009224:	681b      	ldr	r3, [r3, #0]
 8009226:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800922a:	2b00      	cmp	r3, #0
 800922c:	d0f9      	beq.n	8009222 <stm32_clock_init+0x6a>
=======
 800928e:	4a14      	ldr	r2, [pc, #80]	; (80092e0 <stm32_clock_init+0xa4>)
 8009290:	4b13      	ldr	r3, [pc, #76]	; (80092e0 <stm32_clock_init+0xa4>)
 8009292:	685b      	ldr	r3, [r3, #4]
 8009294:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 8009298:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 800929a:	4a11      	ldr	r2, [pc, #68]	; (80092e0 <stm32_clock_init+0xa4>)
 800929c:	4b10      	ldr	r3, [pc, #64]	; (80092e0 <stm32_clock_init+0xa4>)
 800929e:	681b      	ldr	r3, [r3, #0]
 80092a0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80092a4:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80092a6:	4b0e      	ldr	r3, [pc, #56]	; (80092e0 <stm32_clock_init+0xa4>)
 80092a8:	681b      	ldr	r3, [r3, #0]
 80092aa:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80092ae:	2b00      	cmp	r3, #0
 80092b0:	d0f9      	beq.n	80092a6 <stm32_clock_init+0x6a>
>>>>>>> 752c83b... update binaries
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
<<<<<<< HEAD
 800922e:	4b0b      	ldr	r3, [pc, #44]	; (800925c <stm32_clock_init+0xa4>)
 8009230:	4a0b      	ldr	r2, [pc, #44]	; (8009260 <stm32_clock_init+0xa8>)
 8009232:	605a      	str	r2, [r3, #4]
=======
 80092b2:	4b0b      	ldr	r3, [pc, #44]	; (80092e0 <stm32_clock_init+0xa4>)
 80092b4:	4a0b      	ldr	r2, [pc, #44]	; (80092e4 <stm32_clock_init+0xa8>)
 80092b6:	605a      	str	r2, [r3, #4]
>>>>>>> 752c83b... update binaries
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
<<<<<<< HEAD
 8009234:	4b0b      	ldr	r3, [pc, #44]	; (8009264 <stm32_clock_init+0xac>)
 8009236:	2212      	movs	r2, #18
 8009238:	601a      	str	r2, [r3, #0]
=======
 80092b8:	4b0b      	ldr	r3, [pc, #44]	; (80092e8 <stm32_clock_init+0xac>)
 80092ba:	2212      	movs	r2, #18
 80092bc:	601a      	str	r2, [r3, #0]
>>>>>>> 752c83b... update binaries

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
<<<<<<< HEAD
 800923a:	4a08      	ldr	r2, [pc, #32]	; (800925c <stm32_clock_init+0xa4>)
 800923c:	4b07      	ldr	r3, [pc, #28]	; (800925c <stm32_clock_init+0xa4>)
 800923e:	685b      	ldr	r3, [r3, #4]
 8009240:	f043 0302 	orr.w	r3, r3, #2
 8009244:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8009246:	4b05      	ldr	r3, [pc, #20]	; (800925c <stm32_clock_init+0xa4>)
 8009248:	685b      	ldr	r3, [r3, #4]
 800924a:	f003 030c 	and.w	r3, r3, #12
 800924e:	2b08      	cmp	r3, #8
 8009250:	d1f9      	bne.n	8009246 <stm32_clock_init+0x8e>
=======
 80092be:	4a08      	ldr	r2, [pc, #32]	; (80092e0 <stm32_clock_init+0xa4>)
 80092c0:	4b07      	ldr	r3, [pc, #28]	; (80092e0 <stm32_clock_init+0xa4>)
 80092c2:	685b      	ldr	r3, [r3, #4]
 80092c4:	f043 0302 	orr.w	r3, r3, #2
 80092c8:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80092ca:	4b05      	ldr	r3, [pc, #20]	; (80092e0 <stm32_clock_init+0xa4>)
 80092cc:	685b      	ldr	r3, [r3, #4]
 80092ce:	f003 030c 	and.w	r3, r3, #12
 80092d2:	2b08      	cmp	r3, #8
 80092d4:	d1f9      	bne.n	80092ca <stm32_clock_init+0x8e>
>>>>>>> 752c83b... update binaries

#if !STM32_HSI_ENABLED
  RCC->CR &= ~RCC_CR_HSION;
#endif
#endif /* !STM32_NO_INIT */
}
<<<<<<< HEAD
 8009252:	46bd      	mov	sp, r7
 8009254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009258:	4770      	bx	lr
 800925a:	bf00      	nop
 800925c:	40021000 	.word	0x40021000
 8009260:	001d6400 	.word	0x001d6400
 8009264:	40022000 	.word	0x40022000

08009268 <_pal_lld_init>:
=======
 80092d6:	46bd      	mov	sp, r7
 80092d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092dc:	4770      	bx	lr
 80092de:	bf00      	nop
 80092e0:	40021000 	.word	0x40021000
 80092e4:	001d6400 	.word	0x001d6400
 80092e8:	40022000 	.word	0x40022000

080092ec <_pal_lld_init>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init() {
<<<<<<< HEAD
 8009268:	b480      	push	{r7}
 800926a:	af00      	add	r7, sp, #0
=======
 80092ec:	b480      	push	{r7}
 80092ee:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries
#endif

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, true);
<<<<<<< HEAD
 800926c:	4a19      	ldr	r2, [pc, #100]	; (80092d4 <_pal_lld_init+0x6c>)
 800926e:	4b19      	ldr	r3, [pc, #100]	; (80092d4 <_pal_lld_init+0x6c>)
 8009270:	699b      	ldr	r3, [r3, #24]
 8009272:	f043 037d 	orr.w	r3, r3, #125	; 0x7d
 8009276:	6193      	str	r3, [r2, #24]
=======
 80092f0:	4a19      	ldr	r2, [pc, #100]	; (8009358 <_pal_lld_init+0x6c>)
 80092f2:	4b19      	ldr	r3, [pc, #100]	; (8009358 <_pal_lld_init+0x6c>)
 80092f4:	699b      	ldr	r3, [r3, #24]
 80092f6:	f043 037d 	orr.w	r3, r3, #125	; 0x7d
 80092fa:	6193      	str	r3, [r2, #24]
>>>>>>> 752c83b... update binaries

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = VAL_GPIOAODR;
<<<<<<< HEAD
 8009278:	4b17      	ldr	r3, [pc, #92]	; (80092d8 <_pal_lld_init+0x70>)
 800927a:	f04f 32ff 	mov.w	r2, #4294967295
 800927e:	60da      	str	r2, [r3, #12]
  GPIOA->CRH = VAL_GPIOACRH;
 8009280:	4b15      	ldr	r3, [pc, #84]	; (80092d8 <_pal_lld_init+0x70>)
 8009282:	4a16      	ldr	r2, [pc, #88]	; (80092dc <_pal_lld_init+0x74>)
 8009284:	605a      	str	r2, [r3, #4]
  GPIOA->CRL = VAL_GPIOACRL;
 8009286:	4b14      	ldr	r3, [pc, #80]	; (80092d8 <_pal_lld_init+0x70>)
 8009288:	4a15      	ldr	r2, [pc, #84]	; (80092e0 <_pal_lld_init+0x78>)
 800928a:	601a      	str	r2, [r3, #0]
  GPIOB->ODR = VAL_GPIOBODR;
 800928c:	4b15      	ldr	r3, [pc, #84]	; (80092e4 <_pal_lld_init+0x7c>)
 800928e:	f04f 32ff 	mov.w	r2, #4294967295
 8009292:	60da      	str	r2, [r3, #12]
  GPIOB->CRH = VAL_GPIOBCRH;
 8009294:	4b13      	ldr	r3, [pc, #76]	; (80092e4 <_pal_lld_init+0x7c>)
 8009296:	4a14      	ldr	r2, [pc, #80]	; (80092e8 <_pal_lld_init+0x80>)
 8009298:	605a      	str	r2, [r3, #4]
  GPIOB->CRL = VAL_GPIOBCRL;
 800929a:	4b12      	ldr	r3, [pc, #72]	; (80092e4 <_pal_lld_init+0x7c>)
 800929c:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 80092a0:	601a      	str	r2, [r3, #0]
  GPIOC->ODR = VAL_GPIOCODR;
 80092a2:	4b12      	ldr	r3, [pc, #72]	; (80092ec <_pal_lld_init+0x84>)
 80092a4:	f04f 32ff 	mov.w	r2, #4294967295
 80092a8:	60da      	str	r2, [r3, #12]
  GPIOC->CRH = VAL_GPIOCCRH;
 80092aa:	4b10      	ldr	r3, [pc, #64]	; (80092ec <_pal_lld_init+0x84>)
 80092ac:	4a10      	ldr	r2, [pc, #64]	; (80092f0 <_pal_lld_init+0x88>)
 80092ae:	605a      	str	r2, [r3, #4]
  GPIOC->CRL = VAL_GPIOCCRL;
 80092b0:	4b0e      	ldr	r3, [pc, #56]	; (80092ec <_pal_lld_init+0x84>)
 80092b2:	4a10      	ldr	r2, [pc, #64]	; (80092f4 <_pal_lld_init+0x8c>)
 80092b4:	601a      	str	r2, [r3, #0]
  GPIOD->ODR = VAL_GPIODODR;
 80092b6:	4b10      	ldr	r3, [pc, #64]	; (80092f8 <_pal_lld_init+0x90>)
 80092b8:	f04f 32ff 	mov.w	r2, #4294967295
 80092bc:	60da      	str	r2, [r3, #12]
  GPIOD->CRH = VAL_GPIODCRH;
 80092be:	4b0e      	ldr	r3, [pc, #56]	; (80092f8 <_pal_lld_init+0x90>)
 80092c0:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 80092c4:	605a      	str	r2, [r3, #4]
  GPIOD->CRL = VAL_GPIODCRL;
 80092c6:	4b0c      	ldr	r3, [pc, #48]	; (80092f8 <_pal_lld_init+0x90>)
 80092c8:	4a0c      	ldr	r2, [pc, #48]	; (80092fc <_pal_lld_init+0x94>)
 80092ca:	601a      	str	r2, [r3, #0]
}
 80092cc:	46bd      	mov	sp, r7
 80092ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092d2:	4770      	bx	lr
 80092d4:	40021000 	.word	0x40021000
 80092d8:	40010800 	.word	0x40010800
 80092dc:	888b44b8 	.word	0x888b44b8
 80092e0:	88884b84 	.word	0x88884b84
 80092e4:	40010c00 	.word	0x40010c00
 80092e8:	b4b88888 	.word	0xb4b88888
 80092ec:	40011000 	.word	0x40011000
 80092f0:	88833388 	.word	0x88833388
 80092f4:	44848888 	.word	0x44848888
 80092f8:	40011400 	.word	0x40011400
 80092fc:	88888844 	.word	0x88888844

08009300 <port_lock.lto_priv.185>:
=======
 80092fc:	4b17      	ldr	r3, [pc, #92]	; (800935c <_pal_lld_init+0x70>)
 80092fe:	f04f 32ff 	mov.w	r2, #4294967295
 8009302:	60da      	str	r2, [r3, #12]
  GPIOA->CRH = VAL_GPIOACRH;
 8009304:	4b15      	ldr	r3, [pc, #84]	; (800935c <_pal_lld_init+0x70>)
 8009306:	4a16      	ldr	r2, [pc, #88]	; (8009360 <_pal_lld_init+0x74>)
 8009308:	605a      	str	r2, [r3, #4]
  GPIOA->CRL = VAL_GPIOACRL;
 800930a:	4b14      	ldr	r3, [pc, #80]	; (800935c <_pal_lld_init+0x70>)
 800930c:	4a15      	ldr	r2, [pc, #84]	; (8009364 <_pal_lld_init+0x78>)
 800930e:	601a      	str	r2, [r3, #0]
  GPIOB->ODR = VAL_GPIOBODR;
 8009310:	4b15      	ldr	r3, [pc, #84]	; (8009368 <_pal_lld_init+0x7c>)
 8009312:	f04f 32ff 	mov.w	r2, #4294967295
 8009316:	60da      	str	r2, [r3, #12]
  GPIOB->CRH = VAL_GPIOBCRH;
 8009318:	4b13      	ldr	r3, [pc, #76]	; (8009368 <_pal_lld_init+0x7c>)
 800931a:	4a14      	ldr	r2, [pc, #80]	; (800936c <_pal_lld_init+0x80>)
 800931c:	605a      	str	r2, [r3, #4]
  GPIOB->CRL = VAL_GPIOBCRL;
 800931e:	4b12      	ldr	r3, [pc, #72]	; (8009368 <_pal_lld_init+0x7c>)
 8009320:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 8009324:	601a      	str	r2, [r3, #0]
  GPIOC->ODR = VAL_GPIOCODR;
 8009326:	4b12      	ldr	r3, [pc, #72]	; (8009370 <_pal_lld_init+0x84>)
 8009328:	f04f 32ff 	mov.w	r2, #4294967295
 800932c:	60da      	str	r2, [r3, #12]
  GPIOC->CRH = VAL_GPIOCCRH;
 800932e:	4b10      	ldr	r3, [pc, #64]	; (8009370 <_pal_lld_init+0x84>)
 8009330:	4a10      	ldr	r2, [pc, #64]	; (8009374 <_pal_lld_init+0x88>)
 8009332:	605a      	str	r2, [r3, #4]
  GPIOC->CRL = VAL_GPIOCCRL;
 8009334:	4b0e      	ldr	r3, [pc, #56]	; (8009370 <_pal_lld_init+0x84>)
 8009336:	4a10      	ldr	r2, [pc, #64]	; (8009378 <_pal_lld_init+0x8c>)
 8009338:	601a      	str	r2, [r3, #0]
  GPIOD->ODR = VAL_GPIODODR;
 800933a:	4b10      	ldr	r3, [pc, #64]	; (800937c <_pal_lld_init+0x90>)
 800933c:	f04f 32ff 	mov.w	r2, #4294967295
 8009340:	60da      	str	r2, [r3, #12]
  GPIOD->CRH = VAL_GPIODCRH;
 8009342:	4b0e      	ldr	r3, [pc, #56]	; (800937c <_pal_lld_init+0x90>)
 8009344:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
 8009348:	605a      	str	r2, [r3, #4]
  GPIOD->CRL = VAL_GPIODCRL;
 800934a:	4b0c      	ldr	r3, [pc, #48]	; (800937c <_pal_lld_init+0x90>)
 800934c:	4a0c      	ldr	r2, [pc, #48]	; (8009380 <_pal_lld_init+0x94>)
 800934e:	601a      	str	r2, [r3, #0]
}
 8009350:	46bd      	mov	sp, r7
 8009352:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009356:	4770      	bx	lr
 8009358:	40021000 	.word	0x40021000
 800935c:	40010800 	.word	0x40010800
 8009360:	888b44b8 	.word	0x888b44b8
 8009364:	88884b84 	.word	0x88884b84
 8009368:	40010c00 	.word	0x40010c00
 800936c:	b4b88888 	.word	0xb4b88888
 8009370:	40011000 	.word	0x40011000
 8009374:	88833388 	.word	0x88833388
 8009378:	44848888 	.word	0x44848888
 800937c:	40011400 	.word	0x40011400
 8009380:	88888844 	.word	0x88888844

08009384 <port_lock.lto_priv.182>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 8009300:	b480      	push	{r7}
 8009302:	b083      	sub	sp, #12
 8009304:	af00      	add	r7, sp, #0
 8009306:	2320      	movs	r3, #32
 8009308:	607b      	str	r3, [r7, #4]
 800930a:	687b      	ldr	r3, [r7, #4]
 800930c:	f383 8811 	msr	BASEPRI, r3
=======
 8009384:	b480      	push	{r7}
 8009386:	b083      	sub	sp, #12
 8009388:	af00      	add	r7, sp, #0
 800938a:	2320      	movs	r3, #32
 800938c:	607b      	str	r3, [r7, #4]
 800938e:	687b      	ldr	r3, [r7, #4]
 8009390:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009310:	370c      	adds	r7, #12
 8009312:	46bd      	mov	sp, r7
 8009314:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009318:	4770      	bx	lr
 800931a:	bf00      	nop

0800931c <port_unlock.lto_priv.182>:
=======
 8009394:	370c      	adds	r7, #12
 8009396:	46bd      	mov	sp, r7
 8009398:	f85d 7b04 	ldr.w	r7, [sp], #4
 800939c:	4770      	bx	lr
 800939e:	bf00      	nop

080093a0 <port_unlock.lto_priv.179>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800931c:	b480      	push	{r7}
 800931e:	b083      	sub	sp, #12
 8009320:	af00      	add	r7, sp, #0
 8009322:	2300      	movs	r3, #0
 8009324:	607b      	str	r3, [r7, #4]
 8009326:	687b      	ldr	r3, [r7, #4]
 8009328:	f383 8811 	msr	BASEPRI, r3
=======
 80093a0:	b480      	push	{r7}
 80093a2:	b083      	sub	sp, #12
 80093a4:	af00      	add	r7, sp, #0
 80093a6:	2300      	movs	r3, #0
 80093a8:	607b      	str	r3, [r7, #4]
 80093aa:	687b      	ldr	r3, [r7, #4]
 80093ac:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800932c:	370c      	adds	r7, #12
 800932e:	46bd      	mov	sp, r7
 8009330:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009334:	4770      	bx	lr
 8009336:	bf00      	nop

08009338 <port_lock_from_isr.lto_priv.179>:
=======
 80093b0:	370c      	adds	r7, #12
 80093b2:	46bd      	mov	sp, r7
 80093b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093b8:	4770      	bx	lr
 80093ba:	bf00      	nop

080093bc <port_lock_from_isr.lto_priv.176>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
<<<<<<< HEAD
 8009338:	b580      	push	{r7, lr}
 800933a:	af00      	add	r7, sp, #0

  port_lock();
 800933c:	f7ff ffe0 	bl	8009300 <port_lock.lto_priv.185>
}
 8009340:	bd80      	pop	{r7, pc}
 8009342:	bf00      	nop

08009344 <port_unlock_from_isr.lto_priv.177>:
=======
 80093bc:	b580      	push	{r7, lr}
 80093be:	af00      	add	r7, sp, #0

  port_lock();
 80093c0:	f7ff ffe0 	bl	8009384 <port_lock.lto_priv.182>
}
 80093c4:	bd80      	pop	{r7, pc}
 80093c6:	bf00      	nop

080093c8 <port_unlock_from_isr.lto_priv.174>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
<<<<<<< HEAD
 8009344:	b580      	push	{r7, lr}
 8009346:	af00      	add	r7, sp, #0

  port_unlock();
 8009348:	f7ff ffe8 	bl	800931c <port_unlock.lto_priv.182>
}
 800934c:	bd80      	pop	{r7, pc}
 800934e:	bf00      	nop

08009350 <chSysLockFromISR.lto_priv.175>:
=======
 80093c8:	b580      	push	{r7, lr}
 80093ca:	af00      	add	r7, sp, #0

  port_unlock();
 80093cc:	f7ff ffe8 	bl	80093a0 <port_unlock.lto_priv.179>
}
 80093d0:	bd80      	pop	{r7, pc}
 80093d2:	bf00      	nop

080093d4 <chSysLockFromISR.lto_priv.172>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
<<<<<<< HEAD
 8009350:	b580      	push	{r7, lr}
 8009352:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009354:	f7ff fff0 	bl	8009338 <port_lock_from_isr.lto_priv.179>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009358:	f001 fd9e 	bl	800ae98 <_dbg_check_lock_from_isr>
}
 800935c:	bd80      	pop	{r7, pc}
 800935e:	bf00      	nop

08009360 <chSysUnlockFromISR.lto_priv.173>:
=======
 80093d4:	b580      	push	{r7, lr}
 80093d6:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 80093d8:	f7ff fff0 	bl	80093bc <port_lock_from_isr.lto_priv.176>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80093dc:	f001 fda0 	bl	800af20 <_dbg_check_lock_from_isr>
}
 80093e0:	bd80      	pop	{r7, pc}
 80093e2:	bf00      	nop

080093e4 <chSysUnlockFromISR.lto_priv.170>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
<<<<<<< HEAD
 8009360:	b580      	push	{r7, lr}
 8009362:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 8009364:	f001 fdae 	bl	800aec4 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8009368:	f7ff ffec 	bl	8009344 <port_unlock_from_isr.lto_priv.177>
}
 800936c:	bd80      	pop	{r7, pc}
 800936e:	bf00      	nop

08009370 <osalSysLockFromISR.lto_priv.171>:
=======
 80093e4:	b580      	push	{r7, lr}
 80093e6:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 80093e8:	f001 fdb0 	bl	800af4c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80093ec:	f7ff ffec 	bl	80093c8 <port_unlock_from_isr.lto_priv.174>
}
 80093f0:	bd80      	pop	{r7, pc}
 80093f2:	bf00      	nop

080093f4 <osalSysLockFromISR.lto_priv.168>:
>>>>>>> 752c83b... update binaries
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
<<<<<<< HEAD
 8009370:	b580      	push	{r7, lr}
 8009372:	af00      	add	r7, sp, #0

  chSysLockFromISR();
 8009374:	f7ff ffec 	bl	8009350 <chSysLockFromISR.lto_priv.175>
}
 8009378:	bd80      	pop	{r7, pc}
 800937a:	bf00      	nop

0800937c <osalSysUnlockFromISR.lto_priv.169>:
=======
 80093f4:	b580      	push	{r7, lr}
 80093f6:	af00      	add	r7, sp, #0

  chSysLockFromISR();
 80093f8:	f7ff ffec 	bl	80093d4 <chSysLockFromISR.lto_priv.172>
}
 80093fc:	bd80      	pop	{r7, pc}
 80093fe:	bf00      	nop

08009400 <osalSysUnlockFromISR.lto_priv.166>:
>>>>>>> 752c83b... update binaries
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
<<<<<<< HEAD
 800937c:	b580      	push	{r7, lr}
 800937e:	af00      	add	r7, sp, #0

  chSysUnlockFromISR();
 8009380:	f7ff ffee 	bl	8009360 <chSysUnlockFromISR.lto_priv.173>
}
 8009384:	bd80      	pop	{r7, pc}
 8009386:	bf00      	nop

08009388 <osalOsTimerHandlerI>:
=======
 8009400:	b580      	push	{r7, lr}
 8009402:	af00      	add	r7, sp, #0

  chSysUnlockFromISR();
 8009404:	f7ff ffee 	bl	80093e4 <chSysUnlockFromISR.lto_priv.170>
}
 8009408:	bd80      	pop	{r7, pc}
 800940a:	bf00      	nop

0800940c <osalOsTimerHandlerI>:
>>>>>>> 752c83b... update binaries
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
<<<<<<< HEAD
 8009388:	b580      	push	{r7, lr}
 800938a:	af00      	add	r7, sp, #0

  chSysTimerHandlerI();
 800938c:	f001 fd16 	bl	800adbc <chSysTimerHandlerI>
}
 8009390:	bd80      	pop	{r7, pc}
 8009392:	bf00      	nop

08009394 <VectorB0>:
=======
 800940c:	b580      	push	{r7, lr}
 800940e:	af00      	add	r7, sp, #0

  chSysTimerHandlerI();
 8009410:	f001 fd18 	bl	800ae44 <chSysTimerHandlerI>
}
 8009414:	bd80      	pop	{r7, pc}
 8009416:	bf00      	nop

08009418 <VectorB0>:
>>>>>>> 752c83b... update binaries
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
<<<<<<< HEAD
 8009394:	b580      	push	{r7, lr}
 8009396:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 8009398:	f001 fdaa 	bl	800aef0 <_dbg_check_enter_isr>
=======
 8009418:	b580      	push	{r7, lr}
 800941a:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 800941c:	f001 fdac 	bl	800af78 <_dbg_check_enter_isr>
>>>>>>> 752c83b... update binaries

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
<<<<<<< HEAD
 800939c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80093a0:	691b      	ldr	r3, [r3, #16]
 80093a2:	f003 0302 	and.w	r3, r3, #2
 80093a6:	2b00      	cmp	r3, #0
 80093a8:	d009      	beq.n	80093be <VectorB0+0x2a>
    STM32_ST_TIM->SR = 0U;
 80093aa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80093ae:	2200      	movs	r2, #0
 80093b0:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80093b2:	f7ff ffdd 	bl	8009370 <osalSysLockFromISR.lto_priv.171>
    osalOsTimerHandlerI();
 80093b6:	f7ff ffe7 	bl	8009388 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80093ba:	f7ff ffdf 	bl	800937c <osalSysUnlockFromISR.lto_priv.169>
  }

  OSAL_IRQ_EPILOGUE();
 80093be:	f001 fdb3 	bl	800af28 <_dbg_check_leave_isr>
 80093c2:	f000 fcd5 	bl	8009d70 <_port_irq_epilogue>
}
 80093c6:	bd80      	pop	{r7, pc}

080093c8 <st_lld_init>:
=======
 8009420:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009424:	691b      	ldr	r3, [r3, #16]
 8009426:	f003 0302 	and.w	r3, r3, #2
 800942a:	2b00      	cmp	r3, #0
 800942c:	d009      	beq.n	8009442 <VectorB0+0x2a>
    STM32_ST_TIM->SR = 0U;
 800942e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009432:	2200      	movs	r2, #0
 8009434:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8009436:	f7ff ffdd 	bl	80093f4 <osalSysLockFromISR.lto_priv.168>
    osalOsTimerHandlerI();
 800943a:	f7ff ffe7 	bl	800940c <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 800943e:	f7ff ffdf 	bl	8009400 <osalSysUnlockFromISR.lto_priv.166>
  }

  OSAL_IRQ_EPILOGUE();
 8009442:	f001 fdb5 	bl	800afb0 <_dbg_check_leave_isr>
 8009446:	f000 fcd7 	bl	8009df8 <_port_irq_epilogue>
}
 800944a:	bd80      	pop	{r7, pc}

0800944c <st_lld_init>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
<<<<<<< HEAD
 80093c8:	b580      	push	{r7, lr}
 80093ca:	af00      	add	r7, sp, #0
=======
 800944c:	b580      	push	{r7, lr}
 800944e:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
<<<<<<< HEAD
 80093cc:	4a19      	ldr	r2, [pc, #100]	; (8009434 <st_lld_init+0x6c>)
 80093ce:	4b19      	ldr	r3, [pc, #100]	; (8009434 <st_lld_init+0x6c>)
 80093d0:	69db      	ldr	r3, [r3, #28]
 80093d2:	f043 0301 	orr.w	r3, r3, #1
 80093d6:	61d3      	str	r3, [r2, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80093d8:	4a17      	ldr	r2, [pc, #92]	; (8009438 <st_lld_init+0x70>)
 80093da:	4b17      	ldr	r3, [pc, #92]	; (8009438 <st_lld_init+0x70>)
 80093dc:	685b      	ldr	r3, [r3, #4]
 80093de:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80093e2:	6053      	str	r3, [r2, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80093e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80093e8:	f641 421f 	movw	r2, #7199	; 0x1c1f
 80093ec:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80093ee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80093f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80093f6:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80093f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80093fc:	2200      	movs	r2, #0
 80093fe:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8009400:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009404:	2200      	movs	r2, #0
 8009406:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8009408:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800940c:	2200      	movs	r2, #0
 800940e:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8009410:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009414:	2200      	movs	r2, #0
 8009416:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8009418:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800941c:	2201      	movs	r2, #1
 800941e:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8009420:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009424:	2201      	movs	r2, #1
 8009426:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8009428:	201c      	movs	r0, #28
 800942a:	2108      	movs	r1, #8
 800942c:	f7ff fe44 	bl	80090b8 <nvicEnableVector>
=======
 8009450:	4a19      	ldr	r2, [pc, #100]	; (80094b8 <st_lld_init+0x6c>)
 8009452:	4b19      	ldr	r3, [pc, #100]	; (80094b8 <st_lld_init+0x6c>)
 8009454:	69db      	ldr	r3, [r3, #28]
 8009456:	f043 0301 	orr.w	r3, r3, #1
 800945a:	61d3      	str	r3, [r2, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800945c:	4a17      	ldr	r2, [pc, #92]	; (80094bc <st_lld_init+0x70>)
 800945e:	4b17      	ldr	r3, [pc, #92]	; (80094bc <st_lld_init+0x70>)
 8009460:	685b      	ldr	r3, [r3, #4]
 8009462:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009466:	6053      	str	r3, [r2, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8009468:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800946c:	f641 421f 	movw	r2, #7199	; 0x1c1f
 8009470:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8009472:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009476:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800947a:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800947c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009480:	2200      	movs	r2, #0
 8009482:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8009484:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009488:	2200      	movs	r2, #0
 800948a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800948c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009490:	2200      	movs	r2, #0
 8009492:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8009494:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009498:	2200      	movs	r2, #0
 800949a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800949c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80094a0:	2201      	movs	r2, #1
 80094a2:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80094a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80094a8:	2201      	movs	r2, #1
 80094aa:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80094ac:	201c      	movs	r0, #28
 80094ae:	2108      	movs	r1, #8
 80094b0:	f7ff fe44 	bl	800913c <nvicEnableVector>
>>>>>>> 752c83b... update binaries
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
<<<<<<< HEAD
 8009430:	bd80      	pop	{r7, pc}
 8009432:	bf00      	nop
 8009434:	40021000 	.word	0x40021000
 8009438:	e0042000 	.word	0xe0042000

0800943c <port_lock.lto_priv.186>:
=======
 80094b4:	bd80      	pop	{r7, pc}
 80094b6:	bf00      	nop
 80094b8:	40021000 	.word	0x40021000
 80094bc:	e0042000 	.word	0xe0042000

080094c0 <port_lock.lto_priv.183>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800943c:	b480      	push	{r7}
 800943e:	b083      	sub	sp, #12
 8009440:	af00      	add	r7, sp, #0
 8009442:	2320      	movs	r3, #32
 8009444:	607b      	str	r3, [r7, #4]
 8009446:	687b      	ldr	r3, [r7, #4]
 8009448:	f383 8811 	msr	BASEPRI, r3
=======
 80094c0:	b480      	push	{r7}
 80094c2:	b083      	sub	sp, #12
 80094c4:	af00      	add	r7, sp, #0
 80094c6:	2320      	movs	r3, #32
 80094c8:	607b      	str	r3, [r7, #4]
 80094ca:	687b      	ldr	r3, [r7, #4]
 80094cc:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800944c:	370c      	adds	r7, #12
 800944e:	46bd      	mov	sp, r7
 8009450:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009454:	4770      	bx	lr
 8009456:	bf00      	nop

08009458 <port_unlock.lto_priv.183>:
=======
 80094d0:	370c      	adds	r7, #12
 80094d2:	46bd      	mov	sp, r7
 80094d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80094d8:	4770      	bx	lr
 80094da:	bf00      	nop

080094dc <port_unlock.lto_priv.180>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 8009458:	b480      	push	{r7}
 800945a:	b083      	sub	sp, #12
 800945c:	af00      	add	r7, sp, #0
 800945e:	2300      	movs	r3, #0
 8009460:	607b      	str	r3, [r7, #4]
 8009462:	687b      	ldr	r3, [r7, #4]
 8009464:	f383 8811 	msr	BASEPRI, r3
=======
 80094dc:	b480      	push	{r7}
 80094de:	b083      	sub	sp, #12
 80094e0:	af00      	add	r7, sp, #0
 80094e2:	2300      	movs	r3, #0
 80094e4:	607b      	str	r3, [r7, #4]
 80094e6:	687b      	ldr	r3, [r7, #4]
 80094e8:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009468:	370c      	adds	r7, #12
 800946a:	46bd      	mov	sp, r7
 800946c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009470:	4770      	bx	lr
 8009472:	bf00      	nop

08009474 <port_lock_from_isr.lto_priv.180>:
=======
 80094ec:	370c      	adds	r7, #12
 80094ee:	46bd      	mov	sp, r7
 80094f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80094f4:	4770      	bx	lr
 80094f6:	bf00      	nop

080094f8 <port_lock_from_isr.lto_priv.177>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
<<<<<<< HEAD
 8009474:	b580      	push	{r7, lr}
 8009476:	af00      	add	r7, sp, #0

  port_lock();
 8009478:	f7ff ffe0 	bl	800943c <port_lock.lto_priv.186>
}
 800947c:	bd80      	pop	{r7, pc}
 800947e:	bf00      	nop

08009480 <port_unlock_from_isr.lto_priv.178>:
=======
 80094f8:	b580      	push	{r7, lr}
 80094fa:	af00      	add	r7, sp, #0

  port_lock();
 80094fc:	f7ff ffe0 	bl	80094c0 <port_lock.lto_priv.183>
}
 8009500:	bd80      	pop	{r7, pc}
 8009502:	bf00      	nop

08009504 <port_unlock_from_isr.lto_priv.175>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
<<<<<<< HEAD
 8009480:	b580      	push	{r7, lr}
 8009482:	af00      	add	r7, sp, #0

  port_unlock();
 8009484:	f7ff ffe8 	bl	8009458 <port_unlock.lto_priv.183>
}
 8009488:	bd80      	pop	{r7, pc}
 800948a:	bf00      	nop

0800948c <chSysLockFromISR.lto_priv.176>:
=======
 8009504:	b580      	push	{r7, lr}
 8009506:	af00      	add	r7, sp, #0

  port_unlock();
 8009508:	f7ff ffe8 	bl	80094dc <port_unlock.lto_priv.180>
}
 800950c:	bd80      	pop	{r7, pc}
 800950e:	bf00      	nop

08009510 <chSysLockFromISR.lto_priv.173>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
<<<<<<< HEAD
 800948c:	b580      	push	{r7, lr}
 800948e:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009490:	f7ff fff0 	bl	8009474 <port_lock_from_isr.lto_priv.180>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009494:	f001 fd00 	bl	800ae98 <_dbg_check_lock_from_isr>
}
 8009498:	bd80      	pop	{r7, pc}
 800949a:	bf00      	nop

0800949c <chSysUnlockFromISR.lto_priv.174>:
=======
 8009510:	b580      	push	{r7, lr}
 8009512:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009514:	f7ff fff0 	bl	80094f8 <port_lock_from_isr.lto_priv.177>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009518:	f001 fd02 	bl	800af20 <_dbg_check_lock_from_isr>
}
 800951c:	bd80      	pop	{r7, pc}
 800951e:	bf00      	nop

08009520 <chSysUnlockFromISR.lto_priv.171>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
<<<<<<< HEAD
 800949c:	b580      	push	{r7, lr}
 800949e:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 80094a0:	f001 fd10 	bl	800aec4 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80094a4:	f7ff ffec 	bl	8009480 <port_unlock_from_isr.lto_priv.178>
}
 80094a8:	bd80      	pop	{r7, pc}
 80094aa:	bf00      	nop

080094ac <osalSysLockFromISR.lto_priv.172>:
=======
 8009520:	b580      	push	{r7, lr}
 8009522:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 8009524:	f001 fd12 	bl	800af4c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8009528:	f7ff ffec 	bl	8009504 <port_unlock_from_isr.lto_priv.175>
}
 800952c:	bd80      	pop	{r7, pc}
 800952e:	bf00      	nop

08009530 <osalSysLockFromISR.lto_priv.169>:
>>>>>>> 752c83b... update binaries
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
<<<<<<< HEAD
 80094ac:	b580      	push	{r7, lr}
 80094ae:	af00      	add	r7, sp, #0

  chSysLockFromISR();
 80094b0:	f7ff ffec 	bl	800948c <chSysLockFromISR.lto_priv.176>
}
 80094b4:	bd80      	pop	{r7, pc}
 80094b6:	bf00      	nop

080094b8 <osalSysUnlockFromISR.lto_priv.170>:
=======
 8009530:	b580      	push	{r7, lr}
 8009532:	af00      	add	r7, sp, #0

  chSysLockFromISR();
 8009534:	f7ff ffec 	bl	8009510 <chSysLockFromISR.lto_priv.173>
}
 8009538:	bd80      	pop	{r7, pc}
 800953a:	bf00      	nop

0800953c <osalSysUnlockFromISR.lto_priv.167>:
>>>>>>> 752c83b... update binaries
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
<<<<<<< HEAD
 80094b8:	b580      	push	{r7, lr}
 80094ba:	af00      	add	r7, sp, #0

  chSysUnlockFromISR();
 80094bc:	f7ff ffee 	bl	800949c <chSysUnlockFromISR.lto_priv.174>
}
 80094c0:	bd80      	pop	{r7, pc}
 80094c2:	bf00      	nop

080094c4 <osalEventBroadcastFlagsI.lto_priv.168>:
=======
 800953c:	b580      	push	{r7, lr}
 800953e:	af00      	add	r7, sp, #0

  chSysUnlockFromISR();
 8009540:	f7ff ffee 	bl	8009520 <chSysUnlockFromISR.lto_priv.171>
}
 8009544:	bd80      	pop	{r7, pc}
 8009546:	bf00      	nop

08009548 <osalEventBroadcastFlagsI.lto_priv.165>:
>>>>>>> 752c83b... update binaries

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
<<<<<<< HEAD
 80094c4:	b480      	push	{r7}
 80094c6:	b083      	sub	sp, #12
 80094c8:	af00      	add	r7, sp, #0
 80094ca:	6078      	str	r0, [r7, #4]
 80094cc:	6039      	str	r1, [r7, #0]

  esp->flags |= flags;
 80094ce:	687b      	ldr	r3, [r7, #4]
 80094d0:	681a      	ldr	r2, [r3, #0]
 80094d2:	683b      	ldr	r3, [r7, #0]
 80094d4:	431a      	orrs	r2, r3
 80094d6:	687b      	ldr	r3, [r7, #4]
 80094d8:	601a      	str	r2, [r3, #0]
}
 80094da:	370c      	adds	r7, #12
 80094dc:	46bd      	mov	sp, r7
 80094de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80094e2:	4770      	bx	lr

080094e4 <usart_init>:
=======
 8009548:	b480      	push	{r7}
 800954a:	b083      	sub	sp, #12
 800954c:	af00      	add	r7, sp, #0
 800954e:	6078      	str	r0, [r7, #4]
 8009550:	6039      	str	r1, [r7, #0]

  esp->flags |= flags;
 8009552:	687b      	ldr	r3, [r7, #4]
 8009554:	681a      	ldr	r2, [r3, #0]
 8009556:	683b      	ldr	r3, [r7, #0]
 8009558:	431a      	orrs	r2, r3
 800955a:	687b      	ldr	r3, [r7, #4]
 800955c:	601a      	str	r2, [r3, #0]
}
 800955e:	370c      	adds	r7, #12
 8009560:	46bd      	mov	sp, r7
 8009562:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009566:	4770      	bx	lr

08009568 <usart_init>:
>>>>>>> 752c83b... update binaries
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
<<<<<<< HEAD
 80094e4:	b480      	push	{r7}
 80094e6:	b085      	sub	sp, #20
 80094e8:	af00      	add	r7, sp, #0
 80094ea:	6078      	str	r0, [r7, #4]
 80094ec:	6039      	str	r1, [r7, #0]
  USART_TypeDef *u = sdp->usart;
 80094ee:	687b      	ldr	r3, [r7, #4]
 80094f0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80094f2:	60fb      	str	r3, [r7, #12]
=======
 8009568:	b480      	push	{r7}
 800956a:	b085      	sub	sp, #20
 800956c:	af00      	add	r7, sp, #0
 800956e:	6078      	str	r0, [r7, #4]
 8009570:	6039      	str	r1, [r7, #0]
  USART_TypeDef *u = sdp->usart;
 8009572:	687b      	ldr	r3, [r7, #4]
 8009574:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009576:	60fb      	str	r3, [r7, #12]
>>>>>>> 752c83b... update binaries

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
<<<<<<< HEAD
 80094f4:	687b      	ldr	r3, [r7, #4]
 80094f6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80094f8:	4a23      	ldr	r2, [pc, #140]	; (8009588 <usart_init+0xa4>)
 80094fa:	4293      	cmp	r3, r2
 80094fc:	d107      	bne.n	800950e <usart_init+0x2a>
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 80094fe:	683b      	ldr	r3, [r7, #0]
 8009500:	681b      	ldr	r3, [r3, #0]
 8009502:	4a22      	ldr	r2, [pc, #136]	; (800958c <usart_init+0xa8>)
 8009504:	fbb2 f2f3 	udiv	r2, r2, r3
 8009508:	68fb      	ldr	r3, [r7, #12]
 800950a:	609a      	str	r2, [r3, #8]
 800950c:	e006      	b.n	800951c <usart_init+0x38>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 800950e:	683b      	ldr	r3, [r7, #0]
 8009510:	681b      	ldr	r3, [r3, #0]
 8009512:	4a1e      	ldr	r2, [pc, #120]	; (800958c <usart_init+0xa8>)
 8009514:	fbb2 f2f3 	udiv	r2, r2, r3
 8009518:	68fb      	ldr	r3, [r7, #12]
 800951a:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800951c:	683b      	ldr	r3, [r7, #0]
 800951e:	88db      	ldrh	r3, [r3, #6]
 8009520:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009524:	b29b      	uxth	r3, r3
 8009526:	461a      	mov	r2, r3
 8009528:	68fb      	ldr	r3, [r7, #12]
 800952a:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800952c:	683b      	ldr	r3, [r7, #0]
 800952e:	891b      	ldrh	r3, [r3, #8]
 8009530:	f043 0301 	orr.w	r3, r3, #1
 8009534:	b29b      	uxth	r3, r3
 8009536:	461a      	mov	r2, r3
 8009538:	68fb      	ldr	r3, [r7, #12]
 800953a:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800953c:	683b      	ldr	r3, [r7, #0]
 800953e:	889b      	ldrh	r3, [r3, #4]
 8009540:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 8009544:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8009548:	b29b      	uxth	r3, r3
 800954a:	461a      	mov	r2, r3
 800954c:	68fb      	ldr	r3, [r7, #12]
 800954e:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8009550:	68fb      	ldr	r3, [r7, #12]
 8009552:	2200      	movs	r2, #0
 8009554:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8009556:	68fb      	ldr	r3, [r7, #12]
 8009558:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 800955a:	68fb      	ldr	r3, [r7, #12]
 800955c:	685b      	ldr	r3, [r3, #4]
=======
 8009578:	687b      	ldr	r3, [r7, #4]
 800957a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800957c:	4a23      	ldr	r2, [pc, #140]	; (800960c <usart_init+0xa4>)
 800957e:	4293      	cmp	r3, r2
 8009580:	d107      	bne.n	8009592 <usart_init+0x2a>
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8009582:	683b      	ldr	r3, [r7, #0]
 8009584:	681b      	ldr	r3, [r3, #0]
 8009586:	4a22      	ldr	r2, [pc, #136]	; (8009610 <usart_init+0xa8>)
 8009588:	fbb2 f2f3 	udiv	r2, r2, r3
 800958c:	68fb      	ldr	r3, [r7, #12]
 800958e:	609a      	str	r2, [r3, #8]
 8009590:	e006      	b.n	80095a0 <usart_init+0x38>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8009592:	683b      	ldr	r3, [r7, #0]
 8009594:	681b      	ldr	r3, [r3, #0]
 8009596:	4a1e      	ldr	r2, [pc, #120]	; (8009610 <usart_init+0xa8>)
 8009598:	fbb2 f2f3 	udiv	r2, r2, r3
 800959c:	68fb      	ldr	r3, [r7, #12]
 800959e:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80095a0:	683b      	ldr	r3, [r7, #0]
 80095a2:	88db      	ldrh	r3, [r3, #6]
 80095a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80095a8:	b29b      	uxth	r3, r3
 80095aa:	461a      	mov	r2, r3
 80095ac:	68fb      	ldr	r3, [r7, #12]
 80095ae:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80095b0:	683b      	ldr	r3, [r7, #0]
 80095b2:	891b      	ldrh	r3, [r3, #8]
 80095b4:	f043 0301 	orr.w	r3, r3, #1
 80095b8:	b29b      	uxth	r3, r3
 80095ba:	461a      	mov	r2, r3
 80095bc:	68fb      	ldr	r3, [r7, #12]
 80095be:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80095c0:	683b      	ldr	r3, [r7, #0]
 80095c2:	889b      	ldrh	r3, [r3, #4]
 80095c4:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 80095c8:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 80095cc:	b29b      	uxth	r3, r3
 80095ce:	461a      	mov	r2, r3
 80095d0:	68fb      	ldr	r3, [r7, #12]
 80095d2:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 80095d4:	68fb      	ldr	r3, [r7, #12]
 80095d6:	2200      	movs	r2, #0
 80095d8:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 80095da:	68fb      	ldr	r3, [r7, #12]
 80095dc:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 80095de:	68fb      	ldr	r3, [r7, #12]
 80095e0:	685b      	ldr	r3, [r3, #4]
>>>>>>> 752c83b... update binaries

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
<<<<<<< HEAD
 800955e:	683b      	ldr	r3, [r7, #0]
 8009560:	889b      	ldrh	r3, [r3, #4]
 8009562:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 8009566:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800956a:	d104      	bne.n	8009576 <usart_init+0x92>
    sdp->rxmask = 0x7F;
 800956c:	687b      	ldr	r3, [r7, #4]
 800956e:	227f      	movs	r2, #127	; 0x7f
 8009570:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
 8009574:	e003      	b.n	800957e <usart_init+0x9a>
  }
  else {
    sdp->rxmask = 0xFF;
 8009576:	687b      	ldr	r3, [r7, #4]
 8009578:	22ff      	movs	r2, #255	; 0xff
 800957a:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
  }
}
 800957e:	3714      	adds	r7, #20
 8009580:	46bd      	mov	sp, r7
 8009582:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009586:	4770      	bx	lr
 8009588:	40013800 	.word	0x40013800
 800958c:	02255100 	.word	0x02255100

08009590 <set_error>:
=======
 80095e2:	683b      	ldr	r3, [r7, #0]
 80095e4:	889b      	ldrh	r3, [r3, #4]
 80095e6:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 80095ea:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80095ee:	d104      	bne.n	80095fa <usart_init+0x92>
    sdp->rxmask = 0x7F;
 80095f0:	687b      	ldr	r3, [r7, #4]
 80095f2:	227f      	movs	r2, #127	; 0x7f
 80095f4:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
 80095f8:	e003      	b.n	8009602 <usart_init+0x9a>
  }
  else {
    sdp->rxmask = 0xFF;
 80095fa:	687b      	ldr	r3, [r7, #4]
 80095fc:	22ff      	movs	r2, #255	; 0xff
 80095fe:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
  }
}
 8009602:	3714      	adds	r7, #20
 8009604:	46bd      	mov	sp, r7
 8009606:	f85d 7b04 	ldr.w	r7, [sp], #4
 800960a:	4770      	bx	lr
 800960c:	40013800 	.word	0x40013800
 8009610:	02255100 	.word	0x02255100

08009614 <set_error>:
>>>>>>> 752c83b... update binaries
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
<<<<<<< HEAD
 8009590:	b580      	push	{r7, lr}
 8009592:	b084      	sub	sp, #16
 8009594:	af00      	add	r7, sp, #0
 8009596:	6078      	str	r0, [r7, #4]
 8009598:	460b      	mov	r3, r1
 800959a:	807b      	strh	r3, [r7, #2]
  eventflags_t sts = 0;
 800959c:	2300      	movs	r3, #0
 800959e:	60fb      	str	r3, [r7, #12]

  if (sr & USART_SR_ORE)
 80095a0:	887b      	ldrh	r3, [r7, #2]
 80095a2:	f003 0308 	and.w	r3, r3, #8
 80095a6:	2b00      	cmp	r3, #0
 80095a8:	d003      	beq.n	80095b2 <set_error+0x22>
    sts |= SD_OVERRUN_ERROR;
 80095aa:	68fb      	ldr	r3, [r7, #12]
 80095ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80095b0:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_PE)
 80095b2:	887b      	ldrh	r3, [r7, #2]
 80095b4:	f003 0301 	and.w	r3, r3, #1
 80095b8:	2b00      	cmp	r3, #0
 80095ba:	d003      	beq.n	80095c4 <set_error+0x34>
    sts |= SD_PARITY_ERROR;
 80095bc:	68fb      	ldr	r3, [r7, #12]
 80095be:	f043 0320 	orr.w	r3, r3, #32
 80095c2:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_FE)
 80095c4:	887b      	ldrh	r3, [r7, #2]
 80095c6:	f003 0302 	and.w	r3, r3, #2
 80095ca:	2b00      	cmp	r3, #0
 80095cc:	d003      	beq.n	80095d6 <set_error+0x46>
    sts |= SD_FRAMING_ERROR;
 80095ce:	68fb      	ldr	r3, [r7, #12]
 80095d0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80095d4:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_NE)
 80095d6:	887b      	ldrh	r3, [r7, #2]
 80095d8:	f003 0304 	and.w	r3, r3, #4
 80095dc:	2b00      	cmp	r3, #0
 80095de:	d003      	beq.n	80095e8 <set_error+0x58>
    sts |= SD_NOISE_ERROR;
 80095e0:	68fb      	ldr	r3, [r7, #12]
 80095e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80095e6:	60fb      	str	r3, [r7, #12]
  chnAddFlagsI(sdp, sts);
 80095e8:	687b      	ldr	r3, [r7, #4]
 80095ea:	3304      	adds	r3, #4
 80095ec:	4618      	mov	r0, r3
 80095ee:	68f9      	ldr	r1, [r7, #12]
 80095f0:	f7ff ff68 	bl	80094c4 <osalEventBroadcastFlagsI.lto_priv.168>
}
 80095f4:	3710      	adds	r7, #16
 80095f6:	46bd      	mov	sp, r7
 80095f8:	bd80      	pop	{r7, pc}
 80095fa:	bf00      	nop

080095fc <serve_interrupt>:
=======
 8009614:	b580      	push	{r7, lr}
 8009616:	b084      	sub	sp, #16
 8009618:	af00      	add	r7, sp, #0
 800961a:	6078      	str	r0, [r7, #4]
 800961c:	460b      	mov	r3, r1
 800961e:	807b      	strh	r3, [r7, #2]
  eventflags_t sts = 0;
 8009620:	2300      	movs	r3, #0
 8009622:	60fb      	str	r3, [r7, #12]

  if (sr & USART_SR_ORE)
 8009624:	887b      	ldrh	r3, [r7, #2]
 8009626:	f003 0308 	and.w	r3, r3, #8
 800962a:	2b00      	cmp	r3, #0
 800962c:	d003      	beq.n	8009636 <set_error+0x22>
    sts |= SD_OVERRUN_ERROR;
 800962e:	68fb      	ldr	r3, [r7, #12]
 8009630:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009634:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_PE)
 8009636:	887b      	ldrh	r3, [r7, #2]
 8009638:	f003 0301 	and.w	r3, r3, #1
 800963c:	2b00      	cmp	r3, #0
 800963e:	d003      	beq.n	8009648 <set_error+0x34>
    sts |= SD_PARITY_ERROR;
 8009640:	68fb      	ldr	r3, [r7, #12]
 8009642:	f043 0320 	orr.w	r3, r3, #32
 8009646:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_FE)
 8009648:	887b      	ldrh	r3, [r7, #2]
 800964a:	f003 0302 	and.w	r3, r3, #2
 800964e:	2b00      	cmp	r3, #0
 8009650:	d003      	beq.n	800965a <set_error+0x46>
    sts |= SD_FRAMING_ERROR;
 8009652:	68fb      	ldr	r3, [r7, #12]
 8009654:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009658:	60fb      	str	r3, [r7, #12]
  if (sr & USART_SR_NE)
 800965a:	887b      	ldrh	r3, [r7, #2]
 800965c:	f003 0304 	and.w	r3, r3, #4
 8009660:	2b00      	cmp	r3, #0
 8009662:	d003      	beq.n	800966c <set_error+0x58>
    sts |= SD_NOISE_ERROR;
 8009664:	68fb      	ldr	r3, [r7, #12]
 8009666:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800966a:	60fb      	str	r3, [r7, #12]
  chnAddFlagsI(sdp, sts);
 800966c:	687b      	ldr	r3, [r7, #4]
 800966e:	3304      	adds	r3, #4
 8009670:	4618      	mov	r0, r3
 8009672:	68f9      	ldr	r1, [r7, #12]
 8009674:	f7ff ff68 	bl	8009548 <osalEventBroadcastFlagsI.lto_priv.165>
}
 8009678:	3710      	adds	r7, #16
 800967a:	46bd      	mov	sp, r7
 800967c:	bd80      	pop	{r7, pc}
 800967e:	bf00      	nop

08009680 <serve_interrupt>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
<<<<<<< HEAD
 80095fc:	b580      	push	{r7, lr}
 80095fe:	b086      	sub	sp, #24
 8009600:	af00      	add	r7, sp, #0
 8009602:	6078      	str	r0, [r7, #4]
  USART_TypeDef *u = sdp->usart;
 8009604:	687b      	ldr	r3, [r7, #4]
 8009606:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009608:	613b      	str	r3, [r7, #16]
  uint16_t cr1 = u->CR1;
 800960a:	693b      	ldr	r3, [r7, #16]
 800960c:	68db      	ldr	r3, [r3, #12]
 800960e:	81fb      	strh	r3, [r7, #14]
  uint16_t sr = u->SR;
 8009610:	693b      	ldr	r3, [r7, #16]
 8009612:	681b      	ldr	r3, [r3, #0]
 8009614:	82fb      	strh	r3, [r7, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8009616:	8afb      	ldrh	r3, [r7, #22]
 8009618:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800961c:	2b00      	cmp	r3, #0
 800961e:	d00e      	beq.n	800963e <serve_interrupt+0x42>
    osalSysLockFromISR();
 8009620:	f7ff ff44 	bl	80094ac <osalSysLockFromISR.lto_priv.172>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8009624:	687b      	ldr	r3, [r7, #4]
 8009626:	3304      	adds	r3, #4
 8009628:	4618      	mov	r0, r3
 800962a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800962e:	f7ff ff49 	bl	80094c4 <osalEventBroadcastFlagsI.lto_priv.168>
    u->SR = ~USART_SR_LBD;
 8009632:	693b      	ldr	r3, [r7, #16]
 8009634:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009638:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800963a:	f7ff ff3d 	bl	80094b8 <osalSysUnlockFromISR.lto_priv.170>
=======
 8009680:	b580      	push	{r7, lr}
 8009682:	b086      	sub	sp, #24
 8009684:	af00      	add	r7, sp, #0
 8009686:	6078      	str	r0, [r7, #4]
  USART_TypeDef *u = sdp->usart;
 8009688:	687b      	ldr	r3, [r7, #4]
 800968a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800968c:	613b      	str	r3, [r7, #16]
  uint16_t cr1 = u->CR1;
 800968e:	693b      	ldr	r3, [r7, #16]
 8009690:	68db      	ldr	r3, [r3, #12]
 8009692:	81fb      	strh	r3, [r7, #14]
  uint16_t sr = u->SR;
 8009694:	693b      	ldr	r3, [r7, #16]
 8009696:	681b      	ldr	r3, [r3, #0]
 8009698:	82fb      	strh	r3, [r7, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800969a:	8afb      	ldrh	r3, [r7, #22]
 800969c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80096a0:	2b00      	cmp	r3, #0
 80096a2:	d00e      	beq.n	80096c2 <serve_interrupt+0x42>
    osalSysLockFromISR();
 80096a4:	f7ff ff44 	bl	8009530 <osalSysLockFromISR.lto_priv.169>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80096a8:	687b      	ldr	r3, [r7, #4]
 80096aa:	3304      	adds	r3, #4
 80096ac:	4618      	mov	r0, r3
 80096ae:	f44f 7100 	mov.w	r1, #512	; 0x200
 80096b2:	f7ff ff49 	bl	8009548 <osalEventBroadcastFlagsI.lto_priv.165>
    u->SR = ~USART_SR_LBD;
 80096b6:	693b      	ldr	r3, [r7, #16]
 80096b8:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80096bc:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 80096be:	f7ff ff3d 	bl	800953c <osalSysUnlockFromISR.lto_priv.167>
>>>>>>> 752c83b... update binaries
  }

  /* Data available.*/
  osalSysLockFromISR();
<<<<<<< HEAD
 800963e:	f7ff ff35 	bl	80094ac <osalSysLockFromISR.lto_priv.172>
 8009642:	e01e      	b.n	8009682 <serve_interrupt+0x86>
=======
 80096c2:	f7ff ff35 	bl	8009530 <osalSysLockFromISR.lto_priv.169>
 80096c6:	e01e      	b.n	8009706 <serve_interrupt+0x86>
>>>>>>> 752c83b... update binaries
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
<<<<<<< HEAD
 8009644:	8afb      	ldrh	r3, [r7, #22]
 8009646:	f003 030f 	and.w	r3, r3, #15
 800964a:	2b00      	cmp	r3, #0
 800964c:	d004      	beq.n	8009658 <serve_interrupt+0x5c>
      set_error(sdp, sr);
 800964e:	8afb      	ldrh	r3, [r7, #22]
 8009650:	6878      	ldr	r0, [r7, #4]
 8009652:	4619      	mov	r1, r3
 8009654:	f7ff ff9c 	bl	8009590 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 8009658:	693b      	ldr	r3, [r7, #16]
 800965a:	685b      	ldr	r3, [r3, #4]
 800965c:	b2da      	uxtb	r2, r3
 800965e:	687b      	ldr	r3, [r7, #4]
 8009660:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 8009664:	4013      	ands	r3, r2
 8009666:	737b      	strb	r3, [r7, #13]
    if (sr & USART_SR_RXNE)
 8009668:	8afb      	ldrh	r3, [r7, #22]
 800966a:	f003 0320 	and.w	r3, r3, #32
 800966e:	2b00      	cmp	r3, #0
 8009670:	d004      	beq.n	800967c <serve_interrupt+0x80>
      sdIncomingDataI(sdp, b);
 8009672:	7b7b      	ldrb	r3, [r7, #13]
 8009674:	6878      	ldr	r0, [r7, #4]
 8009676:	4619      	mov	r1, r3
 8009678:	f7ff fc72 	bl	8008f60 <sdIncomingDataI>
    sr = u->SR;
 800967c:	693b      	ldr	r3, [r7, #16]
 800967e:	681b      	ldr	r3, [r3, #0]
 8009680:	82fb      	strh	r3, [r7, #22]
=======
 80096c8:	8afb      	ldrh	r3, [r7, #22]
 80096ca:	f003 030f 	and.w	r3, r3, #15
 80096ce:	2b00      	cmp	r3, #0
 80096d0:	d004      	beq.n	80096dc <serve_interrupt+0x5c>
      set_error(sdp, sr);
 80096d2:	8afb      	ldrh	r3, [r7, #22]
 80096d4:	6878      	ldr	r0, [r7, #4]
 80096d6:	4619      	mov	r1, r3
 80096d8:	f7ff ff9c 	bl	8009614 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 80096dc:	693b      	ldr	r3, [r7, #16]
 80096de:	685b      	ldr	r3, [r3, #4]
 80096e0:	b2da      	uxtb	r2, r3
 80096e2:	687b      	ldr	r3, [r7, #4]
 80096e4:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 80096e8:	4013      	ands	r3, r2
 80096ea:	737b      	strb	r3, [r7, #13]
    if (sr & USART_SR_RXNE)
 80096ec:	8afb      	ldrh	r3, [r7, #22]
 80096ee:	f003 0320 	and.w	r3, r3, #32
 80096f2:	2b00      	cmp	r3, #0
 80096f4:	d004      	beq.n	8009700 <serve_interrupt+0x80>
      sdIncomingDataI(sdp, b);
 80096f6:	7b7b      	ldrb	r3, [r7, #13]
 80096f8:	6878      	ldr	r0, [r7, #4]
 80096fa:	4619      	mov	r1, r3
 80096fc:	f7ff fc72 	bl	8008fe4 <sdIncomingDataI>
    sr = u->SR;
 8009700:	693b      	ldr	r3, [r7, #16]
 8009702:	681b      	ldr	r3, [r3, #0]
 8009704:	82fb      	strh	r3, [r7, #22]
>>>>>>> 752c83b... update binaries
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
<<<<<<< HEAD
 8009682:	8afb      	ldrh	r3, [r7, #22]
 8009684:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 8009688:	2b00      	cmp	r3, #0
 800968a:	d1db      	bne.n	8009644 <serve_interrupt+0x48>
=======
 8009706:	8afb      	ldrh	r3, [r7, #22]
 8009708:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 800970c:	2b00      	cmp	r3, #0
 800970e:	d1db      	bne.n	80096c8 <serve_interrupt+0x48>
>>>>>>> 752c83b... update binaries
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
<<<<<<< HEAD
 800968c:	f7ff ff14 	bl	80094b8 <osalSysUnlockFromISR.lto_priv.170>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8009690:	89fb      	ldrh	r3, [r7, #14]
 8009692:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009696:	2b00      	cmp	r3, #0
 8009698:	d022      	beq.n	80096e0 <serve_interrupt+0xe4>
 800969a:	8afb      	ldrh	r3, [r7, #22]
 800969c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80096a0:	2b00      	cmp	r3, #0
 80096a2:	d01d      	beq.n	80096e0 <serve_interrupt+0xe4>
    msg_t b;
    osalSysLockFromISR();
 80096a4:	f7ff ff02 	bl	80094ac <osalSysLockFromISR.lto_priv.172>
    b = oqGetI(&sdp->oqueue);
 80096a8:	687b      	ldr	r3, [r7, #4]
 80096aa:	3330      	adds	r3, #48	; 0x30
 80096ac:	4618      	mov	r0, r3
 80096ae:	f7ff fa2d 	bl	8008b0c <oqGetI>
 80096b2:	60b8      	str	r0, [r7, #8]
    if (b < MSG_OK) {
 80096b4:	68bb      	ldr	r3, [r7, #8]
 80096b6:	2b00      	cmp	r3, #0
 80096b8:	da0d      	bge.n	80096d6 <serve_interrupt+0xda>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80096ba:	687b      	ldr	r3, [r7, #4]
 80096bc:	3304      	adds	r3, #4
 80096be:	4618      	mov	r0, r3
 80096c0:	2108      	movs	r1, #8
 80096c2:	f7ff feff 	bl	80094c4 <osalEventBroadcastFlagsI.lto_priv.168>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80096c6:	89fb      	ldrh	r3, [r7, #14]
 80096c8:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80096cc:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80096d0:	693b      	ldr	r3, [r7, #16]
 80096d2:	60da      	str	r2, [r3, #12]
 80096d4:	e002      	b.n	80096dc <serve_interrupt+0xe0>
    }
    else
      u->DR = b;
 80096d6:	68ba      	ldr	r2, [r7, #8]
 80096d8:	693b      	ldr	r3, [r7, #16]
 80096da:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 80096dc:	f7ff feec 	bl	80094b8 <osalSysUnlockFromISR.lto_priv.170>
=======
 8009710:	f7ff ff14 	bl	800953c <osalSysUnlockFromISR.lto_priv.167>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8009714:	89fb      	ldrh	r3, [r7, #14]
 8009716:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800971a:	2b00      	cmp	r3, #0
 800971c:	d022      	beq.n	8009764 <serve_interrupt+0xe4>
 800971e:	8afb      	ldrh	r3, [r7, #22]
 8009720:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009724:	2b00      	cmp	r3, #0
 8009726:	d01d      	beq.n	8009764 <serve_interrupt+0xe4>
    msg_t b;
    osalSysLockFromISR();
 8009728:	f7ff ff02 	bl	8009530 <osalSysLockFromISR.lto_priv.169>
    b = oqGetI(&sdp->oqueue);
 800972c:	687b      	ldr	r3, [r7, #4]
 800972e:	3330      	adds	r3, #48	; 0x30
 8009730:	4618      	mov	r0, r3
 8009732:	f7ff fa2d 	bl	8008b90 <oqGetI>
 8009736:	60b8      	str	r0, [r7, #8]
    if (b < MSG_OK) {
 8009738:	68bb      	ldr	r3, [r7, #8]
 800973a:	2b00      	cmp	r3, #0
 800973c:	da0d      	bge.n	800975a <serve_interrupt+0xda>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800973e:	687b      	ldr	r3, [r7, #4]
 8009740:	3304      	adds	r3, #4
 8009742:	4618      	mov	r0, r3
 8009744:	2108      	movs	r1, #8
 8009746:	f7ff feff 	bl	8009548 <osalEventBroadcastFlagsI.lto_priv.165>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800974a:	89fb      	ldrh	r3, [r7, #14]
 800974c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009750:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8009754:	693b      	ldr	r3, [r7, #16]
 8009756:	60da      	str	r2, [r3, #12]
 8009758:	e002      	b.n	8009760 <serve_interrupt+0xe0>
    }
    else
      u->DR = b;
 800975a:	68ba      	ldr	r2, [r7, #8]
 800975c:	693b      	ldr	r3, [r7, #16]
 800975e:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 8009760:	f7ff feec 	bl	800953c <osalSysUnlockFromISR.lto_priv.167>
>>>>>>> 752c83b... update binaries
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
<<<<<<< HEAD
 80096e0:	8afb      	ldrh	r3, [r7, #22]
 80096e2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80096e6:	2b00      	cmp	r3, #0
 80096e8:	d024      	beq.n	8009734 <serve_interrupt+0x138>
    osalSysLockFromISR();
 80096ea:	f7ff fedf 	bl	80094ac <osalSysLockFromISR.lto_priv.172>
    if (oqIsEmptyI(&sdp->oqueue))
 80096ee:	687b      	ldr	r3, [r7, #4]
 80096f0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80096f2:	687b      	ldr	r3, [r7, #4]
 80096f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80096f6:	429a      	cmp	r2, r3
 80096f8:	d105      	bne.n	8009706 <serve_interrupt+0x10a>
 80096fa:	687b      	ldr	r3, [r7, #4]
 80096fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80096fe:	2b00      	cmp	r3, #0
 8009700:	d001      	beq.n	8009706 <serve_interrupt+0x10a>
 8009702:	2301      	movs	r3, #1
 8009704:	e000      	b.n	8009708 <serve_interrupt+0x10c>
 8009706:	2300      	movs	r3, #0
 8009708:	f003 0301 	and.w	r3, r3, #1
 800970c:	b2db      	uxtb	r3, r3
 800970e:	2b00      	cmp	r3, #0
 8009710:	d005      	beq.n	800971e <serve_interrupt+0x122>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8009712:	687b      	ldr	r3, [r7, #4]
 8009714:	3304      	adds	r3, #4
 8009716:	4618      	mov	r0, r3
 8009718:	2110      	movs	r1, #16
 800971a:	f7ff fed3 	bl	80094c4 <osalEventBroadcastFlagsI.lto_priv.168>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800971e:	89fb      	ldrh	r3, [r7, #14]
 8009720:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8009724:	693b      	ldr	r3, [r7, #16]
 8009726:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 8009728:	693b      	ldr	r3, [r7, #16]
 800972a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800972e:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8009730:	f7ff fec2 	bl	80094b8 <osalSysUnlockFromISR.lto_priv.170>
  }
}
 8009734:	3718      	adds	r7, #24
 8009736:	46bd      	mov	sp, r7
 8009738:	bd80      	pop	{r7, pc}
 800973a:	bf00      	nop

0800973c <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 800973c:	b480      	push	{r7}
 800973e:	b083      	sub	sp, #12
 8009740:	af00      	add	r7, sp, #0
 8009742:	6078      	str	r0, [r7, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8009744:	4a05      	ldr	r2, [pc, #20]	; (800975c <notify1+0x20>)
 8009746:	4b05      	ldr	r3, [pc, #20]	; (800975c <notify1+0x20>)
 8009748:	68db      	ldr	r3, [r3, #12]
 800974a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800974e:	60d3      	str	r3, [r2, #12]
}
 8009750:	370c      	adds	r7, #12
 8009752:	46bd      	mov	sp, r7
 8009754:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009758:	4770      	bx	lr
 800975a:	bf00      	nop
 800975c:	40013800 	.word	0x40013800

08009760 <VectorD4>:
=======
 8009764:	8afb      	ldrh	r3, [r7, #22]
 8009766:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800976a:	2b00      	cmp	r3, #0
 800976c:	d024      	beq.n	80097b8 <serve_interrupt+0x138>
    osalSysLockFromISR();
 800976e:	f7ff fedf 	bl	8009530 <osalSysLockFromISR.lto_priv.169>
    if (oqIsEmptyI(&sdp->oqueue))
 8009772:	687b      	ldr	r3, [r7, #4]
 8009774:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009776:	687b      	ldr	r3, [r7, #4]
 8009778:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800977a:	429a      	cmp	r2, r3
 800977c:	d105      	bne.n	800978a <serve_interrupt+0x10a>
 800977e:	687b      	ldr	r3, [r7, #4]
 8009780:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009782:	2b00      	cmp	r3, #0
 8009784:	d001      	beq.n	800978a <serve_interrupt+0x10a>
 8009786:	2301      	movs	r3, #1
 8009788:	e000      	b.n	800978c <serve_interrupt+0x10c>
 800978a:	2300      	movs	r3, #0
 800978c:	f003 0301 	and.w	r3, r3, #1
 8009790:	b2db      	uxtb	r3, r3
 8009792:	2b00      	cmp	r3, #0
 8009794:	d005      	beq.n	80097a2 <serve_interrupt+0x122>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8009796:	687b      	ldr	r3, [r7, #4]
 8009798:	3304      	adds	r3, #4
 800979a:	4618      	mov	r0, r3
 800979c:	2110      	movs	r1, #16
 800979e:	f7ff fed3 	bl	8009548 <osalEventBroadcastFlagsI.lto_priv.165>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80097a2:	89fb      	ldrh	r3, [r7, #14]
 80097a4:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 80097a8:	693b      	ldr	r3, [r7, #16]
 80097aa:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 80097ac:	693b      	ldr	r3, [r7, #16]
 80097ae:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80097b2:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 80097b4:	f7ff fec2 	bl	800953c <osalSysUnlockFromISR.lto_priv.167>
  }
}
 80097b8:	3718      	adds	r7, #24
 80097ba:	46bd      	mov	sp, r7
 80097bc:	bd80      	pop	{r7, pc}
 80097be:	bf00      	nop

080097c0 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 80097c0:	b480      	push	{r7}
 80097c2:	b083      	sub	sp, #12
 80097c4:	af00      	add	r7, sp, #0
 80097c6:	6078      	str	r0, [r7, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 80097c8:	4a05      	ldr	r2, [pc, #20]	; (80097e0 <notify1+0x20>)
 80097ca:	4b05      	ldr	r3, [pc, #20]	; (80097e0 <notify1+0x20>)
 80097cc:	68db      	ldr	r3, [r3, #12]
 80097ce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80097d2:	60d3      	str	r3, [r2, #12]
}
 80097d4:	370c      	adds	r7, #12
 80097d6:	46bd      	mov	sp, r7
 80097d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097dc:	4770      	bx	lr
 80097de:	bf00      	nop
 80097e0:	40013800 	.word	0x40013800

080097e4 <VectorD4>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
<<<<<<< HEAD
 8009760:	b580      	push	{r7, lr}
 8009762:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 8009764:	f001 fbc4 	bl	800aef0 <_dbg_check_enter_isr>

  serve_interrupt(&SD1);
 8009768:	4803      	ldr	r0, [pc, #12]	; (8009778 <VectorD4+0x18>)
 800976a:	f7ff ff47 	bl	80095fc <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800976e:	f001 fbdb 	bl	800af28 <_dbg_check_leave_isr>
 8009772:	f000 fafd 	bl	8009d70 <_port_irq_epilogue>
}
 8009776:	bd80      	pop	{r7, pc}
 8009778:	200013ac 	.word	0x200013ac

0800977c <sd_lld_init>:
=======
 80097e4:	b580      	push	{r7, lr}
 80097e6:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 80097e8:	f001 fbc6 	bl	800af78 <_dbg_check_enter_isr>

  serve_interrupt(&SD1);
 80097ec:	4803      	ldr	r0, [pc, #12]	; (80097fc <VectorD4+0x18>)
 80097ee:	f7ff ff47 	bl	8009680 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80097f2:	f001 fbdd 	bl	800afb0 <_dbg_check_leave_isr>
 80097f6:	f000 faff 	bl	8009df8 <_port_irq_epilogue>
}
 80097fa:	bd80      	pop	{r7, pc}
 80097fc:	200013ac 	.word	0x200013ac

08009800 <sd_lld_init>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
<<<<<<< HEAD
 800977c:	b580      	push	{r7, lr}
 800977e:	af00      	add	r7, sp, #0

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8009780:	4804      	ldr	r0, [pc, #16]	; (8009794 <sd_lld_init+0x18>)
 8009782:	2100      	movs	r1, #0
 8009784:	4a04      	ldr	r2, [pc, #16]	; (8009798 <sd_lld_init+0x1c>)
 8009786:	f7ff fb93 	bl	8008eb0 <sdObjectInit>
  SD1.usart = USART1;
 800978a:	4b02      	ldr	r3, [pc, #8]	; (8009794 <sd_lld_init+0x18>)
 800978c:	4a03      	ldr	r2, [pc, #12]	; (800979c <sd_lld_init+0x20>)
 800978e:	675a      	str	r2, [r3, #116]	; 0x74
=======
 8009800:	b580      	push	{r7, lr}
 8009802:	af00      	add	r7, sp, #0

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8009804:	4804      	ldr	r0, [pc, #16]	; (8009818 <sd_lld_init+0x18>)
 8009806:	2100      	movs	r1, #0
 8009808:	4a04      	ldr	r2, [pc, #16]	; (800981c <sd_lld_init+0x1c>)
 800980a:	f7ff fb93 	bl	8008f34 <sdObjectInit>
  SD1.usart = USART1;
 800980e:	4b02      	ldr	r3, [pc, #8]	; (8009818 <sd_lld_init+0x18>)
 8009810:	4a03      	ldr	r2, [pc, #12]	; (8009820 <sd_lld_init+0x20>)
 8009812:	675a      	str	r2, [r3, #116]	; 0x74
>>>>>>> 752c83b... update binaries

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
<<<<<<< HEAD
 8009790:	bd80      	pop	{r7, pc}
 8009792:	bf00      	nop
 8009794:	200013ac 	.word	0x200013ac
 8009798:	0800973d 	.word	0x0800973d
 800979c:	40013800 	.word	0x40013800

080097a0 <sd_lld_start>:
=======
 8009814:	bd80      	pop	{r7, pc}
 8009816:	bf00      	nop
 8009818:	200013ac 	.word	0x200013ac
 800981c:	080097c1 	.word	0x080097c1
 8009820:	40013800 	.word	0x40013800

08009824 <sd_lld_start>:
>>>>>>> 752c83b... update binaries
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
<<<<<<< HEAD
 80097a0:	b580      	push	{r7, lr}
 80097a2:	b082      	sub	sp, #8
 80097a4:	af00      	add	r7, sp, #0
 80097a6:	6078      	str	r0, [r7, #4]
 80097a8:	6039      	str	r1, [r7, #0]

  if (config == NULL)
 80097aa:	683b      	ldr	r3, [r7, #0]
 80097ac:	2b00      	cmp	r3, #0
 80097ae:	d101      	bne.n	80097b4 <sd_lld_start+0x14>
    config = &default_config;
 80097b0:	4b0d      	ldr	r3, [pc, #52]	; (80097e8 <sd_lld_start+0x48>)
 80097b2:	603b      	str	r3, [r7, #0]

  if (sdp->state == SD_STOP) {
 80097b4:	687b      	ldr	r3, [r7, #4]
 80097b6:	7a1b      	ldrb	r3, [r3, #8]
 80097b8:	2b01      	cmp	r3, #1
 80097ba:	d10d      	bne.n	80097d8 <sd_lld_start+0x38>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 80097bc:	687b      	ldr	r3, [r7, #4]
 80097be:	4a0b      	ldr	r2, [pc, #44]	; (80097ec <sd_lld_start+0x4c>)
 80097c0:	4293      	cmp	r3, r2
 80097c2:	d109      	bne.n	80097d8 <sd_lld_start+0x38>
      rccEnableUSART1(FALSE);
 80097c4:	4a0a      	ldr	r2, [pc, #40]	; (80097f0 <sd_lld_start+0x50>)
 80097c6:	4b0a      	ldr	r3, [pc, #40]	; (80097f0 <sd_lld_start+0x50>)
 80097c8:	699b      	ldr	r3, [r3, #24]
 80097ca:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80097ce:	6193      	str	r3, [r2, #24]
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 80097d0:	2025      	movs	r0, #37	; 0x25
 80097d2:	210c      	movs	r1, #12
 80097d4:	f7ff fc70 	bl	80090b8 <nvicEnableVector>
=======
 8009824:	b580      	push	{r7, lr}
 8009826:	b082      	sub	sp, #8
 8009828:	af00      	add	r7, sp, #0
 800982a:	6078      	str	r0, [r7, #4]
 800982c:	6039      	str	r1, [r7, #0]

  if (config == NULL)
 800982e:	683b      	ldr	r3, [r7, #0]
 8009830:	2b00      	cmp	r3, #0
 8009832:	d101      	bne.n	8009838 <sd_lld_start+0x14>
    config = &default_config;
 8009834:	4b0d      	ldr	r3, [pc, #52]	; (800986c <sd_lld_start+0x48>)
 8009836:	603b      	str	r3, [r7, #0]

  if (sdp->state == SD_STOP) {
 8009838:	687b      	ldr	r3, [r7, #4]
 800983a:	7a1b      	ldrb	r3, [r3, #8]
 800983c:	2b01      	cmp	r3, #1
 800983e:	d10d      	bne.n	800985c <sd_lld_start+0x38>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8009840:	687b      	ldr	r3, [r7, #4]
 8009842:	4a0b      	ldr	r2, [pc, #44]	; (8009870 <sd_lld_start+0x4c>)
 8009844:	4293      	cmp	r3, r2
 8009846:	d109      	bne.n	800985c <sd_lld_start+0x38>
      rccEnableUSART1(FALSE);
 8009848:	4a0a      	ldr	r2, [pc, #40]	; (8009874 <sd_lld_start+0x50>)
 800984a:	4b0a      	ldr	r3, [pc, #40]	; (8009874 <sd_lld_start+0x50>)
 800984c:	699b      	ldr	r3, [r3, #24]
 800984e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009852:	6193      	str	r3, [r2, #24]
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8009854:	2025      	movs	r0, #37	; 0x25
 8009856:	210c      	movs	r1, #12
 8009858:	f7ff fc70 	bl	800913c <nvicEnableVector>
>>>>>>> 752c83b... update binaries
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
<<<<<<< HEAD
 80097d8:	6878      	ldr	r0, [r7, #4]
 80097da:	6839      	ldr	r1, [r7, #0]
 80097dc:	f7ff fe82 	bl	80094e4 <usart_init>
}
 80097e0:	3708      	adds	r7, #8
 80097e2:	46bd      	mov	sp, r7
 80097e4:	bd80      	pop	{r7, pc}
 80097e6:	bf00      	nop
 80097e8:	0800eb24 	.word	0x0800eb24
 80097ec:	200013ac 	.word	0x200013ac
 80097f0:	40021000 	.word	0x40021000

080097f4 <boardInit>:
#include <hal.h>

void boardInit(void) {
 80097f4:	b580      	push	{r7, lr}
 80097f6:	af00      	add	r7, sp, #0
=======
 800985c:	6878      	ldr	r0, [r7, #4]
 800985e:	6839      	ldr	r1, [r7, #0]
 8009860:	f7ff fe82 	bl	8009568 <usart_init>
}
 8009864:	3708      	adds	r7, #8
 8009866:	46bd      	mov	sp, r7
 8009868:	bd80      	pop	{r7, pc}
 800986a:	bf00      	nop
 800986c:	0800ebfc 	.word	0x0800ebfc
 8009870:	200013ac 	.word	0x200013ac
 8009874:	40021000 	.word	0x40021000

08009878 <boardInit>:
#include <hal.h>

void boardInit(void) {
 8009878:	b580      	push	{r7, lr}
 800987a:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

    /*
     * Activates the serial driver 1 using the driver default configuration.
     * PA9 and PA10 are routed to USART1.
     */
    sdStart(&SD1, &uartCfg);
<<<<<<< HEAD
 80097f8:	4802      	ldr	r0, [pc, #8]	; (8009804 <boardInit+0x10>)
 80097fa:	4903      	ldr	r1, [pc, #12]	; (8009808 <boardInit+0x14>)
 80097fc:	f7ff fb8a 	bl	8008f14 <sdStart>
=======
 800987c:	4802      	ldr	r0, [pc, #8]	; (8009888 <boardInit+0x10>)
 800987e:	4903      	ldr	r1, [pc, #12]	; (800988c <boardInit+0x14>)
 8009880:	f7ff fb8a 	bl	8008f98 <sdStart>
>>>>>>> 752c83b... update binaries

    /* this is set in board.h */
//    palSetPadMode(GPIOA, 9, PPAL_MODE_STM32_ALTERNATE_PUSHPULL);
//    palSetPadMode(GPIOA, 10, PAL_MODE_INPUT);
}
<<<<<<< HEAD
 8009800:	bd80      	pop	{r7, pc}
 8009802:	bf00      	nop
 8009804:	200013ac 	.word	0x200013ac
 8009808:	0800eb30 	.word	0x0800eb30

0800980c <param_struct_valid>:
=======
 8009884:	bd80      	pop	{r7, pc}
 8009886:	bf00      	nop
 8009888:	200013ac 	.word	0x200013ac
 800988c:	0800ec08 	.word	0x0800ec08

08009890 <param_struct_valid>:
>>>>>>> 752c83b... update binaries
{
    return shared_find_marker(*((uint64_t*)SHARED_APP_DESCRIPTOR_SIGNATURE), buf, buf_len);
}

static bool param_struct_valid(const struct shared_app_parameters_s* parameters, bool ignore_crc64)
{
<<<<<<< HEAD
 800980c:	b5b0      	push	{r4, r5, r7, lr}
 800980e:	b082      	sub	sp, #8
 8009810:	af00      	add	r7, sp, #0
 8009812:	6078      	str	r0, [r7, #4]
 8009814:	460b      	mov	r3, r1
 8009816:	70fb      	strb	r3, [r7, #3]
    return parameters && (ignore_crc64 || crc64_we((uint8_t*)parameters, sizeof(struct shared_app_parameters_s)-sizeof(uint64_t), 0) == parameters->crc64);
 8009818:	687b      	ldr	r3, [r7, #4]
 800981a:	2b00      	cmp	r3, #0
 800981c:	d017      	beq.n	800984e <param_struct_valid+0x42>
 800981e:	78fb      	ldrb	r3, [r7, #3]
 8009820:	2b00      	cmp	r3, #0
 8009822:	d112      	bne.n	800984a <param_struct_valid+0x3e>
 8009824:	6878      	ldr	r0, [r7, #4]
 8009826:	2107      	movs	r1, #7
 8009828:	f04f 0200 	mov.w	r2, #0
 800982c:	f04f 0300 	mov.w	r3, #0
 8009830:	f000 f866 	bl	8009900 <crc64_we>
 8009834:	4604      	mov	r4, r0
 8009836:	460d      	mov	r5, r1
 8009838:	6879      	ldr	r1, [r7, #4]
 800983a:	f8d1 2007 	ldr.w	r2, [r1, #7]
 800983e:	f8d1 300b 	ldr.w	r3, [r1, #11]
 8009842:	429d      	cmp	r5, r3
 8009844:	bf08      	it	eq
 8009846:	4294      	cmpeq	r4, r2
 8009848:	d101      	bne.n	800984e <param_struct_valid+0x42>
 800984a:	2301      	movs	r3, #1
 800984c:	e000      	b.n	8009850 <param_struct_valid+0x44>
 800984e:	2300      	movs	r3, #0
 8009850:	f003 0301 	and.w	r3, r3, #1
 8009854:	b2db      	uxtb	r3, r3
}
 8009856:	4618      	mov	r0, r3
 8009858:	3708      	adds	r7, #8
 800985a:	46bd      	mov	sp, r7
 800985c:	bdb0      	pop	{r4, r5, r7, pc}
 800985e:	bf00      	nop

08009860 <shared_get_parameters>:

const struct shared_app_parameters_s* shared_get_parameters(const struct shared_app_descriptor_s* descriptor)
{
 8009860:	b580      	push	{r7, lr}
 8009862:	b084      	sub	sp, #16
 8009864:	af00      	add	r7, sp, #0
 8009866:	6078      	str	r0, [r7, #4]
    if (descriptor->parameters_fmt != SHARED_APP_PARAMETERS_FMT) {
 8009868:	687b      	ldr	r3, [r7, #4]
 800986a:	7e9b      	ldrb	r3, [r3, #26]
 800986c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009870:	b2db      	uxtb	r3, r3
 8009872:	2b01      	cmp	r3, #1
 8009874:	d001      	beq.n	800987a <shared_get_parameters+0x1a>
        return 0;
 8009876:	2300      	movs	r3, #0
 8009878:	e03e      	b.n	80098f8 <shared_get_parameters+0x98>
    }

    const struct shared_app_parameters_s* ret = 0;
 800987a:	2300      	movs	r3, #0
 800987c:	60fb      	str	r3, [r7, #12]

    for (uint8_t i=0; i<2; i++) {
 800987e:	2300      	movs	r3, #0
 8009880:	72fb      	strb	r3, [r7, #11]
 8009882:	e035      	b.n	80098f0 <shared_get_parameters+0x90>
        if (param_struct_valid(descriptor->parameters[i], descriptor->parameters_ignore_crc64) &&
 8009884:	7afb      	ldrb	r3, [r7, #11]
 8009886:	687a      	ldr	r2, [r7, #4]
 8009888:	3306      	adds	r3, #6
 800988a:	009b      	lsls	r3, r3, #2
 800988c:	4413      	add	r3, r2
 800988e:	f8d3 2003 	ldr.w	r2, [r3, #3]
 8009892:	687b      	ldr	r3, [r7, #4]
 8009894:	7e9b      	ldrb	r3, [r3, #26]
 8009896:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800989a:	b2db      	uxtb	r3, r3
 800989c:	2b00      	cmp	r3, #0
 800989e:	bf14      	ite	ne
 80098a0:	2301      	movne	r3, #1
 80098a2:	2300      	moveq	r3, #0
 80098a4:	b2db      	uxtb	r3, r3
 80098a6:	4610      	mov	r0, r2
 80098a8:	4619      	mov	r1, r3
 80098aa:	f7ff ffaf 	bl	800980c <param_struct_valid>
 80098ae:	4603      	mov	r3, r0
 80098b0:	2b00      	cmp	r3, #0
 80098b2:	d01a      	beq.n	80098ea <shared_get_parameters+0x8a>
 80098b4:	68fb      	ldr	r3, [r7, #12]
 80098b6:	2b00      	cmp	r3, #0
 80098b8:	d00f      	beq.n	80098da <shared_get_parameters+0x7a>
            (!ret || (int8_t)(descriptor->parameters[i]->param_idx-ret->param_idx) > 0)) {
 80098ba:	7afb      	ldrb	r3, [r7, #11]
 80098bc:	687a      	ldr	r2, [r7, #4]
 80098be:	3306      	adds	r3, #6
 80098c0:	009b      	lsls	r3, r3, #2
 80098c2:	4413      	add	r3, r2
 80098c4:	f8d3 3003 	ldr.w	r3, [r3, #3]
 80098c8:	781a      	ldrb	r2, [r3, #0]
 80098ca:	68fb      	ldr	r3, [r7, #12]
 80098cc:	781b      	ldrb	r3, [r3, #0]
 80098ce:	1ad3      	subs	r3, r2, r3
 80098d0:	b2db      	uxtb	r3, r3
 80098d2:	b2db      	uxtb	r3, r3
 80098d4:	b25b      	sxtb	r3, r3
 80098d6:	2b00      	cmp	r3, #0
 80098d8:	dd07      	ble.n	80098ea <shared_get_parameters+0x8a>
            ret = descriptor->parameters[i];
 80098da:	7afb      	ldrb	r3, [r7, #11]
 80098dc:	687a      	ldr	r2, [r7, #4]
 80098de:	3306      	adds	r3, #6
 80098e0:	009b      	lsls	r3, r3, #2
 80098e2:	4413      	add	r3, r2
 80098e4:	f8d3 3003 	ldr.w	r3, [r3, #3]
 80098e8:	60fb      	str	r3, [r7, #12]
=======
 8009890:	b5b0      	push	{r4, r5, r7, lr}
 8009892:	b082      	sub	sp, #8
 8009894:	af00      	add	r7, sp, #0
 8009896:	6078      	str	r0, [r7, #4]
 8009898:	460b      	mov	r3, r1
 800989a:	70fb      	strb	r3, [r7, #3]
    return parameters && (ignore_crc64 || crc64_we((uint8_t*)parameters, sizeof(struct shared_app_parameters_s)-sizeof(uint64_t), 0) == parameters->crc64);
 800989c:	687b      	ldr	r3, [r7, #4]
 800989e:	2b00      	cmp	r3, #0
 80098a0:	d017      	beq.n	80098d2 <param_struct_valid+0x42>
 80098a2:	78fb      	ldrb	r3, [r7, #3]
 80098a4:	2b00      	cmp	r3, #0
 80098a6:	d112      	bne.n	80098ce <param_struct_valid+0x3e>
 80098a8:	6878      	ldr	r0, [r7, #4]
 80098aa:	2107      	movs	r1, #7
 80098ac:	f04f 0200 	mov.w	r2, #0
 80098b0:	f04f 0300 	mov.w	r3, #0
 80098b4:	f000 f868 	bl	8009988 <crc64_we>
 80098b8:	4604      	mov	r4, r0
 80098ba:	460d      	mov	r5, r1
 80098bc:	6879      	ldr	r1, [r7, #4]
 80098be:	f8d1 2007 	ldr.w	r2, [r1, #7]
 80098c2:	f8d1 300b 	ldr.w	r3, [r1, #11]
 80098c6:	429d      	cmp	r5, r3
 80098c8:	bf08      	it	eq
 80098ca:	4294      	cmpeq	r4, r2
 80098cc:	d101      	bne.n	80098d2 <param_struct_valid+0x42>
 80098ce:	2301      	movs	r3, #1
 80098d0:	e000      	b.n	80098d4 <param_struct_valid+0x44>
 80098d2:	2300      	movs	r3, #0
 80098d4:	f003 0301 	and.w	r3, r3, #1
 80098d8:	b2db      	uxtb	r3, r3
}
 80098da:	4618      	mov	r0, r3
 80098dc:	3708      	adds	r7, #8
 80098de:	46bd      	mov	sp, r7
 80098e0:	bdb0      	pop	{r4, r5, r7, pc}
 80098e2:	bf00      	nop

080098e4 <shared_get_parameters>:

const struct shared_app_parameters_s* shared_get_parameters(const struct shared_app_descriptor_s* descriptor)
{
 80098e4:	b580      	push	{r7, lr}
 80098e6:	b084      	sub	sp, #16
 80098e8:	af00      	add	r7, sp, #0
 80098ea:	6078      	str	r0, [r7, #4]
    if (descriptor->parameters_fmt != SHARED_APP_PARAMETERS_FMT) {
 80098ec:	687b      	ldr	r3, [r7, #4]
 80098ee:	7e9b      	ldrb	r3, [r3, #26]
 80098f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80098f4:	b2db      	uxtb	r3, r3
 80098f6:	2b01      	cmp	r3, #1
 80098f8:	d001      	beq.n	80098fe <shared_get_parameters+0x1a>
        return 0;
 80098fa:	2300      	movs	r3, #0
 80098fc:	e03e      	b.n	800997c <shared_get_parameters+0x98>
    }

    const struct shared_app_parameters_s* ret = 0;
 80098fe:	2300      	movs	r3, #0
 8009900:	60fb      	str	r3, [r7, #12]

    for (uint8_t i=0; i<2; i++) {
 8009902:	2300      	movs	r3, #0
 8009904:	72fb      	strb	r3, [r7, #11]
 8009906:	e035      	b.n	8009974 <shared_get_parameters+0x90>
        if (param_struct_valid(descriptor->parameters[i], descriptor->parameters_ignore_crc64) &&
 8009908:	7afb      	ldrb	r3, [r7, #11]
 800990a:	687a      	ldr	r2, [r7, #4]
 800990c:	3306      	adds	r3, #6
 800990e:	009b      	lsls	r3, r3, #2
 8009910:	4413      	add	r3, r2
 8009912:	f8d3 2003 	ldr.w	r2, [r3, #3]
 8009916:	687b      	ldr	r3, [r7, #4]
 8009918:	7e9b      	ldrb	r3, [r3, #26]
 800991a:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800991e:	b2db      	uxtb	r3, r3
 8009920:	2b00      	cmp	r3, #0
 8009922:	bf14      	ite	ne
 8009924:	2301      	movne	r3, #1
 8009926:	2300      	moveq	r3, #0
 8009928:	b2db      	uxtb	r3, r3
 800992a:	4610      	mov	r0, r2
 800992c:	4619      	mov	r1, r3
 800992e:	f7ff ffaf 	bl	8009890 <param_struct_valid>
 8009932:	4603      	mov	r3, r0
 8009934:	2b00      	cmp	r3, #0
 8009936:	d01a      	beq.n	800996e <shared_get_parameters+0x8a>
 8009938:	68fb      	ldr	r3, [r7, #12]
 800993a:	2b00      	cmp	r3, #0
 800993c:	d00f      	beq.n	800995e <shared_get_parameters+0x7a>
            (!ret || (int8_t)(descriptor->parameters[i]->param_idx-ret->param_idx) > 0)) {
 800993e:	7afb      	ldrb	r3, [r7, #11]
 8009940:	687a      	ldr	r2, [r7, #4]
 8009942:	3306      	adds	r3, #6
 8009944:	009b      	lsls	r3, r3, #2
 8009946:	4413      	add	r3, r2
 8009948:	f8d3 3003 	ldr.w	r3, [r3, #3]
 800994c:	781a      	ldrb	r2, [r3, #0]
 800994e:	68fb      	ldr	r3, [r7, #12]
 8009950:	781b      	ldrb	r3, [r3, #0]
 8009952:	1ad3      	subs	r3, r2, r3
 8009954:	b2db      	uxtb	r3, r3
 8009956:	b2db      	uxtb	r3, r3
 8009958:	b25b      	sxtb	r3, r3
 800995a:	2b00      	cmp	r3, #0
 800995c:	dd07      	ble.n	800996e <shared_get_parameters+0x8a>
            ret = descriptor->parameters[i];
 800995e:	7afb      	ldrb	r3, [r7, #11]
 8009960:	687a      	ldr	r2, [r7, #4]
 8009962:	3306      	adds	r3, #6
 8009964:	009b      	lsls	r3, r3, #2
 8009966:	4413      	add	r3, r2
 8009968:	f8d3 3003 	ldr.w	r3, [r3, #3]
 800996c:	60fb      	str	r3, [r7, #12]
>>>>>>> 752c83b... update binaries
        return 0;
    }

    const struct shared_app_parameters_s* ret = 0;

    for (uint8_t i=0; i<2; i++) {
<<<<<<< HEAD
 80098ea:	7afb      	ldrb	r3, [r7, #11]
 80098ec:	3301      	adds	r3, #1
 80098ee:	72fb      	strb	r3, [r7, #11]
 80098f0:	7afb      	ldrb	r3, [r7, #11]
 80098f2:	2b01      	cmp	r3, #1
 80098f4:	d9c6      	bls.n	8009884 <shared_get_parameters+0x24>
=======
 800996e:	7afb      	ldrb	r3, [r7, #11]
 8009970:	3301      	adds	r3, #1
 8009972:	72fb      	strb	r3, [r7, #11]
 8009974:	7afb      	ldrb	r3, [r7, #11]
 8009976:	2b01      	cmp	r3, #1
 8009978:	d9c6      	bls.n	8009908 <shared_get_parameters+0x24>
>>>>>>> 752c83b... update binaries
            (!ret || (int8_t)(descriptor->parameters[i]->param_idx-ret->param_idx) > 0)) {
            ret = descriptor->parameters[i];
        }
    }

    return ret;
<<<<<<< HEAD
 80098f6:	68fb      	ldr	r3, [r7, #12]
}
 80098f8:	4618      	mov	r0, r3
 80098fa:	3710      	adds	r7, #16
 80098fc:	46bd      	mov	sp, r7
 80098fe:	bd80      	pop	{r7, pc}

08009900 <crc64_we>:
=======
 800997a:	68fb      	ldr	r3, [r7, #12]
}
 800997c:	4618      	mov	r0, r3
 800997e:	3710      	adds	r7, #16
 8009980:	46bd      	mov	sp, r7
 8009982:	bd80      	pop	{r7, pc}
 8009984:	0000      	movs	r0, r0
	...

08009988 <crc64_we>:
>>>>>>> 752c83b... update binaries
#include <common/crc64_we.h>

uint64_t crc64_we(const uint8_t *buf, uint32_t len, uint64_t crc)
{
<<<<<<< HEAD
 8009900:	b4b0      	push	{r4, r5, r7}
 8009902:	b087      	sub	sp, #28
 8009904:	af00      	add	r7, sp, #0
 8009906:	60f8      	str	r0, [r7, #12]
 8009908:	60b9      	str	r1, [r7, #8]
 800990a:	e9c7 2300 	strd	r2, r3, [r7]
=======
 8009988:	b4b0      	push	{r4, r5, r7}
 800998a:	b087      	sub	sp, #28
 800998c:	af00      	add	r7, sp, #0
 800998e:	60f8      	str	r0, [r7, #12]
 8009990:	60b9      	str	r1, [r7, #8]
 8009992:	e9c7 2300 	strd	r2, r3, [r7]
>>>>>>> 752c83b... update binaries
    uint32_t i;
    uint8_t j;

    crc = ~crc;
<<<<<<< HEAD
 800990e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009912:	ea6f 0202 	mvn.w	r2, r2
 8009916:	ea6f 0303 	mvn.w	r3, r3
 800991a:	e9c7 2300 	strd	r2, r3, [r7]

    for (i = 0; i < len; i++) {
 800991e:	2300      	movs	r3, #0
 8009920:	617b      	str	r3, [r7, #20]
 8009922:	e036      	b.n	8009992 <crc64_we+0x92>
        crc ^= ((uint64_t)buf[i]) << 56;
 8009924:	68fa      	ldr	r2, [r7, #12]
 8009926:	697b      	ldr	r3, [r7, #20]
 8009928:	4413      	add	r3, r2
 800992a:	781b      	ldrb	r3, [r3, #0]
 800992c:	b2da      	uxtb	r2, r3
 800992e:	f04f 0300 	mov.w	r3, #0
 8009932:	0615      	lsls	r5, r2, #24
 8009934:	2400      	movs	r4, #0
 8009936:	e9d7 2300 	ldrd	r2, r3, [r7]
 800993a:	ea82 0204 	eor.w	r2, r2, r4
 800993e:	ea83 0305 	eor.w	r3, r3, r5
 8009942:	e9c7 2300 	strd	r2, r3, [r7]
        for (j = 0; j < 8; j++) {
 8009946:	2300      	movs	r3, #0
 8009948:	74fb      	strb	r3, [r7, #19]
 800994a:	e01c      	b.n	8009986 <crc64_we+0x86>
            crc = (crc & (1ULL<<63)) ? (crc<<1)^0x42F0E1EBA9EA3693ULL : (crc<<1);
 800994c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009950:	2a00      	cmp	r2, #0
 8009952:	f173 0300 	sbcs.w	r3, r3, #0
 8009956:	da0c      	bge.n	8009972 <crc64_we+0x72>
 8009958:	e9d7 2300 	ldrd	r2, r3, [r7]
 800995c:	1892      	adds	r2, r2, r2
 800995e:	eb43 0303 	adc.w	r3, r3, r3
 8009962:	a115      	add	r1, pc, #84	; (adr r1, 80099b8 <crc64_we+0xb8>)
 8009964:	e9d1 0100 	ldrd	r0, r1, [r1]
 8009968:	ea82 0200 	eor.w	r2, r2, r0
 800996c:	ea83 0301 	eor.w	r3, r3, r1
 8009970:	e004      	b.n	800997c <crc64_we+0x7c>
 8009972:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009976:	1892      	adds	r2, r2, r2
 8009978:	eb43 0303 	adc.w	r3, r3, r3
 800997c:	e9c7 2300 	strd	r2, r3, [r7]
=======
 8009996:	e9d7 2300 	ldrd	r2, r3, [r7]
 800999a:	ea6f 0202 	mvn.w	r2, r2
 800999e:	ea6f 0303 	mvn.w	r3, r3
 80099a2:	e9c7 2300 	strd	r2, r3, [r7]

    for (i = 0; i < len; i++) {
 80099a6:	2300      	movs	r3, #0
 80099a8:	617b      	str	r3, [r7, #20]
 80099aa:	e036      	b.n	8009a1a <crc64_we+0x92>
        crc ^= ((uint64_t)buf[i]) << 56;
 80099ac:	68fa      	ldr	r2, [r7, #12]
 80099ae:	697b      	ldr	r3, [r7, #20]
 80099b0:	4413      	add	r3, r2
 80099b2:	781b      	ldrb	r3, [r3, #0]
 80099b4:	b2da      	uxtb	r2, r3
 80099b6:	f04f 0300 	mov.w	r3, #0
 80099ba:	0615      	lsls	r5, r2, #24
 80099bc:	2400      	movs	r4, #0
 80099be:	e9d7 2300 	ldrd	r2, r3, [r7]
 80099c2:	ea82 0204 	eor.w	r2, r2, r4
 80099c6:	ea83 0305 	eor.w	r3, r3, r5
 80099ca:	e9c7 2300 	strd	r2, r3, [r7]
        for (j = 0; j < 8; j++) {
 80099ce:	2300      	movs	r3, #0
 80099d0:	74fb      	strb	r3, [r7, #19]
 80099d2:	e01c      	b.n	8009a0e <crc64_we+0x86>
            crc = (crc & (1ULL<<63)) ? (crc<<1)^0x42F0E1EBA9EA3693ULL : (crc<<1);
 80099d4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80099d8:	2a00      	cmp	r2, #0
 80099da:	f173 0300 	sbcs.w	r3, r3, #0
 80099de:	da0c      	bge.n	80099fa <crc64_we+0x72>
 80099e0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80099e4:	1892      	adds	r2, r2, r2
 80099e6:	eb43 0303 	adc.w	r3, r3, r3
 80099ea:	a115      	add	r1, pc, #84	; (adr r1, 8009a40 <crc64_we+0xb8>)
 80099ec:	e9d1 0100 	ldrd	r0, r1, [r1]
 80099f0:	ea82 0200 	eor.w	r2, r2, r0
 80099f4:	ea83 0301 	eor.w	r3, r3, r1
 80099f8:	e004      	b.n	8009a04 <crc64_we+0x7c>
 80099fa:	e9d7 2300 	ldrd	r2, r3, [r7]
 80099fe:	1892      	adds	r2, r2, r2
 8009a00:	eb43 0303 	adc.w	r3, r3, r3
 8009a04:	e9c7 2300 	strd	r2, r3, [r7]
>>>>>>> 752c83b... update binaries

    crc = ~crc;

    for (i = 0; i < len; i++) {
        crc ^= ((uint64_t)buf[i]) << 56;
        for (j = 0; j < 8; j++) {
<<<<<<< HEAD
 8009980:	7cfb      	ldrb	r3, [r7, #19]
 8009982:	3301      	adds	r3, #1
 8009984:	74fb      	strb	r3, [r7, #19]
 8009986:	7cfb      	ldrb	r3, [r7, #19]
 8009988:	2b07      	cmp	r3, #7
 800998a:	d9df      	bls.n	800994c <crc64_we+0x4c>
=======
 8009a08:	7cfb      	ldrb	r3, [r7, #19]
 8009a0a:	3301      	adds	r3, #1
 8009a0c:	74fb      	strb	r3, [r7, #19]
 8009a0e:	7cfb      	ldrb	r3, [r7, #19]
 8009a10:	2b07      	cmp	r3, #7
 8009a12:	d9df      	bls.n	80099d4 <crc64_we+0x4c>
>>>>>>> 752c83b... update binaries
    uint32_t i;
    uint8_t j;

    crc = ~crc;

    for (i = 0; i < len; i++) {
<<<<<<< HEAD
 800998c:	697b      	ldr	r3, [r7, #20]
 800998e:	3301      	adds	r3, #1
 8009990:	617b      	str	r3, [r7, #20]
 8009992:	697a      	ldr	r2, [r7, #20]
 8009994:	68bb      	ldr	r3, [r7, #8]
 8009996:	429a      	cmp	r2, r3
 8009998:	d3c4      	bcc.n	8009924 <crc64_we+0x24>
=======
 8009a14:	697b      	ldr	r3, [r7, #20]
 8009a16:	3301      	adds	r3, #1
 8009a18:	617b      	str	r3, [r7, #20]
 8009a1a:	697a      	ldr	r2, [r7, #20]
 8009a1c:	68bb      	ldr	r3, [r7, #8]
 8009a1e:	429a      	cmp	r2, r3
 8009a20:	d3c4      	bcc.n	80099ac <crc64_we+0x24>
>>>>>>> 752c83b... update binaries
        for (j = 0; j < 8; j++) {
            crc = (crc & (1ULL<<63)) ? (crc<<1)^0x42F0E1EBA9EA3693ULL : (crc<<1);
        }
    }

    return ~crc;
<<<<<<< HEAD
 800999a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800999e:	ea6f 0202 	mvn.w	r2, r2
 80099a2:	ea6f 0303 	mvn.w	r3, r3
}
 80099a6:	4610      	mov	r0, r2
 80099a8:	4619      	mov	r1, r3
 80099aa:	371c      	adds	r7, #28
 80099ac:	46bd      	mov	sp, r7
 80099ae:	bcb0      	pop	{r4, r5, r7}
 80099b0:	4770      	bx	lr
 80099b2:	bf00      	nop
 80099b4:	f3af 8000 	nop.w
 80099b8:	a9ea3693 	.word	0xa9ea3693
 80099bc:	42f0e1eb 	.word	0x42f0e1eb

080099c0 <chSysLock.lto_priv.217>:
=======
 8009a22:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009a26:	ea6f 0202 	mvn.w	r2, r2
 8009a2a:	ea6f 0303 	mvn.w	r3, r3
}
 8009a2e:	4610      	mov	r0, r2
 8009a30:	4619      	mov	r1, r3
 8009a32:	371c      	adds	r7, #28
 8009a34:	46bd      	mov	sp, r7
 8009a36:	bcb0      	pop	{r4, r5, r7}
 8009a38:	4770      	bx	lr
 8009a3a:	bf00      	nop
 8009a3c:	f3af 8000 	nop.w
 8009a40:	a9ea3693 	.word	0xa9ea3693
 8009a44:	42f0e1eb 	.word	0x42f0e1eb

08009a48 <chSysLock.lto_priv.214>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 80099c0:	b580      	push	{r7, lr}
 80099c2:	af00      	add	r7, sp, #0

  port_lock();
 80099c4:	f001 f9d2 	bl	800ad6c <port_lock.lto_priv.232>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80099c8:	f001 fa3a 	bl	800ae40 <_dbg_check_lock>
}
 80099cc:	bd80      	pop	{r7, pc}
 80099ce:	bf00      	nop

080099d0 <chSysUnlock.lto_priv.213>:
=======
 8009a48:	b580      	push	{r7, lr}
 8009a4a:	af00      	add	r7, sp, #0

  port_lock();
 8009a4c:	f001 f9d2 	bl	800adf4 <port_lock.lto_priv.229>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009a50:	f001 fa3a 	bl	800aec8 <_dbg_check_lock>
}
 8009a54:	bd80      	pop	{r7, pc}
 8009a56:	bf00      	nop

08009a58 <chSysUnlock.lto_priv.210>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 80099d0:	b580      	push	{r7, lr}
 80099d2:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 80099d4:	f001 fa4a 	bl	800ae6c <_dbg_check_unlock>
=======
 8009a58:	b580      	push	{r7, lr}
 8009a5a:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009a5c:	f001 fa4a 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 80099d8:	4b09      	ldr	r3, [pc, #36]	; (8009a00 <chSysUnlock.lto_priv.213+0x30>)
 80099da:	681b      	ldr	r3, [r3, #0]
 80099dc:	4a08      	ldr	r2, [pc, #32]	; (8009a00 <chSysUnlock.lto_priv.213+0x30>)
 80099de:	4293      	cmp	r3, r2
 80099e0:	d00a      	beq.n	80099f8 <chSysUnlock.lto_priv.213+0x28>
 80099e2:	4b07      	ldr	r3, [pc, #28]	; (8009a00 <chSysUnlock.lto_priv.213+0x30>)
 80099e4:	699b      	ldr	r3, [r3, #24]
 80099e6:	689a      	ldr	r2, [r3, #8]
 80099e8:	4b05      	ldr	r3, [pc, #20]	; (8009a00 <chSysUnlock.lto_priv.213+0x30>)
 80099ea:	681b      	ldr	r3, [r3, #0]
 80099ec:	689b      	ldr	r3, [r3, #8]
 80099ee:	429a      	cmp	r2, r3
 80099f0:	d202      	bcs.n	80099f8 <chSysUnlock.lto_priv.213+0x28>
 80099f2:	4804      	ldr	r0, [pc, #16]	; (8009a04 <chSysUnlock.lto_priv.213+0x34>)
 80099f4:	f001 f9d6 	bl	800ada4 <chSysHalt>
=======
 8009a60:	4b09      	ldr	r3, [pc, #36]	; (8009a88 <chSysUnlock.lto_priv.210+0x30>)
 8009a62:	681b      	ldr	r3, [r3, #0]
 8009a64:	4a08      	ldr	r2, [pc, #32]	; (8009a88 <chSysUnlock.lto_priv.210+0x30>)
 8009a66:	4293      	cmp	r3, r2
 8009a68:	d00a      	beq.n	8009a80 <chSysUnlock.lto_priv.210+0x28>
 8009a6a:	4b07      	ldr	r3, [pc, #28]	; (8009a88 <chSysUnlock.lto_priv.210+0x30>)
 8009a6c:	699b      	ldr	r3, [r3, #24]
 8009a6e:	689a      	ldr	r2, [r3, #8]
 8009a70:	4b05      	ldr	r3, [pc, #20]	; (8009a88 <chSysUnlock.lto_priv.210+0x30>)
 8009a72:	681b      	ldr	r3, [r3, #0]
 8009a74:	689b      	ldr	r3, [r3, #8]
 8009a76:	429a      	cmp	r2, r3
 8009a78:	d202      	bcs.n	8009a80 <chSysUnlock.lto_priv.210+0x28>
 8009a7a:	4804      	ldr	r0, [pc, #16]	; (8009a8c <chSysUnlock.lto_priv.210+0x34>)
 8009a7c:	f001 f9d6 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 80099f8:	f001 f9c6 	bl	800ad88 <port_unlock.lto_priv.227>
}
 80099fc:	bd80      	pop	{r7, pc}
 80099fe:	bf00      	nop
 8009a00:	20001338 	.word	0x20001338
 8009a04:	0800ea40 	.word	0x0800ea40

08009a08 <_core_init>:
=======
 8009a80:	f001 f9c6 	bl	800ae10 <port_unlock.lto_priv.224>
}
 8009a84:	bd80      	pop	{r7, pc}
 8009a86:	bf00      	nop
 8009a88:	20001338 	.word	0x20001338
 8009a8c:	0800eb18 	.word	0x0800eb18

08009a90 <_core_init>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Low level memory manager initialization.
 *
 * @notapi
 */
void _core_init(void) {
<<<<<<< HEAD
 8009a08:	b480      	push	{r7}
 8009a0a:	af00      	add	r7, sp, #0
=======
 8009a90:	b480      	push	{r7}
 8009a92:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
<<<<<<< HEAD
 8009a0c:	4b04      	ldr	r3, [pc, #16]	; (8009a20 <_core_init+0x18>)
 8009a0e:	4a05      	ldr	r2, [pc, #20]	; (8009a24 <_core_init+0x1c>)
 8009a10:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 8009a12:	4b03      	ldr	r3, [pc, #12]	; (8009a20 <_core_init+0x18>)
 8009a14:	4a04      	ldr	r2, [pc, #16]	; (8009a28 <_core_init+0x20>)
 8009a16:	605a      	str	r2, [r3, #4]
=======
 8009a94:	4b04      	ldr	r3, [pc, #16]	; (8009aa8 <_core_init+0x18>)
 8009a96:	4a05      	ldr	r2, [pc, #20]	; (8009aac <_core_init+0x1c>)
 8009a98:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 8009a9a:	4b03      	ldr	r3, [pc, #12]	; (8009aa8 <_core_init+0x18>)
 8009a9c:	4a04      	ldr	r2, [pc, #16]	; (8009ab0 <_core_init+0x20>)
 8009a9e:	605a      	str	r2, [r3, #4]
>>>>>>> 752c83b... update binaries
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
<<<<<<< HEAD
 8009a18:	46bd      	mov	sp, r7
 8009a1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a1e:	4770      	bx	lr
 8009a20:	200013a4 	.word	0x200013a4
 8009a24:	20001558 	.word	0x20001558
 8009a28:	20003f00 	.word	0x20003f00

08009a2c <chCoreAllocAlignedWithOffsetI>:
=======
 8009aa0:	46bd      	mov	sp, r7
 8009aa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009aa6:	4770      	bx	lr
 8009aa8:	200013a4 	.word	0x200013a4
 8009aac:	20001570 	.word	0x20001570
 8009ab0:	20003f00 	.word	0x20003f00

08009ab4 <chCoreAllocAlignedWithOffsetI>:
>>>>>>> 752c83b... update binaries
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
<<<<<<< HEAD
 8009a2c:	b580      	push	{r7, lr}
 8009a2e:	b086      	sub	sp, #24
 8009a30:	af00      	add	r7, sp, #0
 8009a32:	60f8      	str	r0, [r7, #12]
 8009a34:	60b9      	str	r1, [r7, #8]
 8009a36:	607a      	str	r2, [r7, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
 8009a38:	f001 fa92 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8009a3c:	68bb      	ldr	r3, [r7, #8]
 8009a3e:	2b00      	cmp	r3, #0
 8009a40:	d005      	beq.n	8009a4e <chCoreAllocAlignedWithOffsetI+0x22>
 8009a42:	68bb      	ldr	r3, [r7, #8]
 8009a44:	1e5a      	subs	r2, r3, #1
 8009a46:	68bb      	ldr	r3, [r7, #8]
 8009a48:	4013      	ands	r3, r2
 8009a4a:	2b00      	cmp	r3, #0
 8009a4c:	d002      	beq.n	8009a54 <chCoreAllocAlignedWithOffsetI+0x28>
 8009a4e:	4817      	ldr	r0, [pc, #92]	; (8009aac <chCoreAllocAlignedWithOffsetI+0x80>)
 8009a50:	f001 f9a8 	bl	800ada4 <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8009a54:	68ba      	ldr	r2, [r7, #8]
 8009a56:	68fb      	ldr	r3, [r7, #12]
 8009a58:	4413      	add	r3, r2
 8009a5a:	1e5a      	subs	r2, r3, #1
 8009a5c:	68bb      	ldr	r3, [r7, #8]
 8009a5e:	425b      	negs	r3, r3
 8009a60:	4013      	ands	r3, r2
 8009a62:	60fb      	str	r3, [r7, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8009a64:	4b12      	ldr	r3, [pc, #72]	; (8009ab0 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009a66:	681a      	ldr	r2, [r3, #0]
 8009a68:	687b      	ldr	r3, [r7, #4]
 8009a6a:	4413      	add	r3, r2
 8009a6c:	461a      	mov	r2, r3
 8009a6e:	68bb      	ldr	r3, [r7, #8]
 8009a70:	4413      	add	r3, r2
 8009a72:	1e5a      	subs	r2, r3, #1
 8009a74:	68bb      	ldr	r3, [r7, #8]
 8009a76:	425b      	negs	r3, r3
 8009a78:	4013      	ands	r3, r2
 8009a7a:	617b      	str	r3, [r7, #20]
  next = p + size;
 8009a7c:	697a      	ldr	r2, [r7, #20]
 8009a7e:	68fb      	ldr	r3, [r7, #12]
 8009a80:	4413      	add	r3, r2
 8009a82:	613b      	str	r3, [r7, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8009a84:	4b0a      	ldr	r3, [pc, #40]	; (8009ab0 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009a86:	685a      	ldr	r2, [r3, #4]
 8009a88:	693b      	ldr	r3, [r7, #16]
 8009a8a:	429a      	cmp	r2, r3
 8009a8c:	d304      	bcc.n	8009a98 <chCoreAllocAlignedWithOffsetI+0x6c>
 8009a8e:	4b08      	ldr	r3, [pc, #32]	; (8009ab0 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009a90:	681a      	ldr	r2, [r3, #0]
 8009a92:	693b      	ldr	r3, [r7, #16]
 8009a94:	429a      	cmp	r2, r3
 8009a96:	d901      	bls.n	8009a9c <chCoreAllocAlignedWithOffsetI+0x70>
//    CH_CFG_CORE_ALLOCATOR_FAILURE_HOOK();
    return NULL;
 8009a98:	2300      	movs	r3, #0
 8009a9a:	e003      	b.n	8009aa4 <chCoreAllocAlignedWithOffsetI+0x78>
  }

  ch_memcore.nextmem = next;
 8009a9c:	4a04      	ldr	r2, [pc, #16]	; (8009ab0 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009a9e:	693b      	ldr	r3, [r7, #16]
 8009aa0:	6013      	str	r3, [r2, #0]

  return p;
 8009aa2:	697b      	ldr	r3, [r7, #20]
}
 8009aa4:	4618      	mov	r0, r3
 8009aa6:	3718      	adds	r7, #24
 8009aa8:	46bd      	mov	sp, r7
 8009aaa:	bd80      	pop	{r7, pc}
 8009aac:	0800ea20 	.word	0x0800ea20
 8009ab0:	200013a4 	.word	0x200013a4

08009ab4 <chCoreAllocAlignedWithOffset>:
=======
 8009ab4:	b580      	push	{r7, lr}
 8009ab6:	b086      	sub	sp, #24
 8009ab8:	af00      	add	r7, sp, #0
 8009aba:	60f8      	str	r0, [r7, #12]
 8009abc:	60b9      	str	r1, [r7, #8]
 8009abe:	607a      	str	r2, [r7, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
 8009ac0:	f001 fa92 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8009ac4:	68bb      	ldr	r3, [r7, #8]
 8009ac6:	2b00      	cmp	r3, #0
 8009ac8:	d005      	beq.n	8009ad6 <chCoreAllocAlignedWithOffsetI+0x22>
 8009aca:	68bb      	ldr	r3, [r7, #8]
 8009acc:	1e5a      	subs	r2, r3, #1
 8009ace:	68bb      	ldr	r3, [r7, #8]
 8009ad0:	4013      	ands	r3, r2
 8009ad2:	2b00      	cmp	r3, #0
 8009ad4:	d002      	beq.n	8009adc <chCoreAllocAlignedWithOffsetI+0x28>
 8009ad6:	4817      	ldr	r0, [pc, #92]	; (8009b34 <chCoreAllocAlignedWithOffsetI+0x80>)
 8009ad8:	f001 f9a8 	bl	800ae2c <chSysHalt>

  size = MEM_ALIGN_NEXT(size, align);
 8009adc:	68ba      	ldr	r2, [r7, #8]
 8009ade:	68fb      	ldr	r3, [r7, #12]
 8009ae0:	4413      	add	r3, r2
 8009ae2:	1e5a      	subs	r2, r3, #1
 8009ae4:	68bb      	ldr	r3, [r7, #8]
 8009ae6:	425b      	negs	r3, r3
 8009ae8:	4013      	ands	r3, r2
 8009aea:	60fb      	str	r3, [r7, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8009aec:	4b12      	ldr	r3, [pc, #72]	; (8009b38 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009aee:	681a      	ldr	r2, [r3, #0]
 8009af0:	687b      	ldr	r3, [r7, #4]
 8009af2:	4413      	add	r3, r2
 8009af4:	461a      	mov	r2, r3
 8009af6:	68bb      	ldr	r3, [r7, #8]
 8009af8:	4413      	add	r3, r2
 8009afa:	1e5a      	subs	r2, r3, #1
 8009afc:	68bb      	ldr	r3, [r7, #8]
 8009afe:	425b      	negs	r3, r3
 8009b00:	4013      	ands	r3, r2
 8009b02:	617b      	str	r3, [r7, #20]
  next = p + size;
 8009b04:	697a      	ldr	r2, [r7, #20]
 8009b06:	68fb      	ldr	r3, [r7, #12]
 8009b08:	4413      	add	r3, r2
 8009b0a:	613b      	str	r3, [r7, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8009b0c:	4b0a      	ldr	r3, [pc, #40]	; (8009b38 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009b0e:	685a      	ldr	r2, [r3, #4]
 8009b10:	693b      	ldr	r3, [r7, #16]
 8009b12:	429a      	cmp	r2, r3
 8009b14:	d304      	bcc.n	8009b20 <chCoreAllocAlignedWithOffsetI+0x6c>
 8009b16:	4b08      	ldr	r3, [pc, #32]	; (8009b38 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009b18:	681a      	ldr	r2, [r3, #0]
 8009b1a:	693b      	ldr	r3, [r7, #16]
 8009b1c:	429a      	cmp	r2, r3
 8009b1e:	d901      	bls.n	8009b24 <chCoreAllocAlignedWithOffsetI+0x70>
//    CH_CFG_CORE_ALLOCATOR_FAILURE_HOOK();
    return NULL;
 8009b20:	2300      	movs	r3, #0
 8009b22:	e003      	b.n	8009b2c <chCoreAllocAlignedWithOffsetI+0x78>
  }

  ch_memcore.nextmem = next;
 8009b24:	4a04      	ldr	r2, [pc, #16]	; (8009b38 <chCoreAllocAlignedWithOffsetI+0x84>)
 8009b26:	693b      	ldr	r3, [r7, #16]
 8009b28:	6013      	str	r3, [r2, #0]

  return p;
 8009b2a:	697b      	ldr	r3, [r7, #20]
}
 8009b2c:	4618      	mov	r0, r3
 8009b2e:	3718      	adds	r7, #24
 8009b30:	46bd      	mov	sp, r7
 8009b32:	bd80      	pop	{r7, pc}
 8009b34:	0800eaf8 	.word	0x0800eaf8
 8009b38:	200013a4 	.word	0x200013a4

08009b3c <chCoreAllocAlignedWithOffset>:
>>>>>>> 752c83b... update binaries
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
<<<<<<< HEAD
 8009ab4:	b580      	push	{r7, lr}
 8009ab6:	b086      	sub	sp, #24
 8009ab8:	af00      	add	r7, sp, #0
 8009aba:	60f8      	str	r0, [r7, #12]
 8009abc:	60b9      	str	r1, [r7, #8]
 8009abe:	607a      	str	r2, [r7, #4]
  void *p;

  chSysLock();
 8009ac0:	f7ff ff7e 	bl	80099c0 <chSysLock.lto_priv.217>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 8009ac4:	68f8      	ldr	r0, [r7, #12]
 8009ac6:	68b9      	ldr	r1, [r7, #8]
 8009ac8:	687a      	ldr	r2, [r7, #4]
 8009aca:	f7ff ffaf 	bl	8009a2c <chCoreAllocAlignedWithOffsetI>
 8009ace:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 8009ad0:	f7ff ff7e 	bl	80099d0 <chSysUnlock.lto_priv.213>

  return p;
 8009ad4:	697b      	ldr	r3, [r7, #20]
}
 8009ad6:	4618      	mov	r0, r3
 8009ad8:	3718      	adds	r7, #24
 8009ada:	46bd      	mov	sp, r7
 8009adc:	bd80      	pop	{r7, pc}
 8009ade:	bf00      	nop

08009ae0 <chCoreGetStatusX>:
=======
 8009b3c:	b580      	push	{r7, lr}
 8009b3e:	b086      	sub	sp, #24
 8009b40:	af00      	add	r7, sp, #0
 8009b42:	60f8      	str	r0, [r7, #12]
 8009b44:	60b9      	str	r1, [r7, #8]
 8009b46:	607a      	str	r2, [r7, #4]
  void *p;

  chSysLock();
 8009b48:	f7ff ff7e 	bl	8009a48 <chSysLock.lto_priv.214>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 8009b4c:	68f8      	ldr	r0, [r7, #12]
 8009b4e:	68b9      	ldr	r1, [r7, #8]
 8009b50:	687a      	ldr	r2, [r7, #4]
 8009b52:	f7ff ffaf 	bl	8009ab4 <chCoreAllocAlignedWithOffsetI>
 8009b56:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 8009b58:	f7ff ff7e 	bl	8009a58 <chSysUnlock.lto_priv.210>

  return p;
 8009b5c:	697b      	ldr	r3, [r7, #20]
}
 8009b5e:	4618      	mov	r0, r3
 8009b60:	3718      	adds	r7, #24
 8009b62:	46bd      	mov	sp, r7
 8009b64:	bd80      	pop	{r7, pc}
 8009b66:	bf00      	nop

08009b68 <chCoreGetStatusX>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The size, in bytes, of the free core memory.
 *
 * @xclass
 */
size_t chCoreGetStatusX(void) {
<<<<<<< HEAD
 8009ae0:	b480      	push	{r7}
 8009ae2:	af00      	add	r7, sp, #0

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 8009ae4:	4b05      	ldr	r3, [pc, #20]	; (8009afc <chCoreGetStatusX+0x1c>)
 8009ae6:	685b      	ldr	r3, [r3, #4]
 8009ae8:	461a      	mov	r2, r3
 8009aea:	4b04      	ldr	r3, [pc, #16]	; (8009afc <chCoreGetStatusX+0x1c>)
 8009aec:	681b      	ldr	r3, [r3, #0]
 8009aee:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8009af0:	4618      	mov	r0, r3
 8009af2:	46bd      	mov	sp, r7
 8009af4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009af8:	4770      	bx	lr
 8009afa:	bf00      	nop
 8009afc:	200013a4 	.word	0x200013a4

08009b00 <port_lock.lto_priv.233>:
=======
 8009b68:	b480      	push	{r7}
 8009b6a:	af00      	add	r7, sp, #0

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 8009b6c:	4b05      	ldr	r3, [pc, #20]	; (8009b84 <chCoreGetStatusX+0x1c>)
 8009b6e:	685b      	ldr	r3, [r3, #4]
 8009b70:	461a      	mov	r2, r3
 8009b72:	4b04      	ldr	r3, [pc, #16]	; (8009b84 <chCoreGetStatusX+0x1c>)
 8009b74:	681b      	ldr	r3, [r3, #0]
 8009b76:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8009b78:	4618      	mov	r0, r3
 8009b7a:	46bd      	mov	sp, r7
 8009b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b80:	4770      	bx	lr
 8009b82:	bf00      	nop
 8009b84:	200013a4 	.word	0x200013a4

08009b88 <port_lock.lto_priv.230>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 8009b00:	b480      	push	{r7}
 8009b02:	b083      	sub	sp, #12
 8009b04:	af00      	add	r7, sp, #0
 8009b06:	2320      	movs	r3, #32
 8009b08:	607b      	str	r3, [r7, #4]
 8009b0a:	687b      	ldr	r3, [r7, #4]
 8009b0c:	f383 8811 	msr	BASEPRI, r3
=======
 8009b88:	b480      	push	{r7}
 8009b8a:	b083      	sub	sp, #12
 8009b8c:	af00      	add	r7, sp, #0
 8009b8e:	2320      	movs	r3, #32
 8009b90:	607b      	str	r3, [r7, #4]
 8009b92:	687b      	ldr	r3, [r7, #4]
 8009b94:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009b10:	370c      	adds	r7, #12
 8009b12:	46bd      	mov	sp, r7
 8009b14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b18:	4770      	bx	lr
 8009b1a:	bf00      	nop

08009b1c <port_unlock.lto_priv.228>:
=======
 8009b98:	370c      	adds	r7, #12
 8009b9a:	46bd      	mov	sp, r7
 8009b9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ba0:	4770      	bx	lr
 8009ba2:	bf00      	nop

08009ba4 <port_unlock.lto_priv.225>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 8009b1c:	b480      	push	{r7}
 8009b1e:	b083      	sub	sp, #12
 8009b20:	af00      	add	r7, sp, #0
 8009b22:	2300      	movs	r3, #0
 8009b24:	607b      	str	r3, [r7, #4]
 8009b26:	687b      	ldr	r3, [r7, #4]
 8009b28:	f383 8811 	msr	BASEPRI, r3
=======
 8009ba4:	b480      	push	{r7}
 8009ba6:	b083      	sub	sp, #12
 8009ba8:	af00      	add	r7, sp, #0
 8009baa:	2300      	movs	r3, #0
 8009bac:	607b      	str	r3, [r7, #4]
 8009bae:	687b      	ldr	r3, [r7, #4]
 8009bb0:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009b2c:	370c      	adds	r7, #12
 8009b2e:	46bd      	mov	sp, r7
 8009b30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b34:	4770      	bx	lr
 8009b36:	bf00      	nop

08009b38 <chSysLock.lto_priv.218>:
=======
 8009bb4:	370c      	adds	r7, #12
 8009bb6:	46bd      	mov	sp, r7
 8009bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009bbc:	4770      	bx	lr
 8009bbe:	bf00      	nop

08009bc0 <chSysLock.lto_priv.215>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 8009b38:	b580      	push	{r7, lr}
 8009b3a:	af00      	add	r7, sp, #0

  port_lock();
 8009b3c:	f7ff ffe0 	bl	8009b00 <port_lock.lto_priv.233>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009b40:	f001 f97e 	bl	800ae40 <_dbg_check_lock>
}
 8009b44:	bd80      	pop	{r7, pc}
 8009b46:	bf00      	nop

08009b48 <chSysUnlock.lto_priv.214>:
=======
 8009bc0:	b580      	push	{r7, lr}
 8009bc2:	af00      	add	r7, sp, #0

  port_lock();
 8009bc4:	f7ff ffe0 	bl	8009b88 <port_lock.lto_priv.230>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009bc8:	f001 f97e 	bl	800aec8 <_dbg_check_lock>
}
 8009bcc:	bd80      	pop	{r7, pc}
 8009bce:	bf00      	nop

08009bd0 <chSysUnlock.lto_priv.211>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 8009b48:	b580      	push	{r7, lr}
 8009b4a:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009b4c:	f001 f98e 	bl	800ae6c <_dbg_check_unlock>
=======
 8009bd0:	b580      	push	{r7, lr}
 8009bd2:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009bd4:	f001 f98e 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 8009b50:	4b09      	ldr	r3, [pc, #36]	; (8009b78 <chSysUnlock.lto_priv.214+0x30>)
 8009b52:	681b      	ldr	r3, [r3, #0]
 8009b54:	4a08      	ldr	r2, [pc, #32]	; (8009b78 <chSysUnlock.lto_priv.214+0x30>)
 8009b56:	4293      	cmp	r3, r2
 8009b58:	d00a      	beq.n	8009b70 <chSysUnlock.lto_priv.214+0x28>
 8009b5a:	4b07      	ldr	r3, [pc, #28]	; (8009b78 <chSysUnlock.lto_priv.214+0x30>)
 8009b5c:	699b      	ldr	r3, [r3, #24]
 8009b5e:	689a      	ldr	r2, [r3, #8]
 8009b60:	4b05      	ldr	r3, [pc, #20]	; (8009b78 <chSysUnlock.lto_priv.214+0x30>)
 8009b62:	681b      	ldr	r3, [r3, #0]
 8009b64:	689b      	ldr	r3, [r3, #8]
 8009b66:	429a      	cmp	r2, r3
 8009b68:	d202      	bcs.n	8009b70 <chSysUnlock.lto_priv.214+0x28>
 8009b6a:	4804      	ldr	r0, [pc, #16]	; (8009b7c <chSysUnlock.lto_priv.214+0x34>)
 8009b6c:	f001 f91a 	bl	800ada4 <chSysHalt>
=======
 8009bd8:	4b09      	ldr	r3, [pc, #36]	; (8009c00 <chSysUnlock.lto_priv.211+0x30>)
 8009bda:	681b      	ldr	r3, [r3, #0]
 8009bdc:	4a08      	ldr	r2, [pc, #32]	; (8009c00 <chSysUnlock.lto_priv.211+0x30>)
 8009bde:	4293      	cmp	r3, r2
 8009be0:	d00a      	beq.n	8009bf8 <chSysUnlock.lto_priv.211+0x28>
 8009be2:	4b07      	ldr	r3, [pc, #28]	; (8009c00 <chSysUnlock.lto_priv.211+0x30>)
 8009be4:	699b      	ldr	r3, [r3, #24]
 8009be6:	689a      	ldr	r2, [r3, #8]
 8009be8:	4b05      	ldr	r3, [pc, #20]	; (8009c00 <chSysUnlock.lto_priv.211+0x30>)
 8009bea:	681b      	ldr	r3, [r3, #0]
 8009bec:	689b      	ldr	r3, [r3, #8]
 8009bee:	429a      	cmp	r2, r3
 8009bf0:	d202      	bcs.n	8009bf8 <chSysUnlock.lto_priv.211+0x28>
 8009bf2:	4804      	ldr	r0, [pc, #16]	; (8009c04 <chSysUnlock.lto_priv.211+0x34>)
 8009bf4:	f001 f91a 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 8009b70:	f7ff ffd4 	bl	8009b1c <port_unlock.lto_priv.228>
}
 8009b74:	bd80      	pop	{r7, pc}
 8009b76:	bf00      	nop
 8009b78:	20001338 	.word	0x20001338
 8009b7c:	0800ea80 	.word	0x0800ea80

08009b80 <chPoolAdd>:
=======
 8009bf8:	f7ff ffd4 	bl	8009ba4 <port_unlock.lto_priv.225>
}
 8009bfc:	bd80      	pop	{r7, pc}
 8009bfe:	bf00      	nop
 8009c00:	20001338 	.word	0x20001338
 8009c04:	0800eb58 	.word	0x0800eb58

08009c08 <chPoolAdd>:
>>>>>>> 752c83b... update binaries
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
<<<<<<< HEAD
 8009b80:	b580      	push	{r7, lr}
 8009b82:	b082      	sub	sp, #8
 8009b84:	af00      	add	r7, sp, #0
 8009b86:	6078      	str	r0, [r7, #4]
 8009b88:	6039      	str	r1, [r7, #0]

  chPoolFree(mp, objp);
 8009b8a:	6878      	ldr	r0, [r7, #4]
 8009b8c:	6839      	ldr	r1, [r7, #0]
 8009b8e:	f000 f8a1 	bl	8009cd4 <chPoolFree>
}
 8009b92:	3708      	adds	r7, #8
 8009b94:	46bd      	mov	sp, r7
 8009b96:	bd80      	pop	{r7, pc}

08009b98 <chPoolObjectInit>:
=======
 8009c08:	b580      	push	{r7, lr}
 8009c0a:	b082      	sub	sp, #8
 8009c0c:	af00      	add	r7, sp, #0
 8009c0e:	6078      	str	r0, [r7, #4]
 8009c10:	6039      	str	r1, [r7, #0]

  chPoolFree(mp, objp);
 8009c12:	6878      	ldr	r0, [r7, #4]
 8009c14:	6839      	ldr	r1, [r7, #0]
 8009c16:	f000 f8a1 	bl	8009d5c <chPoolFree>
}
 8009c1a:	3708      	adds	r7, #8
 8009c1c:	46bd      	mov	sp, r7
 8009c1e:	bd80      	pop	{r7, pc}

08009c20 <chPoolObjectInit>:
>>>>>>> 752c83b... update binaries
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
<<<<<<< HEAD
 8009b98:	b580      	push	{r7, lr}
 8009b9a:	b084      	sub	sp, #16
 8009b9c:	af00      	add	r7, sp, #0
 8009b9e:	60f8      	str	r0, [r7, #12]
 8009ba0:	60b9      	str	r1, [r7, #8]
 8009ba2:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
 8009ba4:	68fb      	ldr	r3, [r7, #12]
 8009ba6:	2b00      	cmp	r3, #0
 8009ba8:	d002      	beq.n	8009bb0 <chPoolObjectInit+0x18>
 8009baa:	68bb      	ldr	r3, [r7, #8]
 8009bac:	2b03      	cmp	r3, #3
 8009bae:	d802      	bhi.n	8009bb6 <chPoolObjectInit+0x1e>
 8009bb0:	4807      	ldr	r0, [pc, #28]	; (8009bd0 <chPoolObjectInit+0x38>)
 8009bb2:	f001 f8f7 	bl	800ada4 <chSysHalt>

  mp->next = NULL;
 8009bb6:	68fb      	ldr	r3, [r7, #12]
 8009bb8:	2200      	movs	r2, #0
 8009bba:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8009bbc:	68fb      	ldr	r3, [r7, #12]
 8009bbe:	68ba      	ldr	r2, [r7, #8]
 8009bc0:	605a      	str	r2, [r3, #4]
  mp->provider = provider;
 8009bc2:	68fb      	ldr	r3, [r7, #12]
 8009bc4:	687a      	ldr	r2, [r7, #4]
 8009bc6:	609a      	str	r2, [r3, #8]
}
 8009bc8:	3710      	adds	r7, #16
 8009bca:	46bd      	mov	sp, r7
 8009bcc:	bd80      	pop	{r7, pc}
 8009bce:	bf00      	nop
 8009bd0:	0800ea4c 	.word	0x0800ea4c

08009bd4 <chPoolLoadArray>:
=======
 8009c20:	b580      	push	{r7, lr}
 8009c22:	b084      	sub	sp, #16
 8009c24:	af00      	add	r7, sp, #0
 8009c26:	60f8      	str	r0, [r7, #12]
 8009c28:	60b9      	str	r1, [r7, #8]
 8009c2a:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
 8009c2c:	68fb      	ldr	r3, [r7, #12]
 8009c2e:	2b00      	cmp	r3, #0
 8009c30:	d002      	beq.n	8009c38 <chPoolObjectInit+0x18>
 8009c32:	68bb      	ldr	r3, [r7, #8]
 8009c34:	2b03      	cmp	r3, #3
 8009c36:	d802      	bhi.n	8009c3e <chPoolObjectInit+0x1e>
 8009c38:	4807      	ldr	r0, [pc, #28]	; (8009c58 <chPoolObjectInit+0x38>)
 8009c3a:	f001 f8f7 	bl	800ae2c <chSysHalt>

  mp->next = NULL;
 8009c3e:	68fb      	ldr	r3, [r7, #12]
 8009c40:	2200      	movs	r2, #0
 8009c42:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8009c44:	68fb      	ldr	r3, [r7, #12]
 8009c46:	68ba      	ldr	r2, [r7, #8]
 8009c48:	605a      	str	r2, [r3, #4]
  mp->provider = provider;
 8009c4a:	68fb      	ldr	r3, [r7, #12]
 8009c4c:	687a      	ldr	r2, [r7, #4]
 8009c4e:	609a      	str	r2, [r3, #8]
}
 8009c50:	3710      	adds	r7, #16
 8009c52:	46bd      	mov	sp, r7
 8009c54:	bd80      	pop	{r7, pc}
 8009c56:	bf00      	nop
 8009c58:	0800eb24 	.word	0x0800eb24

08009c5c <chPoolLoadArray>:
>>>>>>> 752c83b... update binaries
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
<<<<<<< HEAD
 8009bd4:	b580      	push	{r7, lr}
 8009bd6:	b084      	sub	sp, #16
 8009bd8:	af00      	add	r7, sp, #0
 8009bda:	60f8      	str	r0, [r7, #12]
 8009bdc:	60b9      	str	r1, [r7, #8]
 8009bde:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 8009be0:	68fb      	ldr	r3, [r7, #12]
 8009be2:	2b00      	cmp	r3, #0
 8009be4:	d002      	beq.n	8009bec <chPoolLoadArray+0x18>
 8009be6:	687b      	ldr	r3, [r7, #4]
 8009be8:	2b00      	cmp	r3, #0
 8009bea:	d10f      	bne.n	8009c0c <chPoolLoadArray+0x38>
 8009bec:	480a      	ldr	r0, [pc, #40]	; (8009c18 <chPoolLoadArray+0x44>)
 8009bee:	f001 f8d9 	bl	800ada4 <chSysHalt>
 8009bf2:	e00b      	b.n	8009c0c <chPoolLoadArray+0x38>

  while (n != 0U) {
    chPoolAdd(mp, p);
 8009bf4:	68f8      	ldr	r0, [r7, #12]
 8009bf6:	68b9      	ldr	r1, [r7, #8]
 8009bf8:	f7ff ffc2 	bl	8009b80 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8009bfc:	68fb      	ldr	r3, [r7, #12]
 8009bfe:	685b      	ldr	r3, [r3, #4]
 8009c00:	68ba      	ldr	r2, [r7, #8]
 8009c02:	4413      	add	r3, r2
 8009c04:	60bb      	str	r3, [r7, #8]
    /*lint -restore*/
    n--;
 8009c06:	687b      	ldr	r3, [r7, #4]
 8009c08:	3b01      	subs	r3, #1
 8009c0a:	607b      	str	r3, [r7, #4]
=======
 8009c5c:	b580      	push	{r7, lr}
 8009c5e:	b084      	sub	sp, #16
 8009c60:	af00      	add	r7, sp, #0
 8009c62:	60f8      	str	r0, [r7, #12]
 8009c64:	60b9      	str	r1, [r7, #8]
 8009c66:	607a      	str	r2, [r7, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 8009c68:	68fb      	ldr	r3, [r7, #12]
 8009c6a:	2b00      	cmp	r3, #0
 8009c6c:	d002      	beq.n	8009c74 <chPoolLoadArray+0x18>
 8009c6e:	687b      	ldr	r3, [r7, #4]
 8009c70:	2b00      	cmp	r3, #0
 8009c72:	d10f      	bne.n	8009c94 <chPoolLoadArray+0x38>
 8009c74:	480a      	ldr	r0, [pc, #40]	; (8009ca0 <chPoolLoadArray+0x44>)
 8009c76:	f001 f8d9 	bl	800ae2c <chSysHalt>
 8009c7a:	e00b      	b.n	8009c94 <chPoolLoadArray+0x38>

  while (n != 0U) {
    chPoolAdd(mp, p);
 8009c7c:	68f8      	ldr	r0, [r7, #12]
 8009c7e:	68b9      	ldr	r1, [r7, #8]
 8009c80:	f7ff ffc2 	bl	8009c08 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8009c84:	68fb      	ldr	r3, [r7, #12]
 8009c86:	685b      	ldr	r3, [r3, #4]
 8009c88:	68ba      	ldr	r2, [r7, #8]
 8009c8a:	4413      	add	r3, r2
 8009c8c:	60bb      	str	r3, [r7, #8]
    /*lint -restore*/
    n--;
 8009c8e:	687b      	ldr	r3, [r7, #4]
 8009c90:	3b01      	subs	r3, #1
 8009c92:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
<<<<<<< HEAD
 8009c0c:	687b      	ldr	r3, [r7, #4]
 8009c0e:	2b00      	cmp	r3, #0
 8009c10:	d1f0      	bne.n	8009bf4 <chPoolLoadArray+0x20>
=======
 8009c94:	687b      	ldr	r3, [r7, #4]
 8009c96:	2b00      	cmp	r3, #0
 8009c98:	d1f0      	bne.n	8009c7c <chPoolLoadArray+0x20>
>>>>>>> 752c83b... update binaries
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
    /*lint -restore*/
    n--;
  }
}
<<<<<<< HEAD
 8009c12:	3710      	adds	r7, #16
 8009c14:	46bd      	mov	sp, r7
 8009c16:	bd80      	pop	{r7, pc}
 8009c18:	0800ea60 	.word	0x0800ea60

08009c1c <chPoolAllocI>:
=======
 8009c9a:	3710      	adds	r7, #16
 8009c9c:	46bd      	mov	sp, r7
 8009c9e:	bd80      	pop	{r7, pc}
 8009ca0:	0800eb38 	.word	0x0800eb38

08009ca4 <chPoolAllocI>:
>>>>>>> 752c83b... update binaries
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
<<<<<<< HEAD
 8009c1c:	b580      	push	{r7, lr}
 8009c1e:	b084      	sub	sp, #16
 8009c20:	af00      	add	r7, sp, #0
 8009c22:	6078      	str	r0, [r7, #4]
  void *objp;

  chDbgCheckClassI();
 8009c24:	f001 f99c 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 8009c28:	687b      	ldr	r3, [r7, #4]
 8009c2a:	2b00      	cmp	r3, #0
 8009c2c:	d102      	bne.n	8009c34 <chPoolAllocI+0x18>
 8009c2e:	4810      	ldr	r0, [pc, #64]	; (8009c70 <chPoolAllocI+0x54>)
 8009c30:	f001 f8b8 	bl	800ada4 <chSysHalt>

  objp = mp->next;
 8009c34:	687b      	ldr	r3, [r7, #4]
 8009c36:	681b      	ldr	r3, [r3, #0]
 8009c38:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8009c3a:	68fb      	ldr	r3, [r7, #12]
 8009c3c:	2b00      	cmp	r3, #0
 8009c3e:	d005      	beq.n	8009c4c <chPoolAllocI+0x30>
    mp->next = mp->next->next;
 8009c40:	687b      	ldr	r3, [r7, #4]
 8009c42:	681b      	ldr	r3, [r3, #0]
 8009c44:	681a      	ldr	r2, [r3, #0]
 8009c46:	687b      	ldr	r3, [r7, #4]
 8009c48:	601a      	str	r2, [r3, #0]
 8009c4a:	e00b      	b.n	8009c64 <chPoolAllocI+0x48>
  }
  else if (mp->provider != NULL) {
 8009c4c:	687b      	ldr	r3, [r7, #4]
 8009c4e:	689b      	ldr	r3, [r3, #8]
 8009c50:	2b00      	cmp	r3, #0
 8009c52:	d007      	beq.n	8009c64 <chPoolAllocI+0x48>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8009c54:	687b      	ldr	r3, [r7, #4]
 8009c56:	689b      	ldr	r3, [r3, #8]
 8009c58:	687a      	ldr	r2, [r7, #4]
 8009c5a:	6852      	ldr	r2, [r2, #4]
 8009c5c:	4610      	mov	r0, r2
 8009c5e:	2104      	movs	r1, #4
 8009c60:	4798      	blx	r3
 8009c62:	60f8      	str	r0, [r7, #12]
=======
 8009ca4:	b580      	push	{r7, lr}
 8009ca6:	b084      	sub	sp, #16
 8009ca8:	af00      	add	r7, sp, #0
 8009caa:	6078      	str	r0, [r7, #4]
  void *objp;

  chDbgCheckClassI();
 8009cac:	f001 f99c 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 8009cb0:	687b      	ldr	r3, [r7, #4]
 8009cb2:	2b00      	cmp	r3, #0
 8009cb4:	d102      	bne.n	8009cbc <chPoolAllocI+0x18>
 8009cb6:	4810      	ldr	r0, [pc, #64]	; (8009cf8 <chPoolAllocI+0x54>)
 8009cb8:	f001 f8b8 	bl	800ae2c <chSysHalt>

  objp = mp->next;
 8009cbc:	687b      	ldr	r3, [r7, #4]
 8009cbe:	681b      	ldr	r3, [r3, #0]
 8009cc0:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8009cc2:	68fb      	ldr	r3, [r7, #12]
 8009cc4:	2b00      	cmp	r3, #0
 8009cc6:	d005      	beq.n	8009cd4 <chPoolAllocI+0x30>
    mp->next = mp->next->next;
 8009cc8:	687b      	ldr	r3, [r7, #4]
 8009cca:	681b      	ldr	r3, [r3, #0]
 8009ccc:	681a      	ldr	r2, [r3, #0]
 8009cce:	687b      	ldr	r3, [r7, #4]
 8009cd0:	601a      	str	r2, [r3, #0]
 8009cd2:	e00b      	b.n	8009cec <chPoolAllocI+0x48>
  }
  else if (mp->provider != NULL) {
 8009cd4:	687b      	ldr	r3, [r7, #4]
 8009cd6:	689b      	ldr	r3, [r3, #8]
 8009cd8:	2b00      	cmp	r3, #0
 8009cda:	d007      	beq.n	8009cec <chPoolAllocI+0x48>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8009cdc:	687b      	ldr	r3, [r7, #4]
 8009cde:	689b      	ldr	r3, [r3, #8]
 8009ce0:	687a      	ldr	r2, [r7, #4]
 8009ce2:	6852      	ldr	r2, [r2, #4]
 8009ce4:	4610      	mov	r0, r2
 8009ce6:	2104      	movs	r1, #4
 8009ce8:	4798      	blx	r3
 8009cea:	60f8      	str	r0, [r7, #12]
>>>>>>> 752c83b... update binaries
  }
  /*lint -restore*/

  return objp;
<<<<<<< HEAD
 8009c64:	68fb      	ldr	r3, [r7, #12]
}
 8009c66:	4618      	mov	r0, r3
 8009c68:	3710      	adds	r7, #16
 8009c6a:	46bd      	mov	sp, r7
 8009c6c:	bd80      	pop	{r7, pc}
 8009c6e:	bf00      	nop
 8009c70:	0800ea70 	.word	0x0800ea70

08009c74 <chPoolAlloc>:
=======
 8009cec:	68fb      	ldr	r3, [r7, #12]
}
 8009cee:	4618      	mov	r0, r3
 8009cf0:	3710      	adds	r7, #16
 8009cf2:	46bd      	mov	sp, r7
 8009cf4:	bd80      	pop	{r7, pc}
 8009cf6:	bf00      	nop
 8009cf8:	0800eb48 	.word	0x0800eb48

08009cfc <chPoolAlloc>:
>>>>>>> 752c83b... update binaries
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
<<<<<<< HEAD
 8009c74:	b580      	push	{r7, lr}
 8009c76:	b084      	sub	sp, #16
 8009c78:	af00      	add	r7, sp, #0
 8009c7a:	6078      	str	r0, [r7, #4]
  void *objp;

  chSysLock();
 8009c7c:	f7ff ff5c 	bl	8009b38 <chSysLock.lto_priv.218>
  objp = chPoolAllocI(mp);
 8009c80:	6878      	ldr	r0, [r7, #4]
 8009c82:	f7ff ffcb 	bl	8009c1c <chPoolAllocI>
 8009c86:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 8009c88:	f7ff ff5e 	bl	8009b48 <chSysUnlock.lto_priv.214>

  return objp;
 8009c8c:	68fb      	ldr	r3, [r7, #12]
}
 8009c8e:	4618      	mov	r0, r3
 8009c90:	3710      	adds	r7, #16
 8009c92:	46bd      	mov	sp, r7
 8009c94:	bd80      	pop	{r7, pc}
 8009c96:	bf00      	nop

08009c98 <chPoolFreeI>:
=======
 8009cfc:	b580      	push	{r7, lr}
 8009cfe:	b084      	sub	sp, #16
 8009d00:	af00      	add	r7, sp, #0
 8009d02:	6078      	str	r0, [r7, #4]
  void *objp;

  chSysLock();
 8009d04:	f7ff ff5c 	bl	8009bc0 <chSysLock.lto_priv.215>
  objp = chPoolAllocI(mp);
 8009d08:	6878      	ldr	r0, [r7, #4]
 8009d0a:	f7ff ffcb 	bl	8009ca4 <chPoolAllocI>
 8009d0e:	60f8      	str	r0, [r7, #12]
  chSysUnlock();
 8009d10:	f7ff ff5e 	bl	8009bd0 <chSysUnlock.lto_priv.211>

  return objp;
 8009d14:	68fb      	ldr	r3, [r7, #12]
}
 8009d16:	4618      	mov	r0, r3
 8009d18:	3710      	adds	r7, #16
 8009d1a:	46bd      	mov	sp, r7
 8009d1c:	bd80      	pop	{r7, pc}
 8009d1e:	bf00      	nop

08009d20 <chPoolFreeI>:
>>>>>>> 752c83b... update binaries
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
<<<<<<< HEAD
 8009c98:	b580      	push	{r7, lr}
 8009c9a:	b084      	sub	sp, #16
 8009c9c:	af00      	add	r7, sp, #0
 8009c9e:	6078      	str	r0, [r7, #4]
 8009ca0:	6039      	str	r1, [r7, #0]
  struct pool_header *php = objp;
 8009ca2:	683b      	ldr	r3, [r7, #0]
 8009ca4:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassI();
 8009ca6:	f001 f95b 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8009caa:	687b      	ldr	r3, [r7, #4]
 8009cac:	2b00      	cmp	r3, #0
 8009cae:	d002      	beq.n	8009cb6 <chPoolFreeI+0x1e>
 8009cb0:	683b      	ldr	r3, [r7, #0]
 8009cb2:	2b00      	cmp	r3, #0
 8009cb4:	d102      	bne.n	8009cbc <chPoolFreeI+0x24>
 8009cb6:	4806      	ldr	r0, [pc, #24]	; (8009cd0 <chPoolFreeI+0x38>)
 8009cb8:	f001 f874 	bl	800ada4 <chSysHalt>

  php->next = mp->next;
 8009cbc:	687b      	ldr	r3, [r7, #4]
 8009cbe:	681a      	ldr	r2, [r3, #0]
 8009cc0:	68fb      	ldr	r3, [r7, #12]
 8009cc2:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8009cc4:	687b      	ldr	r3, [r7, #4]
 8009cc6:	68fa      	ldr	r2, [r7, #12]
 8009cc8:	601a      	str	r2, [r3, #0]
}
 8009cca:	3710      	adds	r7, #16
 8009ccc:	46bd      	mov	sp, r7
 8009cce:	bd80      	pop	{r7, pc}
 8009cd0:	0800ea8c 	.word	0x0800ea8c

08009cd4 <chPoolFree>:
=======
 8009d20:	b580      	push	{r7, lr}
 8009d22:	b084      	sub	sp, #16
 8009d24:	af00      	add	r7, sp, #0
 8009d26:	6078      	str	r0, [r7, #4]
 8009d28:	6039      	str	r1, [r7, #0]
  struct pool_header *php = objp;
 8009d2a:	683b      	ldr	r3, [r7, #0]
 8009d2c:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassI();
 8009d2e:	f001 f95b 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8009d32:	687b      	ldr	r3, [r7, #4]
 8009d34:	2b00      	cmp	r3, #0
 8009d36:	d002      	beq.n	8009d3e <chPoolFreeI+0x1e>
 8009d38:	683b      	ldr	r3, [r7, #0]
 8009d3a:	2b00      	cmp	r3, #0
 8009d3c:	d102      	bne.n	8009d44 <chPoolFreeI+0x24>
 8009d3e:	4806      	ldr	r0, [pc, #24]	; (8009d58 <chPoolFreeI+0x38>)
 8009d40:	f001 f874 	bl	800ae2c <chSysHalt>

  php->next = mp->next;
 8009d44:	687b      	ldr	r3, [r7, #4]
 8009d46:	681a      	ldr	r2, [r3, #0]
 8009d48:	68fb      	ldr	r3, [r7, #12]
 8009d4a:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8009d4c:	687b      	ldr	r3, [r7, #4]
 8009d4e:	68fa      	ldr	r2, [r7, #12]
 8009d50:	601a      	str	r2, [r3, #0]
}
 8009d52:	3710      	adds	r7, #16
 8009d54:	46bd      	mov	sp, r7
 8009d56:	bd80      	pop	{r7, pc}
 8009d58:	0800eb64 	.word	0x0800eb64

08009d5c <chPoolFree>:
>>>>>>> 752c83b... update binaries
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
<<<<<<< HEAD
 8009cd4:	b580      	push	{r7, lr}
 8009cd6:	b082      	sub	sp, #8
 8009cd8:	af00      	add	r7, sp, #0
 8009cda:	6078      	str	r0, [r7, #4]
 8009cdc:	6039      	str	r1, [r7, #0]

  chSysLock();
 8009cde:	f7ff ff2b 	bl	8009b38 <chSysLock.lto_priv.218>
  chPoolFreeI(mp, objp);
 8009ce2:	6878      	ldr	r0, [r7, #4]
 8009ce4:	6839      	ldr	r1, [r7, #0]
 8009ce6:	f7ff ffd7 	bl	8009c98 <chPoolFreeI>
  chSysUnlock();
 8009cea:	f7ff ff2d 	bl	8009b48 <chSysUnlock.lto_priv.214>
}
 8009cee:	3708      	adds	r7, #8
 8009cf0:	46bd      	mov	sp, r7
 8009cf2:	bd80      	pop	{r7, pc}

08009cf4 <port_lock.lto_priv.234>:
=======
 8009d5c:	b580      	push	{r7, lr}
 8009d5e:	b082      	sub	sp, #8
 8009d60:	af00      	add	r7, sp, #0
 8009d62:	6078      	str	r0, [r7, #4]
 8009d64:	6039      	str	r1, [r7, #0]

  chSysLock();
 8009d66:	f7ff ff2b 	bl	8009bc0 <chSysLock.lto_priv.215>
  chPoolFreeI(mp, objp);
 8009d6a:	6878      	ldr	r0, [r7, #4]
 8009d6c:	6839      	ldr	r1, [r7, #0]
 8009d6e:	f7ff ffd7 	bl	8009d20 <chPoolFreeI>
  chSysUnlock();
 8009d72:	f7ff ff2d 	bl	8009bd0 <chSysUnlock.lto_priv.211>
}
 8009d76:	3708      	adds	r7, #8
 8009d78:	46bd      	mov	sp, r7
 8009d7a:	bd80      	pop	{r7, pc}

08009d7c <port_lock.lto_priv.231>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 8009cf4:	b480      	push	{r7}
 8009cf6:	b083      	sub	sp, #12
 8009cf8:	af00      	add	r7, sp, #0
 8009cfa:	2320      	movs	r3, #32
 8009cfc:	607b      	str	r3, [r7, #4]
 8009cfe:	687b      	ldr	r3, [r7, #4]
 8009d00:	f383 8811 	msr	BASEPRI, r3
=======
 8009d7c:	b480      	push	{r7}
 8009d7e:	b083      	sub	sp, #12
 8009d80:	af00      	add	r7, sp, #0
 8009d82:	2320      	movs	r3, #32
 8009d84:	607b      	str	r3, [r7, #4]
 8009d86:	687b      	ldr	r3, [r7, #4]
 8009d88:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009d04:	370c      	adds	r7, #12
 8009d06:	46bd      	mov	sp, r7
 8009d08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d0c:	4770      	bx	lr
 8009d0e:	bf00      	nop

08009d10 <port_unlock.lto_priv.229>:
=======
 8009d8c:	370c      	adds	r7, #12
 8009d8e:	46bd      	mov	sp, r7
 8009d90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d94:	4770      	bx	lr
 8009d96:	bf00      	nop

08009d98 <port_unlock.lto_priv.226>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 8009d10:	b480      	push	{r7}
 8009d12:	b083      	sub	sp, #12
 8009d14:	af00      	add	r7, sp, #0
 8009d16:	2300      	movs	r3, #0
 8009d18:	607b      	str	r3, [r7, #4]
 8009d1a:	687b      	ldr	r3, [r7, #4]
 8009d1c:	f383 8811 	msr	BASEPRI, r3
=======
 8009d98:	b480      	push	{r7}
 8009d9a:	b083      	sub	sp, #12
 8009d9c:	af00      	add	r7, sp, #0
 8009d9e:	2300      	movs	r3, #0
 8009da0:	607b      	str	r3, [r7, #4]
 8009da2:	687b      	ldr	r3, [r7, #4]
 8009da4:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009d20:	370c      	adds	r7, #12
 8009d22:	46bd      	mov	sp, r7
 8009d24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d28:	4770      	bx	lr
 8009d2a:	bf00      	nop

08009d2c <port_lock_from_isr>:
=======
 8009da8:	370c      	adds	r7, #12
 8009daa:	46bd      	mov	sp, r7
 8009dac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009db0:	4770      	bx	lr
 8009db2:	bf00      	nop

08009db4 <port_lock_from_isr>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
<<<<<<< HEAD
 8009d2c:	b580      	push	{r7, lr}
 8009d2e:	af00      	add	r7, sp, #0

  port_lock();
 8009d30:	f7ff ffe0 	bl	8009cf4 <port_lock.lto_priv.234>
}
 8009d34:	bd80      	pop	{r7, pc}
 8009d36:	bf00      	nop

08009d38 <port_unlock_from_isr>:
=======
 8009db4:	b580      	push	{r7, lr}
 8009db6:	af00      	add	r7, sp, #0

  port_lock();
 8009db8:	f7ff ffe0 	bl	8009d7c <port_lock.lto_priv.231>
}
 8009dbc:	bd80      	pop	{r7, pc}
 8009dbe:	bf00      	nop

08009dc0 <port_unlock_from_isr>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
<<<<<<< HEAD
 8009d38:	b580      	push	{r7, lr}
 8009d3a:	af00      	add	r7, sp, #0

  port_unlock();
 8009d3c:	f7ff ffe8 	bl	8009d10 <port_unlock.lto_priv.229>
}
 8009d40:	bd80      	pop	{r7, pc}
 8009d42:	bf00      	nop

08009d44 <SVC_Handler>:
=======
 8009dc0:	b580      	push	{r7, lr}
 8009dc2:	af00      	add	r7, sp, #0

  port_unlock();
 8009dc4:	f7ff ffe8 	bl	8009d98 <port_unlock.lto_priv.226>
}
 8009dc8:	bd80      	pop	{r7, pc}
 8009dca:	bf00      	nop

08009dcc <SVC_Handler>:
>>>>>>> 752c83b... update binaries
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
<<<<<<< HEAD
 8009d44:	b590      	push	{r4, r7, lr}
 8009d46:	b083      	sub	sp, #12
 8009d48:	af00      	add	r7, sp, #0
=======
 8009dcc:	b590      	push	{r4, r7, lr}
 8009dce:	b083      	sub	sp, #12
 8009dd0:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
<<<<<<< HEAD
 8009d4a:	f3ef 8309 	mrs	r3, PSP
 8009d4e:	461c      	mov	r4, r3
  return(result);
 8009d50:	4623      	mov	r3, r4
=======
 8009dd2:	f3ef 8309 	mrs	r3, PSP
 8009dd6:	461c      	mov	r4, r3
  return(result);
 8009dd8:	4623      	mov	r3, r4
>>>>>>> 752c83b... update binaries
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
<<<<<<< HEAD
 8009d52:	607b      	str	r3, [r7, #4]
=======
 8009dda:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
<<<<<<< HEAD
 8009d54:	687b      	ldr	r3, [r7, #4]
 8009d56:	3320      	adds	r3, #32
 8009d58:	607b      	str	r3, [r7, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8009d5a:	687b      	ldr	r3, [r7, #4]
 8009d5c:	603b      	str	r3, [r7, #0]
=======
 8009ddc:	687b      	ldr	r3, [r7, #4]
 8009dde:	3320      	adds	r3, #32
 8009de0:	607b      	str	r3, [r7, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8009de2:	687b      	ldr	r3, [r7, #4]
 8009de4:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
<<<<<<< HEAD
 8009d5e:	683b      	ldr	r3, [r7, #0]
 8009d60:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8009d64:	f7ff ffe8 	bl	8009d38 <port_unlock_from_isr>
}
 8009d68:	370c      	adds	r7, #12
 8009d6a:	46bd      	mov	sp, r7
 8009d6c:	bd90      	pop	{r4, r7, pc}
 8009d6e:	bf00      	nop

08009d70 <_port_irq_epilogue>:
=======
 8009de6:	683b      	ldr	r3, [r7, #0]
 8009de8:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8009dec:	f7ff ffe8 	bl	8009dc0 <port_unlock_from_isr>
}
 8009df0:	370c      	adds	r7, #12
 8009df2:	46bd      	mov	sp, r7
 8009df4:	bd90      	pop	{r4, r7, pc}
 8009df6:	bf00      	nop

08009df8 <_port_irq_epilogue>:
>>>>>>> 752c83b... update binaries
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
<<<<<<< HEAD
 8009d70:	b590      	push	{r4, r7, lr}
 8009d72:	b083      	sub	sp, #12
 8009d74:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009d76:	f7ff ffd9 	bl	8009d2c <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009d7a:	4b14      	ldr	r3, [pc, #80]	; (8009dcc <_port_irq_epilogue+0x5c>)
 8009d7c:	685b      	ldr	r3, [r3, #4]
 8009d7e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8009d82:	2b00      	cmp	r3, #0
 8009d84:	d01d      	beq.n	8009dc2 <_port_irq_epilogue+0x52>
=======
 8009df8:	b590      	push	{r4, r7, lr}
 8009dfa:	b083      	sub	sp, #12
 8009dfc:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8009dfe:	f7ff ffd9 	bl	8009db4 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8009e02:	4b14      	ldr	r3, [pc, #80]	; (8009e54 <_port_irq_epilogue+0x5c>)
 8009e04:	685b      	ldr	r3, [r3, #4]
 8009e06:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8009e0a:	2b00      	cmp	r3, #0
 8009e0c:	d01d      	beq.n	8009e4a <_port_irq_epilogue+0x52>
>>>>>>> 752c83b... update binaries
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
<<<<<<< HEAD
 8009d86:	f3ef 8309 	mrs	r3, PSP
 8009d8a:	461c      	mov	r4, r3
  return(result);
 8009d8c:	4623      	mov	r3, r4
=======
 8009e0e:	f3ef 8309 	mrs	r3, PSP
 8009e12:	461c      	mov	r4, r3
  return(result);
 8009e14:	4623      	mov	r3, r4
>>>>>>> 752c83b... update binaries
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
<<<<<<< HEAD
 8009d8e:	607b      	str	r3, [r7, #4]
=======
 8009e16:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
<<<<<<< HEAD
 8009d90:	687b      	ldr	r3, [r7, #4]
 8009d92:	3b20      	subs	r3, #32
 8009d94:	607b      	str	r3, [r7, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8009d96:	687b      	ldr	r3, [r7, #4]
 8009d98:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8009d9c:	61da      	str	r2, [r3, #28]
=======
 8009e18:	687b      	ldr	r3, [r7, #4]
 8009e1a:	3b20      	subs	r3, #32
 8009e1c:	607b      	str	r3, [r7, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8009e1e:	687b      	ldr	r3, [r7, #4]
 8009e20:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8009e24:	61da      	str	r2, [r3, #28]
>>>>>>> 752c83b... update binaries
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
<<<<<<< HEAD
 8009d9e:	687b      	ldr	r3, [r7, #4]
 8009da0:	603b      	str	r3, [r7, #0]
=======
 8009e26:	687b      	ldr	r3, [r7, #4]
 8009e28:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
<<<<<<< HEAD
 8009da2:	683b      	ldr	r3, [r7, #0]
 8009da4:	f383 8809 	msr	PSP, r3
=======
 8009e2a:	683b      	ldr	r3, [r7, #0]
 8009e2c:	f383 8809 	msr	PSP, r3
>>>>>>> 752c83b... update binaries

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
<<<<<<< HEAD
 8009da8:	f001 fce8 	bl	800b77c <chSchIsPreemptionRequired>
 8009dac:	4603      	mov	r3, r0
 8009dae:	2b00      	cmp	r3, #0
 8009db0:	d003      	beq.n	8009dba <_port_irq_epilogue+0x4a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009db2:	687b      	ldr	r3, [r7, #4]
 8009db4:	4a06      	ldr	r2, [pc, #24]	; (8009dd0 <_port_irq_epilogue+0x60>)
 8009db6:	619a      	str	r2, [r3, #24]
 8009db8:	e005      	b.n	8009dc6 <_port_irq_epilogue+0x56>
=======
 8009e30:	f001 fce8 	bl	800b804 <chSchIsPreemptionRequired>
 8009e34:	4603      	mov	r3, r0
 8009e36:	2b00      	cmp	r3, #0
 8009e38:	d003      	beq.n	8009e42 <_port_irq_epilogue+0x4a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8009e3a:	687b      	ldr	r3, [r7, #4]
 8009e3c:	4a06      	ldr	r2, [pc, #24]	; (8009e58 <_port_irq_epilogue+0x60>)
 8009e3e:	619a      	str	r2, [r3, #24]
 8009e40:	e005      	b.n	8009e4e <_port_irq_epilogue+0x56>
>>>>>>> 752c83b... update binaries
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
<<<<<<< HEAD
 8009dba:	687b      	ldr	r3, [r7, #4]
 8009dbc:	4a05      	ldr	r2, [pc, #20]	; (8009dd4 <_port_irq_epilogue+0x64>)
 8009dbe:	619a      	str	r2, [r3, #24]
 8009dc0:	e001      	b.n	8009dc6 <_port_irq_epilogue+0x56>
=======
 8009e42:	687b      	ldr	r3, [r7, #4]
 8009e44:	4a05      	ldr	r2, [pc, #20]	; (8009e5c <_port_irq_epilogue+0x64>)
 8009e46:	619a      	str	r2, [r3, #24]
 8009e48:	e001      	b.n	8009e4e <_port_irq_epilogue+0x56>
>>>>>>> 752c83b... update binaries

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
<<<<<<< HEAD
 8009dc2:	f7ff ffb9 	bl	8009d38 <port_unlock_from_isr>
}
 8009dc6:	370c      	adds	r7, #12
 8009dc8:	46bd      	mov	sp, r7
 8009dca:	bd90      	pop	{r4, r7, pc}
 8009dcc:	e000ed00 	.word	0xe000ed00
 8009dd0:	080032c9 	.word	0x080032c9
 8009dd4:	080032d4 	.word	0x080032d4

08009dd8 <osalInit>:
=======
 8009e4a:	f7ff ffb9 	bl	8009dc0 <port_unlock_from_isr>
}
 8009e4e:	370c      	adds	r7, #12
 8009e50:	46bd      	mov	sp, r7
 8009e52:	bd90      	pop	{r4, r7, pc}
 8009e54:	e000ed00 	.word	0xe000ed00
 8009e58:	080032c9 	.word	0x080032c9
 8009e5c:	080032d4 	.word	0x080032d4

08009e60 <osalInit>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   OSAL module initialization.
 *
 * @api
 */
static inline void osalInit(void) {
<<<<<<< HEAD
 8009dd8:	b480      	push	{r7}
 8009dda:	af00      	add	r7, sp, #0

}
 8009ddc:	46bd      	mov	sp, r7
 8009dde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009de2:	4770      	bx	lr

08009de4 <halInit>:
=======
 8009e60:	b480      	push	{r7}
 8009e62:	af00      	add	r7, sp, #0

}
 8009e64:	46bd      	mov	sp, r7
 8009e66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e6a:	4770      	bx	lr

08009e6c <halInit>:
>>>>>>> 752c83b... update binaries
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
<<<<<<< HEAD
 8009de4:	b580      	push	{r7, lr}
 8009de6:	af00      	add	r7, sp, #0

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8009de8:	f7ff fff6 	bl	8009dd8 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8009dec:	f7ff f9be 	bl	800916c <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit();
 8009df0:	f7ff fa3a 	bl	8009268 <_pal_lld_init>
=======
 8009e6c:	b580      	push	{r7, lr}
 8009e6e:	af00      	add	r7, sp, #0

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8009e70:	f7ff fff6 	bl	8009e60 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8009e74:	f7ff f9bc 	bl	80091f0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit();
 8009e78:	f7ff fa38 	bl	80092ec <_pal_lld_init>
>>>>>>> 752c83b... update binaries
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
<<<<<<< HEAD
 8009df4:	f7ff f856 	bl	8008ea4 <sdInit>
=======
 8009e7c:	f7ff f854 	bl	8008f28 <sdInit>
>>>>>>> 752c83b... update binaries
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
<<<<<<< HEAD
 8009df8:	f7ff fcfc 	bl	80097f4 <boardInit>
=======
 8009e80:	f7ff fcfa 	bl	8009878 <boardInit>
>>>>>>> 752c83b... update binaries
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
<<<<<<< HEAD
 8009dfc:	f7ff f920 	bl	8009040 <stInit>
#endif
}
 8009e00:	bd80      	pop	{r7, pc}
 8009e02:	bf00      	nop

08009e04 <port_lock.lto_priv.236>:
=======
 8009e84:	f7ff f91e 	bl	80090c4 <stInit>
#endif
}
 8009e88:	bd80      	pop	{r7, pc}
 8009e8a:	bf00      	nop

08009e8c <port_lock.lto_priv.233>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 8009e04:	b480      	push	{r7}
 8009e06:	b083      	sub	sp, #12
 8009e08:	af00      	add	r7, sp, #0
 8009e0a:	2320      	movs	r3, #32
 8009e0c:	607b      	str	r3, [r7, #4]
=======
 8009e8c:	b480      	push	{r7}
 8009e8e:	b083      	sub	sp, #12
 8009e90:	af00      	add	r7, sp, #0
 8009e92:	2320      	movs	r3, #32
 8009e94:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
<<<<<<< HEAD
 8009e0e:	687b      	ldr	r3, [r7, #4]
 8009e10:	f383 8811 	msr	BASEPRI, r3
=======
 8009e96:	687b      	ldr	r3, [r7, #4]
 8009e98:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009e14:	370c      	adds	r7, #12
 8009e16:	46bd      	mov	sp, r7
 8009e18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e1c:	4770      	bx	lr
 8009e1e:	bf00      	nop

08009e20 <port_unlock.lto_priv.231>:
=======
 8009e9c:	370c      	adds	r7, #12
 8009e9e:	46bd      	mov	sp, r7
 8009ea0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ea4:	4770      	bx	lr
 8009ea6:	bf00      	nop

08009ea8 <port_unlock.lto_priv.228>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 8009e20:	b480      	push	{r7}
 8009e22:	b083      	sub	sp, #12
 8009e24:	af00      	add	r7, sp, #0
 8009e26:	2300      	movs	r3, #0
 8009e28:	607b      	str	r3, [r7, #4]
 8009e2a:	687b      	ldr	r3, [r7, #4]
 8009e2c:	f383 8811 	msr	BASEPRI, r3
=======
 8009ea8:	b480      	push	{r7}
 8009eaa:	b083      	sub	sp, #12
 8009eac:	af00      	add	r7, sp, #0
 8009eae:	2300      	movs	r3, #0
 8009eb0:	607b      	str	r3, [r7, #4]
 8009eb2:	687b      	ldr	r3, [r7, #4]
 8009eb4:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 8009e30:	370c      	adds	r7, #12
 8009e32:	46bd      	mov	sp, r7
 8009e34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e38:	4770      	bx	lr
 8009e3a:	bf00      	nop

08009e3c <st_lld_get_counter.lto_priv.226>:
=======
 8009eb8:	370c      	adds	r7, #12
 8009eba:	46bd      	mov	sp, r7
 8009ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ec0:	4770      	bx	lr
 8009ec2:	bf00      	nop

08009ec4 <st_lld_get_counter.lto_priv.223>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
<<<<<<< HEAD
 8009e3c:	b480      	push	{r7}
 8009e3e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8009e40:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009e44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009e46:	b29b      	uxth	r3, r3
}
 8009e48:	4618      	mov	r0, r3
 8009e4a:	46bd      	mov	sp, r7
 8009e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e50:	4770      	bx	lr
 8009e52:	bf00      	nop

08009e54 <port_timer_get_time.lto_priv.224>:
=======
 8009ec4:	b480      	push	{r7}
 8009ec6:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 8009ec8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009ecc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009ece:	b29b      	uxth	r3, r3
}
 8009ed0:	4618      	mov	r0, r3
 8009ed2:	46bd      	mov	sp, r7
 8009ed4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ed8:	4770      	bx	lr
 8009eda:	bf00      	nop

08009edc <port_timer_get_time.lto_priv.221>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
<<<<<<< HEAD
 8009e54:	b580      	push	{r7, lr}
 8009e56:	af00      	add	r7, sp, #0

  return stGetCounter();
 8009e58:	f7ff fff0 	bl	8009e3c <st_lld_get_counter.lto_priv.226>
 8009e5c:	4603      	mov	r3, r0
}
 8009e5e:	4618      	mov	r0, r3
 8009e60:	bd80      	pop	{r7, pc}
 8009e62:	bf00      	nop

08009e64 <queue_init.lto_priv.222>:
=======
 8009edc:	b580      	push	{r7, lr}
 8009ede:	af00      	add	r7, sp, #0

  return stGetCounter();
 8009ee0:	f7ff fff0 	bl	8009ec4 <st_lld_get_counter.lto_priv.223>
 8009ee4:	4603      	mov	r3, r0
}
 8009ee6:	4618      	mov	r0, r3
 8009ee8:	bd80      	pop	{r7, pc}
 8009eea:	bf00      	nop

08009eec <queue_init.lto_priv.219>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
<<<<<<< HEAD
 8009e64:	b480      	push	{r7}
 8009e66:	b083      	sub	sp, #12
 8009e68:	af00      	add	r7, sp, #0
 8009e6a:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 8009e6c:	687b      	ldr	r3, [r7, #4]
 8009e6e:	687a      	ldr	r2, [r7, #4]
 8009e70:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8009e72:	687b      	ldr	r3, [r7, #4]
 8009e74:	687a      	ldr	r2, [r7, #4]
 8009e76:	605a      	str	r2, [r3, #4]
}
 8009e78:	370c      	adds	r7, #12
 8009e7a:	46bd      	mov	sp, r7
 8009e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e80:	4770      	bx	lr
 8009e82:	bf00      	nop

08009e84 <chSysLock.lto_priv.220>:
=======
 8009eec:	b480      	push	{r7}
 8009eee:	b083      	sub	sp, #12
 8009ef0:	af00      	add	r7, sp, #0
 8009ef2:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 8009ef4:	687b      	ldr	r3, [r7, #4]
 8009ef6:	687a      	ldr	r2, [r7, #4]
 8009ef8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8009efa:	687b      	ldr	r3, [r7, #4]
 8009efc:	687a      	ldr	r2, [r7, #4]
 8009efe:	605a      	str	r2, [r3, #4]
}
 8009f00:	370c      	adds	r7, #12
 8009f02:	46bd      	mov	sp, r7
 8009f04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f08:	4770      	bx	lr
 8009f0a:	bf00      	nop

08009f0c <chSysLock.lto_priv.217>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 8009e84:	b580      	push	{r7, lr}
 8009e86:	af00      	add	r7, sp, #0

  port_lock();
 8009e88:	f7ff ffbc 	bl	8009e04 <port_lock.lto_priv.236>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009e8c:	f000 ffd8 	bl	800ae40 <_dbg_check_lock>
}
 8009e90:	bd80      	pop	{r7, pc}
 8009e92:	bf00      	nop

08009e94 <chSysUnlock.lto_priv.216>:
=======
 8009f0c:	b580      	push	{r7, lr}
 8009f0e:	af00      	add	r7, sp, #0

  port_lock();
 8009f10:	f7ff ffbc 	bl	8009e8c <port_lock.lto_priv.233>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009f14:	f000 ffd8 	bl	800aec8 <_dbg_check_lock>
}
 8009f18:	bd80      	pop	{r7, pc}
 8009f1a:	bf00      	nop

08009f1c <chSysUnlock.lto_priv.213>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 8009e94:	b580      	push	{r7, lr}
 8009e96:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009e98:	f000 ffe8 	bl	800ae6c <_dbg_check_unlock>
=======
 8009f1c:	b580      	push	{r7, lr}
 8009f1e:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 8009f20:	f000 ffe8 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 8009e9c:	4b09      	ldr	r3, [pc, #36]	; (8009ec4 <chSysUnlock.lto_priv.216+0x30>)
 8009e9e:	681b      	ldr	r3, [r3, #0]
 8009ea0:	4a08      	ldr	r2, [pc, #32]	; (8009ec4 <chSysUnlock.lto_priv.216+0x30>)
 8009ea2:	4293      	cmp	r3, r2
 8009ea4:	d00a      	beq.n	8009ebc <chSysUnlock.lto_priv.216+0x28>
 8009ea6:	4b07      	ldr	r3, [pc, #28]	; (8009ec4 <chSysUnlock.lto_priv.216+0x30>)
 8009ea8:	699b      	ldr	r3, [r3, #24]
 8009eaa:	689a      	ldr	r2, [r3, #8]
 8009eac:	4b05      	ldr	r3, [pc, #20]	; (8009ec4 <chSysUnlock.lto_priv.216+0x30>)
 8009eae:	681b      	ldr	r3, [r3, #0]
 8009eb0:	689b      	ldr	r3, [r3, #8]
 8009eb2:	429a      	cmp	r2, r3
 8009eb4:	d202      	bcs.n	8009ebc <chSysUnlock.lto_priv.216+0x28>
 8009eb6:	4804      	ldr	r0, [pc, #16]	; (8009ec8 <chSysUnlock.lto_priv.216+0x34>)
 8009eb8:	f000 ff74 	bl	800ada4 <chSysHalt>
=======
 8009f24:	4b09      	ldr	r3, [pc, #36]	; (8009f4c <chSysUnlock.lto_priv.213+0x30>)
 8009f26:	681b      	ldr	r3, [r3, #0]
 8009f28:	4a08      	ldr	r2, [pc, #32]	; (8009f4c <chSysUnlock.lto_priv.213+0x30>)
 8009f2a:	4293      	cmp	r3, r2
 8009f2c:	d00a      	beq.n	8009f44 <chSysUnlock.lto_priv.213+0x28>
 8009f2e:	4b07      	ldr	r3, [pc, #28]	; (8009f4c <chSysUnlock.lto_priv.213+0x30>)
 8009f30:	699b      	ldr	r3, [r3, #24]
 8009f32:	689a      	ldr	r2, [r3, #8]
 8009f34:	4b05      	ldr	r3, [pc, #20]	; (8009f4c <chSysUnlock.lto_priv.213+0x30>)
 8009f36:	681b      	ldr	r3, [r3, #0]
 8009f38:	689b      	ldr	r3, [r3, #8]
 8009f3a:	429a      	cmp	r2, r3
 8009f3c:	d202      	bcs.n	8009f44 <chSysUnlock.lto_priv.213+0x28>
 8009f3e:	4804      	ldr	r0, [pc, #16]	; (8009f50 <chSysUnlock.lto_priv.213+0x34>)
 8009f40:	f000 ff74 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 8009ebc:	f7ff ffb0 	bl	8009e20 <port_unlock.lto_priv.231>
}
 8009ec0:	bd80      	pop	{r7, pc}
 8009ec2:	bf00      	nop
 8009ec4:	20001338 	.word	0x20001338
 8009ec8:	0800ea98 	.word	0x0800ea98

08009ecc <chVTGetSystemTimeX.lto_priv.212>:
=======
 8009f44:	f7ff ffb0 	bl	8009ea8 <port_unlock.lto_priv.228>
}
 8009f48:	bd80      	pop	{r7, pc}
 8009f4a:	bf00      	nop
 8009f4c:	20001338 	.word	0x20001338
 8009f50:	0800eb70 	.word	0x0800eb70

08009f54 <chVTGetSystemTimeX.lto_priv.209>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
<<<<<<< HEAD
 8009ecc:	b580      	push	{r7, lr}
 8009ece:	af00      	add	r7, sp, #0
=======
 8009f54:	b580      	push	{r7, lr}
 8009f56:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
<<<<<<< HEAD
 8009ed0:	f7ff ffc0 	bl	8009e54 <port_timer_get_time.lto_priv.224>
 8009ed4:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8009ed6:	4618      	mov	r0, r3
 8009ed8:	bd80      	pop	{r7, pc}
 8009eda:	bf00      	nop

08009edc <chThdQueueObjectInit.lto_priv.210>:
=======
 8009f58:	f7ff ffc0 	bl	8009edc <port_timer_get_time.lto_priv.221>
 8009f5c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8009f5e:	4618      	mov	r0, r3
 8009f60:	bd80      	pop	{r7, pc}
 8009f62:	bf00      	nop

08009f64 <chThdQueueObjectInit.lto_priv.207>:
>>>>>>> 752c83b... update binaries
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
<<<<<<< HEAD
 8009edc:	b580      	push	{r7, lr}
 8009ede:	b082      	sub	sp, #8
 8009ee0:	af00      	add	r7, sp, #0
 8009ee2:	6078      	str	r0, [r7, #4]

  queue_init(tqp);
 8009ee4:	6878      	ldr	r0, [r7, #4]
 8009ee6:	f7ff ffbd 	bl	8009e64 <queue_init.lto_priv.222>
}
 8009eea:	3708      	adds	r7, #8
 8009eec:	46bd      	mov	sp, r7
 8009eee:	bd80      	pop	{r7, pc}

08009ef0 <osalSysLock.lto_priv.197>:
=======
 8009f64:	b580      	push	{r7, lr}
 8009f66:	b082      	sub	sp, #8
 8009f68:	af00      	add	r7, sp, #0
 8009f6a:	6078      	str	r0, [r7, #4]

  queue_init(tqp);
 8009f6c:	6878      	ldr	r0, [r7, #4]
 8009f6e:	f7ff ffbd 	bl	8009eec <queue_init.lto_priv.219>
}
 8009f72:	3708      	adds	r7, #8
 8009f74:	46bd      	mov	sp, r7
 8009f76:	bd80      	pop	{r7, pc}

08009f78 <osalSysLock.lto_priv.194>:
>>>>>>> 752c83b... update binaries
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
<<<<<<< HEAD
 8009ef0:	b580      	push	{r7, lr}
 8009ef2:	af00      	add	r7, sp, #0

  chSysLock();
 8009ef4:	f7ff ffc6 	bl	8009e84 <chSysLock.lto_priv.220>
}
 8009ef8:	bd80      	pop	{r7, pc}
 8009efa:	bf00      	nop

08009efc <osalSysUnlock.lto_priv.195>:
=======
 8009f78:	b580      	push	{r7, lr}
 8009f7a:	af00      	add	r7, sp, #0

  chSysLock();
 8009f7c:	f7ff ffc6 	bl	8009f0c <chSysLock.lto_priv.217>
}
 8009f80:	bd80      	pop	{r7, pc}
 8009f82:	bf00      	nop

08009f84 <osalSysUnlock.lto_priv.192>:
>>>>>>> 752c83b... update binaries
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
<<<<<<< HEAD
 8009efc:	b580      	push	{r7, lr}
 8009efe:	af00      	add	r7, sp, #0

  chSysUnlock();
 8009f00:	f7ff ffc8 	bl	8009e94 <chSysUnlock.lto_priv.216>
}
 8009f04:	bd80      	pop	{r7, pc}
 8009f06:	bf00      	nop

08009f08 <osalOsGetSystemTimeX.lto_priv.203>:
=======
 8009f84:	b580      	push	{r7, lr}
 8009f86:	af00      	add	r7, sp, #0

  chSysUnlock();
 8009f88:	f7ff ffc8 	bl	8009f1c <chSysUnlock.lto_priv.213>
}
 8009f8c:	bd80      	pop	{r7, pc}
 8009f8e:	bf00      	nop

08009f90 <osalOsGetSystemTimeX.lto_priv.200>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
<<<<<<< HEAD
 8009f08:	b580      	push	{r7, lr}
 8009f0a:	af00      	add	r7, sp, #0

  return chVTGetSystemTimeX();
 8009f0c:	f7ff ffde 	bl	8009ecc <chVTGetSystemTimeX.lto_priv.212>
 8009f10:	4603      	mov	r3, r0
}
 8009f12:	4618      	mov	r0, r3
 8009f14:	bd80      	pop	{r7, pc}
 8009f16:	bf00      	nop

08009f18 <osalThreadQueueObjectInit.lto_priv.208>:
=======
 8009f90:	b580      	push	{r7, lr}
 8009f92:	af00      	add	r7, sp, #0

  return chVTGetSystemTimeX();
 8009f94:	f7ff ffde 	bl	8009f54 <chVTGetSystemTimeX.lto_priv.209>
 8009f98:	4603      	mov	r3, r0
}
 8009f9a:	4618      	mov	r0, r3
 8009f9c:	bd80      	pop	{r7, pc}
 8009f9e:	bf00      	nop

08009fa0 <osalThreadQueueObjectInit.lto_priv.205>:
>>>>>>> 752c83b... update binaries
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
<<<<<<< HEAD
 8009f18:	b580      	push	{r7, lr}
 8009f1a:	b082      	sub	sp, #8
 8009f1c:	af00      	add	r7, sp, #0
 8009f1e:	6078      	str	r0, [r7, #4]

  chThdQueueObjectInit(tqp);
 8009f20:	6878      	ldr	r0, [r7, #4]
 8009f22:	f7ff ffdb 	bl	8009edc <chThdQueueObjectInit.lto_priv.210>
}
 8009f26:	3708      	adds	r7, #8
 8009f28:	46bd      	mov	sp, r7
 8009f2a:	bd80      	pop	{r7, pc}

08009f2c <osalThreadEnqueueTimeoutS.lto_priv.202>:
=======
 8009fa0:	b580      	push	{r7, lr}
 8009fa2:	b082      	sub	sp, #8
 8009fa4:	af00      	add	r7, sp, #0
 8009fa6:	6078      	str	r0, [r7, #4]

  chThdQueueObjectInit(tqp);
 8009fa8:	6878      	ldr	r0, [r7, #4]
 8009faa:	f7ff ffdb 	bl	8009f64 <chThdQueueObjectInit.lto_priv.207>
}
 8009fae:	3708      	adds	r7, #8
 8009fb0:	46bd      	mov	sp, r7
 8009fb2:	bd80      	pop	{r7, pc}

08009fb4 <osalThreadEnqueueTimeoutS.lto_priv.199>:
>>>>>>> 752c83b... update binaries
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
<<<<<<< HEAD
 8009f2c:	b580      	push	{r7, lr}
 8009f2e:	b082      	sub	sp, #8
 8009f30:	af00      	add	r7, sp, #0
 8009f32:	6078      	str	r0, [r7, #4]
 8009f34:	460b      	mov	r3, r1
 8009f36:	807b      	strh	r3, [r7, #2]

  return chThdEnqueueTimeoutS(tqp, time);
 8009f38:	887b      	ldrh	r3, [r7, #2]
 8009f3a:	6878      	ldr	r0, [r7, #4]
 8009f3c:	4619      	mov	r1, r3
 8009f3e:	f000 fa9d 	bl	800a47c <chThdEnqueueTimeoutS>
 8009f42:	4603      	mov	r3, r0
}
 8009f44:	4618      	mov	r0, r3
 8009f46:	3708      	adds	r7, #8
 8009f48:	46bd      	mov	sp, r7
 8009f4a:	bd80      	pop	{r7, pc}

08009f4c <osalThreadDequeueNextI.lto_priv.204>:
=======
 8009fb4:	b580      	push	{r7, lr}
 8009fb6:	b082      	sub	sp, #8
 8009fb8:	af00      	add	r7, sp, #0
 8009fba:	6078      	str	r0, [r7, #4]
 8009fbc:	460b      	mov	r3, r1
 8009fbe:	807b      	strh	r3, [r7, #2]

  return chThdEnqueueTimeoutS(tqp, time);
 8009fc0:	887b      	ldrh	r3, [r7, #2]
 8009fc2:	6878      	ldr	r0, [r7, #4]
 8009fc4:	4619      	mov	r1, r3
 8009fc6:	f000 fa9d 	bl	800a504 <chThdEnqueueTimeoutS>
 8009fca:	4603      	mov	r3, r0
}
 8009fcc:	4618      	mov	r0, r3
 8009fce:	3708      	adds	r7, #8
 8009fd0:	46bd      	mov	sp, r7
 8009fd2:	bd80      	pop	{r7, pc}

08009fd4 <osalThreadDequeueNextI.lto_priv.201>:
>>>>>>> 752c83b... update binaries
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
<<<<<<< HEAD
 8009f4c:	b580      	push	{r7, lr}
 8009f4e:	b082      	sub	sp, #8
 8009f50:	af00      	add	r7, sp, #0
 8009f52:	6078      	str	r0, [r7, #4]
 8009f54:	6039      	str	r1, [r7, #0]

  chThdDequeueNextI(tqp, msg);
 8009f56:	6878      	ldr	r0, [r7, #4]
 8009f58:	6839      	ldr	r1, [r7, #0]
 8009f5a:	f000 faad 	bl	800a4b8 <chThdDequeueNextI>
}
 8009f5e:	3708      	adds	r7, #8
 8009f60:	46bd      	mov	sp, r7
 8009f62:	bd80      	pop	{r7, pc}

08009f64 <iqObjectInit>:
=======
 8009fd4:	b580      	push	{r7, lr}
 8009fd6:	b082      	sub	sp, #8
 8009fd8:	af00      	add	r7, sp, #0
 8009fda:	6078      	str	r0, [r7, #4]
 8009fdc:	6039      	str	r1, [r7, #0]

  chThdDequeueNextI(tqp, msg);
 8009fde:	6878      	ldr	r0, [r7, #4]
 8009fe0:	6839      	ldr	r1, [r7, #0]
 8009fe2:	f000 faad 	bl	800a540 <chThdDequeueNextI>
}
 8009fe6:	3708      	adds	r7, #8
 8009fe8:	46bd      	mov	sp, r7
 8009fea:	bd80      	pop	{r7, pc}

08009fec <iqObjectInit>:
>>>>>>> 752c83b... update binaries
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
<<<<<<< HEAD
 8009f64:	b580      	push	{r7, lr}
 8009f66:	b084      	sub	sp, #16
 8009f68:	af00      	add	r7, sp, #0
 8009f6a:	60f8      	str	r0, [r7, #12]
 8009f6c:	60b9      	str	r1, [r7, #8]
 8009f6e:	607a      	str	r2, [r7, #4]
 8009f70:	603b      	str	r3, [r7, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8009f72:	68fb      	ldr	r3, [r7, #12]
 8009f74:	4618      	mov	r0, r3
 8009f76:	f7ff ffcf 	bl	8009f18 <osalThreadQueueObjectInit.lto_priv.208>
  iqp->q_counter = 0;
 8009f7a:	68fb      	ldr	r3, [r7, #12]
 8009f7c:	2200      	movs	r2, #0
 8009f7e:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 8009f80:	68fb      	ldr	r3, [r7, #12]
 8009f82:	68ba      	ldr	r2, [r7, #8]
 8009f84:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8009f86:	68fb      	ldr	r3, [r7, #12]
 8009f88:	68ba      	ldr	r2, [r7, #8]
 8009f8a:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8009f8c:	68fb      	ldr	r3, [r7, #12]
 8009f8e:	68ba      	ldr	r2, [r7, #8]
 8009f90:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 8009f92:	68ba      	ldr	r2, [r7, #8]
 8009f94:	687b      	ldr	r3, [r7, #4]
 8009f96:	441a      	add	r2, r3
 8009f98:	68fb      	ldr	r3, [r7, #12]
 8009f9a:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8009f9c:	68fb      	ldr	r3, [r7, #12]
 8009f9e:	683a      	ldr	r2, [r7, #0]
 8009fa0:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 8009fa2:	68fb      	ldr	r3, [r7, #12]
 8009fa4:	69ba      	ldr	r2, [r7, #24]
 8009fa6:	621a      	str	r2, [r3, #32]
}
 8009fa8:	3710      	adds	r7, #16
 8009faa:	46bd      	mov	sp, r7
 8009fac:	bd80      	pop	{r7, pc}
 8009fae:	bf00      	nop

08009fb0 <iqPutI>:
=======
 8009fec:	b580      	push	{r7, lr}
 8009fee:	b084      	sub	sp, #16
 8009ff0:	af00      	add	r7, sp, #0
 8009ff2:	60f8      	str	r0, [r7, #12]
 8009ff4:	60b9      	str	r1, [r7, #8]
 8009ff6:	607a      	str	r2, [r7, #4]
 8009ff8:	603b      	str	r3, [r7, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8009ffa:	68fb      	ldr	r3, [r7, #12]
 8009ffc:	4618      	mov	r0, r3
 8009ffe:	f7ff ffcf 	bl	8009fa0 <osalThreadQueueObjectInit.lto_priv.205>
  iqp->q_counter = 0;
 800a002:	68fb      	ldr	r3, [r7, #12]
 800a004:	2200      	movs	r2, #0
 800a006:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800a008:	68fb      	ldr	r3, [r7, #12]
 800a00a:	68ba      	ldr	r2, [r7, #8]
 800a00c:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 800a00e:	68fb      	ldr	r3, [r7, #12]
 800a010:	68ba      	ldr	r2, [r7, #8]
 800a012:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 800a014:	68fb      	ldr	r3, [r7, #12]
 800a016:	68ba      	ldr	r2, [r7, #8]
 800a018:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800a01a:	68ba      	ldr	r2, [r7, #8]
 800a01c:	687b      	ldr	r3, [r7, #4]
 800a01e:	441a      	add	r2, r3
 800a020:	68fb      	ldr	r3, [r7, #12]
 800a022:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 800a024:	68fb      	ldr	r3, [r7, #12]
 800a026:	683a      	ldr	r2, [r7, #0]
 800a028:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800a02a:	68fb      	ldr	r3, [r7, #12]
 800a02c:	69ba      	ldr	r2, [r7, #24]
 800a02e:	621a      	str	r2, [r3, #32]
}
 800a030:	3710      	adds	r7, #16
 800a032:	46bd      	mov	sp, r7
 800a034:	bd80      	pop	{r7, pc}
 800a036:	bf00      	nop

0800a038 <iqPutI>:
>>>>>>> 752c83b... update binaries
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
<<<<<<< HEAD
 8009fb0:	b580      	push	{r7, lr}
 8009fb2:	b082      	sub	sp, #8
 8009fb4:	af00      	add	r7, sp, #0
 8009fb6:	6078      	str	r0, [r7, #4]
 8009fb8:	460b      	mov	r3, r1
 8009fba:	70fb      	strb	r3, [r7, #3]

  osalDbgCheckClassI();
 8009fbc:	f000 ffd0 	bl	800af60 <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
 8009fc0:	687b      	ldr	r3, [r7, #4]
 8009fc2:	695a      	ldr	r2, [r3, #20]
 8009fc4:	687b      	ldr	r3, [r7, #4]
 8009fc6:	699b      	ldr	r3, [r3, #24]
 8009fc8:	429a      	cmp	r2, r3
 8009fca:	d105      	bne.n	8009fd8 <iqPutI+0x28>
 8009fcc:	687b      	ldr	r3, [r7, #4]
 8009fce:	689b      	ldr	r3, [r3, #8]
 8009fd0:	2b00      	cmp	r3, #0
 8009fd2:	d001      	beq.n	8009fd8 <iqPutI+0x28>
 8009fd4:	2301      	movs	r3, #1
 8009fd6:	e000      	b.n	8009fda <iqPutI+0x2a>
 8009fd8:	2300      	movs	r3, #0
 8009fda:	f003 0301 	and.w	r3, r3, #1
 8009fde:	b2db      	uxtb	r3, r3
 8009fe0:	2b00      	cmp	r3, #0
 8009fe2:	d002      	beq.n	8009fea <iqPutI+0x3a>
    return MSG_TIMEOUT;
 8009fe4:	f04f 33ff 	mov.w	r3, #4294967295
 8009fe8:	e01b      	b.n	800a022 <iqPutI+0x72>
  }

  iqp->q_counter++;
 8009fea:	687b      	ldr	r3, [r7, #4]
 8009fec:	689b      	ldr	r3, [r3, #8]
 8009fee:	1c5a      	adds	r2, r3, #1
 8009ff0:	687b      	ldr	r3, [r7, #4]
 8009ff2:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8009ff4:	687b      	ldr	r3, [r7, #4]
 8009ff6:	695b      	ldr	r3, [r3, #20]
 8009ff8:	1c59      	adds	r1, r3, #1
 8009ffa:	687a      	ldr	r2, [r7, #4]
 8009ffc:	6151      	str	r1, [r2, #20]
 8009ffe:	78fa      	ldrb	r2, [r7, #3]
 800a000:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 800a002:	687b      	ldr	r3, [r7, #4]
 800a004:	695a      	ldr	r2, [r3, #20]
 800a006:	687b      	ldr	r3, [r7, #4]
 800a008:	691b      	ldr	r3, [r3, #16]
 800a00a:	429a      	cmp	r2, r3
 800a00c:	d303      	bcc.n	800a016 <iqPutI+0x66>
    iqp->q_wrptr = iqp->q_buffer;
 800a00e:	687b      	ldr	r3, [r7, #4]
 800a010:	68da      	ldr	r2, [r3, #12]
 800a012:	687b      	ldr	r3, [r7, #4]
 800a014:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 800a016:	687b      	ldr	r3, [r7, #4]
 800a018:	4618      	mov	r0, r3
 800a01a:	2100      	movs	r1, #0
 800a01c:	f7ff ff96 	bl	8009f4c <osalThreadDequeueNextI.lto_priv.204>

  return MSG_OK;
 800a020:	2300      	movs	r3, #0
}
 800a022:	4618      	mov	r0, r3
 800a024:	3708      	adds	r7, #8
 800a026:	46bd      	mov	sp, r7
 800a028:	bd80      	pop	{r7, pc}
 800a02a:	bf00      	nop

0800a02c <iqGetTimeout>:
=======
 800a038:	b580      	push	{r7, lr}
 800a03a:	b082      	sub	sp, #8
 800a03c:	af00      	add	r7, sp, #0
 800a03e:	6078      	str	r0, [r7, #4]
 800a040:	460b      	mov	r3, r1
 800a042:	70fb      	strb	r3, [r7, #3]

  osalDbgCheckClassI();
 800a044:	f000 ffd0 	bl	800afe8 <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
 800a048:	687b      	ldr	r3, [r7, #4]
 800a04a:	695a      	ldr	r2, [r3, #20]
 800a04c:	687b      	ldr	r3, [r7, #4]
 800a04e:	699b      	ldr	r3, [r3, #24]
 800a050:	429a      	cmp	r2, r3
 800a052:	d105      	bne.n	800a060 <iqPutI+0x28>
 800a054:	687b      	ldr	r3, [r7, #4]
 800a056:	689b      	ldr	r3, [r3, #8]
 800a058:	2b00      	cmp	r3, #0
 800a05a:	d001      	beq.n	800a060 <iqPutI+0x28>
 800a05c:	2301      	movs	r3, #1
 800a05e:	e000      	b.n	800a062 <iqPutI+0x2a>
 800a060:	2300      	movs	r3, #0
 800a062:	f003 0301 	and.w	r3, r3, #1
 800a066:	b2db      	uxtb	r3, r3
 800a068:	2b00      	cmp	r3, #0
 800a06a:	d002      	beq.n	800a072 <iqPutI+0x3a>
    return MSG_TIMEOUT;
 800a06c:	f04f 33ff 	mov.w	r3, #4294967295
 800a070:	e01b      	b.n	800a0aa <iqPutI+0x72>
  }

  iqp->q_counter++;
 800a072:	687b      	ldr	r3, [r7, #4]
 800a074:	689b      	ldr	r3, [r3, #8]
 800a076:	1c5a      	adds	r2, r3, #1
 800a078:	687b      	ldr	r3, [r7, #4]
 800a07a:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 800a07c:	687b      	ldr	r3, [r7, #4]
 800a07e:	695b      	ldr	r3, [r3, #20]
 800a080:	1c59      	adds	r1, r3, #1
 800a082:	687a      	ldr	r2, [r7, #4]
 800a084:	6151      	str	r1, [r2, #20]
 800a086:	78fa      	ldrb	r2, [r7, #3]
 800a088:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 800a08a:	687b      	ldr	r3, [r7, #4]
 800a08c:	695a      	ldr	r2, [r3, #20]
 800a08e:	687b      	ldr	r3, [r7, #4]
 800a090:	691b      	ldr	r3, [r3, #16]
 800a092:	429a      	cmp	r2, r3
 800a094:	d303      	bcc.n	800a09e <iqPutI+0x66>
    iqp->q_wrptr = iqp->q_buffer;
 800a096:	687b      	ldr	r3, [r7, #4]
 800a098:	68da      	ldr	r2, [r3, #12]
 800a09a:	687b      	ldr	r3, [r7, #4]
 800a09c:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 800a09e:	687b      	ldr	r3, [r7, #4]
 800a0a0:	4618      	mov	r0, r3
 800a0a2:	2100      	movs	r1, #0
 800a0a4:	f7ff ff96 	bl	8009fd4 <osalThreadDequeueNextI.lto_priv.201>

  return MSG_OK;
 800a0a8:	2300      	movs	r3, #0
}
 800a0aa:	4618      	mov	r0, r3
 800a0ac:	3708      	adds	r7, #8
 800a0ae:	46bd      	mov	sp, r7
 800a0b0:	bd80      	pop	{r7, pc}
 800a0b2:	bf00      	nop

0800a0b4 <iqGetTimeout>:
>>>>>>> 752c83b... update binaries
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
<<<<<<< HEAD
 800a02c:	b580      	push	{r7, lr}
 800a02e:	b084      	sub	sp, #16
 800a030:	af00      	add	r7, sp, #0
 800a032:	6078      	str	r0, [r7, #4]
 800a034:	460b      	mov	r3, r1
 800a036:	807b      	strh	r3, [r7, #2]
  uint8_t b;

  osalSysLock();
 800a038:	f7ff ff5a 	bl	8009ef0 <osalSysLock.lto_priv.197>
 800a03c:	e00d      	b.n	800a05a <iqGetTimeout+0x2e>
=======
 800a0b4:	b580      	push	{r7, lr}
 800a0b6:	b084      	sub	sp, #16
 800a0b8:	af00      	add	r7, sp, #0
 800a0ba:	6078      	str	r0, [r7, #4]
 800a0bc:	460b      	mov	r3, r1
 800a0be:	807b      	strh	r3, [r7, #2]
  uint8_t b;

  osalSysLock();
 800a0c0:	f7ff ff5a 	bl	8009f78 <osalSysLock.lto_priv.194>
 800a0c4:	e00d      	b.n	800a0e2 <iqGetTimeout+0x2e>
>>>>>>> 752c83b... update binaries

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
<<<<<<< HEAD
 800a03e:	687a      	ldr	r2, [r7, #4]
 800a040:	887b      	ldrh	r3, [r7, #2]
 800a042:	4610      	mov	r0, r2
 800a044:	4619      	mov	r1, r3
 800a046:	f7ff ff71 	bl	8009f2c <osalThreadEnqueueTimeoutS.lto_priv.202>
 800a04a:	60f8      	str	r0, [r7, #12]
    if (msg < MSG_OK) {
 800a04c:	68fb      	ldr	r3, [r7, #12]
 800a04e:	2b00      	cmp	r3, #0
 800a050:	da03      	bge.n	800a05a <iqGetTimeout+0x2e>
      osalSysUnlock();
 800a052:	f7ff ff53 	bl	8009efc <osalSysUnlock.lto_priv.195>
      return msg;
 800a056:	68fb      	ldr	r3, [r7, #12]
 800a058:	e024      	b.n	800a0a4 <iqGetTimeout+0x78>
=======
 800a0c6:	687a      	ldr	r2, [r7, #4]
 800a0c8:	887b      	ldrh	r3, [r7, #2]
 800a0ca:	4610      	mov	r0, r2
 800a0cc:	4619      	mov	r1, r3
 800a0ce:	f7ff ff71 	bl	8009fb4 <osalThreadEnqueueTimeoutS.lto_priv.199>
 800a0d2:	60f8      	str	r0, [r7, #12]
    if (msg < MSG_OK) {
 800a0d4:	68fb      	ldr	r3, [r7, #12]
 800a0d6:	2b00      	cmp	r3, #0
 800a0d8:	da03      	bge.n	800a0e2 <iqGetTimeout+0x2e>
      osalSysUnlock();
 800a0da:	f7ff ff53 	bl	8009f84 <osalSysUnlock.lto_priv.192>
      return msg;
 800a0de:	68fb      	ldr	r3, [r7, #12]
 800a0e0:	e024      	b.n	800a12c <iqGetTimeout+0x78>
>>>>>>> 752c83b... update binaries
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
<<<<<<< HEAD
 800a05a:	687b      	ldr	r3, [r7, #4]
 800a05c:	689b      	ldr	r3, [r3, #8]
 800a05e:	2b00      	cmp	r3, #0
 800a060:	d0ed      	beq.n	800a03e <iqGetTimeout+0x12>
=======
 800a0e2:	687b      	ldr	r3, [r7, #4]
 800a0e4:	689b      	ldr	r3, [r3, #8]
 800a0e6:	2b00      	cmp	r3, #0
 800a0e8:	d0ed      	beq.n	800a0c6 <iqGetTimeout+0x12>
>>>>>>> 752c83b... update binaries
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
<<<<<<< HEAD
 800a062:	687b      	ldr	r3, [r7, #4]
 800a064:	689b      	ldr	r3, [r3, #8]
 800a066:	1e5a      	subs	r2, r3, #1
 800a068:	687b      	ldr	r3, [r7, #4]
 800a06a:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800a06c:	687b      	ldr	r3, [r7, #4]
 800a06e:	699b      	ldr	r3, [r3, #24]
 800a070:	1c59      	adds	r1, r3, #1
 800a072:	687a      	ldr	r2, [r7, #4]
 800a074:	6191      	str	r1, [r2, #24]
 800a076:	781b      	ldrb	r3, [r3, #0]
 800a078:	72fb      	strb	r3, [r7, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 800a07a:	687b      	ldr	r3, [r7, #4]
 800a07c:	699a      	ldr	r2, [r3, #24]
 800a07e:	687b      	ldr	r3, [r7, #4]
 800a080:	691b      	ldr	r3, [r3, #16]
 800a082:	429a      	cmp	r2, r3
 800a084:	d303      	bcc.n	800a08e <iqGetTimeout+0x62>
    iqp->q_rdptr = iqp->q_buffer;
 800a086:	687b      	ldr	r3, [r7, #4]
 800a088:	68da      	ldr	r2, [r3, #12]
 800a08a:	687b      	ldr	r3, [r7, #4]
 800a08c:	619a      	str	r2, [r3, #24]
=======
 800a0ea:	687b      	ldr	r3, [r7, #4]
 800a0ec:	689b      	ldr	r3, [r3, #8]
 800a0ee:	1e5a      	subs	r2, r3, #1
 800a0f0:	687b      	ldr	r3, [r7, #4]
 800a0f2:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800a0f4:	687b      	ldr	r3, [r7, #4]
 800a0f6:	699b      	ldr	r3, [r3, #24]
 800a0f8:	1c59      	adds	r1, r3, #1
 800a0fa:	687a      	ldr	r2, [r7, #4]
 800a0fc:	6191      	str	r1, [r2, #24]
 800a0fe:	781b      	ldrb	r3, [r3, #0]
 800a100:	72fb      	strb	r3, [r7, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 800a102:	687b      	ldr	r3, [r7, #4]
 800a104:	699a      	ldr	r2, [r3, #24]
 800a106:	687b      	ldr	r3, [r7, #4]
 800a108:	691b      	ldr	r3, [r3, #16]
 800a10a:	429a      	cmp	r2, r3
 800a10c:	d303      	bcc.n	800a116 <iqGetTimeout+0x62>
    iqp->q_rdptr = iqp->q_buffer;
 800a10e:	687b      	ldr	r3, [r7, #4]
 800a110:	68da      	ldr	r2, [r3, #12]
 800a112:	687b      	ldr	r3, [r7, #4]
 800a114:	619a      	str	r2, [r3, #24]
>>>>>>> 752c83b... update binaries
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
<<<<<<< HEAD
 800a08e:	687b      	ldr	r3, [r7, #4]
 800a090:	69db      	ldr	r3, [r3, #28]
 800a092:	2b00      	cmp	r3, #0
 800a094:	d003      	beq.n	800a09e <iqGetTimeout+0x72>
    iqp->q_notify(iqp);
 800a096:	687b      	ldr	r3, [r7, #4]
 800a098:	69db      	ldr	r3, [r3, #28]
 800a09a:	6878      	ldr	r0, [r7, #4]
 800a09c:	4798      	blx	r3
  }

  osalSysUnlock();
 800a09e:	f7ff ff2d 	bl	8009efc <osalSysUnlock.lto_priv.195>

  return (msg_t)b;
 800a0a2:	7afb      	ldrb	r3, [r7, #11]
}
 800a0a4:	4618      	mov	r0, r3
 800a0a6:	3710      	adds	r7, #16
 800a0a8:	46bd      	mov	sp, r7
 800a0aa:	bd80      	pop	{r7, pc}

0800a0ac <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 800a0ac:	b580      	push	{r7, lr}
 800a0ae:	b088      	sub	sp, #32
 800a0b0:	af00      	add	r7, sp, #0
 800a0b2:	60f8      	str	r0, [r7, #12]
 800a0b4:	60b9      	str	r1, [r7, #8]
 800a0b6:	607a      	str	r2, [r7, #4]
 800a0b8:	807b      	strh	r3, [r7, #2]
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 800a0ba:	68fb      	ldr	r3, [r7, #12]
 800a0bc:	69db      	ldr	r3, [r3, #28]
 800a0be:	617b      	str	r3, [r7, #20]
  size_t r = 0;
 800a0c0:	2300      	movs	r3, #0
 800a0c2:	61fb      	str	r3, [r7, #28]

  osalDbgCheck(n > 0U);
 800a0c4:	687b      	ldr	r3, [r7, #4]
 800a0c6:	2b00      	cmp	r3, #0
 800a0c8:	d102      	bne.n	800a0d0 <iqReadTimeout+0x24>
 800a0ca:	4838      	ldr	r0, [pc, #224]	; (800a1ac <iqReadTimeout+0x100>)
 800a0cc:	f000 fe6a 	bl	800ada4 <chSysHalt>

  osalSysLock();
 800a0d0:	f7ff ff0e 	bl	8009ef0 <osalSysLock.lto_priv.197>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800a0d4:	f7ff ff18 	bl	8009f08 <osalOsGetSystemTimeX.lto_priv.203>
 800a0d8:	4603      	mov	r3, r0
 800a0da:	461a      	mov	r2, r3
 800a0dc:	887b      	ldrh	r3, [r7, #2]
 800a0de:	4413      	add	r3, r2
 800a0e0:	827b      	strh	r3, [r7, #18]
 800a0e2:	e02c      	b.n	800a13e <iqReadTimeout+0x92>
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800a0e4:	887b      	ldrh	r3, [r7, #2]
 800a0e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a0ea:	4293      	cmp	r3, r2
 800a0ec:	d002      	beq.n	800a0f4 <iqReadTimeout+0x48>
 800a0ee:	887b      	ldrh	r3, [r7, #2]
 800a0f0:	2b00      	cmp	r3, #0
 800a0f2:	d107      	bne.n	800a104 <iqReadTimeout+0x58>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800a0f4:	68fa      	ldr	r2, [r7, #12]
 800a0f6:	887b      	ldrh	r3, [r7, #2]
 800a0f8:	4610      	mov	r0, r2
 800a0fa:	4619      	mov	r1, r3
 800a0fc:	f7ff ff16 	bl	8009f2c <osalThreadEnqueueTimeoutS.lto_priv.202>
 800a100:	61b8      	str	r0, [r7, #24]
 800a102:	e015      	b.n	800a130 <iqReadTimeout+0x84>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800a104:	f7ff ff00 	bl	8009f08 <osalOsGetSystemTimeX.lto_priv.203>
 800a108:	4603      	mov	r3, r0
 800a10a:	461a      	mov	r2, r3
 800a10c:	8a7b      	ldrh	r3, [r7, #18]
 800a10e:	1a9b      	subs	r3, r3, r2
 800a110:	823b      	strh	r3, [r7, #16]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800a112:	8a3a      	ldrh	r2, [r7, #16]
 800a114:	887b      	ldrh	r3, [r7, #2]
 800a116:	429a      	cmp	r2, r3
 800a118:	d903      	bls.n	800a122 <iqReadTimeout+0x76>
          osalSysUnlock();
 800a11a:	f7ff feef 	bl	8009efc <osalSysUnlock.lto_priv.195>
          return r;
 800a11e:	69fb      	ldr	r3, [r7, #28]
 800a120:	e040      	b.n	800a1a4 <iqReadTimeout+0xf8>
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
 800a122:	68fa      	ldr	r2, [r7, #12]
 800a124:	8a3b      	ldrh	r3, [r7, #16]
 800a126:	4610      	mov	r0, r2
 800a128:	4619      	mov	r1, r3
 800a12a:	f7ff feff 	bl	8009f2c <osalThreadEnqueueTimeoutS.lto_priv.202>
 800a12e:	61b8      	str	r0, [r7, #24]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800a130:	69bb      	ldr	r3, [r7, #24]
 800a132:	2b00      	cmp	r3, #0
 800a134:	d003      	beq.n	800a13e <iqReadTimeout+0x92>
        osalSysUnlock();
 800a136:	f7ff fee1 	bl	8009efc <osalSysUnlock.lto_priv.195>
        return r;
 800a13a:	69fb      	ldr	r3, [r7, #28]
 800a13c:	e032      	b.n	800a1a4 <iqReadTimeout+0xf8>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800a13e:	68fb      	ldr	r3, [r7, #12]
 800a140:	689b      	ldr	r3, [r3, #8]
 800a142:	2b00      	cmp	r3, #0
 800a144:	d0ce      	beq.n	800a0e4 <iqReadTimeout+0x38>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800a146:	68fb      	ldr	r3, [r7, #12]
 800a148:	689b      	ldr	r3, [r3, #8]
 800a14a:	1e5a      	subs	r2, r3, #1
 800a14c:	68fb      	ldr	r3, [r7, #12]
 800a14e:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 800a150:	68bb      	ldr	r3, [r7, #8]
 800a152:	1c5a      	adds	r2, r3, #1
 800a154:	60ba      	str	r2, [r7, #8]
 800a156:	68fa      	ldr	r2, [r7, #12]
 800a158:	6992      	ldr	r2, [r2, #24]
 800a15a:	1c50      	adds	r0, r2, #1
 800a15c:	68f9      	ldr	r1, [r7, #12]
 800a15e:	6188      	str	r0, [r1, #24]
 800a160:	7812      	ldrb	r2, [r2, #0]
 800a162:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800a164:	68fb      	ldr	r3, [r7, #12]
 800a166:	699a      	ldr	r2, [r3, #24]
 800a168:	68fb      	ldr	r3, [r7, #12]
 800a16a:	691b      	ldr	r3, [r3, #16]
 800a16c:	429a      	cmp	r2, r3
 800a16e:	d303      	bcc.n	800a178 <iqReadTimeout+0xcc>
      iqp->q_rdptr = iqp->q_buffer;
 800a170:	68fb      	ldr	r3, [r7, #12]
 800a172:	68da      	ldr	r2, [r3, #12]
 800a174:	68fb      	ldr	r3, [r7, #12]
 800a176:	619a      	str	r2, [r3, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 800a178:	697b      	ldr	r3, [r7, #20]
 800a17a:	2b00      	cmp	r3, #0
 800a17c:	d002      	beq.n	800a184 <iqReadTimeout+0xd8>
      nfy(iqp);
 800a17e:	697b      	ldr	r3, [r7, #20]
 800a180:	68f8      	ldr	r0, [r7, #12]
 800a182:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 800a184:	f7ff feba 	bl	8009efc <osalSysUnlock.lto_priv.195>

    r++;
 800a188:	69fb      	ldr	r3, [r7, #28]
 800a18a:	3301      	adds	r3, #1
 800a18c:	61fb      	str	r3, [r7, #28]
    if (--n == 0U) {
 800a18e:	687b      	ldr	r3, [r7, #4]
 800a190:	3b01      	subs	r3, #1
 800a192:	607b      	str	r3, [r7, #4]
 800a194:	687b      	ldr	r3, [r7, #4]
 800a196:	2b00      	cmp	r3, #0
 800a198:	d101      	bne.n	800a19e <iqReadTimeout+0xf2>
      return r;
 800a19a:	69fb      	ldr	r3, [r7, #28]
 800a19c:	e002      	b.n	800a1a4 <iqReadTimeout+0xf8>
    }

    osalSysLock();
 800a19e:	f7ff fea7 	bl	8009ef0 <osalSysLock.lto_priv.197>
 800a1a2:	e7cc      	b.n	800a13e <iqReadTimeout+0x92>
  }
}
 800a1a4:	4618      	mov	r0, r3
 800a1a6:	3720      	adds	r7, #32
 800a1a8:	46bd      	mov	sp, r7
 800a1aa:	bd80      	pop	{r7, pc}
 800a1ac:	0800eaa4 	.word	0x0800eaa4

0800a1b0 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 800a1b0:	b580      	push	{r7, lr}
 800a1b2:	b084      	sub	sp, #16
 800a1b4:	af00      	add	r7, sp, #0
 800a1b6:	60f8      	str	r0, [r7, #12]
 800a1b8:	60b9      	str	r1, [r7, #8]
 800a1ba:	607a      	str	r2, [r7, #4]
 800a1bc:	603b      	str	r3, [r7, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800a1be:	68fb      	ldr	r3, [r7, #12]
 800a1c0:	4618      	mov	r0, r3
 800a1c2:	f7ff fea9 	bl	8009f18 <osalThreadQueueObjectInit.lto_priv.208>
  oqp->q_counter = size;
 800a1c6:	68fb      	ldr	r3, [r7, #12]
 800a1c8:	687a      	ldr	r2, [r7, #4]
 800a1ca:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800a1cc:	68fb      	ldr	r3, [r7, #12]
 800a1ce:	68ba      	ldr	r2, [r7, #8]
 800a1d0:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 800a1d2:	68fb      	ldr	r3, [r7, #12]
 800a1d4:	68ba      	ldr	r2, [r7, #8]
 800a1d6:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 800a1d8:	68fb      	ldr	r3, [r7, #12]
 800a1da:	68ba      	ldr	r2, [r7, #8]
 800a1dc:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800a1de:	68ba      	ldr	r2, [r7, #8]
 800a1e0:	687b      	ldr	r3, [r7, #4]
 800a1e2:	441a      	add	r2, r3
 800a1e4:	68fb      	ldr	r3, [r7, #12]
 800a1e6:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 800a1e8:	68fb      	ldr	r3, [r7, #12]
 800a1ea:	683a      	ldr	r2, [r7, #0]
 800a1ec:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800a1ee:	68fb      	ldr	r3, [r7, #12]
 800a1f0:	69ba      	ldr	r2, [r7, #24]
 800a1f2:	621a      	str	r2, [r3, #32]
}
 800a1f4:	3710      	adds	r7, #16
 800a1f6:	46bd      	mov	sp, r7
 800a1f8:	bd80      	pop	{r7, pc}
 800a1fa:	bf00      	nop

0800a1fc <chThdRelease>:
=======
 800a116:	687b      	ldr	r3, [r7, #4]
 800a118:	69db      	ldr	r3, [r3, #28]
 800a11a:	2b00      	cmp	r3, #0
 800a11c:	d003      	beq.n	800a126 <iqGetTimeout+0x72>
    iqp->q_notify(iqp);
 800a11e:	687b      	ldr	r3, [r7, #4]
 800a120:	69db      	ldr	r3, [r3, #28]
 800a122:	6878      	ldr	r0, [r7, #4]
 800a124:	4798      	blx	r3
  }

  osalSysUnlock();
 800a126:	f7ff ff2d 	bl	8009f84 <osalSysUnlock.lto_priv.192>

  return (msg_t)b;
 800a12a:	7afb      	ldrb	r3, [r7, #11]
}
 800a12c:	4618      	mov	r0, r3
 800a12e:	3710      	adds	r7, #16
 800a130:	46bd      	mov	sp, r7
 800a132:	bd80      	pop	{r7, pc}

0800a134 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 800a134:	b580      	push	{r7, lr}
 800a136:	b088      	sub	sp, #32
 800a138:	af00      	add	r7, sp, #0
 800a13a:	60f8      	str	r0, [r7, #12]
 800a13c:	60b9      	str	r1, [r7, #8]
 800a13e:	607a      	str	r2, [r7, #4]
 800a140:	807b      	strh	r3, [r7, #2]
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 800a142:	68fb      	ldr	r3, [r7, #12]
 800a144:	69db      	ldr	r3, [r3, #28]
 800a146:	617b      	str	r3, [r7, #20]
  size_t r = 0;
 800a148:	2300      	movs	r3, #0
 800a14a:	61fb      	str	r3, [r7, #28]

  osalDbgCheck(n > 0U);
 800a14c:	687b      	ldr	r3, [r7, #4]
 800a14e:	2b00      	cmp	r3, #0
 800a150:	d102      	bne.n	800a158 <iqReadTimeout+0x24>
 800a152:	4838      	ldr	r0, [pc, #224]	; (800a234 <iqReadTimeout+0x100>)
 800a154:	f000 fe6a 	bl	800ae2c <chSysHalt>

  osalSysLock();
 800a158:	f7ff ff0e 	bl	8009f78 <osalSysLock.lto_priv.194>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800a15c:	f7ff ff18 	bl	8009f90 <osalOsGetSystemTimeX.lto_priv.200>
 800a160:	4603      	mov	r3, r0
 800a162:	461a      	mov	r2, r3
 800a164:	887b      	ldrh	r3, [r7, #2]
 800a166:	4413      	add	r3, r2
 800a168:	827b      	strh	r3, [r7, #18]
 800a16a:	e02c      	b.n	800a1c6 <iqReadTimeout+0x92>
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800a16c:	887b      	ldrh	r3, [r7, #2]
 800a16e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a172:	4293      	cmp	r3, r2
 800a174:	d002      	beq.n	800a17c <iqReadTimeout+0x48>
 800a176:	887b      	ldrh	r3, [r7, #2]
 800a178:	2b00      	cmp	r3, #0
 800a17a:	d107      	bne.n	800a18c <iqReadTimeout+0x58>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800a17c:	68fa      	ldr	r2, [r7, #12]
 800a17e:	887b      	ldrh	r3, [r7, #2]
 800a180:	4610      	mov	r0, r2
 800a182:	4619      	mov	r1, r3
 800a184:	f7ff ff16 	bl	8009fb4 <osalThreadEnqueueTimeoutS.lto_priv.199>
 800a188:	61b8      	str	r0, [r7, #24]
 800a18a:	e015      	b.n	800a1b8 <iqReadTimeout+0x84>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800a18c:	f7ff ff00 	bl	8009f90 <osalOsGetSystemTimeX.lto_priv.200>
 800a190:	4603      	mov	r3, r0
 800a192:	461a      	mov	r2, r3
 800a194:	8a7b      	ldrh	r3, [r7, #18]
 800a196:	1a9b      	subs	r3, r3, r2
 800a198:	823b      	strh	r3, [r7, #16]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800a19a:	8a3a      	ldrh	r2, [r7, #16]
 800a19c:	887b      	ldrh	r3, [r7, #2]
 800a19e:	429a      	cmp	r2, r3
 800a1a0:	d903      	bls.n	800a1aa <iqReadTimeout+0x76>
          osalSysUnlock();
 800a1a2:	f7ff feef 	bl	8009f84 <osalSysUnlock.lto_priv.192>
          return r;
 800a1a6:	69fb      	ldr	r3, [r7, #28]
 800a1a8:	e040      	b.n	800a22c <iqReadTimeout+0xf8>
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
 800a1aa:	68fa      	ldr	r2, [r7, #12]
 800a1ac:	8a3b      	ldrh	r3, [r7, #16]
 800a1ae:	4610      	mov	r0, r2
 800a1b0:	4619      	mov	r1, r3
 800a1b2:	f7ff feff 	bl	8009fb4 <osalThreadEnqueueTimeoutS.lto_priv.199>
 800a1b6:	61b8      	str	r0, [r7, #24]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800a1b8:	69bb      	ldr	r3, [r7, #24]
 800a1ba:	2b00      	cmp	r3, #0
 800a1bc:	d003      	beq.n	800a1c6 <iqReadTimeout+0x92>
        osalSysUnlock();
 800a1be:	f7ff fee1 	bl	8009f84 <osalSysUnlock.lto_priv.192>
        return r;
 800a1c2:	69fb      	ldr	r3, [r7, #28]
 800a1c4:	e032      	b.n	800a22c <iqReadTimeout+0xf8>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800a1c6:	68fb      	ldr	r3, [r7, #12]
 800a1c8:	689b      	ldr	r3, [r3, #8]
 800a1ca:	2b00      	cmp	r3, #0
 800a1cc:	d0ce      	beq.n	800a16c <iqReadTimeout+0x38>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800a1ce:	68fb      	ldr	r3, [r7, #12]
 800a1d0:	689b      	ldr	r3, [r3, #8]
 800a1d2:	1e5a      	subs	r2, r3, #1
 800a1d4:	68fb      	ldr	r3, [r7, #12]
 800a1d6:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 800a1d8:	68bb      	ldr	r3, [r7, #8]
 800a1da:	1c5a      	adds	r2, r3, #1
 800a1dc:	60ba      	str	r2, [r7, #8]
 800a1de:	68fa      	ldr	r2, [r7, #12]
 800a1e0:	6992      	ldr	r2, [r2, #24]
 800a1e2:	1c50      	adds	r0, r2, #1
 800a1e4:	68f9      	ldr	r1, [r7, #12]
 800a1e6:	6188      	str	r0, [r1, #24]
 800a1e8:	7812      	ldrb	r2, [r2, #0]
 800a1ea:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800a1ec:	68fb      	ldr	r3, [r7, #12]
 800a1ee:	699a      	ldr	r2, [r3, #24]
 800a1f0:	68fb      	ldr	r3, [r7, #12]
 800a1f2:	691b      	ldr	r3, [r3, #16]
 800a1f4:	429a      	cmp	r2, r3
 800a1f6:	d303      	bcc.n	800a200 <iqReadTimeout+0xcc>
      iqp->q_rdptr = iqp->q_buffer;
 800a1f8:	68fb      	ldr	r3, [r7, #12]
 800a1fa:	68da      	ldr	r2, [r3, #12]
 800a1fc:	68fb      	ldr	r3, [r7, #12]
 800a1fe:	619a      	str	r2, [r3, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 800a200:	697b      	ldr	r3, [r7, #20]
 800a202:	2b00      	cmp	r3, #0
 800a204:	d002      	beq.n	800a20c <iqReadTimeout+0xd8>
      nfy(iqp);
 800a206:	697b      	ldr	r3, [r7, #20]
 800a208:	68f8      	ldr	r0, [r7, #12]
 800a20a:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 800a20c:	f7ff feba 	bl	8009f84 <osalSysUnlock.lto_priv.192>

    r++;
 800a210:	69fb      	ldr	r3, [r7, #28]
 800a212:	3301      	adds	r3, #1
 800a214:	61fb      	str	r3, [r7, #28]
    if (--n == 0U) {
 800a216:	687b      	ldr	r3, [r7, #4]
 800a218:	3b01      	subs	r3, #1
 800a21a:	607b      	str	r3, [r7, #4]
 800a21c:	687b      	ldr	r3, [r7, #4]
 800a21e:	2b00      	cmp	r3, #0
 800a220:	d101      	bne.n	800a226 <iqReadTimeout+0xf2>
      return r;
 800a222:	69fb      	ldr	r3, [r7, #28]
 800a224:	e002      	b.n	800a22c <iqReadTimeout+0xf8>
    }

    osalSysLock();
 800a226:	f7ff fea7 	bl	8009f78 <osalSysLock.lto_priv.194>
 800a22a:	e7cc      	b.n	800a1c6 <iqReadTimeout+0x92>
  }
}
 800a22c:	4618      	mov	r0, r3
 800a22e:	3720      	adds	r7, #32
 800a230:	46bd      	mov	sp, r7
 800a232:	bd80      	pop	{r7, pc}
 800a234:	0800eb7c 	.word	0x0800eb7c

0800a238 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 800a238:	b580      	push	{r7, lr}
 800a23a:	b084      	sub	sp, #16
 800a23c:	af00      	add	r7, sp, #0
 800a23e:	60f8      	str	r0, [r7, #12]
 800a240:	60b9      	str	r1, [r7, #8]
 800a242:	607a      	str	r2, [r7, #4]
 800a244:	603b      	str	r3, [r7, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800a246:	68fb      	ldr	r3, [r7, #12]
 800a248:	4618      	mov	r0, r3
 800a24a:	f7ff fea9 	bl	8009fa0 <osalThreadQueueObjectInit.lto_priv.205>
  oqp->q_counter = size;
 800a24e:	68fb      	ldr	r3, [r7, #12]
 800a250:	687a      	ldr	r2, [r7, #4]
 800a252:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800a254:	68fb      	ldr	r3, [r7, #12]
 800a256:	68ba      	ldr	r2, [r7, #8]
 800a258:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 800a25a:	68fb      	ldr	r3, [r7, #12]
 800a25c:	68ba      	ldr	r2, [r7, #8]
 800a25e:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 800a260:	68fb      	ldr	r3, [r7, #12]
 800a262:	68ba      	ldr	r2, [r7, #8]
 800a264:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800a266:	68ba      	ldr	r2, [r7, #8]
 800a268:	687b      	ldr	r3, [r7, #4]
 800a26a:	441a      	add	r2, r3
 800a26c:	68fb      	ldr	r3, [r7, #12]
 800a26e:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 800a270:	68fb      	ldr	r3, [r7, #12]
 800a272:	683a      	ldr	r2, [r7, #0]
 800a274:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800a276:	68fb      	ldr	r3, [r7, #12]
 800a278:	69ba      	ldr	r2, [r7, #24]
 800a27a:	621a      	str	r2, [r3, #32]
}
 800a27c:	3710      	adds	r7, #16
 800a27e:	46bd      	mov	sp, r7
 800a280:	bd80      	pop	{r7, pc}
 800a282:	bf00      	nop

0800a284 <chThdRelease>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
<<<<<<< HEAD
 800a1fc:	b590      	push	{r4, r7, lr}
 800a1fe:	b083      	sub	sp, #12
 800a200:	af00      	add	r7, sp, #0
 800a202:	6078      	str	r0, [r7, #4]

  chSysLock();
 800a204:	f001 fb84 	bl	800b910 <chSysLock.lto_priv.258>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800a208:	687b      	ldr	r3, [r7, #4]
 800a20a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a20e:	2b00      	cmp	r3, #0
 800a210:	d102      	bne.n	800a218 <chThdRelease+0x1c>
 800a212:	481c      	ldr	r0, [pc, #112]	; (800a284 <chThdRelease+0x88>)
 800a214:	f000 fdc6 	bl	800ada4 <chSysHalt>
  tp->refs--;
 800a218:	687b      	ldr	r3, [r7, #4]
 800a21a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a21e:	3b01      	subs	r3, #1
 800a220:	b2da      	uxtb	r2, r3
 800a222:	687b      	ldr	r3, [r7, #4]
 800a224:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
=======
 800a284:	b590      	push	{r4, r7, lr}
 800a286:	b083      	sub	sp, #12
 800a288:	af00      	add	r7, sp, #0
 800a28a:	6078      	str	r0, [r7, #4]

  chSysLock();
 800a28c:	f001 fb84 	bl	800b998 <chSysLock.lto_priv.255>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800a290:	687b      	ldr	r3, [r7, #4]
 800a292:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a296:	2b00      	cmp	r3, #0
 800a298:	d102      	bne.n	800a2a0 <chThdRelease+0x1c>
 800a29a:	481c      	ldr	r0, [pc, #112]	; (800a30c <chThdRelease+0x88>)
 800a29c:	f000 fdc6 	bl	800ae2c <chSysHalt>
  tp->refs--;
 800a2a0:	687b      	ldr	r3, [r7, #4]
 800a2a2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a2a6:	3b01      	subs	r3, #1
 800a2a8:	b2da      	uxtb	r2, r3
 800a2aa:	687b      	ldr	r3, [r7, #4]
 800a2ac:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
>>>>>>> 752c83b... update binaries

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
<<<<<<< HEAD
 800a228:	687b      	ldr	r3, [r7, #4]
 800a22a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a22e:	2b00      	cmp	r3, #0
 800a230:	d123      	bne.n	800a27a <chThdRelease+0x7e>
 800a232:	687b      	ldr	r3, [r7, #4]
 800a234:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a238:	2b0f      	cmp	r3, #15
 800a23a:	d11e      	bne.n	800a27a <chThdRelease+0x7e>
    REG_REMOVE(tp);
 800a23c:	687b      	ldr	r3, [r7, #4]
 800a23e:	695b      	ldr	r3, [r3, #20]
 800a240:	687a      	ldr	r2, [r7, #4]
 800a242:	6912      	ldr	r2, [r2, #16]
 800a244:	611a      	str	r2, [r3, #16]
 800a246:	687b      	ldr	r3, [r7, #4]
 800a248:	691b      	ldr	r3, [r3, #16]
 800a24a:	687a      	ldr	r2, [r7, #4]
 800a24c:	6952      	ldr	r2, [r2, #20]
 800a24e:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 800a250:	f001 fb66 	bl	800b920 <chSysUnlock.lto_priv.253>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 800a254:	687b      	ldr	r3, [r7, #4]
 800a256:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a25a:	f003 0303 	and.w	r3, r3, #3
 800a25e:	2b02      	cmp	r3, #2
 800a260:	d000      	beq.n	800a264 <chThdRelease+0x68>
 800a262:	e00c      	b.n	800a27e <chThdRelease+0x82>
=======
 800a2b0:	687b      	ldr	r3, [r7, #4]
 800a2b2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a2b6:	2b00      	cmp	r3, #0
 800a2b8:	d123      	bne.n	800a302 <chThdRelease+0x7e>
 800a2ba:	687b      	ldr	r3, [r7, #4]
 800a2bc:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a2c0:	2b0f      	cmp	r3, #15
 800a2c2:	d11e      	bne.n	800a302 <chThdRelease+0x7e>
    REG_REMOVE(tp);
 800a2c4:	687b      	ldr	r3, [r7, #4]
 800a2c6:	695b      	ldr	r3, [r3, #20]
 800a2c8:	687a      	ldr	r2, [r7, #4]
 800a2ca:	6912      	ldr	r2, [r2, #16]
 800a2cc:	611a      	str	r2, [r3, #16]
 800a2ce:	687b      	ldr	r3, [r7, #4]
 800a2d0:	691b      	ldr	r3, [r3, #16]
 800a2d2:	687a      	ldr	r2, [r7, #4]
 800a2d4:	6952      	ldr	r2, [r2, #20]
 800a2d6:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 800a2d8:	f001 fb66 	bl	800b9a8 <chSysUnlock.lto_priv.250>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 800a2dc:	687b      	ldr	r3, [r7, #4]
 800a2de:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a2e2:	f003 0303 	and.w	r3, r3, #3
 800a2e6:	2b02      	cmp	r3, #2
 800a2e8:	d000      	beq.n	800a2ec <chThdRelease+0x68>
 800a2ea:	e00c      	b.n	800a306 <chThdRelease+0x82>
>>>>>>> 752c83b... update binaries
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
<<<<<<< HEAD
 800a264:	687b      	ldr	r3, [r7, #4]
 800a266:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 800a268:	6878      	ldr	r0, [r7, #4]
 800a26a:	f001 fb81 	bl	800b970 <chThdGetWorkingAreaX.lto_priv.281>
 800a26e:	4603      	mov	r3, r0
 800a270:	4620      	mov	r0, r4
 800a272:	4619      	mov	r1, r3
 800a274:	f7ff fd2e 	bl	8009cd4 <chPoolFree>
 800a278:	e001      	b.n	800a27e <chThdRelease+0x82>
=======
 800a2ec:	687b      	ldr	r3, [r7, #4]
 800a2ee:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 800a2f0:	6878      	ldr	r0, [r7, #4]
 800a2f2:	f001 fb81 	bl	800b9f8 <chThdGetWorkingAreaX.lto_priv.278>
 800a2f6:	4603      	mov	r3, r0
 800a2f8:	4620      	mov	r0, r4
 800a2fa:	4619      	mov	r1, r3
 800a2fc:	f7ff fd2e 	bl	8009d5c <chPoolFree>
 800a300:	e001      	b.n	800a306 <chThdRelease+0x82>
>>>>>>> 752c83b... update binaries
      break;
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
<<<<<<< HEAD
 800a27a:	f001 fb51 	bl	800b920 <chSysUnlock.lto_priv.253>
}
 800a27e:	370c      	adds	r7, #12
 800a280:	46bd      	mov	sp, r7
 800a282:	bd90      	pop	{r4, r7, pc}
 800a284:	0800e8f8 	.word	0x0800e8f8

0800a288 <chThdExit>:
=======
 800a302:	f001 fb51 	bl	800b9a8 <chSysUnlock.lto_priv.250>
}
 800a306:	370c      	adds	r7, #12
 800a308:	46bd      	mov	sp, r7
 800a30a:	bd90      	pop	{r4, r7, pc}
 800a30c:	0800e9d0 	.word	0x0800e9d0

0800a310 <chThdExit>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
<<<<<<< HEAD
 800a288:	b580      	push	{r7, lr}
 800a28a:	b082      	sub	sp, #8
 800a28c:	af00      	add	r7, sp, #0
 800a28e:	6078      	str	r0, [r7, #4]

  chSysLock();
 800a290:	f001 fb3e 	bl	800b910 <chSysLock.lto_priv.258>
  chThdExitS(msg);
 800a294:	6878      	ldr	r0, [r7, #4]
 800a296:	f000 f803 	bl	800a2a0 <chThdExitS>
  /* The thread never returns here.*/
}
 800a29a:	3708      	adds	r7, #8
 800a29c:	46bd      	mov	sp, r7
 800a29e:	bd80      	pop	{r7, pc}

0800a2a0 <chThdExitS>:
=======
 800a310:	b580      	push	{r7, lr}
 800a312:	b082      	sub	sp, #8
 800a314:	af00      	add	r7, sp, #0
 800a316:	6078      	str	r0, [r7, #4]

  chSysLock();
 800a318:	f001 fb3e 	bl	800b998 <chSysLock.lto_priv.255>
  chThdExitS(msg);
 800a31c:	6878      	ldr	r0, [r7, #4]
 800a31e:	f000 f803 	bl	800a328 <chThdExitS>
  /* The thread never returns here.*/
}
 800a322:	3708      	adds	r7, #8
 800a324:	46bd      	mov	sp, r7
 800a326:	bd80      	pop	{r7, pc}

0800a328 <chThdExitS>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
<<<<<<< HEAD
 800a2a0:	b580      	push	{r7, lr}
 800a2a2:	b084      	sub	sp, #16
 800a2a4:	af00      	add	r7, sp, #0
 800a2a6:	6078      	str	r0, [r7, #4]
  thread_t *tp = currp;
 800a2a8:	4b1b      	ldr	r3, [pc, #108]	; (800a318 <chThdExitS+0x78>)
 800a2aa:	699b      	ldr	r3, [r3, #24]
 800a2ac:	60fb      	str	r3, [r7, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800a2ae:	68fb      	ldr	r3, [r7, #12]
 800a2b0:	687a      	ldr	r2, [r7, #4]
 800a2b2:	625a      	str	r2, [r3, #36]	; 0x24
 800a2b4:	e008      	b.n	800a2c8 <chThdExitS+0x28>
=======
 800a328:	b580      	push	{r7, lr}
 800a32a:	b084      	sub	sp, #16
 800a32c:	af00      	add	r7, sp, #0
 800a32e:	6078      	str	r0, [r7, #4]
  thread_t *tp = currp;
 800a330:	4b1b      	ldr	r3, [pc, #108]	; (800a3a0 <chThdExitS+0x78>)
 800a332:	699b      	ldr	r3, [r3, #24]
 800a334:	60fb      	str	r3, [r7, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800a336:	68fb      	ldr	r3, [r7, #12]
 800a338:	687a      	ldr	r2, [r7, #4]
 800a33a:	625a      	str	r2, [r3, #36]	; 0x24
 800a33c:	e008      	b.n	800a350 <chThdExitS+0x28>
>>>>>>> 752c83b... update binaries
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
<<<<<<< HEAD
 800a2b6:	68fb      	ldr	r3, [r7, #12]
 800a2b8:	3328      	adds	r3, #40	; 0x28
 800a2ba:	4618      	mov	r0, r3
 800a2bc:	f001 f8da 	bl	800b474 <list_remove>
 800a2c0:	4603      	mov	r3, r0
 800a2c2:	4618      	mov	r0, r3
 800a2c4:	f001 f8e8 	bl	800b498 <chSchReadyI>
=======
 800a33e:	68fb      	ldr	r3, [r7, #12]
 800a340:	3328      	adds	r3, #40	; 0x28
 800a342:	4618      	mov	r0, r3
 800a344:	f001 f8da 	bl	800b4fc <list_remove>
 800a348:	4603      	mov	r3, r0
 800a34a:	4618      	mov	r0, r3
 800a34c:	f001 f8e8 	bl	800b520 <chSchReadyI>
>>>>>>> 752c83b... update binaries
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
<<<<<<< HEAD
 800a2c8:	68fb      	ldr	r3, [r7, #12]
 800a2ca:	3328      	adds	r3, #40	; 0x28
 800a2cc:	4618      	mov	r0, r3
 800a2ce:	f001 fafb 	bl	800b8c8 <list_notempty.lto_priv.296>
 800a2d2:	4603      	mov	r3, r0
 800a2d4:	2b00      	cmp	r3, #0
 800a2d6:	d1ee      	bne.n	800a2b6 <chThdExitS+0x16>
=======
 800a350:	68fb      	ldr	r3, [r7, #12]
 800a352:	3328      	adds	r3, #40	; 0x28
 800a354:	4618      	mov	r0, r3
 800a356:	f001 fafb 	bl	800b950 <list_notempty.lto_priv.293>
 800a35a:	4603      	mov	r3, r0
 800a35c:	2b00      	cmp	r3, #0
 800a35e:	d1ee      	bne.n	800a33e <chThdExitS+0x16>
>>>>>>> 752c83b... update binaries

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
<<<<<<< HEAD
 800a2d8:	68fb      	ldr	r3, [r7, #12]
 800a2da:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a2de:	2b00      	cmp	r3, #0
 800a2e0:	d110      	bne.n	800a304 <chThdExitS+0x64>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 800a2e2:	68fb      	ldr	r3, [r7, #12]
 800a2e4:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a2e8:	f003 0303 	and.w	r3, r3, #3
=======
 800a360:	68fb      	ldr	r3, [r7, #12]
 800a362:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a366:	2b00      	cmp	r3, #0
 800a368:	d110      	bne.n	800a38c <chThdExitS+0x64>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 800a36a:	68fb      	ldr	r3, [r7, #12]
 800a36c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a370:	f003 0303 	and.w	r3, r3, #3
>>>>>>> 752c83b... update binaries

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
<<<<<<< HEAD
 800a2ec:	2b00      	cmp	r3, #0
 800a2ee:	d109      	bne.n	800a304 <chThdExitS+0x64>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800a2f0:	68fb      	ldr	r3, [r7, #12]
 800a2f2:	695b      	ldr	r3, [r3, #20]
 800a2f4:	68fa      	ldr	r2, [r7, #12]
 800a2f6:	6912      	ldr	r2, [r2, #16]
 800a2f8:	611a      	str	r2, [r3, #16]
 800a2fa:	68fb      	ldr	r3, [r7, #12]
 800a2fc:	691b      	ldr	r3, [r3, #16]
 800a2fe:	68fa      	ldr	r2, [r7, #12]
 800a300:	6952      	ldr	r2, [r2, #20]
 800a302:	615a      	str	r2, [r3, #20]
=======
 800a374:	2b00      	cmp	r3, #0
 800a376:	d109      	bne.n	800a38c <chThdExitS+0x64>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800a378:	68fb      	ldr	r3, [r7, #12]
 800a37a:	695b      	ldr	r3, [r3, #20]
 800a37c:	68fa      	ldr	r2, [r7, #12]
 800a37e:	6912      	ldr	r2, [r2, #16]
 800a380:	611a      	str	r2, [r3, #16]
 800a382:	68fb      	ldr	r3, [r7, #12]
 800a384:	691b      	ldr	r3, [r3, #16]
 800a386:	68fa      	ldr	r2, [r7, #12]
 800a388:	6952      	ldr	r2, [r2, #20]
 800a38a:	615a      	str	r2, [r3, #20]
>>>>>>> 752c83b... update binaries
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
<<<<<<< HEAD
 800a304:	200f      	movs	r0, #15
 800a306:	f001 f947 	bl	800b598 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800a30a:	4804      	ldr	r0, [pc, #16]	; (800a31c <chThdExitS+0x7c>)
 800a30c:	f000 fd4a 	bl	800ada4 <chSysHalt>
}
 800a310:	3710      	adds	r7, #16
 800a312:	46bd      	mov	sp, r7
 800a314:	bd80      	pop	{r7, pc}
 800a316:	bf00      	nop
 800a318:	20001338 	.word	0x20001338
 800a31c:	0800e908 	.word	0x0800e908

0800a320 <chThdSetPriority>:
=======
 800a38c:	200f      	movs	r0, #15
 800a38e:	f001 f947 	bl	800b620 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800a392:	4804      	ldr	r0, [pc, #16]	; (800a3a4 <chThdExitS+0x7c>)
 800a394:	f000 fd4a 	bl	800ae2c <chSysHalt>
}
 800a398:	3710      	adds	r7, #16
 800a39a:	46bd      	mov	sp, r7
 800a39c:	bd80      	pop	{r7, pc}
 800a39e:	bf00      	nop
 800a3a0:	20001338 	.word	0x20001338
 800a3a4:	0800e9e0 	.word	0x0800e9e0

0800a3a8 <chThdSetPriority>:
>>>>>>> 752c83b... update binaries
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
<<<<<<< HEAD
 800a320:	b580      	push	{r7, lr}
 800a322:	b084      	sub	sp, #16
 800a324:	af00      	add	r7, sp, #0
 800a326:	6078      	str	r0, [r7, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 800a328:	687b      	ldr	r3, [r7, #4]
 800a32a:	2bff      	cmp	r3, #255	; 0xff
 800a32c:	d902      	bls.n	800a334 <chThdSetPriority+0x14>
 800a32e:	4814      	ldr	r0, [pc, #80]	; (800a380 <chThdSetPriority+0x60>)
 800a330:	f000 fd38 	bl	800ada4 <chSysHalt>

  chSysLock();
 800a334:	f001 faec 	bl	800b910 <chSysLock.lto_priv.258>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 800a338:	4b12      	ldr	r3, [pc, #72]	; (800a384 <chThdSetPriority+0x64>)
 800a33a:	699b      	ldr	r3, [r3, #24]
 800a33c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a33e:	60fb      	str	r3, [r7, #12]
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 800a340:	4b10      	ldr	r3, [pc, #64]	; (800a384 <chThdSetPriority+0x64>)
 800a342:	699b      	ldr	r3, [r3, #24]
 800a344:	689a      	ldr	r2, [r3, #8]
 800a346:	4b0f      	ldr	r3, [pc, #60]	; (800a384 <chThdSetPriority+0x64>)
 800a348:	699b      	ldr	r3, [r3, #24]
 800a34a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a34c:	429a      	cmp	r2, r3
 800a34e:	d005      	beq.n	800a35c <chThdSetPriority+0x3c>
 800a350:	4b0c      	ldr	r3, [pc, #48]	; (800a384 <chThdSetPriority+0x64>)
 800a352:	699b      	ldr	r3, [r3, #24]
 800a354:	689a      	ldr	r2, [r3, #8]
 800a356:	687b      	ldr	r3, [r7, #4]
 800a358:	429a      	cmp	r2, r3
 800a35a:	d203      	bcs.n	800a364 <chThdSetPriority+0x44>
    currp->prio = newprio;
 800a35c:	4b09      	ldr	r3, [pc, #36]	; (800a384 <chThdSetPriority+0x64>)
 800a35e:	699b      	ldr	r3, [r3, #24]
 800a360:	687a      	ldr	r2, [r7, #4]
 800a362:	609a      	str	r2, [r3, #8]
  }
  currp->realprio = newprio;
 800a364:	4b07      	ldr	r3, [pc, #28]	; (800a384 <chThdSetPriority+0x64>)
 800a366:	699b      	ldr	r3, [r3, #24]
 800a368:	687a      	ldr	r2, [r7, #4]
 800a36a:	631a      	str	r2, [r3, #48]	; 0x30
=======
 800a3a8:	b580      	push	{r7, lr}
 800a3aa:	b084      	sub	sp, #16
 800a3ac:	af00      	add	r7, sp, #0
 800a3ae:	6078      	str	r0, [r7, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 800a3b0:	687b      	ldr	r3, [r7, #4]
 800a3b2:	2bff      	cmp	r3, #255	; 0xff
 800a3b4:	d902      	bls.n	800a3bc <chThdSetPriority+0x14>
 800a3b6:	4814      	ldr	r0, [pc, #80]	; (800a408 <chThdSetPriority+0x60>)
 800a3b8:	f000 fd38 	bl	800ae2c <chSysHalt>

  chSysLock();
 800a3bc:	f001 faec 	bl	800b998 <chSysLock.lto_priv.255>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 800a3c0:	4b12      	ldr	r3, [pc, #72]	; (800a40c <chThdSetPriority+0x64>)
 800a3c2:	699b      	ldr	r3, [r3, #24]
 800a3c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a3c6:	60fb      	str	r3, [r7, #12]
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 800a3c8:	4b10      	ldr	r3, [pc, #64]	; (800a40c <chThdSetPriority+0x64>)
 800a3ca:	699b      	ldr	r3, [r3, #24]
 800a3cc:	689a      	ldr	r2, [r3, #8]
 800a3ce:	4b0f      	ldr	r3, [pc, #60]	; (800a40c <chThdSetPriority+0x64>)
 800a3d0:	699b      	ldr	r3, [r3, #24]
 800a3d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a3d4:	429a      	cmp	r2, r3
 800a3d6:	d005      	beq.n	800a3e4 <chThdSetPriority+0x3c>
 800a3d8:	4b0c      	ldr	r3, [pc, #48]	; (800a40c <chThdSetPriority+0x64>)
 800a3da:	699b      	ldr	r3, [r3, #24]
 800a3dc:	689a      	ldr	r2, [r3, #8]
 800a3de:	687b      	ldr	r3, [r7, #4]
 800a3e0:	429a      	cmp	r2, r3
 800a3e2:	d203      	bcs.n	800a3ec <chThdSetPriority+0x44>
    currp->prio = newprio;
 800a3e4:	4b09      	ldr	r3, [pc, #36]	; (800a40c <chThdSetPriority+0x64>)
 800a3e6:	699b      	ldr	r3, [r3, #24]
 800a3e8:	687a      	ldr	r2, [r7, #4]
 800a3ea:	609a      	str	r2, [r3, #8]
  }
  currp->realprio = newprio;
 800a3ec:	4b07      	ldr	r3, [pc, #28]	; (800a40c <chThdSetPriority+0x64>)
 800a3ee:	699b      	ldr	r3, [r3, #24]
 800a3f0:	687a      	ldr	r2, [r7, #4]
 800a3f2:	631a      	str	r2, [r3, #48]	; 0x30
>>>>>>> 752c83b... update binaries
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
<<<<<<< HEAD
 800a36c:	f001 f9fa 	bl	800b764 <chSchRescheduleS>
  chSysUnlock();
 800a370:	f001 fad6 	bl	800b920 <chSysUnlock.lto_priv.253>

  return oldprio;
 800a374:	68fb      	ldr	r3, [r7, #12]
}
 800a376:	4618      	mov	r0, r3
 800a378:	3710      	adds	r7, #16
 800a37a:	46bd      	mov	sp, r7
 800a37c:	bd80      	pop	{r7, pc}
 800a37e:	bf00      	nop
 800a380:	0800e914 	.word	0x0800e914
 800a384:	20001338 	.word	0x20001338

0800a388 <chThdSuspendTimeoutS>:
=======
 800a3f4:	f001 f9fa 	bl	800b7ec <chSchRescheduleS>
  chSysUnlock();
 800a3f8:	f001 fad6 	bl	800b9a8 <chSysUnlock.lto_priv.250>

  return oldprio;
 800a3fc:	68fb      	ldr	r3, [r7, #12]
}
 800a3fe:	4618      	mov	r0, r3
 800a400:	3710      	adds	r7, #16
 800a402:	46bd      	mov	sp, r7
 800a404:	bd80      	pop	{r7, pc}
 800a406:	bf00      	nop
 800a408:	0800e9ec 	.word	0x0800e9ec
 800a40c:	20001338 	.word	0x20001338

0800a410 <chThdSuspendTimeoutS>:
>>>>>>> 752c83b... update binaries
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
<<<<<<< HEAD
 800a388:	b580      	push	{r7, lr}
 800a38a:	b084      	sub	sp, #16
 800a38c:	af00      	add	r7, sp, #0
 800a38e:	6078      	str	r0, [r7, #4]
 800a390:	460b      	mov	r3, r1
 800a392:	807b      	strh	r3, [r7, #2]
  thread_t *tp = chThdGetSelfX();
 800a394:	f001 fae0 	bl	800b958 <chThdGetSelfX.lto_priv.291>
 800a398:	60f8      	str	r0, [r7, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 800a39a:	687b      	ldr	r3, [r7, #4]
 800a39c:	681b      	ldr	r3, [r3, #0]
 800a39e:	2b00      	cmp	r3, #0
 800a3a0:	d002      	beq.n	800a3a8 <chThdSuspendTimeoutS+0x20>
 800a3a2:	480c      	ldr	r0, [pc, #48]	; (800a3d4 <chThdSuspendTimeoutS+0x4c>)
 800a3a4:	f000 fcfe 	bl	800ada4 <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
 800a3a8:	887b      	ldrh	r3, [r7, #2]
 800a3aa:	2b00      	cmp	r3, #0
 800a3ac:	d102      	bne.n	800a3b4 <chThdSuspendTimeoutS+0x2c>
    return MSG_TIMEOUT;
 800a3ae:	f04f 33ff 	mov.w	r3, #4294967295
 800a3b2:	e00b      	b.n	800a3cc <chThdSuspendTimeoutS+0x44>
  }

  *trp = tp;
 800a3b4:	687b      	ldr	r3, [r7, #4]
 800a3b6:	68fa      	ldr	r2, [r7, #12]
 800a3b8:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 800a3ba:	68fb      	ldr	r3, [r7, #12]
 800a3bc:	687a      	ldr	r2, [r7, #4]
 800a3be:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800a3c0:	887b      	ldrh	r3, [r7, #2]
 800a3c2:	2003      	movs	r0, #3
 800a3c4:	4619      	mov	r1, r3
 800a3c6:	f001 f945 	bl	800b654 <chSchGoSleepTimeoutS>
 800a3ca:	4603      	mov	r3, r0
}
 800a3cc:	4618      	mov	r0, r3
 800a3ce:	3710      	adds	r7, #16
 800a3d0:	46bd      	mov	sp, r7
 800a3d2:	bd80      	pop	{r7, pc}
 800a3d4:	0800e928 	.word	0x0800e928

0800a3d8 <chThdResumeI>:
=======
 800a410:	b580      	push	{r7, lr}
 800a412:	b084      	sub	sp, #16
 800a414:	af00      	add	r7, sp, #0
 800a416:	6078      	str	r0, [r7, #4]
 800a418:	460b      	mov	r3, r1
 800a41a:	807b      	strh	r3, [r7, #2]
  thread_t *tp = chThdGetSelfX();
 800a41c:	f001 fae0 	bl	800b9e0 <chThdGetSelfX.lto_priv.288>
 800a420:	60f8      	str	r0, [r7, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 800a422:	687b      	ldr	r3, [r7, #4]
 800a424:	681b      	ldr	r3, [r3, #0]
 800a426:	2b00      	cmp	r3, #0
 800a428:	d002      	beq.n	800a430 <chThdSuspendTimeoutS+0x20>
 800a42a:	480c      	ldr	r0, [pc, #48]	; (800a45c <chThdSuspendTimeoutS+0x4c>)
 800a42c:	f000 fcfe 	bl	800ae2c <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
 800a430:	887b      	ldrh	r3, [r7, #2]
 800a432:	2b00      	cmp	r3, #0
 800a434:	d102      	bne.n	800a43c <chThdSuspendTimeoutS+0x2c>
    return MSG_TIMEOUT;
 800a436:	f04f 33ff 	mov.w	r3, #4294967295
 800a43a:	e00b      	b.n	800a454 <chThdSuspendTimeoutS+0x44>
  }

  *trp = tp;
 800a43c:	687b      	ldr	r3, [r7, #4]
 800a43e:	68fa      	ldr	r2, [r7, #12]
 800a440:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 800a442:	68fb      	ldr	r3, [r7, #12]
 800a444:	687a      	ldr	r2, [r7, #4]
 800a446:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800a448:	887b      	ldrh	r3, [r7, #2]
 800a44a:	2003      	movs	r0, #3
 800a44c:	4619      	mov	r1, r3
 800a44e:	f001 f945 	bl	800b6dc <chSchGoSleepTimeoutS>
 800a452:	4603      	mov	r3, r0
}
 800a454:	4618      	mov	r0, r3
 800a456:	3710      	adds	r7, #16
 800a458:	46bd      	mov	sp, r7
 800a45a:	bd80      	pop	{r7, pc}
 800a45c:	0800ea00 	.word	0x0800ea00

0800a460 <chThdResumeI>:
>>>>>>> 752c83b... update binaries
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
<<<<<<< HEAD
 800a3d8:	b580      	push	{r7, lr}
 800a3da:	b084      	sub	sp, #16
 800a3dc:	af00      	add	r7, sp, #0
 800a3de:	6078      	str	r0, [r7, #4]
 800a3e0:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 800a3e2:	687b      	ldr	r3, [r7, #4]
 800a3e4:	681b      	ldr	r3, [r3, #0]
 800a3e6:	2b00      	cmp	r3, #0
 800a3e8:	d013      	beq.n	800a412 <chThdResumeI+0x3a>
    thread_t *tp = *trp;
 800a3ea:	687b      	ldr	r3, [r7, #4]
 800a3ec:	681b      	ldr	r3, [r3, #0]
 800a3ee:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800a3f0:	68fb      	ldr	r3, [r7, #12]
 800a3f2:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a3f6:	2b03      	cmp	r3, #3
 800a3f8:	d002      	beq.n	800a400 <chThdResumeI+0x28>
 800a3fa:	4807      	ldr	r0, [pc, #28]	; (800a418 <chThdResumeI+0x40>)
 800a3fc:	f000 fcd2 	bl	800ada4 <chSysHalt>

    *trp = NULL;
 800a400:	687b      	ldr	r3, [r7, #4]
 800a402:	2200      	movs	r2, #0
 800a404:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800a406:	68fb      	ldr	r3, [r7, #12]
 800a408:	683a      	ldr	r2, [r7, #0]
 800a40a:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800a40c:	68f8      	ldr	r0, [r7, #12]
 800a40e:	f001 f843 	bl	800b498 <chSchReadyI>
  }
}
 800a412:	3710      	adds	r7, #16
 800a414:	46bd      	mov	sp, r7
 800a416:	bd80      	pop	{r7, pc}
 800a418:	0800e940 	.word	0x0800e940

0800a41c <chThdResumeS>:
=======
 800a460:	b580      	push	{r7, lr}
 800a462:	b084      	sub	sp, #16
 800a464:	af00      	add	r7, sp, #0
 800a466:	6078      	str	r0, [r7, #4]
 800a468:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 800a46a:	687b      	ldr	r3, [r7, #4]
 800a46c:	681b      	ldr	r3, [r3, #0]
 800a46e:	2b00      	cmp	r3, #0
 800a470:	d013      	beq.n	800a49a <chThdResumeI+0x3a>
    thread_t *tp = *trp;
 800a472:	687b      	ldr	r3, [r7, #4]
 800a474:	681b      	ldr	r3, [r3, #0]
 800a476:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800a478:	68fb      	ldr	r3, [r7, #12]
 800a47a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a47e:	2b03      	cmp	r3, #3
 800a480:	d002      	beq.n	800a488 <chThdResumeI+0x28>
 800a482:	4807      	ldr	r0, [pc, #28]	; (800a4a0 <chThdResumeI+0x40>)
 800a484:	f000 fcd2 	bl	800ae2c <chSysHalt>

    *trp = NULL;
 800a488:	687b      	ldr	r3, [r7, #4]
 800a48a:	2200      	movs	r2, #0
 800a48c:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800a48e:	68fb      	ldr	r3, [r7, #12]
 800a490:	683a      	ldr	r2, [r7, #0]
 800a492:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800a494:	68f8      	ldr	r0, [r7, #12]
 800a496:	f001 f843 	bl	800b520 <chSchReadyI>
  }
}
 800a49a:	3710      	adds	r7, #16
 800a49c:	46bd      	mov	sp, r7
 800a49e:	bd80      	pop	{r7, pc}
 800a4a0:	0800ea18 	.word	0x0800ea18

0800a4a4 <chThdResumeS>:
>>>>>>> 752c83b... update binaries
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
<<<<<<< HEAD
 800a41c:	b580      	push	{r7, lr}
 800a41e:	b084      	sub	sp, #16
 800a420:	af00      	add	r7, sp, #0
 800a422:	6078      	str	r0, [r7, #4]
 800a424:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 800a426:	687b      	ldr	r3, [r7, #4]
 800a428:	681b      	ldr	r3, [r3, #0]
 800a42a:	2b00      	cmp	r3, #0
 800a42c:	d011      	beq.n	800a452 <chThdResumeS+0x36>
    thread_t *tp = *trp;
 800a42e:	687b      	ldr	r3, [r7, #4]
 800a430:	681b      	ldr	r3, [r3, #0]
 800a432:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800a434:	68fb      	ldr	r3, [r7, #12]
 800a436:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a43a:	2b03      	cmp	r3, #3
 800a43c:	d002      	beq.n	800a444 <chThdResumeS+0x28>
 800a43e:	4806      	ldr	r0, [pc, #24]	; (800a458 <chThdResumeS+0x3c>)
 800a440:	f000 fcb0 	bl	800ada4 <chSysHalt>

    *trp = NULL;
 800a444:	687b      	ldr	r3, [r7, #4]
 800a446:	2200      	movs	r2, #0
 800a448:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800a44a:	68f8      	ldr	r0, [r7, #12]
 800a44c:	6839      	ldr	r1, [r7, #0]
 800a44e:	f001 f93b 	bl	800b6c8 <chSchWakeupS>
  }
}
 800a452:	3710      	adds	r7, #16
 800a454:	46bd      	mov	sp, r7
 800a456:	bd80      	pop	{r7, pc}
 800a458:	0800e950 	.word	0x0800e950

0800a45c <chThdResume>:
=======
 800a4a4:	b580      	push	{r7, lr}
 800a4a6:	b084      	sub	sp, #16
 800a4a8:	af00      	add	r7, sp, #0
 800a4aa:	6078      	str	r0, [r7, #4]
 800a4ac:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 800a4ae:	687b      	ldr	r3, [r7, #4]
 800a4b0:	681b      	ldr	r3, [r3, #0]
 800a4b2:	2b00      	cmp	r3, #0
 800a4b4:	d011      	beq.n	800a4da <chThdResumeS+0x36>
    thread_t *tp = *trp;
 800a4b6:	687b      	ldr	r3, [r7, #4]
 800a4b8:	681b      	ldr	r3, [r3, #0]
 800a4ba:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800a4bc:	68fb      	ldr	r3, [r7, #12]
 800a4be:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a4c2:	2b03      	cmp	r3, #3
 800a4c4:	d002      	beq.n	800a4cc <chThdResumeS+0x28>
 800a4c6:	4806      	ldr	r0, [pc, #24]	; (800a4e0 <chThdResumeS+0x3c>)
 800a4c8:	f000 fcb0 	bl	800ae2c <chSysHalt>

    *trp = NULL;
 800a4cc:	687b      	ldr	r3, [r7, #4]
 800a4ce:	2200      	movs	r2, #0
 800a4d0:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800a4d2:	68f8      	ldr	r0, [r7, #12]
 800a4d4:	6839      	ldr	r1, [r7, #0]
 800a4d6:	f001 f93b 	bl	800b750 <chSchWakeupS>
  }
}
 800a4da:	3710      	adds	r7, #16
 800a4dc:	46bd      	mov	sp, r7
 800a4de:	bd80      	pop	{r7, pc}
 800a4e0:	0800ea28 	.word	0x0800ea28

0800a4e4 <chThdResume>:
>>>>>>> 752c83b... update binaries
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
<<<<<<< HEAD
 800a45c:	b580      	push	{r7, lr}
 800a45e:	b082      	sub	sp, #8
 800a460:	af00      	add	r7, sp, #0
 800a462:	6078      	str	r0, [r7, #4]
 800a464:	6039      	str	r1, [r7, #0]

  chSysLock();
 800a466:	f001 fa53 	bl	800b910 <chSysLock.lto_priv.258>
  chThdResumeS(trp, msg);
 800a46a:	6878      	ldr	r0, [r7, #4]
 800a46c:	6839      	ldr	r1, [r7, #0]
 800a46e:	f7ff ffd5 	bl	800a41c <chThdResumeS>
  chSysUnlock();
 800a472:	f001 fa55 	bl	800b920 <chSysUnlock.lto_priv.253>
}
 800a476:	3708      	adds	r7, #8
 800a478:	46bd      	mov	sp, r7
 800a47a:	bd80      	pop	{r7, pc}

0800a47c <chThdEnqueueTimeoutS>:
=======
 800a4e4:	b580      	push	{r7, lr}
 800a4e6:	b082      	sub	sp, #8
 800a4e8:	af00      	add	r7, sp, #0
 800a4ea:	6078      	str	r0, [r7, #4]
 800a4ec:	6039      	str	r1, [r7, #0]

  chSysLock();
 800a4ee:	f001 fa53 	bl	800b998 <chSysLock.lto_priv.255>
  chThdResumeS(trp, msg);
 800a4f2:	6878      	ldr	r0, [r7, #4]
 800a4f4:	6839      	ldr	r1, [r7, #0]
 800a4f6:	f7ff ffd5 	bl	800a4a4 <chThdResumeS>
  chSysUnlock();
 800a4fa:	f001 fa55 	bl	800b9a8 <chSysUnlock.lto_priv.250>
}
 800a4fe:	3708      	adds	r7, #8
 800a500:	46bd      	mov	sp, r7
 800a502:	bd80      	pop	{r7, pc}

0800a504 <chThdEnqueueTimeoutS>:
>>>>>>> 752c83b... update binaries
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
<<<<<<< HEAD
 800a47c:	b580      	push	{r7, lr}
 800a47e:	b082      	sub	sp, #8
 800a480:	af00      	add	r7, sp, #0
 800a482:	6078      	str	r0, [r7, #4]
 800a484:	460b      	mov	r3, r1
 800a486:	807b      	strh	r3, [r7, #2]

  if (TIME_IMMEDIATE == timeout) {
 800a488:	887b      	ldrh	r3, [r7, #2]
 800a48a:	2b00      	cmp	r3, #0
 800a48c:	d102      	bne.n	800a494 <chThdEnqueueTimeoutS+0x18>
    return MSG_TIMEOUT;
 800a48e:	f04f 33ff 	mov.w	r3, #4294967295
 800a492:	e00b      	b.n	800a4ac <chThdEnqueueTimeoutS+0x30>
  }

  queue_insert(currp, tqp);
 800a494:	4b07      	ldr	r3, [pc, #28]	; (800a4b4 <chThdEnqueueTimeoutS+0x38>)
 800a496:	699b      	ldr	r3, [r3, #24]
 800a498:	4618      	mov	r0, r3
 800a49a:	6879      	ldr	r1, [r7, #4]
 800a49c:	f000 ffa6 	bl	800b3ec <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800a4a0:	887b      	ldrh	r3, [r7, #2]
 800a4a2:	2004      	movs	r0, #4
 800a4a4:	4619      	mov	r1, r3
 800a4a6:	f001 f8d5 	bl	800b654 <chSchGoSleepTimeoutS>
 800a4aa:	4603      	mov	r3, r0
}
 800a4ac:	4618      	mov	r0, r3
 800a4ae:	3708      	adds	r7, #8
 800a4b0:	46bd      	mov	sp, r7
 800a4b2:	bd80      	pop	{r7, pc}
 800a4b4:	20001338 	.word	0x20001338

0800a4b8 <chThdDequeueNextI>:
=======
 800a504:	b580      	push	{r7, lr}
 800a506:	b082      	sub	sp, #8
 800a508:	af00      	add	r7, sp, #0
 800a50a:	6078      	str	r0, [r7, #4]
 800a50c:	460b      	mov	r3, r1
 800a50e:	807b      	strh	r3, [r7, #2]

  if (TIME_IMMEDIATE == timeout) {
 800a510:	887b      	ldrh	r3, [r7, #2]
 800a512:	2b00      	cmp	r3, #0
 800a514:	d102      	bne.n	800a51c <chThdEnqueueTimeoutS+0x18>
    return MSG_TIMEOUT;
 800a516:	f04f 33ff 	mov.w	r3, #4294967295
 800a51a:	e00b      	b.n	800a534 <chThdEnqueueTimeoutS+0x30>
  }

  queue_insert(currp, tqp);
 800a51c:	4b07      	ldr	r3, [pc, #28]	; (800a53c <chThdEnqueueTimeoutS+0x38>)
 800a51e:	699b      	ldr	r3, [r3, #24]
 800a520:	4618      	mov	r0, r3
 800a522:	6879      	ldr	r1, [r7, #4]
 800a524:	f000 ffa6 	bl	800b474 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800a528:	887b      	ldrh	r3, [r7, #2]
 800a52a:	2004      	movs	r0, #4
 800a52c:	4619      	mov	r1, r3
 800a52e:	f001 f8d5 	bl	800b6dc <chSchGoSleepTimeoutS>
 800a532:	4603      	mov	r3, r0
}
 800a534:	4618      	mov	r0, r3
 800a536:	3708      	adds	r7, #8
 800a538:	46bd      	mov	sp, r7
 800a53a:	bd80      	pop	{r7, pc}
 800a53c:	20001338 	.word	0x20001338

0800a540 <chThdDequeueNextI>:
>>>>>>> 752c83b... update binaries
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
<<<<<<< HEAD
 800a4b8:	b580      	push	{r7, lr}
 800a4ba:	b082      	sub	sp, #8
 800a4bc:	af00      	add	r7, sp, #0
 800a4be:	6078      	str	r0, [r7, #4]
 800a4c0:	6039      	str	r1, [r7, #0]

  if (queue_notempty(tqp)) {
 800a4c2:	6878      	ldr	r0, [r7, #4]
 800a4c4:	f001 fa12 	bl	800b8ec <queue_notempty.lto_priv.278>
 800a4c8:	4603      	mov	r3, r0
 800a4ca:	2b00      	cmp	r3, #0
 800a4cc:	d003      	beq.n	800a4d6 <chThdDequeueNextI+0x1e>
    chThdDoDequeueNextI(tqp, msg);
 800a4ce:	6878      	ldr	r0, [r7, #4]
 800a4d0:	6839      	ldr	r1, [r7, #0]
 800a4d2:	f001 fa59 	bl	800b988 <chThdDoDequeueNextI.lto_priv.290>
  }
}
 800a4d6:	3708      	adds	r7, #8
 800a4d8:	46bd      	mov	sp, r7
 800a4da:	bd80      	pop	{r7, pc}

0800a4dc <port_lock.lto_priv.269>:
=======
 800a540:	b580      	push	{r7, lr}
 800a542:	b082      	sub	sp, #8
 800a544:	af00      	add	r7, sp, #0
 800a546:	6078      	str	r0, [r7, #4]
 800a548:	6039      	str	r1, [r7, #0]

  if (queue_notempty(tqp)) {
 800a54a:	6878      	ldr	r0, [r7, #4]
 800a54c:	f001 fa12 	bl	800b974 <queue_notempty.lto_priv.275>
 800a550:	4603      	mov	r3, r0
 800a552:	2b00      	cmp	r3, #0
 800a554:	d003      	beq.n	800a55e <chThdDequeueNextI+0x1e>
    chThdDoDequeueNextI(tqp, msg);
 800a556:	6878      	ldr	r0, [r7, #4]
 800a558:	6839      	ldr	r1, [r7, #0]
 800a55a:	f001 fa59 	bl	800ba10 <chThdDoDequeueNextI.lto_priv.287>
  }
}
 800a55e:	3708      	adds	r7, #8
 800a560:	46bd      	mov	sp, r7
 800a562:	bd80      	pop	{r7, pc}

0800a564 <port_lock.lto_priv.266>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800a4dc:	b480      	push	{r7}
 800a4de:	b083      	sub	sp, #12
 800a4e0:	af00      	add	r7, sp, #0
 800a4e2:	2320      	movs	r3, #32
 800a4e4:	607b      	str	r3, [r7, #4]
 800a4e6:	687b      	ldr	r3, [r7, #4]
 800a4e8:	f383 8811 	msr	BASEPRI, r3
=======
 800a564:	b480      	push	{r7}
 800a566:	b083      	sub	sp, #12
 800a568:	af00      	add	r7, sp, #0
 800a56a:	2320      	movs	r3, #32
 800a56c:	607b      	str	r3, [r7, #4]
 800a56e:	687b      	ldr	r3, [r7, #4]
 800a570:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800a4ec:	370c      	adds	r7, #12
 800a4ee:	46bd      	mov	sp, r7
 800a4f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4f4:	4770      	bx	lr
 800a4f6:	bf00      	nop

0800a4f8 <port_unlock.lto_priv.265>:
=======
 800a574:	370c      	adds	r7, #12
 800a576:	46bd      	mov	sp, r7
 800a578:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a57c:	4770      	bx	lr
 800a57e:	bf00      	nop

0800a580 <port_unlock.lto_priv.262>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800a4f8:	b480      	push	{r7}
 800a4fa:	b083      	sub	sp, #12
 800a4fc:	af00      	add	r7, sp, #0
 800a4fe:	2300      	movs	r3, #0
 800a500:	607b      	str	r3, [r7, #4]
 800a502:	687b      	ldr	r3, [r7, #4]
 800a504:	f383 8811 	msr	BASEPRI, r3
=======
 800a580:	b480      	push	{r7}
 800a582:	b083      	sub	sp, #12
 800a584:	af00      	add	r7, sp, #0
 800a586:	2300      	movs	r3, #0
 800a588:	607b      	str	r3, [r7, #4]
 800a58a:	687b      	ldr	r3, [r7, #4]
 800a58c:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800a508:	370c      	adds	r7, #12
 800a50a:	46bd      	mov	sp, r7
 800a50c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a510:	4770      	bx	lr
 800a512:	bf00      	nop

0800a514 <chSysLock.lto_priv.259>:
=======
 800a590:	370c      	adds	r7, #12
 800a592:	46bd      	mov	sp, r7
 800a594:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a598:	4770      	bx	lr
 800a59a:	bf00      	nop

0800a59c <chSysLock.lto_priv.256>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 800a514:	b580      	push	{r7, lr}
 800a516:	af00      	add	r7, sp, #0

  port_lock();
 800a518:	f7ff ffe0 	bl	800a4dc <port_lock.lto_priv.269>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a51c:	f000 fc90 	bl	800ae40 <_dbg_check_lock>
}
 800a520:	bd80      	pop	{r7, pc}
 800a522:	bf00      	nop

0800a524 <chSysUnlock.lto_priv.254>:
=======
 800a59c:	b580      	push	{r7, lr}
 800a59e:	af00      	add	r7, sp, #0

  port_lock();
 800a5a0:	f7ff ffe0 	bl	800a564 <port_lock.lto_priv.266>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a5a4:	f000 fc90 	bl	800aec8 <_dbg_check_lock>
}
 800a5a8:	bd80      	pop	{r7, pc}
 800a5aa:	bf00      	nop

0800a5ac <chSysUnlock.lto_priv.251>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 800a524:	b580      	push	{r7, lr}
 800a526:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a528:	f000 fca0 	bl	800ae6c <_dbg_check_unlock>
=======
 800a5ac:	b580      	push	{r7, lr}
 800a5ae:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a5b0:	f000 fca0 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 800a52c:	4b09      	ldr	r3, [pc, #36]	; (800a554 <chSysUnlock.lto_priv.254+0x30>)
 800a52e:	681b      	ldr	r3, [r3, #0]
 800a530:	4a08      	ldr	r2, [pc, #32]	; (800a554 <chSysUnlock.lto_priv.254+0x30>)
 800a532:	4293      	cmp	r3, r2
 800a534:	d00a      	beq.n	800a54c <chSysUnlock.lto_priv.254+0x28>
 800a536:	4b07      	ldr	r3, [pc, #28]	; (800a554 <chSysUnlock.lto_priv.254+0x30>)
 800a538:	699b      	ldr	r3, [r3, #24]
 800a53a:	689a      	ldr	r2, [r3, #8]
 800a53c:	4b05      	ldr	r3, [pc, #20]	; (800a554 <chSysUnlock.lto_priv.254+0x30>)
 800a53e:	681b      	ldr	r3, [r3, #0]
 800a540:	689b      	ldr	r3, [r3, #8]
 800a542:	429a      	cmp	r2, r3
 800a544:	d202      	bcs.n	800a54c <chSysUnlock.lto_priv.254+0x28>
 800a546:	4804      	ldr	r0, [pc, #16]	; (800a558 <chSysUnlock.lto_priv.254+0x34>)
 800a548:	f000 fc2c 	bl	800ada4 <chSysHalt>
=======
 800a5b4:	4b09      	ldr	r3, [pc, #36]	; (800a5dc <chSysUnlock.lto_priv.251+0x30>)
 800a5b6:	681b      	ldr	r3, [r3, #0]
 800a5b8:	4a08      	ldr	r2, [pc, #32]	; (800a5dc <chSysUnlock.lto_priv.251+0x30>)
 800a5ba:	4293      	cmp	r3, r2
 800a5bc:	d00a      	beq.n	800a5d4 <chSysUnlock.lto_priv.251+0x28>
 800a5be:	4b07      	ldr	r3, [pc, #28]	; (800a5dc <chSysUnlock.lto_priv.251+0x30>)
 800a5c0:	699b      	ldr	r3, [r3, #24]
 800a5c2:	689a      	ldr	r2, [r3, #8]
 800a5c4:	4b05      	ldr	r3, [pc, #20]	; (800a5dc <chSysUnlock.lto_priv.251+0x30>)
 800a5c6:	681b      	ldr	r3, [r3, #0]
 800a5c8:	689b      	ldr	r3, [r3, #8]
 800a5ca:	429a      	cmp	r2, r3
 800a5cc:	d202      	bcs.n	800a5d4 <chSysUnlock.lto_priv.251+0x28>
 800a5ce:	4804      	ldr	r0, [pc, #16]	; (800a5e0 <chSysUnlock.lto_priv.251+0x34>)
 800a5d0:	f000 fc2c 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 800a54c:	f7ff ffd4 	bl	800a4f8 <port_unlock.lto_priv.265>
}
 800a550:	bd80      	pop	{r7, pc}
 800a552:	bf00      	nop
 800a554:	20001338 	.word	0x20001338
 800a558:	0800e98c 	.word	0x0800e98c

0800a55c <chThdGetWorkingAreaX.lto_priv.282>:
=======
 800a5d4:	f7ff ffd4 	bl	800a580 <port_unlock.lto_priv.262>
}
 800a5d8:	bd80      	pop	{r7, pc}
 800a5da:	bf00      	nop
 800a5dc:	20001338 	.word	0x20001338
 800a5e0:	0800ea64 	.word	0x0800ea64

0800a5e4 <chThdGetWorkingAreaX.lto_priv.279>:
>>>>>>> 752c83b... update binaries
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
<<<<<<< HEAD
 800a55c:	b480      	push	{r7}
 800a55e:	b083      	sub	sp, #12
 800a560:	af00      	add	r7, sp, #0
 800a562:	6078      	str	r0, [r7, #4]

  return tp->wabase;
 800a564:	687b      	ldr	r3, [r7, #4]
 800a566:	69db      	ldr	r3, [r3, #28]
}
 800a568:	4618      	mov	r0, r3
 800a56a:	370c      	adds	r7, #12
 800a56c:	46bd      	mov	sp, r7
 800a56e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a572:	4770      	bx	lr

0800a574 <chRegFirstThread>:
=======
 800a5e4:	b480      	push	{r7}
 800a5e6:	b083      	sub	sp, #12
 800a5e8:	af00      	add	r7, sp, #0
 800a5ea:	6078      	str	r0, [r7, #4]

  return tp->wabase;
 800a5ec:	687b      	ldr	r3, [r7, #4]
 800a5ee:	69db      	ldr	r3, [r3, #28]
}
 800a5f0:	4618      	mov	r0, r3
 800a5f2:	370c      	adds	r7, #12
 800a5f4:	46bd      	mov	sp, r7
 800a5f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a5fa:	4770      	bx	lr

0800a5fc <chRegFirstThread>:
>>>>>>> 752c83b... update binaries
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
<<<<<<< HEAD
 800a574:	b580      	push	{r7, lr}
 800a576:	b082      	sub	sp, #8
 800a578:	af00      	add	r7, sp, #0
  thread_t *tp;

  chSysLock();
 800a57a:	f7ff ffcb 	bl	800a514 <chSysLock.lto_priv.259>
  tp = ch.rlist.newer;
 800a57e:	4b09      	ldr	r3, [pc, #36]	; (800a5a4 <chRegFirstThread+0x30>)
 800a580:	691b      	ldr	r3, [r3, #16]
 800a582:	607b      	str	r3, [r7, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 800a584:	687b      	ldr	r3, [r7, #4]
 800a586:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a58a:	3301      	adds	r3, #1
 800a58c:	b2da      	uxtb	r2, r3
 800a58e:	687b      	ldr	r3, [r7, #4]
 800a590:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 800a594:	f7ff ffc6 	bl	800a524 <chSysUnlock.lto_priv.254>

  return tp;
 800a598:	687b      	ldr	r3, [r7, #4]
}
 800a59a:	4618      	mov	r0, r3
 800a59c:	3708      	adds	r7, #8
 800a59e:	46bd      	mov	sp, r7
 800a5a0:	bd80      	pop	{r7, pc}
 800a5a2:	bf00      	nop
 800a5a4:	20001338 	.word	0x20001338

0800a5a8 <chRegNextThread>:
=======
 800a5fc:	b580      	push	{r7, lr}
 800a5fe:	b082      	sub	sp, #8
 800a600:	af00      	add	r7, sp, #0
  thread_t *tp;

  chSysLock();
 800a602:	f7ff ffcb 	bl	800a59c <chSysLock.lto_priv.256>
  tp = ch.rlist.newer;
 800a606:	4b09      	ldr	r3, [pc, #36]	; (800a62c <chRegFirstThread+0x30>)
 800a608:	691b      	ldr	r3, [r3, #16]
 800a60a:	607b      	str	r3, [r7, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 800a60c:	687b      	ldr	r3, [r7, #4]
 800a60e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a612:	3301      	adds	r3, #1
 800a614:	b2da      	uxtb	r2, r3
 800a616:	687b      	ldr	r3, [r7, #4]
 800a618:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 800a61c:	f7ff ffc6 	bl	800a5ac <chSysUnlock.lto_priv.251>

  return tp;
 800a620:	687b      	ldr	r3, [r7, #4]
}
 800a622:	4618      	mov	r0, r3
 800a624:	3708      	adds	r7, #8
 800a626:	46bd      	mov	sp, r7
 800a628:	bd80      	pop	{r7, pc}
 800a62a:	bf00      	nop
 800a62c:	20001338 	.word	0x20001338

0800a630 <chRegNextThread>:
>>>>>>> 752c83b... update binaries
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
<<<<<<< HEAD
 800a5a8:	b580      	push	{r7, lr}
 800a5aa:	b084      	sub	sp, #16
 800a5ac:	af00      	add	r7, sp, #0
 800a5ae:	6078      	str	r0, [r7, #4]
  thread_t *ntp;

  chSysLock();
 800a5b0:	f7ff ffb0 	bl	800a514 <chSysLock.lto_priv.259>
  ntp = tp->newer;
 800a5b4:	687b      	ldr	r3, [r7, #4]
 800a5b6:	691b      	ldr	r3, [r3, #16]
 800a5b8:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800a5ba:	68fb      	ldr	r3, [r7, #12]
 800a5bc:	4a0f      	ldr	r2, [pc, #60]	; (800a5fc <chRegNextThread+0x54>)
 800a5be:	4293      	cmp	r3, r2
 800a5c0:	d102      	bne.n	800a5c8 <chRegNextThread+0x20>
  /*lint -restore*/
    ntp = NULL;
 800a5c2:	2300      	movs	r3, #0
 800a5c4:	60fb      	str	r3, [r7, #12]
 800a5c6:	e00f      	b.n	800a5e8 <chRegNextThread+0x40>
=======
 800a630:	b580      	push	{r7, lr}
 800a632:	b084      	sub	sp, #16
 800a634:	af00      	add	r7, sp, #0
 800a636:	6078      	str	r0, [r7, #4]
  thread_t *ntp;

  chSysLock();
 800a638:	f7ff ffb0 	bl	800a59c <chSysLock.lto_priv.256>
  ntp = tp->newer;
 800a63c:	687b      	ldr	r3, [r7, #4]
 800a63e:	691b      	ldr	r3, [r3, #16]
 800a640:	60fb      	str	r3, [r7, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800a642:	68fb      	ldr	r3, [r7, #12]
 800a644:	4a0f      	ldr	r2, [pc, #60]	; (800a684 <chRegNextThread+0x54>)
 800a646:	4293      	cmp	r3, r2
 800a648:	d102      	bne.n	800a650 <chRegNextThread+0x20>
  /*lint -restore*/
    ntp = NULL;
 800a64a:	2300      	movs	r3, #0
 800a64c:	60fb      	str	r3, [r7, #12]
 800a64e:	e00f      	b.n	800a670 <chRegNextThread+0x40>
>>>>>>> 752c83b... update binaries
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
<<<<<<< HEAD
 800a5c8:	68fb      	ldr	r3, [r7, #12]
 800a5ca:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a5ce:	2bff      	cmp	r3, #255	; 0xff
 800a5d0:	d102      	bne.n	800a5d8 <chRegNextThread+0x30>
 800a5d2:	480b      	ldr	r0, [pc, #44]	; (800a600 <chRegNextThread+0x58>)
 800a5d4:	f000 fbe6 	bl	800ada4 <chSysHalt>
    ntp->refs++;
 800a5d8:	68fb      	ldr	r3, [r7, #12]
 800a5da:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a5de:	3301      	adds	r3, #1
 800a5e0:	b2da      	uxtb	r2, r3
 800a5e2:	68fb      	ldr	r3, [r7, #12]
 800a5e4:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 800a5e8:	f7ff ff9c 	bl	800a524 <chSysUnlock.lto_priv.254>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 800a5ec:	6878      	ldr	r0, [r7, #4]
 800a5ee:	f7ff fe05 	bl	800a1fc <chThdRelease>
#endif

  return ntp;
 800a5f2:	68fb      	ldr	r3, [r7, #12]
}
 800a5f4:	4618      	mov	r0, r3
 800a5f6:	3710      	adds	r7, #16
 800a5f8:	46bd      	mov	sp, r7
 800a5fa:	bd80      	pop	{r7, pc}
 800a5fc:	20001338 	.word	0x20001338
 800a600:	0800e998 	.word	0x0800e998

0800a604 <chRegFindThreadByWorkingArea>:
=======
 800a650:	68fb      	ldr	r3, [r7, #12]
 800a652:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a656:	2bff      	cmp	r3, #255	; 0xff
 800a658:	d102      	bne.n	800a660 <chRegNextThread+0x30>
 800a65a:	480b      	ldr	r0, [pc, #44]	; (800a688 <chRegNextThread+0x58>)
 800a65c:	f000 fbe6 	bl	800ae2c <chSysHalt>
    ntp->refs++;
 800a660:	68fb      	ldr	r3, [r7, #12]
 800a662:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a666:	3301      	adds	r3, #1
 800a668:	b2da      	uxtb	r2, r3
 800a66a:	68fb      	ldr	r3, [r7, #12]
 800a66c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 800a670:	f7ff ff9c 	bl	800a5ac <chSysUnlock.lto_priv.251>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 800a674:	6878      	ldr	r0, [r7, #4]
 800a676:	f7ff fe05 	bl	800a284 <chThdRelease>
#endif

  return ntp;
 800a67a:	68fb      	ldr	r3, [r7, #12]
}
 800a67c:	4618      	mov	r0, r3
 800a67e:	3710      	adds	r7, #16
 800a680:	46bd      	mov	sp, r7
 800a682:	bd80      	pop	{r7, pc}
 800a684:	20001338 	.word	0x20001338
 800a688:	0800ea70 	.word	0x0800ea70

0800a68c <chRegFindThreadByWorkingArea>:
>>>>>>> 752c83b... update binaries
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
<<<<<<< HEAD
 800a604:	b580      	push	{r7, lr}
 800a606:	b084      	sub	sp, #16
 800a608:	af00      	add	r7, sp, #0
 800a60a:	6078      	str	r0, [r7, #4]
=======
 800a68c:	b580      	push	{r7, lr}
 800a68e:	b084      	sub	sp, #16
 800a690:	af00      	add	r7, sp, #0
 800a692:	6078      	str	r0, [r7, #4]
>>>>>>> 752c83b... update binaries
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
<<<<<<< HEAD
 800a60c:	f7ff ffb2 	bl	800a574 <chRegFirstThread>
 800a610:	60f8      	str	r0, [r7, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800a612:	68f8      	ldr	r0, [r7, #12]
 800a614:	f7ff ffa2 	bl	800a55c <chThdGetWorkingAreaX.lto_priv.282>
 800a618:	4602      	mov	r2, r0
 800a61a:	687b      	ldr	r3, [r7, #4]
 800a61c:	429a      	cmp	r2, r3
 800a61e:	d101      	bne.n	800a624 <chRegFindThreadByWorkingArea+0x20>
      return ctp;
 800a620:	68fb      	ldr	r3, [r7, #12]
 800a622:	e007      	b.n	800a634 <chRegFindThreadByWorkingArea+0x30>
    }
    ctp = chRegNextThread(ctp);
 800a624:	68f8      	ldr	r0, [r7, #12]
 800a626:	f7ff ffbf 	bl	800a5a8 <chRegNextThread>
 800a62a:	60f8      	str	r0, [r7, #12]
  } while (ctp != NULL);
 800a62c:	68fb      	ldr	r3, [r7, #12]
 800a62e:	2b00      	cmp	r3, #0
 800a630:	d1ef      	bne.n	800a612 <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 800a632:	2300      	movs	r3, #0
}
 800a634:	4618      	mov	r0, r3
 800a636:	3710      	adds	r7, #16
 800a638:	46bd      	mov	sp, r7
 800a63a:	bd80      	pop	{r7, pc}

0800a63c <port_lock.lto_priv.270>:
=======
 800a694:	f7ff ffb2 	bl	800a5fc <chRegFirstThread>
 800a698:	60f8      	str	r0, [r7, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 800a69a:	68f8      	ldr	r0, [r7, #12]
 800a69c:	f7ff ffa2 	bl	800a5e4 <chThdGetWorkingAreaX.lto_priv.279>
 800a6a0:	4602      	mov	r2, r0
 800a6a2:	687b      	ldr	r3, [r7, #4]
 800a6a4:	429a      	cmp	r2, r3
 800a6a6:	d101      	bne.n	800a6ac <chRegFindThreadByWorkingArea+0x20>
      return ctp;
 800a6a8:	68fb      	ldr	r3, [r7, #12]
 800a6aa:	e007      	b.n	800a6bc <chRegFindThreadByWorkingArea+0x30>
    }
    ctp = chRegNextThread(ctp);
 800a6ac:	68f8      	ldr	r0, [r7, #12]
 800a6ae:	f7ff ffbf 	bl	800a630 <chRegNextThread>
 800a6b2:	60f8      	str	r0, [r7, #12]
  } while (ctp != NULL);
 800a6b4:	68fb      	ldr	r3, [r7, #12]
 800a6b6:	2b00      	cmp	r3, #0
 800a6b8:	d1ef      	bne.n	800a69a <chRegFindThreadByWorkingArea+0xe>

  return NULL;
 800a6ba:	2300      	movs	r3, #0
}
 800a6bc:	4618      	mov	r0, r3
 800a6be:	3710      	adds	r7, #16
 800a6c0:	46bd      	mov	sp, r7
 800a6c2:	bd80      	pop	{r7, pc}

0800a6c4 <port_lock.lto_priv.267>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800a63c:	b480      	push	{r7}
 800a63e:	b083      	sub	sp, #12
 800a640:	af00      	add	r7, sp, #0
 800a642:	2320      	movs	r3, #32
 800a644:	607b      	str	r3, [r7, #4]
 800a646:	687b      	ldr	r3, [r7, #4]
 800a648:	f383 8811 	msr	BASEPRI, r3
=======
 800a6c4:	b480      	push	{r7}
 800a6c6:	b083      	sub	sp, #12
 800a6c8:	af00      	add	r7, sp, #0
 800a6ca:	2320      	movs	r3, #32
 800a6cc:	607b      	str	r3, [r7, #4]
 800a6ce:	687b      	ldr	r3, [r7, #4]
 800a6d0:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800a64c:	370c      	adds	r7, #12
 800a64e:	46bd      	mov	sp, r7
 800a650:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a654:	4770      	bx	lr
 800a656:	bf00      	nop

0800a658 <port_unlock.lto_priv.266>:
=======
 800a6d4:	370c      	adds	r7, #12
 800a6d6:	46bd      	mov	sp, r7
 800a6d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6dc:	4770      	bx	lr
 800a6de:	bf00      	nop

0800a6e0 <port_unlock.lto_priv.263>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800a658:	b480      	push	{r7}
 800a65a:	b083      	sub	sp, #12
 800a65c:	af00      	add	r7, sp, #0
 800a65e:	2300      	movs	r3, #0
 800a660:	607b      	str	r3, [r7, #4]
 800a662:	687b      	ldr	r3, [r7, #4]
 800a664:	f383 8811 	msr	BASEPRI, r3
=======
 800a6e0:	b480      	push	{r7}
 800a6e2:	b083      	sub	sp, #12
 800a6e4:	af00      	add	r7, sp, #0
 800a6e6:	2300      	movs	r3, #0
 800a6e8:	607b      	str	r3, [r7, #4]
 800a6ea:	687b      	ldr	r3, [r7, #4]
 800a6ec:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800a668:	370c      	adds	r7, #12
 800a66a:	46bd      	mov	sp, r7
 800a66c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a670:	4770      	bx	lr
 800a672:	bf00      	nop

0800a674 <queue_init.lto_priv.263>:
=======
 800a6f0:	370c      	adds	r7, #12
 800a6f2:	46bd      	mov	sp, r7
 800a6f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6f8:	4770      	bx	lr
 800a6fa:	bf00      	nop

0800a6fc <queue_init.lto_priv.260>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
<<<<<<< HEAD
 800a674:	b480      	push	{r7}
 800a676:	b083      	sub	sp, #12
 800a678:	af00      	add	r7, sp, #0
 800a67a:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800a67c:	687b      	ldr	r3, [r7, #4]
 800a67e:	687a      	ldr	r2, [r7, #4]
 800a680:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800a682:	687b      	ldr	r3, [r7, #4]
 800a684:	687a      	ldr	r2, [r7, #4]
 800a686:	605a      	str	r2, [r3, #4]
}
 800a688:	370c      	adds	r7, #12
 800a68a:	46bd      	mov	sp, r7
 800a68c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a690:	4770      	bx	lr
 800a692:	bf00      	nop

0800a694 <queue_notempty.lto_priv.279>:
=======
 800a6fc:	b480      	push	{r7}
 800a6fe:	b083      	sub	sp, #12
 800a700:	af00      	add	r7, sp, #0
 800a702:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800a704:	687b      	ldr	r3, [r7, #4]
 800a706:	687a      	ldr	r2, [r7, #4]
 800a708:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800a70a:	687b      	ldr	r3, [r7, #4]
 800a70c:	687a      	ldr	r2, [r7, #4]
 800a70e:	605a      	str	r2, [r3, #4]
}
 800a710:	370c      	adds	r7, #12
 800a712:	46bd      	mov	sp, r7
 800a714:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a718:	4770      	bx	lr
 800a71a:	bf00      	nop

0800a71c <queue_notempty.lto_priv.276>:
>>>>>>> 752c83b... update binaries
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
<<<<<<< HEAD
 800a694:	b480      	push	{r7}
 800a696:	b083      	sub	sp, #12
 800a698:	af00      	add	r7, sp, #0
 800a69a:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 800a69c:	687b      	ldr	r3, [r7, #4]
 800a69e:	681a      	ldr	r2, [r3, #0]
 800a6a0:	687b      	ldr	r3, [r7, #4]
 800a6a2:	429a      	cmp	r2, r3
 800a6a4:	bf14      	ite	ne
 800a6a6:	2301      	movne	r3, #1
 800a6a8:	2300      	moveq	r3, #0
 800a6aa:	b2db      	uxtb	r3, r3
}
 800a6ac:	4618      	mov	r0, r3
 800a6ae:	370c      	adds	r7, #12
 800a6b0:	46bd      	mov	sp, r7
 800a6b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6b6:	4770      	bx	lr

0800a6b8 <chSysLock.lto_priv.260>:
=======
 800a71c:	b480      	push	{r7}
 800a71e:	b083      	sub	sp, #12
 800a720:	af00      	add	r7, sp, #0
 800a722:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 800a724:	687b      	ldr	r3, [r7, #4]
 800a726:	681a      	ldr	r2, [r3, #0]
 800a728:	687b      	ldr	r3, [r7, #4]
 800a72a:	429a      	cmp	r2, r3
 800a72c:	bf14      	ite	ne
 800a72e:	2301      	movne	r3, #1
 800a730:	2300      	moveq	r3, #0
 800a732:	b2db      	uxtb	r3, r3
}
 800a734:	4618      	mov	r0, r3
 800a736:	370c      	adds	r7, #12
 800a738:	46bd      	mov	sp, r7
 800a73a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a73e:	4770      	bx	lr

0800a740 <chSysLock.lto_priv.257>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 800a6b8:	b580      	push	{r7, lr}
 800a6ba:	af00      	add	r7, sp, #0

  port_lock();
 800a6bc:	f7ff ffbe 	bl	800a63c <port_lock.lto_priv.270>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a6c0:	f000 fbbe 	bl	800ae40 <_dbg_check_lock>
}
 800a6c4:	bd80      	pop	{r7, pc}
 800a6c6:	bf00      	nop

0800a6c8 <chSysUnlock.lto_priv.255>:
=======
 800a740:	b580      	push	{r7, lr}
 800a742:	af00      	add	r7, sp, #0

  port_lock();
 800a744:	f7ff ffbe 	bl	800a6c4 <port_lock.lto_priv.267>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a748:	f000 fbbe 	bl	800aec8 <_dbg_check_lock>
}
 800a74c:	bd80      	pop	{r7, pc}
 800a74e:	bf00      	nop

0800a750 <chSysUnlock.lto_priv.252>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 800a6c8:	b580      	push	{r7, lr}
 800a6ca:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a6cc:	f000 fbce 	bl	800ae6c <_dbg_check_unlock>
=======
 800a750:	b580      	push	{r7, lr}
 800a752:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800a754:	f000 fbce 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 800a6d0:	4b09      	ldr	r3, [pc, #36]	; (800a6f8 <chSysUnlock.lto_priv.255+0x30>)
 800a6d2:	681b      	ldr	r3, [r3, #0]
 800a6d4:	4a08      	ldr	r2, [pc, #32]	; (800a6f8 <chSysUnlock.lto_priv.255+0x30>)
 800a6d6:	4293      	cmp	r3, r2
 800a6d8:	d00a      	beq.n	800a6f0 <chSysUnlock.lto_priv.255+0x28>
 800a6da:	4b07      	ldr	r3, [pc, #28]	; (800a6f8 <chSysUnlock.lto_priv.255+0x30>)
 800a6dc:	699b      	ldr	r3, [r3, #24]
 800a6de:	689a      	ldr	r2, [r3, #8]
 800a6e0:	4b05      	ldr	r3, [pc, #20]	; (800a6f8 <chSysUnlock.lto_priv.255+0x30>)
 800a6e2:	681b      	ldr	r3, [r3, #0]
 800a6e4:	689b      	ldr	r3, [r3, #8]
 800a6e6:	429a      	cmp	r2, r3
 800a6e8:	d202      	bcs.n	800a6f0 <chSysUnlock.lto_priv.255+0x28>
 800a6ea:	4804      	ldr	r0, [pc, #16]	; (800a6fc <chSysUnlock.lto_priv.255+0x34>)
 800a6ec:	f000 fb5a 	bl	800ada4 <chSysHalt>
=======
 800a758:	4b09      	ldr	r3, [pc, #36]	; (800a780 <chSysUnlock.lto_priv.252+0x30>)
 800a75a:	681b      	ldr	r3, [r3, #0]
 800a75c:	4a08      	ldr	r2, [pc, #32]	; (800a780 <chSysUnlock.lto_priv.252+0x30>)
 800a75e:	4293      	cmp	r3, r2
 800a760:	d00a      	beq.n	800a778 <chSysUnlock.lto_priv.252+0x28>
 800a762:	4b07      	ldr	r3, [pc, #28]	; (800a780 <chSysUnlock.lto_priv.252+0x30>)
 800a764:	699b      	ldr	r3, [r3, #24]
 800a766:	689a      	ldr	r2, [r3, #8]
 800a768:	4b05      	ldr	r3, [pc, #20]	; (800a780 <chSysUnlock.lto_priv.252+0x30>)
 800a76a:	681b      	ldr	r3, [r3, #0]
 800a76c:	689b      	ldr	r3, [r3, #8]
 800a76e:	429a      	cmp	r2, r3
 800a770:	d202      	bcs.n	800a778 <chSysUnlock.lto_priv.252+0x28>
 800a772:	4804      	ldr	r0, [pc, #16]	; (800a784 <chSysUnlock.lto_priv.252+0x34>)
 800a774:	f000 fb5a 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 800a6f0:	f7ff ffb2 	bl	800a658 <port_unlock.lto_priv.266>
}
 800a6f4:	bd80      	pop	{r7, pc}
 800a6f6:	bf00      	nop
 800a6f8:	20001338 	.word	0x20001338
 800a6fc:	0800e9b8 	.word	0x0800e9b8

0800a700 <chMtxQueueNotEmptyS>:
=======
 800a778:	f7ff ffb2 	bl	800a6e0 <port_unlock.lto_priv.263>
}
 800a77c:	bd80      	pop	{r7, pc}
 800a77e:	bf00      	nop
 800a780:	20001338 	.word	0x20001338
 800a784:	0800ea90 	.word	0x0800ea90

0800a788 <chMtxQueueNotEmptyS>:
>>>>>>> 752c83b... update binaries
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
<<<<<<< HEAD
 800a700:	b580      	push	{r7, lr}
 800a702:	b082      	sub	sp, #8
 800a704:	af00      	add	r7, sp, #0
 800a706:	6078      	str	r0, [r7, #4]

  chDbgCheckClassS();
 800a708:	f000 fc3c 	bl	800af84 <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 800a70c:	687b      	ldr	r3, [r7, #4]
 800a70e:	4618      	mov	r0, r3
 800a710:	f7ff ffc0 	bl	800a694 <queue_notempty.lto_priv.279>
 800a714:	4603      	mov	r3, r0
}
 800a716:	4618      	mov	r0, r3
 800a718:	3708      	adds	r7, #8
 800a71a:	46bd      	mov	sp, r7
 800a71c:	bd80      	pop	{r7, pc}
 800a71e:	bf00      	nop

0800a720 <chMtxObjectInit>:
=======
 800a788:	b580      	push	{r7, lr}
 800a78a:	b082      	sub	sp, #8
 800a78c:	af00      	add	r7, sp, #0
 800a78e:	6078      	str	r0, [r7, #4]

  chDbgCheckClassS();
 800a790:	f000 fc3c 	bl	800b00c <chDbgCheckClassS>

  return queue_notempty(&mp->queue);
 800a794:	687b      	ldr	r3, [r7, #4]
 800a796:	4618      	mov	r0, r3
 800a798:	f7ff ffc0 	bl	800a71c <queue_notempty.lto_priv.276>
 800a79c:	4603      	mov	r3, r0
}
 800a79e:	4618      	mov	r0, r3
 800a7a0:	3708      	adds	r7, #8
 800a7a2:	46bd      	mov	sp, r7
 800a7a4:	bd80      	pop	{r7, pc}
 800a7a6:	bf00      	nop

0800a7a8 <chMtxObjectInit>:
>>>>>>> 752c83b... update binaries
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
<<<<<<< HEAD
 800a720:	b580      	push	{r7, lr}
 800a722:	b082      	sub	sp, #8
 800a724:	af00      	add	r7, sp, #0
 800a726:	6078      	str	r0, [r7, #4]

  chDbgCheck(mp != NULL);
 800a728:	687b      	ldr	r3, [r7, #4]
 800a72a:	2b00      	cmp	r3, #0
 800a72c:	d102      	bne.n	800a734 <chMtxObjectInit+0x14>
 800a72e:	4808      	ldr	r0, [pc, #32]	; (800a750 <chMtxObjectInit+0x30>)
 800a730:	f000 fb38 	bl	800ada4 <chSysHalt>

  queue_init(&mp->queue);
 800a734:	687b      	ldr	r3, [r7, #4]
 800a736:	4618      	mov	r0, r3
 800a738:	f7ff ff9c 	bl	800a674 <queue_init.lto_priv.263>
  mp->owner = NULL;
 800a73c:	687b      	ldr	r3, [r7, #4]
 800a73e:	2200      	movs	r2, #0
 800a740:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
 800a742:	687b      	ldr	r3, [r7, #4]
 800a744:	2200      	movs	r2, #0
 800a746:	611a      	str	r2, [r3, #16]
#endif
}
 800a748:	3708      	adds	r7, #8
 800a74a:	46bd      	mov	sp, r7
 800a74c:	bd80      	pop	{r7, pc}
 800a74e:	bf00      	nop
 800a750:	0800e9a8 	.word	0x0800e9a8

0800a754 <chMtxLockS>:
=======
 800a7a8:	b580      	push	{r7, lr}
 800a7aa:	b082      	sub	sp, #8
 800a7ac:	af00      	add	r7, sp, #0
 800a7ae:	6078      	str	r0, [r7, #4]

  chDbgCheck(mp != NULL);
 800a7b0:	687b      	ldr	r3, [r7, #4]
 800a7b2:	2b00      	cmp	r3, #0
 800a7b4:	d102      	bne.n	800a7bc <chMtxObjectInit+0x14>
 800a7b6:	4808      	ldr	r0, [pc, #32]	; (800a7d8 <chMtxObjectInit+0x30>)
 800a7b8:	f000 fb38 	bl	800ae2c <chSysHalt>

  queue_init(&mp->queue);
 800a7bc:	687b      	ldr	r3, [r7, #4]
 800a7be:	4618      	mov	r0, r3
 800a7c0:	f7ff ff9c 	bl	800a6fc <queue_init.lto_priv.260>
  mp->owner = NULL;
 800a7c4:	687b      	ldr	r3, [r7, #4]
 800a7c6:	2200      	movs	r2, #0
 800a7c8:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
 800a7ca:	687b      	ldr	r3, [r7, #4]
 800a7cc:	2200      	movs	r2, #0
 800a7ce:	611a      	str	r2, [r3, #16]
#endif
}
 800a7d0:	3708      	adds	r7, #8
 800a7d2:	46bd      	mov	sp, r7
 800a7d4:	bd80      	pop	{r7, pc}
 800a7d6:	bf00      	nop
 800a7d8:	0800ea80 	.word	0x0800ea80

0800a7dc <chMtxLockS>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
<<<<<<< HEAD
 800a754:	b580      	push	{r7, lr}
 800a756:	b084      	sub	sp, #16
 800a758:	af00      	add	r7, sp, #0
 800a75a:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800a75c:	4b46      	ldr	r3, [pc, #280]	; (800a878 <chMtxLockS+0x124>)
 800a75e:	699b      	ldr	r3, [r3, #24]
 800a760:	60bb      	str	r3, [r7, #8]

  chDbgCheckClassS();
 800a762:	f000 fc0f 	bl	800af84 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800a766:	687b      	ldr	r3, [r7, #4]
 800a768:	2b00      	cmp	r3, #0
 800a76a:	d102      	bne.n	800a772 <chMtxLockS+0x1e>
 800a76c:	4843      	ldr	r0, [pc, #268]	; (800a87c <chMtxLockS+0x128>)
 800a76e:	f000 fb19 	bl	800ada4 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800a772:	687b      	ldr	r3, [r7, #4]
 800a774:	689b      	ldr	r3, [r3, #8]
 800a776:	2b00      	cmp	r3, #0
 800a778:	d065      	beq.n	800a846 <chMtxLockS+0xf2>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE

    chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800a77a:	687b      	ldr	r3, [r7, #4]
 800a77c:	691b      	ldr	r3, [r3, #16]
 800a77e:	2b00      	cmp	r3, #0
 800a780:	dc02      	bgt.n	800a788 <chMtxLockS+0x34>
 800a782:	483e      	ldr	r0, [pc, #248]	; (800a87c <chMtxLockS+0x128>)
 800a784:	f000 fb0e 	bl	800ada4 <chSysHalt>
=======
 800a7dc:	b580      	push	{r7, lr}
 800a7de:	b084      	sub	sp, #16
 800a7e0:	af00      	add	r7, sp, #0
 800a7e2:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800a7e4:	4b46      	ldr	r3, [pc, #280]	; (800a900 <chMtxLockS+0x124>)
 800a7e6:	699b      	ldr	r3, [r3, #24]
 800a7e8:	60bb      	str	r3, [r7, #8]

  chDbgCheckClassS();
 800a7ea:	f000 fc0f 	bl	800b00c <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800a7ee:	687b      	ldr	r3, [r7, #4]
 800a7f0:	2b00      	cmp	r3, #0
 800a7f2:	d102      	bne.n	800a7fa <chMtxLockS+0x1e>
 800a7f4:	4843      	ldr	r0, [pc, #268]	; (800a904 <chMtxLockS+0x128>)
 800a7f6:	f000 fb19 	bl	800ae2c <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800a7fa:	687b      	ldr	r3, [r7, #4]
 800a7fc:	689b      	ldr	r3, [r3, #8]
 800a7fe:	2b00      	cmp	r3, #0
 800a800:	d065      	beq.n	800a8ce <chMtxLockS+0xf2>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE

    chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800a802:	687b      	ldr	r3, [r7, #4]
 800a804:	691b      	ldr	r3, [r3, #16]
 800a806:	2b00      	cmp	r3, #0
 800a808:	dc02      	bgt.n	800a810 <chMtxLockS+0x34>
 800a80a:	483e      	ldr	r0, [pc, #248]	; (800a904 <chMtxLockS+0x128>)
 800a80c:	f000 fb0e 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

    /* If the mutex is already owned by this thread, the counter is increased
       and there is no need of more actions.*/
    if (mp->owner == ctp) {
<<<<<<< HEAD
 800a788:	687b      	ldr	r3, [r7, #4]
 800a78a:	689a      	ldr	r2, [r3, #8]
 800a78c:	68bb      	ldr	r3, [r7, #8]
 800a78e:	429a      	cmp	r2, r3
 800a790:	d105      	bne.n	800a79e <chMtxLockS+0x4a>
      mp->cnt++;
 800a792:	687b      	ldr	r3, [r7, #4]
 800a794:	691b      	ldr	r3, [r3, #16]
 800a796:	1c5a      	adds	r2, r3, #1
 800a798:	687b      	ldr	r3, [r7, #4]
 800a79a:	611a      	str	r2, [r3, #16]
 800a79c:	e069      	b.n	800a872 <chMtxLockS+0x11e>
=======
 800a810:	687b      	ldr	r3, [r7, #4]
 800a812:	689a      	ldr	r2, [r3, #8]
 800a814:	68bb      	ldr	r3, [r7, #8]
 800a816:	429a      	cmp	r2, r3
 800a818:	d105      	bne.n	800a826 <chMtxLockS+0x4a>
      mp->cnt++;
 800a81a:	687b      	ldr	r3, [r7, #4]
 800a81c:	691b      	ldr	r3, [r3, #16]
 800a81e:	1c5a      	adds	r2, r3, #1
 800a820:	687b      	ldr	r3, [r7, #4]
 800a822:	611a      	str	r2, [r3, #16]
 800a824:	e069      	b.n	800a8fa <chMtxLockS+0x11e>
>>>>>>> 752c83b... update binaries
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
<<<<<<< HEAD
 800a79e:	687b      	ldr	r3, [r7, #4]
 800a7a0:	689b      	ldr	r3, [r3, #8]
 800a7a2:	60fb      	str	r3, [r7, #12]
 800a7a4:	e026      	b.n	800a7f4 <chMtxLockS+0xa0>
=======
 800a826:	687b      	ldr	r3, [r7, #4]
 800a828:	689b      	ldr	r3, [r3, #8]
 800a82a:	60fb      	str	r3, [r7, #12]
 800a82c:	e026      	b.n	800a87c <chMtxLockS+0xa0>
>>>>>>> 752c83b... update binaries

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
<<<<<<< HEAD
 800a7a6:	68bb      	ldr	r3, [r7, #8]
 800a7a8:	689a      	ldr	r2, [r3, #8]
 800a7aa:	68fb      	ldr	r3, [r7, #12]
 800a7ac:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800a7ae:	68fb      	ldr	r3, [r7, #12]
 800a7b0:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a7b4:	2b00      	cmp	r3, #0
 800a7b6:	d011      	beq.n	800a7dc <chMtxLockS+0x88>
 800a7b8:	2b06      	cmp	r3, #6
 800a7ba:	d000      	beq.n	800a7be <chMtxLockS+0x6a>
 800a7bc:	e020      	b.n	800a800 <chMtxLockS+0xac>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800a7be:	68f8      	ldr	r0, [r7, #12]
 800a7c0:	f000 fe42 	bl	800b448 <queue_dequeue>
 800a7c4:	4602      	mov	r2, r0
 800a7c6:	68fb      	ldr	r3, [r7, #12]
 800a7c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7ca:	4610      	mov	r0, r2
 800a7cc:	4619      	mov	r1, r3
 800a7ce:	f000 fde5 	bl	800b39c <queue_prio_insert>
          tp = tp->u.wtmtxp->owner;
 800a7d2:	68fb      	ldr	r3, [r7, #12]
 800a7d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a7d6:	689b      	ldr	r3, [r3, #8]
 800a7d8:	60fb      	str	r3, [r7, #12]
 800a7da:	e00b      	b.n	800a7f4 <chMtxLockS+0xa0>
=======
 800a82e:	68bb      	ldr	r3, [r7, #8]
 800a830:	689a      	ldr	r2, [r3, #8]
 800a832:	68fb      	ldr	r3, [r7, #12]
 800a834:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800a836:	68fb      	ldr	r3, [r7, #12]
 800a838:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a83c:	2b00      	cmp	r3, #0
 800a83e:	d011      	beq.n	800a864 <chMtxLockS+0x88>
 800a840:	2b06      	cmp	r3, #6
 800a842:	d000      	beq.n	800a846 <chMtxLockS+0x6a>
 800a844:	e020      	b.n	800a888 <chMtxLockS+0xac>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800a846:	68f8      	ldr	r0, [r7, #12]
 800a848:	f000 fe42 	bl	800b4d0 <queue_dequeue>
 800a84c:	4602      	mov	r2, r0
 800a84e:	68fb      	ldr	r3, [r7, #12]
 800a850:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a852:	4610      	mov	r0, r2
 800a854:	4619      	mov	r1, r3
 800a856:	f000 fde5 	bl	800b424 <queue_prio_insert>
          tp = tp->u.wtmtxp->owner;
 800a85a:	68fb      	ldr	r3, [r7, #12]
 800a85c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a85e:	689b      	ldr	r3, [r3, #8]
 800a860:	60fb      	str	r3, [r7, #12]
 800a862:	e00b      	b.n	800a87c <chMtxLockS+0xa0>
>>>>>>> 752c83b... update binaries
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
<<<<<<< HEAD
 800a7dc:	68fb      	ldr	r3, [r7, #12]
 800a7de:	2201      	movs	r2, #1
 800a7e0:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800a7e4:	68f8      	ldr	r0, [r7, #12]
 800a7e6:	f000 fe2f 	bl	800b448 <queue_dequeue>
 800a7ea:	4603      	mov	r3, r0
 800a7ec:	4618      	mov	r0, r3
 800a7ee:	f000 fe53 	bl	800b498 <chSchReadyI>
 800a7f2:	e005      	b.n	800a800 <chMtxLockS+0xac>
=======
 800a864:	68fb      	ldr	r3, [r7, #12]
 800a866:	2201      	movs	r2, #1
 800a868:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800a86c:	68f8      	ldr	r0, [r7, #12]
 800a86e:	f000 fe2f 	bl	800b4d0 <queue_dequeue>
 800a872:	4603      	mov	r3, r0
 800a874:	4618      	mov	r0, r3
 800a876:	f000 fe53 	bl	800b520 <chSchReadyI>
 800a87a:	e005      	b.n	800a888 <chMtxLockS+0xac>
>>>>>>> 752c83b... update binaries
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
<<<<<<< HEAD
 800a7f4:	68fb      	ldr	r3, [r7, #12]
 800a7f6:	689a      	ldr	r2, [r3, #8]
 800a7f8:	68bb      	ldr	r3, [r7, #8]
 800a7fa:	689b      	ldr	r3, [r3, #8]
 800a7fc:	429a      	cmp	r2, r3
 800a7fe:	d3d2      	bcc.n	800a7a6 <chMtxLockS+0x52>
=======
 800a87c:	68fb      	ldr	r3, [r7, #12]
 800a87e:	689a      	ldr	r2, [r3, #8]
 800a880:	68bb      	ldr	r3, [r7, #8]
 800a882:	689b      	ldr	r3, [r3, #8]
 800a884:	429a      	cmp	r2, r3
 800a886:	d3d2      	bcc.n	800a82e <chMtxLockS+0x52>
>>>>>>> 752c83b... update binaries
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
<<<<<<< HEAD
 800a800:	687b      	ldr	r3, [r7, #4]
 800a802:	68b8      	ldr	r0, [r7, #8]
 800a804:	4619      	mov	r1, r3
 800a806:	f000 fdc9 	bl	800b39c <queue_prio_insert>
      ctp->u.wtmtxp = mp;
 800a80a:	68bb      	ldr	r3, [r7, #8]
 800a80c:	687a      	ldr	r2, [r7, #4]
 800a80e:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800a810:	2006      	movs	r0, #6
 800a812:	f000 fec1 	bl	800b598 <chSchGoSleepS>
=======
 800a888:	687b      	ldr	r3, [r7, #4]
 800a88a:	68b8      	ldr	r0, [r7, #8]
 800a88c:	4619      	mov	r1, r3
 800a88e:	f000 fdc9 	bl	800b424 <queue_prio_insert>
      ctp->u.wtmtxp = mp;
 800a892:	68bb      	ldr	r3, [r7, #8]
 800a894:	687a      	ldr	r2, [r7, #4]
 800a896:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800a898:	2006      	movs	r0, #6
 800a89a:	f000 fec1 	bl	800b620 <chSchGoSleepS>
>>>>>>> 752c83b... update binaries

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
<<<<<<< HEAD
 800a816:	687b      	ldr	r3, [r7, #4]
 800a818:	689a      	ldr	r2, [r3, #8]
 800a81a:	68bb      	ldr	r3, [r7, #8]
 800a81c:	429a      	cmp	r2, r3
 800a81e:	d002      	beq.n	800a826 <chMtxLockS+0xd2>
 800a820:	4816      	ldr	r0, [pc, #88]	; (800a87c <chMtxLockS+0x128>)
 800a822:	f000 fabf 	bl	800ada4 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 800a826:	68bb      	ldr	r3, [r7, #8]
 800a828:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a82a:	687b      	ldr	r3, [r7, #4]
 800a82c:	429a      	cmp	r2, r3
 800a82e:	d002      	beq.n	800a836 <chMtxLockS+0xe2>
 800a830:	4812      	ldr	r0, [pc, #72]	; (800a87c <chMtxLockS+0x128>)
 800a832:	f000 fab7 	bl	800ada4 <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      chDbgAssert(mp->cnt == (cnt_t)1, "counter is not one");
 800a836:	687b      	ldr	r3, [r7, #4]
 800a838:	691b      	ldr	r3, [r3, #16]
 800a83a:	2b01      	cmp	r3, #1
 800a83c:	d019      	beq.n	800a872 <chMtxLockS+0x11e>
 800a83e:	480f      	ldr	r0, [pc, #60]	; (800a87c <chMtxLockS+0x128>)
 800a840:	f000 fab0 	bl	800ada4 <chSysHalt>
 800a844:	e015      	b.n	800a872 <chMtxLockS+0x11e>
=======
 800a89e:	687b      	ldr	r3, [r7, #4]
 800a8a0:	689a      	ldr	r2, [r3, #8]
 800a8a2:	68bb      	ldr	r3, [r7, #8]
 800a8a4:	429a      	cmp	r2, r3
 800a8a6:	d002      	beq.n	800a8ae <chMtxLockS+0xd2>
 800a8a8:	4816      	ldr	r0, [pc, #88]	; (800a904 <chMtxLockS+0x128>)
 800a8aa:	f000 fabf 	bl	800ae2c <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 800a8ae:	68bb      	ldr	r3, [r7, #8]
 800a8b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a8b2:	687b      	ldr	r3, [r7, #4]
 800a8b4:	429a      	cmp	r2, r3
 800a8b6:	d002      	beq.n	800a8be <chMtxLockS+0xe2>
 800a8b8:	4812      	ldr	r0, [pc, #72]	; (800a904 <chMtxLockS+0x128>)
 800a8ba:	f000 fab7 	bl	800ae2c <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      chDbgAssert(mp->cnt == (cnt_t)1, "counter is not one");
 800a8be:	687b      	ldr	r3, [r7, #4]
 800a8c0:	691b      	ldr	r3, [r3, #16]
 800a8c2:	2b01      	cmp	r3, #1
 800a8c4:	d019      	beq.n	800a8fa <chMtxLockS+0x11e>
 800a8c6:	480f      	ldr	r0, [pc, #60]	; (800a904 <chMtxLockS+0x128>)
 800a8c8:	f000 fab0 	bl	800ae2c <chSysHalt>
 800a8cc:	e015      	b.n	800a8fa <chMtxLockS+0x11e>
>>>>>>> 752c83b... update binaries
    }
#endif
  }
  else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");
<<<<<<< HEAD
 800a846:	687b      	ldr	r3, [r7, #4]
 800a848:	691b      	ldr	r3, [r3, #16]
 800a84a:	2b00      	cmp	r3, #0
 800a84c:	d002      	beq.n	800a854 <chMtxLockS+0x100>
 800a84e:	480b      	ldr	r0, [pc, #44]	; (800a87c <chMtxLockS+0x128>)
 800a850:	f000 faa8 	bl	800ada4 <chSysHalt>

    mp->cnt++;
 800a854:	687b      	ldr	r3, [r7, #4]
 800a856:	691b      	ldr	r3, [r3, #16]
 800a858:	1c5a      	adds	r2, r3, #1
 800a85a:	687b      	ldr	r3, [r7, #4]
 800a85c:	611a      	str	r2, [r3, #16]
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 800a85e:	687b      	ldr	r3, [r7, #4]
 800a860:	68ba      	ldr	r2, [r7, #8]
 800a862:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 800a864:	68bb      	ldr	r3, [r7, #8]
 800a866:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a868:	687b      	ldr	r3, [r7, #4]
 800a86a:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 800a86c:	68bb      	ldr	r3, [r7, #8]
 800a86e:	687a      	ldr	r2, [r7, #4]
 800a870:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
 800a872:	3710      	adds	r7, #16
 800a874:	46bd      	mov	sp, r7
 800a876:	bd80      	pop	{r7, pc}
 800a878:	20001338 	.word	0x20001338
 800a87c:	0800e9c4 	.word	0x0800e9c4

0800a880 <chMtxUnlock>:
=======
 800a8ce:	687b      	ldr	r3, [r7, #4]
 800a8d0:	691b      	ldr	r3, [r3, #16]
 800a8d2:	2b00      	cmp	r3, #0
 800a8d4:	d002      	beq.n	800a8dc <chMtxLockS+0x100>
 800a8d6:	480b      	ldr	r0, [pc, #44]	; (800a904 <chMtxLockS+0x128>)
 800a8d8:	f000 faa8 	bl	800ae2c <chSysHalt>

    mp->cnt++;
 800a8dc:	687b      	ldr	r3, [r7, #4]
 800a8de:	691b      	ldr	r3, [r3, #16]
 800a8e0:	1c5a      	adds	r2, r3, #1
 800a8e2:	687b      	ldr	r3, [r7, #4]
 800a8e4:	611a      	str	r2, [r3, #16]
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 800a8e6:	687b      	ldr	r3, [r7, #4]
 800a8e8:	68ba      	ldr	r2, [r7, #8]
 800a8ea:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 800a8ec:	68bb      	ldr	r3, [r7, #8]
 800a8ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a8f0:	687b      	ldr	r3, [r7, #4]
 800a8f2:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 800a8f4:	68bb      	ldr	r3, [r7, #8]
 800a8f6:	687a      	ldr	r2, [r7, #4]
 800a8f8:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
 800a8fa:	3710      	adds	r7, #16
 800a8fc:	46bd      	mov	sp, r7
 800a8fe:	bd80      	pop	{r7, pc}
 800a900:	20001338 	.word	0x20001338
 800a904:	0800ea9c 	.word	0x0800ea9c

0800a908 <chMtxUnlock>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
<<<<<<< HEAD
 800a880:	b580      	push	{r7, lr}
 800a882:	b086      	sub	sp, #24
 800a884:	af00      	add	r7, sp, #0
 800a886:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800a888:	4b3e      	ldr	r3, [pc, #248]	; (800a984 <chMtxUnlock+0x104>)
 800a88a:	699b      	ldr	r3, [r3, #24]
 800a88c:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800a88e:	687b      	ldr	r3, [r7, #4]
 800a890:	2b00      	cmp	r3, #0
 800a892:	d102      	bne.n	800a89a <chMtxUnlock+0x1a>
 800a894:	483c      	ldr	r0, [pc, #240]	; (800a988 <chMtxUnlock+0x108>)
 800a896:	f000 fa85 	bl	800ada4 <chSysHalt>

  chSysLock();
 800a89a:	f7ff ff0d 	bl	800a6b8 <chSysLock.lto_priv.260>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800a89e:	68fb      	ldr	r3, [r7, #12]
 800a8a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a8a2:	2b00      	cmp	r3, #0
 800a8a4:	d102      	bne.n	800a8ac <chMtxUnlock+0x2c>
 800a8a6:	4838      	ldr	r0, [pc, #224]	; (800a988 <chMtxUnlock+0x108>)
 800a8a8:	f000 fa7c 	bl	800ada4 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800a8ac:	68fb      	ldr	r3, [r7, #12]
 800a8ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a8b0:	689a      	ldr	r2, [r3, #8]
 800a8b2:	68fb      	ldr	r3, [r7, #12]
 800a8b4:	429a      	cmp	r2, r3
 800a8b6:	d002      	beq.n	800a8be <chMtxUnlock+0x3e>
 800a8b8:	4833      	ldr	r0, [pc, #204]	; (800a988 <chMtxUnlock+0x108>)
 800a8ba:	f000 fa73 	bl	800ada4 <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800a8be:	687b      	ldr	r3, [r7, #4]
 800a8c0:	691b      	ldr	r3, [r3, #16]
 800a8c2:	2b00      	cmp	r3, #0
 800a8c4:	dc02      	bgt.n	800a8cc <chMtxUnlock+0x4c>
 800a8c6:	4830      	ldr	r0, [pc, #192]	; (800a988 <chMtxUnlock+0x108>)
 800a8c8:	f000 fa6c 	bl	800ada4 <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 800a8cc:	687b      	ldr	r3, [r7, #4]
 800a8ce:	691b      	ldr	r3, [r3, #16]
 800a8d0:	1e5a      	subs	r2, r3, #1
 800a8d2:	687b      	ldr	r3, [r7, #4]
 800a8d4:	611a      	str	r2, [r3, #16]
 800a8d6:	687b      	ldr	r3, [r7, #4]
 800a8d8:	691b      	ldr	r3, [r3, #16]
 800a8da:	2b00      	cmp	r3, #0
 800a8dc:	d14c      	bne.n	800a978 <chMtxUnlock+0xf8>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 800a8de:	68fb      	ldr	r3, [r7, #12]
 800a8e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a8e2:	687b      	ldr	r3, [r7, #4]
 800a8e4:	429a      	cmp	r2, r3
 800a8e6:	d002      	beq.n	800a8ee <chMtxUnlock+0x6e>
 800a8e8:	4827      	ldr	r0, [pc, #156]	; (800a988 <chMtxUnlock+0x108>)
 800a8ea:	f000 fa5b 	bl	800ada4 <chSysHalt>
=======
 800a908:	b580      	push	{r7, lr}
 800a90a:	b086      	sub	sp, #24
 800a90c:	af00      	add	r7, sp, #0
 800a90e:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800a910:	4b3e      	ldr	r3, [pc, #248]	; (800aa0c <chMtxUnlock+0x104>)
 800a912:	699b      	ldr	r3, [r3, #24]
 800a914:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800a916:	687b      	ldr	r3, [r7, #4]
 800a918:	2b00      	cmp	r3, #0
 800a91a:	d102      	bne.n	800a922 <chMtxUnlock+0x1a>
 800a91c:	483c      	ldr	r0, [pc, #240]	; (800aa10 <chMtxUnlock+0x108>)
 800a91e:	f000 fa85 	bl	800ae2c <chSysHalt>

  chSysLock();
 800a922:	f7ff ff0d 	bl	800a740 <chSysLock.lto_priv.257>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800a926:	68fb      	ldr	r3, [r7, #12]
 800a928:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a92a:	2b00      	cmp	r3, #0
 800a92c:	d102      	bne.n	800a934 <chMtxUnlock+0x2c>
 800a92e:	4838      	ldr	r0, [pc, #224]	; (800aa10 <chMtxUnlock+0x108>)
 800a930:	f000 fa7c 	bl	800ae2c <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800a934:	68fb      	ldr	r3, [r7, #12]
 800a936:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a938:	689a      	ldr	r2, [r3, #8]
 800a93a:	68fb      	ldr	r3, [r7, #12]
 800a93c:	429a      	cmp	r2, r3
 800a93e:	d002      	beq.n	800a946 <chMtxUnlock+0x3e>
 800a940:	4833      	ldr	r0, [pc, #204]	; (800aa10 <chMtxUnlock+0x108>)
 800a942:	f000 fa73 	bl	800ae2c <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800a946:	687b      	ldr	r3, [r7, #4]
 800a948:	691b      	ldr	r3, [r3, #16]
 800a94a:	2b00      	cmp	r3, #0
 800a94c:	dc02      	bgt.n	800a954 <chMtxUnlock+0x4c>
 800a94e:	4830      	ldr	r0, [pc, #192]	; (800aa10 <chMtxUnlock+0x108>)
 800a950:	f000 fa6c 	bl	800ae2c <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 800a954:	687b      	ldr	r3, [r7, #4]
 800a956:	691b      	ldr	r3, [r3, #16]
 800a958:	1e5a      	subs	r2, r3, #1
 800a95a:	687b      	ldr	r3, [r7, #4]
 800a95c:	611a      	str	r2, [r3, #16]
 800a95e:	687b      	ldr	r3, [r7, #4]
 800a960:	691b      	ldr	r3, [r3, #16]
 800a962:	2b00      	cmp	r3, #0
 800a964:	d14c      	bne.n	800aa00 <chMtxUnlock+0xf8>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 800a966:	68fb      	ldr	r3, [r7, #12]
 800a968:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a96a:	687b      	ldr	r3, [r7, #4]
 800a96c:	429a      	cmp	r2, r3
 800a96e:	d002      	beq.n	800a976 <chMtxUnlock+0x6e>
 800a970:	4827      	ldr	r0, [pc, #156]	; (800aa10 <chMtxUnlock+0x108>)
 800a972:	f000 fa5b 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
<<<<<<< HEAD
 800a8ee:	687b      	ldr	r3, [r7, #4]
 800a8f0:	68da      	ldr	r2, [r3, #12]
 800a8f2:	68fb      	ldr	r3, [r7, #12]
 800a8f4:	62da      	str	r2, [r3, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800a8f6:	6878      	ldr	r0, [r7, #4]
 800a8f8:	f7ff ff02 	bl	800a700 <chMtxQueueNotEmptyS>
 800a8fc:	4603      	mov	r3, r0
 800a8fe:	2b00      	cmp	r3, #0
 800a900:	d037      	beq.n	800a972 <chMtxUnlock+0xf2>
=======
 800a976:	687b      	ldr	r3, [r7, #4]
 800a978:	68da      	ldr	r2, [r3, #12]
 800a97a:	68fb      	ldr	r3, [r7, #12]
 800a97c:	62da      	str	r2, [r3, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800a97e:	6878      	ldr	r0, [r7, #4]
 800a980:	f7ff ff02 	bl	800a788 <chMtxQueueNotEmptyS>
 800a984:	4603      	mov	r3, r0
 800a986:	2b00      	cmp	r3, #0
 800a988:	d037      	beq.n	800a9fa <chMtxUnlock+0xf2>
>>>>>>> 752c83b... update binaries
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
<<<<<<< HEAD
 800a902:	68fb      	ldr	r3, [r7, #12]
 800a904:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a906:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 800a908:	68fb      	ldr	r3, [r7, #12]
 800a90a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a90c:	617b      	str	r3, [r7, #20]
 800a90e:	e012      	b.n	800a936 <chMtxUnlock+0xb6>
=======
 800a98a:	68fb      	ldr	r3, [r7, #12]
 800a98c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a98e:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 800a990:	68fb      	ldr	r3, [r7, #12]
 800a992:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a994:	617b      	str	r3, [r7, #20]
 800a996:	e012      	b.n	800a9be <chMtxUnlock+0xb6>
>>>>>>> 752c83b... update binaries
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
<<<<<<< HEAD
 800a910:	6978      	ldr	r0, [r7, #20]
 800a912:	f7ff fef5 	bl	800a700 <chMtxQueueNotEmptyS>
 800a916:	4603      	mov	r3, r0
 800a918:	2b00      	cmp	r3, #0
 800a91a:	d009      	beq.n	800a930 <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
 800a91c:	697b      	ldr	r3, [r7, #20]
 800a91e:	681b      	ldr	r3, [r3, #0]
 800a920:	689a      	ldr	r2, [r3, #8]
=======
 800a998:	6978      	ldr	r0, [r7, #20]
 800a99a:	f7ff fef5 	bl	800a788 <chMtxQueueNotEmptyS>
 800a99e:	4603      	mov	r3, r0
 800a9a0:	2b00      	cmp	r3, #0
 800a9a2:	d009      	beq.n	800a9b8 <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
 800a9a4:	697b      	ldr	r3, [r7, #20]
 800a9a6:	681b      	ldr	r3, [r3, #0]
 800a9a8:	689a      	ldr	r2, [r3, #8]
>>>>>>> 752c83b... update binaries
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
<<<<<<< HEAD
 800a922:	693b      	ldr	r3, [r7, #16]
 800a924:	429a      	cmp	r2, r3
 800a926:	d903      	bls.n	800a930 <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800a928:	697b      	ldr	r3, [r7, #20]
 800a92a:	681b      	ldr	r3, [r3, #0]
 800a92c:	689b      	ldr	r3, [r3, #8]
 800a92e:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 800a930:	697b      	ldr	r3, [r7, #20]
 800a932:	68db      	ldr	r3, [r3, #12]
 800a934:	617b      	str	r3, [r7, #20]
=======
 800a9aa:	693b      	ldr	r3, [r7, #16]
 800a9ac:	429a      	cmp	r2, r3
 800a9ae:	d903      	bls.n	800a9b8 <chMtxUnlock+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800a9b0:	697b      	ldr	r3, [r7, #20]
 800a9b2:	681b      	ldr	r3, [r3, #0]
 800a9b4:	689b      	ldr	r3, [r3, #8]
 800a9b6:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 800a9b8:	697b      	ldr	r3, [r7, #20]
 800a9ba:	68db      	ldr	r3, [r3, #12]
 800a9bc:	617b      	str	r3, [r7, #20]
>>>>>>> 752c83b... update binaries

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
<<<<<<< HEAD
 800a936:	697b      	ldr	r3, [r7, #20]
 800a938:	2b00      	cmp	r3, #0
 800a93a:	d1e9      	bne.n	800a910 <chMtxUnlock+0x90>
=======
 800a9be:	697b      	ldr	r3, [r7, #20]
 800a9c0:	2b00      	cmp	r3, #0
 800a9c2:	d1e9      	bne.n	800a998 <chMtxUnlock+0x90>
>>>>>>> 752c83b... update binaries
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
<<<<<<< HEAD
 800a93c:	68fb      	ldr	r3, [r7, #12]
 800a93e:	693a      	ldr	r2, [r7, #16]
 800a940:	609a      	str	r2, [r3, #8]
=======
 800a9c4:	68fb      	ldr	r3, [r7, #12]
 800a9c6:	693a      	ldr	r2, [r7, #16]
 800a9c8:	609a      	str	r2, [r3, #8]
>>>>>>> 752c83b... update binaries

      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
<<<<<<< HEAD
 800a942:	687b      	ldr	r3, [r7, #4]
 800a944:	2201      	movs	r2, #1
 800a946:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 800a948:	687b      	ldr	r3, [r7, #4]
 800a94a:	4618      	mov	r0, r3
 800a94c:	f000 fd66 	bl	800b41c <queue_fifo_remove>
 800a950:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 800a952:	687b      	ldr	r3, [r7, #4]
 800a954:	68ba      	ldr	r2, [r7, #8]
 800a956:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800a958:	68bb      	ldr	r3, [r7, #8]
 800a95a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a95c:	687b      	ldr	r3, [r7, #4]
 800a95e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800a960:	68bb      	ldr	r3, [r7, #8]
 800a962:	687a      	ldr	r2, [r7, #4]
 800a964:	62da      	str	r2, [r3, #44]	; 0x2c
=======
 800a9ca:	687b      	ldr	r3, [r7, #4]
 800a9cc:	2201      	movs	r2, #1
 800a9ce:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 800a9d0:	687b      	ldr	r3, [r7, #4]
 800a9d2:	4618      	mov	r0, r3
 800a9d4:	f000 fd66 	bl	800b4a4 <queue_fifo_remove>
 800a9d8:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 800a9da:	687b      	ldr	r3, [r7, #4]
 800a9dc:	68ba      	ldr	r2, [r7, #8]
 800a9de:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800a9e0:	68bb      	ldr	r3, [r7, #8]
 800a9e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a9e4:	687b      	ldr	r3, [r7, #4]
 800a9e6:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800a9e8:	68bb      	ldr	r3, [r7, #8]
 800a9ea:	687a      	ldr	r2, [r7, #4]
 800a9ec:	62da      	str	r2, [r3, #44]	; 0x2c
>>>>>>> 752c83b... update binaries

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
<<<<<<< HEAD
 800a966:	68b8      	ldr	r0, [r7, #8]
 800a968:	f000 fd96 	bl	800b498 <chSchReadyI>
      chSchRescheduleS();
 800a96c:	f000 fefa 	bl	800b764 <chSchRescheduleS>
 800a970:	e002      	b.n	800a978 <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 800a972:	687b      	ldr	r3, [r7, #4]
 800a974:	2200      	movs	r2, #0
 800a976:	609a      	str	r2, [r3, #8]
=======
 800a9ee:	68b8      	ldr	r0, [r7, #8]
 800a9f0:	f000 fd96 	bl	800b520 <chSchReadyI>
      chSchRescheduleS();
 800a9f4:	f000 fefa 	bl	800b7ec <chSchRescheduleS>
 800a9f8:	e002      	b.n	800aa00 <chMtxUnlock+0xf8>
    }
    else {
      mp->owner = NULL;
 800a9fa:	687b      	ldr	r3, [r7, #4]
 800a9fc:	2200      	movs	r2, #0
 800a9fe:	609a      	str	r2, [r3, #8]
>>>>>>> 752c83b... update binaries
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
<<<<<<< HEAD
 800a978:	f7ff fea6 	bl	800a6c8 <chSysUnlock.lto_priv.255>
}
 800a97c:	3718      	adds	r7, #24
 800a97e:	46bd      	mov	sp, r7
 800a980:	bd80      	pop	{r7, pc}
 800a982:	bf00      	nop
 800a984:	20001338 	.word	0x20001338
 800a988:	0800e9d0 	.word	0x0800e9d0

0800a98c <chMtxUnlockS>:
=======
 800aa00:	f7ff fea6 	bl	800a750 <chSysUnlock.lto_priv.252>
}
 800aa04:	3718      	adds	r7, #24
 800aa06:	46bd      	mov	sp, r7
 800aa08:	bd80      	pop	{r7, pc}
 800aa0a:	bf00      	nop
 800aa0c:	20001338 	.word	0x20001338
 800aa10:	0800eaa8 	.word	0x0800eaa8

0800aa14 <chMtxUnlockS>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
<<<<<<< HEAD
 800a98c:	b580      	push	{r7, lr}
 800a98e:	b086      	sub	sp, #24
 800a990:	af00      	add	r7, sp, #0
 800a992:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800a994:	4b3c      	ldr	r3, [pc, #240]	; (800aa88 <chMtxUnlockS+0xfc>)
 800a996:	699b      	ldr	r3, [r3, #24]
 800a998:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheckClassS();
 800a99a:	f000 faf3 	bl	800af84 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800a99e:	687b      	ldr	r3, [r7, #4]
 800a9a0:	2b00      	cmp	r3, #0
 800a9a2:	d102      	bne.n	800a9aa <chMtxUnlockS+0x1e>
 800a9a4:	4839      	ldr	r0, [pc, #228]	; (800aa8c <chMtxUnlockS+0x100>)
 800a9a6:	f000 f9fd 	bl	800ada4 <chSysHalt>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800a9aa:	68fb      	ldr	r3, [r7, #12]
 800a9ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a9ae:	2b00      	cmp	r3, #0
 800a9b0:	d102      	bne.n	800a9b8 <chMtxUnlockS+0x2c>
 800a9b2:	4836      	ldr	r0, [pc, #216]	; (800aa8c <chMtxUnlockS+0x100>)
 800a9b4:	f000 f9f6 	bl	800ada4 <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800a9b8:	68fb      	ldr	r3, [r7, #12]
 800a9ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a9bc:	689a      	ldr	r2, [r3, #8]
 800a9be:	68fb      	ldr	r3, [r7, #12]
 800a9c0:	429a      	cmp	r2, r3
 800a9c2:	d002      	beq.n	800a9ca <chMtxUnlockS+0x3e>
 800a9c4:	4831      	ldr	r0, [pc, #196]	; (800aa8c <chMtxUnlockS+0x100>)
 800a9c6:	f000 f9ed 	bl	800ada4 <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800a9ca:	687b      	ldr	r3, [r7, #4]
 800a9cc:	691b      	ldr	r3, [r3, #16]
 800a9ce:	2b00      	cmp	r3, #0
 800a9d0:	dc02      	bgt.n	800a9d8 <chMtxUnlockS+0x4c>
 800a9d2:	482e      	ldr	r0, [pc, #184]	; (800aa8c <chMtxUnlockS+0x100>)
 800a9d4:	f000 f9e6 	bl	800ada4 <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 800a9d8:	687b      	ldr	r3, [r7, #4]
 800a9da:	691b      	ldr	r3, [r3, #16]
 800a9dc:	1e5a      	subs	r2, r3, #1
 800a9de:	687b      	ldr	r3, [r7, #4]
 800a9e0:	611a      	str	r2, [r3, #16]
 800a9e2:	687b      	ldr	r3, [r7, #4]
 800a9e4:	691b      	ldr	r3, [r3, #16]
 800a9e6:	2b00      	cmp	r3, #0
 800a9e8:	d14a      	bne.n	800aa80 <chMtxUnlockS+0xf4>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 800a9ea:	68fb      	ldr	r3, [r7, #12]
 800a9ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a9ee:	687b      	ldr	r3, [r7, #4]
 800a9f0:	429a      	cmp	r2, r3
 800a9f2:	d002      	beq.n	800a9fa <chMtxUnlockS+0x6e>
 800a9f4:	4825      	ldr	r0, [pc, #148]	; (800aa8c <chMtxUnlockS+0x100>)
 800a9f6:	f000 f9d5 	bl	800ada4 <chSysHalt>
=======
 800aa14:	b580      	push	{r7, lr}
 800aa16:	b086      	sub	sp, #24
 800aa18:	af00      	add	r7, sp, #0
 800aa1a:	6078      	str	r0, [r7, #4]
  thread_t *ctp = currp;
 800aa1c:	4b3c      	ldr	r3, [pc, #240]	; (800ab10 <chMtxUnlockS+0xfc>)
 800aa1e:	699b      	ldr	r3, [r3, #24]
 800aa20:	60fb      	str	r3, [r7, #12]
  mutex_t *lmp;

  chDbgCheckClassS();
 800aa22:	f000 faf3 	bl	800b00c <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800aa26:	687b      	ldr	r3, [r7, #4]
 800aa28:	2b00      	cmp	r3, #0
 800aa2a:	d102      	bne.n	800aa32 <chMtxUnlockS+0x1e>
 800aa2c:	4839      	ldr	r0, [pc, #228]	; (800ab14 <chMtxUnlockS+0x100>)
 800aa2e:	f000 f9fd 	bl	800ae2c <chSysHalt>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800aa32:	68fb      	ldr	r3, [r7, #12]
 800aa34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aa36:	2b00      	cmp	r3, #0
 800aa38:	d102      	bne.n	800aa40 <chMtxUnlockS+0x2c>
 800aa3a:	4836      	ldr	r0, [pc, #216]	; (800ab14 <chMtxUnlockS+0x100>)
 800aa3c:	f000 f9f6 	bl	800ae2c <chSysHalt>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800aa40:	68fb      	ldr	r3, [r7, #12]
 800aa42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aa44:	689a      	ldr	r2, [r3, #8]
 800aa46:	68fb      	ldr	r3, [r7, #12]
 800aa48:	429a      	cmp	r2, r3
 800aa4a:	d002      	beq.n	800aa52 <chMtxUnlockS+0x3e>
 800aa4c:	4831      	ldr	r0, [pc, #196]	; (800ab14 <chMtxUnlockS+0x100>)
 800aa4e:	f000 f9ed 	bl	800ae2c <chSysHalt>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 800aa52:	687b      	ldr	r3, [r7, #4]
 800aa54:	691b      	ldr	r3, [r3, #16]
 800aa56:	2b00      	cmp	r3, #0
 800aa58:	dc02      	bgt.n	800aa60 <chMtxUnlockS+0x4c>
 800aa5a:	482e      	ldr	r0, [pc, #184]	; (800ab14 <chMtxUnlockS+0x100>)
 800aa5c:	f000 f9e6 	bl	800ae2c <chSysHalt>

  if (--mp->cnt == (cnt_t)0) {
 800aa60:	687b      	ldr	r3, [r7, #4]
 800aa62:	691b      	ldr	r3, [r3, #16]
 800aa64:	1e5a      	subs	r2, r3, #1
 800aa66:	687b      	ldr	r3, [r7, #4]
 800aa68:	611a      	str	r2, [r3, #16]
 800aa6a:	687b      	ldr	r3, [r7, #4]
 800aa6c:	691b      	ldr	r3, [r3, #16]
 800aa6e:	2b00      	cmp	r3, #0
 800aa70:	d14a      	bne.n	800ab08 <chMtxUnlockS+0xf4>
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 800aa72:	68fb      	ldr	r3, [r7, #12]
 800aa74:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800aa76:	687b      	ldr	r3, [r7, #4]
 800aa78:	429a      	cmp	r2, r3
 800aa7a:	d002      	beq.n	800aa82 <chMtxUnlockS+0x6e>
 800aa7c:	4825      	ldr	r0, [pc, #148]	; (800ab14 <chMtxUnlockS+0x100>)
 800aa7e:	f000 f9d5 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
<<<<<<< HEAD
 800a9fa:	687b      	ldr	r3, [r7, #4]
 800a9fc:	68da      	ldr	r2, [r3, #12]
 800a9fe:	68fb      	ldr	r3, [r7, #12]
 800aa00:	62da      	str	r2, [r3, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800aa02:	6878      	ldr	r0, [r7, #4]
 800aa04:	f7ff fe7c 	bl	800a700 <chMtxQueueNotEmptyS>
 800aa08:	4603      	mov	r3, r0
 800aa0a:	2b00      	cmp	r3, #0
 800aa0c:	d035      	beq.n	800aa7a <chMtxUnlockS+0xee>
=======
 800aa82:	687b      	ldr	r3, [r7, #4]
 800aa84:	68da      	ldr	r2, [r3, #12]
 800aa86:	68fb      	ldr	r3, [r7, #12]
 800aa88:	62da      	str	r2, [r3, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800aa8a:	6878      	ldr	r0, [r7, #4]
 800aa8c:	f7ff fe7c 	bl	800a788 <chMtxQueueNotEmptyS>
 800aa90:	4603      	mov	r3, r0
 800aa92:	2b00      	cmp	r3, #0
 800aa94:	d035      	beq.n	800ab02 <chMtxUnlockS+0xee>
>>>>>>> 752c83b... update binaries
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
<<<<<<< HEAD
 800aa0e:	68fb      	ldr	r3, [r7, #12]
 800aa10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aa12:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 800aa14:	68fb      	ldr	r3, [r7, #12]
 800aa16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aa18:	617b      	str	r3, [r7, #20]
 800aa1a:	e012      	b.n	800aa42 <chMtxUnlockS+0xb6>
=======
 800aa96:	68fb      	ldr	r3, [r7, #12]
 800aa98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aa9a:	613b      	str	r3, [r7, #16]
      lmp = ctp->mtxlist;
 800aa9c:	68fb      	ldr	r3, [r7, #12]
 800aa9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aaa0:	617b      	str	r3, [r7, #20]
 800aaa2:	e012      	b.n	800aaca <chMtxUnlockS+0xb6>
>>>>>>> 752c83b... update binaries
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
<<<<<<< HEAD
 800aa1c:	6978      	ldr	r0, [r7, #20]
 800aa1e:	f7ff fe6f 	bl	800a700 <chMtxQueueNotEmptyS>
 800aa22:	4603      	mov	r3, r0
 800aa24:	2b00      	cmp	r3, #0
 800aa26:	d009      	beq.n	800aa3c <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
 800aa28:	697b      	ldr	r3, [r7, #20]
 800aa2a:	681b      	ldr	r3, [r3, #0]
 800aa2c:	689a      	ldr	r2, [r3, #8]
=======
 800aaa4:	6978      	ldr	r0, [r7, #20]
 800aaa6:	f7ff fe6f 	bl	800a788 <chMtxQueueNotEmptyS>
 800aaaa:	4603      	mov	r3, r0
 800aaac:	2b00      	cmp	r3, #0
 800aaae:	d009      	beq.n	800aac4 <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
 800aab0:	697b      	ldr	r3, [r7, #20]
 800aab2:	681b      	ldr	r3, [r3, #0]
 800aab4:	689a      	ldr	r2, [r3, #8]
>>>>>>> 752c83b... update binaries
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
<<<<<<< HEAD
 800aa2e:	693b      	ldr	r3, [r7, #16]
 800aa30:	429a      	cmp	r2, r3
 800aa32:	d903      	bls.n	800aa3c <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800aa34:	697b      	ldr	r3, [r7, #20]
 800aa36:	681b      	ldr	r3, [r3, #0]
 800aa38:	689b      	ldr	r3, [r3, #8]
 800aa3a:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 800aa3c:	697b      	ldr	r3, [r7, #20]
 800aa3e:	68db      	ldr	r3, [r3, #12]
 800aa40:	617b      	str	r3, [r7, #20]
=======
 800aab6:	693b      	ldr	r3, [r7, #16]
 800aab8:	429a      	cmp	r2, r3
 800aaba:	d903      	bls.n	800aac4 <chMtxUnlockS+0xb0>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800aabc:	697b      	ldr	r3, [r7, #20]
 800aabe:	681b      	ldr	r3, [r3, #0]
 800aac0:	689b      	ldr	r3, [r3, #8]
 800aac2:	613b      	str	r3, [r7, #16]
        }
        lmp = lmp->next;
 800aac4:	697b      	ldr	r3, [r7, #20]
 800aac6:	68db      	ldr	r3, [r3, #12]
 800aac8:	617b      	str	r3, [r7, #20]
>>>>>>> 752c83b... update binaries

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
<<<<<<< HEAD
 800aa42:	697b      	ldr	r3, [r7, #20]
 800aa44:	2b00      	cmp	r3, #0
 800aa46:	d1e9      	bne.n	800aa1c <chMtxUnlockS+0x90>
=======
 800aaca:	697b      	ldr	r3, [r7, #20]
 800aacc:	2b00      	cmp	r3, #0
 800aace:	d1e9      	bne.n	800aaa4 <chMtxUnlockS+0x90>
>>>>>>> 752c83b... update binaries
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
<<<<<<< HEAD
 800aa48:	68fb      	ldr	r3, [r7, #12]
 800aa4a:	693a      	ldr	r2, [r7, #16]
 800aa4c:	609a      	str	r2, [r3, #8]
=======
 800aad0:	68fb      	ldr	r3, [r7, #12]
 800aad2:	693a      	ldr	r2, [r7, #16]
 800aad4:	609a      	str	r2, [r3, #8]
>>>>>>> 752c83b... update binaries

      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
<<<<<<< HEAD
 800aa4e:	687b      	ldr	r3, [r7, #4]
 800aa50:	2201      	movs	r2, #1
 800aa52:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 800aa54:	687b      	ldr	r3, [r7, #4]
 800aa56:	4618      	mov	r0, r3
 800aa58:	f000 fce0 	bl	800b41c <queue_fifo_remove>
 800aa5c:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 800aa5e:	687b      	ldr	r3, [r7, #4]
 800aa60:	68ba      	ldr	r2, [r7, #8]
 800aa62:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800aa64:	68bb      	ldr	r3, [r7, #8]
 800aa66:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800aa68:	687b      	ldr	r3, [r7, #4]
 800aa6a:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800aa6c:	68bb      	ldr	r3, [r7, #8]
 800aa6e:	687a      	ldr	r2, [r7, #4]
 800aa70:	62da      	str	r2, [r3, #44]	; 0x2c
      (void) chSchReadyI(tp);
 800aa72:	68b8      	ldr	r0, [r7, #8]
 800aa74:	f000 fd10 	bl	800b498 <chSchReadyI>
 800aa78:	e002      	b.n	800aa80 <chMtxUnlockS+0xf4>
    }
    else {
      mp->owner = NULL;
 800aa7a:	687b      	ldr	r3, [r7, #4]
 800aa7c:	2200      	movs	r2, #0
 800aa7e:	609a      	str	r2, [r3, #8]
=======
 800aad6:	687b      	ldr	r3, [r7, #4]
 800aad8:	2201      	movs	r2, #1
 800aada:	611a      	str	r2, [r3, #16]
#endif
      tp = queue_fifo_remove(&mp->queue);
 800aadc:	687b      	ldr	r3, [r7, #4]
 800aade:	4618      	mov	r0, r3
 800aae0:	f000 fce0 	bl	800b4a4 <queue_fifo_remove>
 800aae4:	60b8      	str	r0, [r7, #8]
      mp->owner = tp;
 800aae6:	687b      	ldr	r3, [r7, #4]
 800aae8:	68ba      	ldr	r2, [r7, #8]
 800aaea:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 800aaec:	68bb      	ldr	r3, [r7, #8]
 800aaee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800aaf0:	687b      	ldr	r3, [r7, #4]
 800aaf2:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800aaf4:	68bb      	ldr	r3, [r7, #8]
 800aaf6:	687a      	ldr	r2, [r7, #4]
 800aaf8:	62da      	str	r2, [r3, #44]	; 0x2c
      (void) chSchReadyI(tp);
 800aafa:	68b8      	ldr	r0, [r7, #8]
 800aafc:	f000 fd10 	bl	800b520 <chSchReadyI>
 800ab00:	e002      	b.n	800ab08 <chMtxUnlockS+0xf4>
    }
    else {
      mp->owner = NULL;
 800ab02:	687b      	ldr	r3, [r7, #4]
 800ab04:	2200      	movs	r2, #0
 800ab06:	609a      	str	r2, [r3, #8]
>>>>>>> 752c83b... update binaries
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
<<<<<<< HEAD
 800aa80:	3718      	adds	r7, #24
 800aa82:	46bd      	mov	sp, r7
 800aa84:	bd80      	pop	{r7, pc}
 800aa86:	bf00      	nop
 800aa88:	20001338 	.word	0x20001338
 800aa8c:	0800e9dc 	.word	0x0800e9dc

0800aa90 <port_lock.lto_priv.272>:
=======
 800ab08:	3718      	adds	r7, #24
 800ab0a:	46bd      	mov	sp, r7
 800ab0c:	bd80      	pop	{r7, pc}
 800ab0e:	bf00      	nop
 800ab10:	20001338 	.word	0x20001338
 800ab14:	0800eab4 	.word	0x0800eab4

0800ab18 <port_lock.lto_priv.269>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800aa90:	b480      	push	{r7}
 800aa92:	b083      	sub	sp, #12
 800aa94:	af00      	add	r7, sp, #0
 800aa96:	2320      	movs	r3, #32
 800aa98:	607b      	str	r3, [r7, #4]
 800aa9a:	687b      	ldr	r3, [r7, #4]
 800aa9c:	f383 8811 	msr	BASEPRI, r3
=======
 800ab18:	b480      	push	{r7}
 800ab1a:	b083      	sub	sp, #12
 800ab1c:	af00      	add	r7, sp, #0
 800ab1e:	2320      	movs	r3, #32
 800ab20:	607b      	str	r3, [r7, #4]
 800ab22:	687b      	ldr	r3, [r7, #4]
 800ab24:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800aaa0:	370c      	adds	r7, #12
 800aaa2:	46bd      	mov	sp, r7
 800aaa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aaa8:	4770      	bx	lr
 800aaaa:	bf00      	nop

0800aaac <port_unlock.lto_priv.268>:
=======
 800ab28:	370c      	adds	r7, #12
 800ab2a:	46bd      	mov	sp, r7
 800ab2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab30:	4770      	bx	lr
 800ab32:	bf00      	nop

0800ab34 <port_unlock.lto_priv.265>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800aaac:	b480      	push	{r7}
 800aaae:	b083      	sub	sp, #12
 800aab0:	af00      	add	r7, sp, #0
 800aab2:	2300      	movs	r3, #0
 800aab4:	607b      	str	r3, [r7, #4]
 800aab6:	687b      	ldr	r3, [r7, #4]
 800aab8:	f383 8811 	msr	BASEPRI, r3
=======
 800ab34:	b480      	push	{r7}
 800ab36:	b083      	sub	sp, #12
 800ab38:	af00      	add	r7, sp, #0
 800ab3a:	2300      	movs	r3, #0
 800ab3c:	607b      	str	r3, [r7, #4]
 800ab3e:	687b      	ldr	r3, [r7, #4]
 800ab40:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800aabc:	370c      	adds	r7, #12
 800aabe:	46bd      	mov	sp, r7
 800aac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aac4:	4770      	bx	lr
 800aac6:	bf00      	nop

0800aac8 <queue_init.lto_priv.264>:
=======
 800ab44:	370c      	adds	r7, #12
 800ab46:	46bd      	mov	sp, r7
 800ab48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab4c:	4770      	bx	lr
 800ab4e:	bf00      	nop

0800ab50 <queue_init.lto_priv.261>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
<<<<<<< HEAD
 800aac8:	b480      	push	{r7}
 800aaca:	b083      	sub	sp, #12
 800aacc:	af00      	add	r7, sp, #0
 800aace:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800aad0:	687b      	ldr	r3, [r7, #4]
 800aad2:	687a      	ldr	r2, [r7, #4]
 800aad4:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800aad6:	687b      	ldr	r3, [r7, #4]
 800aad8:	687a      	ldr	r2, [r7, #4]
 800aada:	605a      	str	r2, [r3, #4]
}
 800aadc:	370c      	adds	r7, #12
 800aade:	46bd      	mov	sp, r7
 800aae0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aae4:	4770      	bx	lr
 800aae6:	bf00      	nop

0800aae8 <chSysLock.lto_priv.262>:
=======
 800ab50:	b480      	push	{r7}
 800ab52:	b083      	sub	sp, #12
 800ab54:	af00      	add	r7, sp, #0
 800ab56:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800ab58:	687b      	ldr	r3, [r7, #4]
 800ab5a:	687a      	ldr	r2, [r7, #4]
 800ab5c:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800ab5e:	687b      	ldr	r3, [r7, #4]
 800ab60:	687a      	ldr	r2, [r7, #4]
 800ab62:	605a      	str	r2, [r3, #4]
}
 800ab64:	370c      	adds	r7, #12
 800ab66:	46bd      	mov	sp, r7
 800ab68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab6c:	4770      	bx	lr
 800ab6e:	bf00      	nop

0800ab70 <chSysLock.lto_priv.259>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 800aae8:	b580      	push	{r7, lr}
 800aaea:	af00      	add	r7, sp, #0

  port_lock();
 800aaec:	f7ff ffd0 	bl	800aa90 <port_lock.lto_priv.272>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800aaf0:	f000 f9a6 	bl	800ae40 <_dbg_check_lock>
}
 800aaf4:	bd80      	pop	{r7, pc}
 800aaf6:	bf00      	nop

0800aaf8 <chSysUnlock.lto_priv.257>:
=======
 800ab70:	b580      	push	{r7, lr}
 800ab72:	af00      	add	r7, sp, #0

  port_lock();
 800ab74:	f7ff ffd0 	bl	800ab18 <port_lock.lto_priv.269>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ab78:	f000 f9a6 	bl	800aec8 <_dbg_check_lock>
}
 800ab7c:	bd80      	pop	{r7, pc}
 800ab7e:	bf00      	nop

0800ab80 <chSysUnlock.lto_priv.254>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 800aaf8:	b580      	push	{r7, lr}
 800aafa:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800aafc:	f000 f9b6 	bl	800ae6c <_dbg_check_unlock>
=======
 800ab80:	b580      	push	{r7, lr}
 800ab82:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800ab84:	f000 f9b6 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 800ab00:	4b09      	ldr	r3, [pc, #36]	; (800ab28 <chSysUnlock.lto_priv.257+0x30>)
 800ab02:	681b      	ldr	r3, [r3, #0]
 800ab04:	4a08      	ldr	r2, [pc, #32]	; (800ab28 <chSysUnlock.lto_priv.257+0x30>)
 800ab06:	4293      	cmp	r3, r2
 800ab08:	d00a      	beq.n	800ab20 <chSysUnlock.lto_priv.257+0x28>
 800ab0a:	4b07      	ldr	r3, [pc, #28]	; (800ab28 <chSysUnlock.lto_priv.257+0x30>)
 800ab0c:	699b      	ldr	r3, [r3, #24]
 800ab0e:	689a      	ldr	r2, [r3, #8]
 800ab10:	4b05      	ldr	r3, [pc, #20]	; (800ab28 <chSysUnlock.lto_priv.257+0x30>)
 800ab12:	681b      	ldr	r3, [r3, #0]
 800ab14:	689b      	ldr	r3, [r3, #8]
 800ab16:	429a      	cmp	r2, r3
 800ab18:	d202      	bcs.n	800ab20 <chSysUnlock.lto_priv.257+0x28>
 800ab1a:	4804      	ldr	r0, [pc, #16]	; (800ab2c <chSysUnlock.lto_priv.257+0x34>)
 800ab1c:	f000 f942 	bl	800ada4 <chSysHalt>
=======
 800ab88:	4b09      	ldr	r3, [pc, #36]	; (800abb0 <chSysUnlock.lto_priv.254+0x30>)
 800ab8a:	681b      	ldr	r3, [r3, #0]
 800ab8c:	4a08      	ldr	r2, [pc, #32]	; (800abb0 <chSysUnlock.lto_priv.254+0x30>)
 800ab8e:	4293      	cmp	r3, r2
 800ab90:	d00a      	beq.n	800aba8 <chSysUnlock.lto_priv.254+0x28>
 800ab92:	4b07      	ldr	r3, [pc, #28]	; (800abb0 <chSysUnlock.lto_priv.254+0x30>)
 800ab94:	699b      	ldr	r3, [r3, #24]
 800ab96:	689a      	ldr	r2, [r3, #8]
 800ab98:	4b05      	ldr	r3, [pc, #20]	; (800abb0 <chSysUnlock.lto_priv.254+0x30>)
 800ab9a:	681b      	ldr	r3, [r3, #0]
 800ab9c:	689b      	ldr	r3, [r3, #8]
 800ab9e:	429a      	cmp	r2, r3
 800aba0:	d202      	bcs.n	800aba8 <chSysUnlock.lto_priv.254+0x28>
 800aba2:	4804      	ldr	r0, [pc, #16]	; (800abb4 <chSysUnlock.lto_priv.254+0x34>)
 800aba4:	f000 f942 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 800ab20:	f7ff ffc4 	bl	800aaac <port_unlock.lto_priv.268>
}
 800ab24:	bd80      	pop	{r7, pc}
 800ab26:	bf00      	nop
 800ab28:	20001338 	.word	0x20001338
 800ab2c:	0800e9fc 	.word	0x0800e9fc

0800ab30 <chThdQueueObjectInit>:
=======
 800aba8:	f7ff ffc4 	bl	800ab34 <port_unlock.lto_priv.265>
}
 800abac:	bd80      	pop	{r7, pc}
 800abae:	bf00      	nop
 800abb0:	20001338 	.word	0x20001338
 800abb4:	0800ead4 	.word	0x0800ead4

0800abb8 <chThdQueueObjectInit>:
>>>>>>> 752c83b... update binaries
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
<<<<<<< HEAD
 800ab30:	b580      	push	{r7, lr}
 800ab32:	b082      	sub	sp, #8
 800ab34:	af00      	add	r7, sp, #0
 800ab36:	6078      	str	r0, [r7, #4]

  queue_init(tqp);
 800ab38:	6878      	ldr	r0, [r7, #4]
 800ab3a:	f7ff ffc5 	bl	800aac8 <queue_init.lto_priv.264>
}
 800ab3e:	3708      	adds	r7, #8
 800ab40:	46bd      	mov	sp, r7
 800ab42:	bd80      	pop	{r7, pc}

0800ab44 <chMBGetSizeI>:
=======
 800abb8:	b580      	push	{r7, lr}
 800abba:	b082      	sub	sp, #8
 800abbc:	af00      	add	r7, sp, #0
 800abbe:	6078      	str	r0, [r7, #4]

  queue_init(tqp);
 800abc0:	6878      	ldr	r0, [r7, #4]
 800abc2:	f7ff ffc5 	bl	800ab50 <queue_init.lto_priv.261>
}
 800abc6:	3708      	adds	r7, #8
 800abc8:	46bd      	mov	sp, r7
 800abca:	bd80      	pop	{r7, pc}

0800abcc <chMBGetSizeI>:
>>>>>>> 752c83b... update binaries
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {
<<<<<<< HEAD
 800ab44:	b480      	push	{r7}
 800ab46:	b083      	sub	sp, #12
 800ab48:	af00      	add	r7, sp, #0
 800ab4a:	6078      	str	r0, [r7, #4]
=======
 800abcc:	b480      	push	{r7}
 800abce:	b083      	sub	sp, #12
 800abd0:	af00      	add	r7, sp, #0
 800abd2:	6078      	str	r0, [r7, #4]
>>>>>>> 752c83b... update binaries

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
<<<<<<< HEAD
 800ab4c:	687b      	ldr	r3, [r7, #4]
 800ab4e:	685b      	ldr	r3, [r3, #4]
 800ab50:	461a      	mov	r2, r3
 800ab52:	687b      	ldr	r3, [r7, #4]
 800ab54:	681b      	ldr	r3, [r3, #0]
 800ab56:	1ad3      	subs	r3, r2, r3
 800ab58:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 800ab5a:	4618      	mov	r0, r3
 800ab5c:	370c      	adds	r7, #12
 800ab5e:	46bd      	mov	sp, r7
 800ab60:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab64:	4770      	bx	lr
 800ab66:	bf00      	nop

0800ab68 <chMBGetUsedCountI>:
=======
 800abd4:	687b      	ldr	r3, [r7, #4]
 800abd6:	685b      	ldr	r3, [r3, #4]
 800abd8:	461a      	mov	r2, r3
 800abda:	687b      	ldr	r3, [r7, #4]
 800abdc:	681b      	ldr	r3, [r3, #0]
 800abde:	1ad3      	subs	r3, r2, r3
 800abe0:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 800abe2:	4618      	mov	r0, r3
 800abe4:	370c      	adds	r7, #12
 800abe6:	46bd      	mov	sp, r7
 800abe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800abec:	4770      	bx	lr
 800abee:	bf00      	nop

0800abf0 <chMBGetUsedCountI>:
>>>>>>> 752c83b... update binaries
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
<<<<<<< HEAD
 800ab68:	b580      	push	{r7, lr}
 800ab6a:	b082      	sub	sp, #8
 800ab6c:	af00      	add	r7, sp, #0
 800ab6e:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800ab70:	f000 f9f6 	bl	800af60 <chDbgCheckClassI>

  return mbp->cnt;
 800ab74:	687b      	ldr	r3, [r7, #4]
 800ab76:	691b      	ldr	r3, [r3, #16]
}
 800ab78:	4618      	mov	r0, r3
 800ab7a:	3708      	adds	r7, #8
 800ab7c:	46bd      	mov	sp, r7
 800ab7e:	bd80      	pop	{r7, pc}

0800ab80 <chMBGetFreeCountI>:
=======
 800abf0:	b580      	push	{r7, lr}
 800abf2:	b082      	sub	sp, #8
 800abf4:	af00      	add	r7, sp, #0
 800abf6:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800abf8:	f000 f9f6 	bl	800afe8 <chDbgCheckClassI>

  return mbp->cnt;
 800abfc:	687b      	ldr	r3, [r7, #4]
 800abfe:	691b      	ldr	r3, [r3, #16]
}
 800ac00:	4618      	mov	r0, r3
 800ac02:	3708      	adds	r7, #8
 800ac04:	46bd      	mov	sp, r7
 800ac06:	bd80      	pop	{r7, pc}

0800ac08 <chMBGetFreeCountI>:
>>>>>>> 752c83b... update binaries
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
<<<<<<< HEAD
 800ab80:	b590      	push	{r4, r7, lr}
 800ab82:	b083      	sub	sp, #12
 800ab84:	af00      	add	r7, sp, #0
 800ab86:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800ab88:	f000 f9ea 	bl	800af60 <chDbgCheckClassI>

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800ab8c:	6878      	ldr	r0, [r7, #4]
 800ab8e:	f7ff ffd9 	bl	800ab44 <chMBGetSizeI>
 800ab92:	4604      	mov	r4, r0
 800ab94:	6878      	ldr	r0, [r7, #4]
 800ab96:	f7ff ffe7 	bl	800ab68 <chMBGetUsedCountI>
 800ab9a:	4603      	mov	r3, r0
 800ab9c:	1ae3      	subs	r3, r4, r3
}
 800ab9e:	4618      	mov	r0, r3
 800aba0:	370c      	adds	r7, #12
 800aba2:	46bd      	mov	sp, r7
 800aba4:	bd90      	pop	{r4, r7, pc}
 800aba6:	bf00      	nop

0800aba8 <chMBObjectInit>:
=======
 800ac08:	b590      	push	{r4, r7, lr}
 800ac0a:	b083      	sub	sp, #12
 800ac0c:	af00      	add	r7, sp, #0
 800ac0e:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800ac10:	f000 f9ea 	bl	800afe8 <chDbgCheckClassI>

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800ac14:	6878      	ldr	r0, [r7, #4]
 800ac16:	f7ff ffd9 	bl	800abcc <chMBGetSizeI>
 800ac1a:	4604      	mov	r4, r0
 800ac1c:	6878      	ldr	r0, [r7, #4]
 800ac1e:	f7ff ffe7 	bl	800abf0 <chMBGetUsedCountI>
 800ac22:	4603      	mov	r3, r0
 800ac24:	1ae3      	subs	r3, r4, r3
}
 800ac26:	4618      	mov	r0, r3
 800ac28:	370c      	adds	r7, #12
 800ac2a:	46bd      	mov	sp, r7
 800ac2c:	bd90      	pop	{r4, r7, pc}
 800ac2e:	bf00      	nop

0800ac30 <chMBObjectInit>:
>>>>>>> 752c83b... update binaries
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
<<<<<<< HEAD
 800aba8:	b580      	push	{r7, lr}
 800abaa:	b084      	sub	sp, #16
 800abac:	af00      	add	r7, sp, #0
 800abae:	60f8      	str	r0, [r7, #12]
 800abb0:	60b9      	str	r1, [r7, #8]
 800abb2:	607a      	str	r2, [r7, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
 800abb4:	68fb      	ldr	r3, [r7, #12]
 800abb6:	2b00      	cmp	r3, #0
 800abb8:	d005      	beq.n	800abc6 <chMBObjectInit+0x1e>
 800abba:	68bb      	ldr	r3, [r7, #8]
 800abbc:	2b00      	cmp	r3, #0
 800abbe:	d002      	beq.n	800abc6 <chMBObjectInit+0x1e>
 800abc0:	687b      	ldr	r3, [r7, #4]
 800abc2:	2b00      	cmp	r3, #0
 800abc4:	dc02      	bgt.n	800abcc <chMBObjectInit+0x24>
 800abc6:	4812      	ldr	r0, [pc, #72]	; (800ac10 <chMBObjectInit+0x68>)
 800abc8:	f000 f8ec 	bl	800ada4 <chSysHalt>

  mbp->buffer = buf;
 800abcc:	68fb      	ldr	r3, [r7, #12]
 800abce:	68ba      	ldr	r2, [r7, #8]
 800abd0:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 800abd2:	68fb      	ldr	r3, [r7, #12]
 800abd4:	68ba      	ldr	r2, [r7, #8]
 800abd6:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 800abd8:	68fb      	ldr	r3, [r7, #12]
 800abda:	68ba      	ldr	r2, [r7, #8]
 800abdc:	609a      	str	r2, [r3, #8]
  mbp->top    = &buf[n];
 800abde:	687b      	ldr	r3, [r7, #4]
 800abe0:	009b      	lsls	r3, r3, #2
 800abe2:	68ba      	ldr	r2, [r7, #8]
 800abe4:	441a      	add	r2, r3
 800abe6:	68fb      	ldr	r3, [r7, #12]
 800abe8:	605a      	str	r2, [r3, #4]
  mbp->cnt    = (cnt_t)0;
 800abea:	68fb      	ldr	r3, [r7, #12]
 800abec:	2200      	movs	r2, #0
 800abee:	611a      	str	r2, [r3, #16]
  mbp->reset  = false;
 800abf0:	68fb      	ldr	r3, [r7, #12]
 800abf2:	2200      	movs	r2, #0
 800abf4:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->qw);
 800abf6:	68fb      	ldr	r3, [r7, #12]
 800abf8:	3318      	adds	r3, #24
 800abfa:	4618      	mov	r0, r3
 800abfc:	f7ff ff98 	bl	800ab30 <chThdQueueObjectInit>
  chThdQueueObjectInit(&mbp->qr);
 800ac00:	68fb      	ldr	r3, [r7, #12]
 800ac02:	3320      	adds	r3, #32
 800ac04:	4618      	mov	r0, r3
 800ac06:	f7ff ff93 	bl	800ab30 <chThdQueueObjectInit>
}
 800ac0a:	3710      	adds	r7, #16
 800ac0c:	46bd      	mov	sp, r7
 800ac0e:	bd80      	pop	{r7, pc}
 800ac10:	0800e9ec 	.word	0x0800e9ec

0800ac14 <chMBPostI>:
=======
 800ac30:	b580      	push	{r7, lr}
 800ac32:	b084      	sub	sp, #16
 800ac34:	af00      	add	r7, sp, #0
 800ac36:	60f8      	str	r0, [r7, #12]
 800ac38:	60b9      	str	r1, [r7, #8]
 800ac3a:	607a      	str	r2, [r7, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
 800ac3c:	68fb      	ldr	r3, [r7, #12]
 800ac3e:	2b00      	cmp	r3, #0
 800ac40:	d005      	beq.n	800ac4e <chMBObjectInit+0x1e>
 800ac42:	68bb      	ldr	r3, [r7, #8]
 800ac44:	2b00      	cmp	r3, #0
 800ac46:	d002      	beq.n	800ac4e <chMBObjectInit+0x1e>
 800ac48:	687b      	ldr	r3, [r7, #4]
 800ac4a:	2b00      	cmp	r3, #0
 800ac4c:	dc02      	bgt.n	800ac54 <chMBObjectInit+0x24>
 800ac4e:	4812      	ldr	r0, [pc, #72]	; (800ac98 <chMBObjectInit+0x68>)
 800ac50:	f000 f8ec 	bl	800ae2c <chSysHalt>

  mbp->buffer = buf;
 800ac54:	68fb      	ldr	r3, [r7, #12]
 800ac56:	68ba      	ldr	r2, [r7, #8]
 800ac58:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 800ac5a:	68fb      	ldr	r3, [r7, #12]
 800ac5c:	68ba      	ldr	r2, [r7, #8]
 800ac5e:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 800ac60:	68fb      	ldr	r3, [r7, #12]
 800ac62:	68ba      	ldr	r2, [r7, #8]
 800ac64:	609a      	str	r2, [r3, #8]
  mbp->top    = &buf[n];
 800ac66:	687b      	ldr	r3, [r7, #4]
 800ac68:	009b      	lsls	r3, r3, #2
 800ac6a:	68ba      	ldr	r2, [r7, #8]
 800ac6c:	441a      	add	r2, r3
 800ac6e:	68fb      	ldr	r3, [r7, #12]
 800ac70:	605a      	str	r2, [r3, #4]
  mbp->cnt    = (cnt_t)0;
 800ac72:	68fb      	ldr	r3, [r7, #12]
 800ac74:	2200      	movs	r2, #0
 800ac76:	611a      	str	r2, [r3, #16]
  mbp->reset  = false;
 800ac78:	68fb      	ldr	r3, [r7, #12]
 800ac7a:	2200      	movs	r2, #0
 800ac7c:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->qw);
 800ac7e:	68fb      	ldr	r3, [r7, #12]
 800ac80:	3318      	adds	r3, #24
 800ac82:	4618      	mov	r0, r3
 800ac84:	f7ff ff98 	bl	800abb8 <chThdQueueObjectInit>
  chThdQueueObjectInit(&mbp->qr);
 800ac88:	68fb      	ldr	r3, [r7, #12]
 800ac8a:	3320      	adds	r3, #32
 800ac8c:	4618      	mov	r0, r3
 800ac8e:	f7ff ff93 	bl	800abb8 <chThdQueueObjectInit>
}
 800ac92:	3710      	adds	r7, #16
 800ac94:	46bd      	mov	sp, r7
 800ac96:	bd80      	pop	{r7, pc}
 800ac98:	0800eac4 	.word	0x0800eac4

0800ac9c <chMBPostI>:
>>>>>>> 752c83b... update binaries
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
<<<<<<< HEAD
 800ac14:	b580      	push	{r7, lr}
 800ac16:	b082      	sub	sp, #8
 800ac18:	af00      	add	r7, sp, #0
 800ac1a:	6078      	str	r0, [r7, #4]
 800ac1c:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 800ac1e:	f000 f99f 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 800ac22:	687b      	ldr	r3, [r7, #4]
 800ac24:	2b00      	cmp	r3, #0
 800ac26:	d102      	bne.n	800ac2e <chMBPostI+0x1a>
 800ac28:	4819      	ldr	r0, [pc, #100]	; (800ac90 <chMBPostI+0x7c>)
 800ac2a:	f000 f8bb 	bl	800ada4 <chSysHalt>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 800ac2e:	687b      	ldr	r3, [r7, #4]
 800ac30:	7d1b      	ldrb	r3, [r3, #20]
 800ac32:	2b00      	cmp	r3, #0
 800ac34:	d002      	beq.n	800ac3c <chMBPostI+0x28>
    return MSG_RESET;
 800ac36:	f06f 0301 	mvn.w	r3, #1
 800ac3a:	e025      	b.n	800ac88 <chMBPostI+0x74>
=======
 800ac9c:	b580      	push	{r7, lr}
 800ac9e:	b082      	sub	sp, #8
 800aca0:	af00      	add	r7, sp, #0
 800aca2:	6078      	str	r0, [r7, #4]
 800aca4:	6039      	str	r1, [r7, #0]

  chDbgCheckClassI();
 800aca6:	f000 f99f 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 800acaa:	687b      	ldr	r3, [r7, #4]
 800acac:	2b00      	cmp	r3, #0
 800acae:	d102      	bne.n	800acb6 <chMBPostI+0x1a>
 800acb0:	4819      	ldr	r0, [pc, #100]	; (800ad18 <chMBPostI+0x7c>)
 800acb2:	f000 f8bb 	bl	800ae2c <chSysHalt>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 800acb6:	687b      	ldr	r3, [r7, #4]
 800acb8:	7d1b      	ldrb	r3, [r3, #20]
 800acba:	2b00      	cmp	r3, #0
 800acbc:	d002      	beq.n	800acc4 <chMBPostI+0x28>
    return MSG_RESET;
 800acbe:	f06f 0301 	mvn.w	r3, #1
 800acc2:	e025      	b.n	800ad10 <chMBPostI+0x74>
>>>>>>> 752c83b... update binaries
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
<<<<<<< HEAD
 800ac3c:	6878      	ldr	r0, [r7, #4]
 800ac3e:	f7ff ff9f 	bl	800ab80 <chMBGetFreeCountI>
 800ac42:	4603      	mov	r3, r0
 800ac44:	2b00      	cmp	r3, #0
 800ac46:	dd1d      	ble.n	800ac84 <chMBPostI+0x70>
    *mbp->wrptr++ = msg;
 800ac48:	687b      	ldr	r3, [r7, #4]
 800ac4a:	689b      	ldr	r3, [r3, #8]
 800ac4c:	1d19      	adds	r1, r3, #4
 800ac4e:	687a      	ldr	r2, [r7, #4]
 800ac50:	6091      	str	r1, [r2, #8]
 800ac52:	683a      	ldr	r2, [r7, #0]
 800ac54:	601a      	str	r2, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
 800ac56:	687b      	ldr	r3, [r7, #4]
 800ac58:	689a      	ldr	r2, [r3, #8]
 800ac5a:	687b      	ldr	r3, [r7, #4]
 800ac5c:	685b      	ldr	r3, [r3, #4]
 800ac5e:	429a      	cmp	r2, r3
 800ac60:	d303      	bcc.n	800ac6a <chMBPostI+0x56>
      mbp->wrptr = mbp->buffer;
 800ac62:	687b      	ldr	r3, [r7, #4]
 800ac64:	681a      	ldr	r2, [r3, #0]
 800ac66:	687b      	ldr	r3, [r7, #4]
 800ac68:	609a      	str	r2, [r3, #8]
    }
    mbp->cnt++;
 800ac6a:	687b      	ldr	r3, [r7, #4]
 800ac6c:	691b      	ldr	r3, [r3, #16]
 800ac6e:	1c5a      	adds	r2, r3, #1
 800ac70:	687b      	ldr	r3, [r7, #4]
 800ac72:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 800ac74:	687b      	ldr	r3, [r7, #4]
 800ac76:	3320      	adds	r3, #32
 800ac78:	4618      	mov	r0, r3
 800ac7a:	2100      	movs	r1, #0
 800ac7c:	f7ff fc1c 	bl	800a4b8 <chThdDequeueNextI>

    return MSG_OK;
 800ac80:	2300      	movs	r3, #0
 800ac82:	e001      	b.n	800ac88 <chMBPostI+0x74>
=======
 800acc4:	6878      	ldr	r0, [r7, #4]
 800acc6:	f7ff ff9f 	bl	800ac08 <chMBGetFreeCountI>
 800acca:	4603      	mov	r3, r0
 800accc:	2b00      	cmp	r3, #0
 800acce:	dd1d      	ble.n	800ad0c <chMBPostI+0x70>
    *mbp->wrptr++ = msg;
 800acd0:	687b      	ldr	r3, [r7, #4]
 800acd2:	689b      	ldr	r3, [r3, #8]
 800acd4:	1d19      	adds	r1, r3, #4
 800acd6:	687a      	ldr	r2, [r7, #4]
 800acd8:	6091      	str	r1, [r2, #8]
 800acda:	683a      	ldr	r2, [r7, #0]
 800acdc:	601a      	str	r2, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
 800acde:	687b      	ldr	r3, [r7, #4]
 800ace0:	689a      	ldr	r2, [r3, #8]
 800ace2:	687b      	ldr	r3, [r7, #4]
 800ace4:	685b      	ldr	r3, [r3, #4]
 800ace6:	429a      	cmp	r2, r3
 800ace8:	d303      	bcc.n	800acf2 <chMBPostI+0x56>
      mbp->wrptr = mbp->buffer;
 800acea:	687b      	ldr	r3, [r7, #4]
 800acec:	681a      	ldr	r2, [r3, #0]
 800acee:	687b      	ldr	r3, [r7, #4]
 800acf0:	609a      	str	r2, [r3, #8]
    }
    mbp->cnt++;
 800acf2:	687b      	ldr	r3, [r7, #4]
 800acf4:	691b      	ldr	r3, [r3, #16]
 800acf6:	1c5a      	adds	r2, r3, #1
 800acf8:	687b      	ldr	r3, [r7, #4]
 800acfa:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 800acfc:	687b      	ldr	r3, [r7, #4]
 800acfe:	3320      	adds	r3, #32
 800ad00:	4618      	mov	r0, r3
 800ad02:	2100      	movs	r1, #0
 800ad04:	f7ff fc1c 	bl	800a540 <chThdDequeueNextI>

    return MSG_OK;
 800ad08:	2300      	movs	r3, #0
 800ad0a:	e001      	b.n	800ad10 <chMBPostI+0x74>
>>>>>>> 752c83b... update binaries
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
<<<<<<< HEAD
 800ac84:	f04f 33ff 	mov.w	r3, #4294967295
}
 800ac88:	4618      	mov	r0, r3
 800ac8a:	3708      	adds	r7, #8
 800ac8c:	46bd      	mov	sp, r7
 800ac8e:	bd80      	pop	{r7, pc}
 800ac90:	0800ea08 	.word	0x0800ea08

0800ac94 <chMBFetch>:
=======
 800ad0c:	f04f 33ff 	mov.w	r3, #4294967295
}
 800ad10:	4618      	mov	r0, r3
 800ad12:	3708      	adds	r7, #8
 800ad14:	46bd      	mov	sp, r7
 800ad16:	bd80      	pop	{r7, pc}
 800ad18:	0800eae0 	.word	0x0800eae0

0800ad1c <chMBFetch>:
>>>>>>> 752c83b... update binaries
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
<<<<<<< HEAD
 800ac94:	b580      	push	{r7, lr}
 800ac96:	b086      	sub	sp, #24
 800ac98:	af00      	add	r7, sp, #0
 800ac9a:	60f8      	str	r0, [r7, #12]
 800ac9c:	60b9      	str	r1, [r7, #8]
 800ac9e:	4613      	mov	r3, r2
 800aca0:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chSysLock();
 800aca2:	f7ff ff21 	bl	800aae8 <chSysLock.lto_priv.262>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 800aca6:	88fb      	ldrh	r3, [r7, #6]
 800aca8:	68f8      	ldr	r0, [r7, #12]
 800acaa:	68b9      	ldr	r1, [r7, #8]
 800acac:	461a      	mov	r2, r3
 800acae:	f000 f809 	bl	800acc4 <chMBFetchS>
 800acb2:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 800acb4:	f7ff ff20 	bl	800aaf8 <chSysUnlock.lto_priv.257>

  return rdymsg;
 800acb8:	697b      	ldr	r3, [r7, #20]
}
 800acba:	4618      	mov	r0, r3
 800acbc:	3718      	adds	r7, #24
 800acbe:	46bd      	mov	sp, r7
 800acc0:	bd80      	pop	{r7, pc}
 800acc2:	bf00      	nop

0800acc4 <chMBFetchS>:
=======
 800ad1c:	b580      	push	{r7, lr}
 800ad1e:	b086      	sub	sp, #24
 800ad20:	af00      	add	r7, sp, #0
 800ad22:	60f8      	str	r0, [r7, #12]
 800ad24:	60b9      	str	r1, [r7, #8]
 800ad26:	4613      	mov	r3, r2
 800ad28:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chSysLock();
 800ad2a:	f7ff ff21 	bl	800ab70 <chSysLock.lto_priv.259>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 800ad2e:	88fb      	ldrh	r3, [r7, #6]
 800ad30:	68f8      	ldr	r0, [r7, #12]
 800ad32:	68b9      	ldr	r1, [r7, #8]
 800ad34:	461a      	mov	r2, r3
 800ad36:	f000 f809 	bl	800ad4c <chMBFetchS>
 800ad3a:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 800ad3c:	f7ff ff20 	bl	800ab80 <chSysUnlock.lto_priv.254>

  return rdymsg;
 800ad40:	697b      	ldr	r3, [r7, #20]
}
 800ad42:	4618      	mov	r0, r3
 800ad44:	3718      	adds	r7, #24
 800ad46:	46bd      	mov	sp, r7
 800ad48:	bd80      	pop	{r7, pc}
 800ad4a:	bf00      	nop

0800ad4c <chMBFetchS>:
>>>>>>> 752c83b... update binaries
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
<<<<<<< HEAD
 800acc4:	b580      	push	{r7, lr}
 800acc6:	b086      	sub	sp, #24
 800acc8:	af00      	add	r7, sp, #0
 800acca:	60f8      	str	r0, [r7, #12]
 800accc:	60b9      	str	r1, [r7, #8]
 800acce:	4613      	mov	r3, r2
 800acd0:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chDbgCheckClassS();
 800acd2:	f000 f957 	bl	800af84 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 800acd6:	68fb      	ldr	r3, [r7, #12]
 800acd8:	2b00      	cmp	r3, #0
 800acda:	d002      	beq.n	800ace2 <chMBFetchS+0x1e>
 800acdc:	68bb      	ldr	r3, [r7, #8]
 800acde:	2b00      	cmp	r3, #0
 800ace0:	d102      	bne.n	800ace8 <chMBFetchS+0x24>
 800ace2:	4821      	ldr	r0, [pc, #132]	; (800ad68 <chMBFetchS+0xa4>)
 800ace4:	f000 f85e 	bl	800ada4 <chSysHalt>
=======
 800ad4c:	b580      	push	{r7, lr}
 800ad4e:	b086      	sub	sp, #24
 800ad50:	af00      	add	r7, sp, #0
 800ad52:	60f8      	str	r0, [r7, #12]
 800ad54:	60b9      	str	r1, [r7, #8]
 800ad56:	4613      	mov	r3, r2
 800ad58:	80fb      	strh	r3, [r7, #6]
  msg_t rdymsg;

  chDbgCheckClassS();
 800ad5a:	f000 f957 	bl	800b00c <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 800ad5e:	68fb      	ldr	r3, [r7, #12]
 800ad60:	2b00      	cmp	r3, #0
 800ad62:	d002      	beq.n	800ad6a <chMBFetchS+0x1e>
 800ad64:	68bb      	ldr	r3, [r7, #8]
 800ad66:	2b00      	cmp	r3, #0
 800ad68:	d102      	bne.n	800ad70 <chMBFetchS+0x24>
 800ad6a:	4821      	ldr	r0, [pc, #132]	; (800adf0 <chMBFetchS+0xa4>)
 800ad6c:	f000 f85e 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
<<<<<<< HEAD
 800ace8:	68fb      	ldr	r3, [r7, #12]
 800acea:	7d1b      	ldrb	r3, [r3, #20]
 800acec:	2b00      	cmp	r3, #0
 800acee:	d002      	beq.n	800acf6 <chMBFetchS+0x32>
      return MSG_RESET;
 800acf0:	f06f 0301 	mvn.w	r3, #1
 800acf4:	e033      	b.n	800ad5e <chMBFetchS+0x9a>
=======
 800ad70:	68fb      	ldr	r3, [r7, #12]
 800ad72:	7d1b      	ldrb	r3, [r3, #20]
 800ad74:	2b00      	cmp	r3, #0
 800ad76:	d002      	beq.n	800ad7e <chMBFetchS+0x32>
      return MSG_RESET;
 800ad78:	f06f 0301 	mvn.w	r3, #1
 800ad7c:	e033      	b.n	800ade6 <chMBFetchS+0x9a>
>>>>>>> 752c83b... update binaries
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
<<<<<<< HEAD
 800acf6:	68f8      	ldr	r0, [r7, #12]
 800acf8:	f7ff ff36 	bl	800ab68 <chMBGetUsedCountI>
 800acfc:	4603      	mov	r3, r0
 800acfe:	2b00      	cmp	r3, #0
 800ad00:	dd20      	ble.n	800ad44 <chMBFetchS+0x80>
      *msgp = *mbp->rdptr++;
 800ad02:	68fb      	ldr	r3, [r7, #12]
 800ad04:	68db      	ldr	r3, [r3, #12]
 800ad06:	1d19      	adds	r1, r3, #4
 800ad08:	68fa      	ldr	r2, [r7, #12]
 800ad0a:	60d1      	str	r1, [r2, #12]
 800ad0c:	681a      	ldr	r2, [r3, #0]
 800ad0e:	68bb      	ldr	r3, [r7, #8]
 800ad10:	601a      	str	r2, [r3, #0]
      if (mbp->rdptr >= mbp->top) {
 800ad12:	68fb      	ldr	r3, [r7, #12]
 800ad14:	68da      	ldr	r2, [r3, #12]
 800ad16:	68fb      	ldr	r3, [r7, #12]
 800ad18:	685b      	ldr	r3, [r3, #4]
 800ad1a:	429a      	cmp	r2, r3
 800ad1c:	d303      	bcc.n	800ad26 <chMBFetchS+0x62>
        mbp->rdptr = mbp->buffer;
 800ad1e:	68fb      	ldr	r3, [r7, #12]
 800ad20:	681a      	ldr	r2, [r3, #0]
 800ad22:	68fb      	ldr	r3, [r7, #12]
 800ad24:	60da      	str	r2, [r3, #12]
      }
      mbp->cnt--;
 800ad26:	68fb      	ldr	r3, [r7, #12]
 800ad28:	691b      	ldr	r3, [r3, #16]
 800ad2a:	1e5a      	subs	r2, r3, #1
 800ad2c:	68fb      	ldr	r3, [r7, #12]
 800ad2e:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 800ad30:	68fb      	ldr	r3, [r7, #12]
 800ad32:	3318      	adds	r3, #24
 800ad34:	4618      	mov	r0, r3
 800ad36:	2100      	movs	r1, #0
 800ad38:	f7ff fbbe 	bl	800a4b8 <chThdDequeueNextI>
      chSchRescheduleS();
 800ad3c:	f000 fd12 	bl	800b764 <chSchRescheduleS>

      return MSG_OK;
 800ad40:	2300      	movs	r3, #0
 800ad42:	e00c      	b.n	800ad5e <chMBFetchS+0x9a>
=======
 800ad7e:	68f8      	ldr	r0, [r7, #12]
 800ad80:	f7ff ff36 	bl	800abf0 <chMBGetUsedCountI>
 800ad84:	4603      	mov	r3, r0
 800ad86:	2b00      	cmp	r3, #0
 800ad88:	dd20      	ble.n	800adcc <chMBFetchS+0x80>
      *msgp = *mbp->rdptr++;
 800ad8a:	68fb      	ldr	r3, [r7, #12]
 800ad8c:	68db      	ldr	r3, [r3, #12]
 800ad8e:	1d19      	adds	r1, r3, #4
 800ad90:	68fa      	ldr	r2, [r7, #12]
 800ad92:	60d1      	str	r1, [r2, #12]
 800ad94:	681a      	ldr	r2, [r3, #0]
 800ad96:	68bb      	ldr	r3, [r7, #8]
 800ad98:	601a      	str	r2, [r3, #0]
      if (mbp->rdptr >= mbp->top) {
 800ad9a:	68fb      	ldr	r3, [r7, #12]
 800ad9c:	68da      	ldr	r2, [r3, #12]
 800ad9e:	68fb      	ldr	r3, [r7, #12]
 800ada0:	685b      	ldr	r3, [r3, #4]
 800ada2:	429a      	cmp	r2, r3
 800ada4:	d303      	bcc.n	800adae <chMBFetchS+0x62>
        mbp->rdptr = mbp->buffer;
 800ada6:	68fb      	ldr	r3, [r7, #12]
 800ada8:	681a      	ldr	r2, [r3, #0]
 800adaa:	68fb      	ldr	r3, [r7, #12]
 800adac:	60da      	str	r2, [r3, #12]
      }
      mbp->cnt--;
 800adae:	68fb      	ldr	r3, [r7, #12]
 800adb0:	691b      	ldr	r3, [r3, #16]
 800adb2:	1e5a      	subs	r2, r3, #1
 800adb4:	68fb      	ldr	r3, [r7, #12]
 800adb6:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 800adb8:	68fb      	ldr	r3, [r7, #12]
 800adba:	3318      	adds	r3, #24
 800adbc:	4618      	mov	r0, r3
 800adbe:	2100      	movs	r1, #0
 800adc0:	f7ff fbbe 	bl	800a540 <chThdDequeueNextI>
      chSchRescheduleS();
 800adc4:	f000 fd12 	bl	800b7ec <chSchRescheduleS>

      return MSG_OK;
 800adc8:	2300      	movs	r3, #0
 800adca:	e00c      	b.n	800ade6 <chMBFetchS+0x9a>
>>>>>>> 752c83b... update binaries
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
<<<<<<< HEAD
 800ad44:	68fb      	ldr	r3, [r7, #12]
 800ad46:	f103 0220 	add.w	r2, r3, #32
 800ad4a:	88fb      	ldrh	r3, [r7, #6]
 800ad4c:	4610      	mov	r0, r2
 800ad4e:	4619      	mov	r1, r3
 800ad50:	f7ff fb94 	bl	800a47c <chThdEnqueueTimeoutS>
 800ad54:	6178      	str	r0, [r7, #20]
  } while (rdymsg == MSG_OK);
 800ad56:	697b      	ldr	r3, [r7, #20]
 800ad58:	2b00      	cmp	r3, #0
 800ad5a:	d0c5      	beq.n	800ace8 <chMBFetchS+0x24>

  return rdymsg;
 800ad5c:	697b      	ldr	r3, [r7, #20]
}
 800ad5e:	4618      	mov	r0, r3
 800ad60:	3718      	adds	r7, #24
 800ad62:	46bd      	mov	sp, r7
 800ad64:	bd80      	pop	{r7, pc}
 800ad66:	bf00      	nop
 800ad68:	0800ea14 	.word	0x0800ea14

0800ad6c <port_lock.lto_priv.232>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800ad6c:	b480      	push	{r7}
 800ad6e:	b083      	sub	sp, #12
 800ad70:	af00      	add	r7, sp, #0
 800ad72:	2320      	movs	r3, #32
 800ad74:	607b      	str	r3, [r7, #4]
 800ad76:	687b      	ldr	r3, [r7, #4]
 800ad78:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ad7c:	370c      	adds	r7, #12
 800ad7e:	46bd      	mov	sp, r7
 800ad80:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ad84:	4770      	bx	lr
 800ad86:	bf00      	nop

0800ad88 <port_unlock.lto_priv.227>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ad88:	b480      	push	{r7}
 800ad8a:	b083      	sub	sp, #12
 800ad8c:	af00      	add	r7, sp, #0
 800ad8e:	2300      	movs	r3, #0
 800ad90:	607b      	str	r3, [r7, #4]
 800ad92:	687b      	ldr	r3, [r7, #4]
 800ad94:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ad98:	370c      	adds	r7, #12
 800ad9a:	46bd      	mov	sp, r7
 800ad9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ada0:	4770      	bx	lr
 800ada2:	bf00      	nop

0800ada4 <chSysHalt>:
=======
 800adcc:	68fb      	ldr	r3, [r7, #12]
 800adce:	f103 0220 	add.w	r2, r3, #32
 800add2:	88fb      	ldrh	r3, [r7, #6]
 800add4:	4610      	mov	r0, r2
 800add6:	4619      	mov	r1, r3
 800add8:	f7ff fb94 	bl	800a504 <chThdEnqueueTimeoutS>
 800addc:	6178      	str	r0, [r7, #20]
  } while (rdymsg == MSG_OK);
 800adde:	697b      	ldr	r3, [r7, #20]
 800ade0:	2b00      	cmp	r3, #0
 800ade2:	d0c5      	beq.n	800ad70 <chMBFetchS+0x24>

  return rdymsg;
 800ade4:	697b      	ldr	r3, [r7, #20]
}
 800ade6:	4618      	mov	r0, r3
 800ade8:	3718      	adds	r7, #24
 800adea:	46bd      	mov	sp, r7
 800adec:	bd80      	pop	{r7, pc}
 800adee:	bf00      	nop
 800adf0:	0800eaec 	.word	0x0800eaec

0800adf4 <port_lock.lto_priv.229>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800adf4:	b480      	push	{r7}
 800adf6:	b083      	sub	sp, #12
 800adf8:	af00      	add	r7, sp, #0
 800adfa:	2320      	movs	r3, #32
 800adfc:	607b      	str	r3, [r7, #4]
 800adfe:	687b      	ldr	r3, [r7, #4]
 800ae00:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ae04:	370c      	adds	r7, #12
 800ae06:	46bd      	mov	sp, r7
 800ae08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae0c:	4770      	bx	lr
 800ae0e:	bf00      	nop

0800ae10 <port_unlock.lto_priv.224>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ae10:	b480      	push	{r7}
 800ae12:	b083      	sub	sp, #12
 800ae14:	af00      	add	r7, sp, #0
 800ae16:	2300      	movs	r3, #0
 800ae18:	607b      	str	r3, [r7, #4]
 800ae1a:	687b      	ldr	r3, [r7, #4]
 800ae1c:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ae20:	370c      	adds	r7, #12
 800ae22:	46bd      	mov	sp, r7
 800ae24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae28:	4770      	bx	lr
 800ae2a:	bf00      	nop

0800ae2c <chSysHalt>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
<<<<<<< HEAD
 800ada4:	b580      	push	{r7, lr}
 800ada6:	b082      	sub	sp, #8
 800ada8:	af00      	add	r7, sp, #0
 800adaa:	6078      	str	r0, [r7, #4]

  port_disable();
 800adac:	f001 fce6 	bl	800c77c <port_disable.lto_priv.331>
=======
 800ae2c:	b580      	push	{r7, lr}
 800ae2e:	b082      	sub	sp, #8
 800ae30:	af00      	add	r7, sp, #0
 800ae32:	6078      	str	r0, [r7, #4]

  port_disable();
 800ae34:	f001 fce6 	bl	800c804 <port_disable.lto_priv.328>
>>>>>>> 752c83b... update binaries

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
<<<<<<< HEAD
 800adb0:	4a01      	ldr	r2, [pc, #4]	; (800adb8 <chSysHalt+0x14>)
 800adb2:	687b      	ldr	r3, [r7, #4]
 800adb4:	6293      	str	r3, [r2, #40]	; 0x28
 800adb6:	e7fe      	b.n	800adb6 <chSysHalt+0x12>
 800adb8:	20001338 	.word	0x20001338

0800adbc <chSysTimerHandlerI>:
=======
 800ae38:	4a01      	ldr	r2, [pc, #4]	; (800ae40 <chSysHalt+0x14>)
 800ae3a:	687b      	ldr	r3, [r7, #4]
 800ae3c:	6293      	str	r3, [r2, #40]	; 0x28
 800ae3e:	e7fe      	b.n	800ae3e <chSysHalt+0x12>
 800ae40:	20001338 	.word	0x20001338

0800ae44 <chSysTimerHandlerI>:
>>>>>>> 752c83b... update binaries
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
<<<<<<< HEAD
 800adbc:	b580      	push	{r7, lr}
 800adbe:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800adc0:	f000 f8ce 	bl	800af60 <chDbgCheckClassI>
=======
 800ae44:	b580      	push	{r7, lr}
 800ae46:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800ae48:	f000 f8ce 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
<<<<<<< HEAD
 800adc4:	f001 fd3c 	bl	800c840 <chVTDoTickI.lto_priv.330>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800adc8:	bd80      	pop	{r7, pc}
 800adca:	bf00      	nop

0800adcc <port_lock.lto_priv.312>:
=======
 800ae4c:	f001 fd3c 	bl	800c8c8 <chVTDoTickI.lto_priv.327>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800ae50:	bd80      	pop	{r7, pc}
 800ae52:	bf00      	nop

0800ae54 <port_lock.lto_priv.309>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800adcc:	b480      	push	{r7}
 800adce:	b083      	sub	sp, #12
 800add0:	af00      	add	r7, sp, #0
 800add2:	2320      	movs	r3, #32
 800add4:	607b      	str	r3, [r7, #4]
 800add6:	687b      	ldr	r3, [r7, #4]
 800add8:	f383 8811 	msr	BASEPRI, r3
=======
 800ae54:	b480      	push	{r7}
 800ae56:	b083      	sub	sp, #12
 800ae58:	af00      	add	r7, sp, #0
 800ae5a:	2320      	movs	r3, #32
 800ae5c:	607b      	str	r3, [r7, #4]
 800ae5e:	687b      	ldr	r3, [r7, #4]
 800ae60:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800addc:	370c      	adds	r7, #12
 800adde:	46bd      	mov	sp, r7
 800ade0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ade4:	4770      	bx	lr
 800ade6:	bf00      	nop

0800ade8 <port_unlock.lto_priv.309>:
=======
 800ae64:	370c      	adds	r7, #12
 800ae66:	46bd      	mov	sp, r7
 800ae68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae6c:	4770      	bx	lr
 800ae6e:	bf00      	nop

0800ae70 <port_unlock.lto_priv.306>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800ade8:	b480      	push	{r7}
 800adea:	b083      	sub	sp, #12
 800adec:	af00      	add	r7, sp, #0
 800adee:	2300      	movs	r3, #0
 800adf0:	607b      	str	r3, [r7, #4]
 800adf2:	687b      	ldr	r3, [r7, #4]
 800adf4:	f383 8811 	msr	BASEPRI, r3
=======
 800ae70:	b480      	push	{r7}
 800ae72:	b083      	sub	sp, #12
 800ae74:	af00      	add	r7, sp, #0
 800ae76:	2300      	movs	r3, #0
 800ae78:	607b      	str	r3, [r7, #4]
 800ae7a:	687b      	ldr	r3, [r7, #4]
 800ae7c:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800adf8:	370c      	adds	r7, #12
 800adfa:	46bd      	mov	sp, r7
 800adfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae00:	4770      	bx	lr
 800ae02:	bf00      	nop

0800ae04 <port_lock_from_isr.lto_priv.322>:
=======
 800ae80:	370c      	adds	r7, #12
 800ae82:	46bd      	mov	sp, r7
 800ae84:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae88:	4770      	bx	lr
 800ae8a:	bf00      	nop

0800ae8c <port_lock_from_isr.lto_priv.319>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
<<<<<<< HEAD
 800ae04:	b580      	push	{r7, lr}
 800ae06:	af00      	add	r7, sp, #0

  port_lock();
 800ae08:	f7ff ffe0 	bl	800adcc <port_lock.lto_priv.312>
}
 800ae0c:	bd80      	pop	{r7, pc}
 800ae0e:	bf00      	nop

0800ae10 <port_unlock_from_isr.lto_priv.320>:
=======
 800ae8c:	b580      	push	{r7, lr}
 800ae8e:	af00      	add	r7, sp, #0

  port_lock();
 800ae90:	f7ff ffe0 	bl	800ae54 <port_lock.lto_priv.309>
}
 800ae94:	bd80      	pop	{r7, pc}
 800ae96:	bf00      	nop

0800ae98 <port_unlock_from_isr.lto_priv.317>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
<<<<<<< HEAD
 800ae10:	b580      	push	{r7, lr}
 800ae12:	af00      	add	r7, sp, #0

  port_unlock();
 800ae14:	f7ff ffe8 	bl	800ade8 <port_unlock.lto_priv.309>
}
 800ae18:	bd80      	pop	{r7, pc}
 800ae1a:	bf00      	nop

0800ae1c <_dbg_check_enable>:
=======
 800ae98:	b580      	push	{r7, lr}
 800ae9a:	af00      	add	r7, sp, #0

  port_unlock();
 800ae9c:	f7ff ffe8 	bl	800ae70 <port_unlock.lto_priv.306>
}
 800aea0:	bd80      	pop	{r7, pc}
 800aea2:	bf00      	nop

0800aea4 <_dbg_check_enable>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
<<<<<<< HEAD
 800ae1c:	b580      	push	{r7, lr}
 800ae1e:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ae20:	4b05      	ldr	r3, [pc, #20]	; (800ae38 <_dbg_check_enable+0x1c>)
 800ae22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ae24:	2b00      	cmp	r3, #0
 800ae26:	d103      	bne.n	800ae30 <_dbg_check_enable+0x14>
 800ae28:	4b03      	ldr	r3, [pc, #12]	; (800ae38 <_dbg_check_enable+0x1c>)
 800ae2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae2c:	2b00      	cmp	r3, #0
 800ae2e:	d002      	beq.n	800ae36 <_dbg_check_enable+0x1a>
    chSysHalt("SV#3");
 800ae30:	4802      	ldr	r0, [pc, #8]	; (800ae3c <_dbg_check_enable+0x20>)
 800ae32:	f7ff ffb7 	bl	800ada4 <chSysHalt>
  }
}
 800ae36:	bd80      	pop	{r7, pc}
 800ae38:	20001338 	.word	0x20001338
 800ae3c:	0800e678 	.word	0x0800e678

0800ae40 <_dbg_check_lock>:
=======
 800aea4:	b580      	push	{r7, lr}
 800aea6:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800aea8:	4b05      	ldr	r3, [pc, #20]	; (800aec0 <_dbg_check_enable+0x1c>)
 800aeaa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aeac:	2b00      	cmp	r3, #0
 800aeae:	d103      	bne.n	800aeb8 <_dbg_check_enable+0x14>
 800aeb0:	4b03      	ldr	r3, [pc, #12]	; (800aec0 <_dbg_check_enable+0x1c>)
 800aeb2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aeb4:	2b00      	cmp	r3, #0
 800aeb6:	d002      	beq.n	800aebe <_dbg_check_enable+0x1a>
    chSysHalt("SV#3");
 800aeb8:	4802      	ldr	r0, [pc, #8]	; (800aec4 <_dbg_check_enable+0x20>)
 800aeba:	f7ff ffb7 	bl	800ae2c <chSysHalt>
  }
}
 800aebe:	bd80      	pop	{r7, pc}
 800aec0:	20001338 	.word	0x20001338
 800aec4:	0800e754 	.word	0x0800e754

0800aec8 <_dbg_check_lock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
<<<<<<< HEAD
 800ae40:	b580      	push	{r7, lr}
 800ae42:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ae44:	4b07      	ldr	r3, [pc, #28]	; (800ae64 <_dbg_check_lock+0x24>)
 800ae46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ae48:	2b00      	cmp	r3, #0
 800ae4a:	d103      	bne.n	800ae54 <_dbg_check_lock+0x14>
 800ae4c:	4b05      	ldr	r3, [pc, #20]	; (800ae64 <_dbg_check_lock+0x24>)
 800ae4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae50:	2b00      	cmp	r3, #0
 800ae52:	d002      	beq.n	800ae5a <_dbg_check_lock+0x1a>
    chSysHalt("SV#4");
 800ae54:	4804      	ldr	r0, [pc, #16]	; (800ae68 <_dbg_check_lock+0x28>)
 800ae56:	f7ff ffa5 	bl	800ada4 <chSysHalt>
  }
  _dbg_enter_lock();
 800ae5a:	4b02      	ldr	r3, [pc, #8]	; (800ae64 <_dbg_check_lock+0x24>)
 800ae5c:	2201      	movs	r2, #1
 800ae5e:	631a      	str	r2, [r3, #48]	; 0x30
}
 800ae60:	bd80      	pop	{r7, pc}
 800ae62:	bf00      	nop
 800ae64:	20001338 	.word	0x20001338
 800ae68:	0800e680 	.word	0x0800e680

0800ae6c <_dbg_check_unlock>:
=======
 800aec8:	b580      	push	{r7, lr}
 800aeca:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800aecc:	4b07      	ldr	r3, [pc, #28]	; (800aeec <_dbg_check_lock+0x24>)
 800aece:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aed0:	2b00      	cmp	r3, #0
 800aed2:	d103      	bne.n	800aedc <_dbg_check_lock+0x14>
 800aed4:	4b05      	ldr	r3, [pc, #20]	; (800aeec <_dbg_check_lock+0x24>)
 800aed6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aed8:	2b00      	cmp	r3, #0
 800aeda:	d002      	beq.n	800aee2 <_dbg_check_lock+0x1a>
    chSysHalt("SV#4");
 800aedc:	4804      	ldr	r0, [pc, #16]	; (800aef0 <_dbg_check_lock+0x28>)
 800aede:	f7ff ffa5 	bl	800ae2c <chSysHalt>
  }
  _dbg_enter_lock();
 800aee2:	4b02      	ldr	r3, [pc, #8]	; (800aeec <_dbg_check_lock+0x24>)
 800aee4:	2201      	movs	r2, #1
 800aee6:	631a      	str	r2, [r3, #48]	; 0x30
}
 800aee8:	bd80      	pop	{r7, pc}
 800aeea:	bf00      	nop
 800aeec:	20001338 	.word	0x20001338
 800aef0:	0800e75c 	.word	0x0800e75c

0800aef4 <_dbg_check_unlock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
<<<<<<< HEAD
 800ae6c:	b580      	push	{r7, lr}
 800ae6e:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800ae70:	4b07      	ldr	r3, [pc, #28]	; (800ae90 <_dbg_check_unlock+0x24>)
 800ae72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ae74:	2b00      	cmp	r3, #0
 800ae76:	d103      	bne.n	800ae80 <_dbg_check_unlock+0x14>
 800ae78:	4b05      	ldr	r3, [pc, #20]	; (800ae90 <_dbg_check_unlock+0x24>)
 800ae7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae7c:	2b00      	cmp	r3, #0
 800ae7e:	dc02      	bgt.n	800ae86 <_dbg_check_unlock+0x1a>
    chSysHalt("SV#5");
 800ae80:	4804      	ldr	r0, [pc, #16]	; (800ae94 <_dbg_check_unlock+0x28>)
 800ae82:	f7ff ff8f 	bl	800ada4 <chSysHalt>
  }
  _dbg_leave_lock();
 800ae86:	4b02      	ldr	r3, [pc, #8]	; (800ae90 <_dbg_check_unlock+0x24>)
 800ae88:	2200      	movs	r2, #0
 800ae8a:	631a      	str	r2, [r3, #48]	; 0x30
}
 800ae8c:	bd80      	pop	{r7, pc}
 800ae8e:	bf00      	nop
 800ae90:	20001338 	.word	0x20001338
 800ae94:	0800e688 	.word	0x0800e688

0800ae98 <_dbg_check_lock_from_isr>:
=======
 800aef4:	b580      	push	{r7, lr}
 800aef6:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800aef8:	4b07      	ldr	r3, [pc, #28]	; (800af18 <_dbg_check_unlock+0x24>)
 800aefa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aefc:	2b00      	cmp	r3, #0
 800aefe:	d103      	bne.n	800af08 <_dbg_check_unlock+0x14>
 800af00:	4b05      	ldr	r3, [pc, #20]	; (800af18 <_dbg_check_unlock+0x24>)
 800af02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af04:	2b00      	cmp	r3, #0
 800af06:	dc02      	bgt.n	800af0e <_dbg_check_unlock+0x1a>
    chSysHalt("SV#5");
 800af08:	4804      	ldr	r0, [pc, #16]	; (800af1c <_dbg_check_unlock+0x28>)
 800af0a:	f7ff ff8f 	bl	800ae2c <chSysHalt>
  }
  _dbg_leave_lock();
 800af0e:	4b02      	ldr	r3, [pc, #8]	; (800af18 <_dbg_check_unlock+0x24>)
 800af10:	2200      	movs	r2, #0
 800af12:	631a      	str	r2, [r3, #48]	; 0x30
}
 800af14:	bd80      	pop	{r7, pc}
 800af16:	bf00      	nop
 800af18:	20001338 	.word	0x20001338
 800af1c:	0800e764 	.word	0x0800e764

0800af20 <_dbg_check_lock_from_isr>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
<<<<<<< HEAD
 800ae98:	b580      	push	{r7, lr}
 800ae9a:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ae9c:	4b07      	ldr	r3, [pc, #28]	; (800aebc <_dbg_check_lock_from_isr+0x24>)
 800ae9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aea0:	2b00      	cmp	r3, #0
 800aea2:	dd03      	ble.n	800aeac <_dbg_check_lock_from_isr+0x14>
 800aea4:	4b05      	ldr	r3, [pc, #20]	; (800aebc <_dbg_check_lock_from_isr+0x24>)
 800aea6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aea8:	2b00      	cmp	r3, #0
 800aeaa:	d002      	beq.n	800aeb2 <_dbg_check_lock_from_isr+0x1a>
    chSysHalt("SV#6");
 800aeac:	4804      	ldr	r0, [pc, #16]	; (800aec0 <_dbg_check_lock_from_isr+0x28>)
 800aeae:	f7ff ff79 	bl	800ada4 <chSysHalt>
  }
  _dbg_enter_lock();
 800aeb2:	4b02      	ldr	r3, [pc, #8]	; (800aebc <_dbg_check_lock_from_isr+0x24>)
 800aeb4:	2201      	movs	r2, #1
 800aeb6:	631a      	str	r2, [r3, #48]	; 0x30
}
 800aeb8:	bd80      	pop	{r7, pc}
 800aeba:	bf00      	nop
 800aebc:	20001338 	.word	0x20001338
 800aec0:	0800e690 	.word	0x0800e690

0800aec4 <_dbg_check_unlock_from_isr>:
=======
 800af20:	b580      	push	{r7, lr}
 800af22:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800af24:	4b07      	ldr	r3, [pc, #28]	; (800af44 <_dbg_check_lock_from_isr+0x24>)
 800af26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af28:	2b00      	cmp	r3, #0
 800af2a:	dd03      	ble.n	800af34 <_dbg_check_lock_from_isr+0x14>
 800af2c:	4b05      	ldr	r3, [pc, #20]	; (800af44 <_dbg_check_lock_from_isr+0x24>)
 800af2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af30:	2b00      	cmp	r3, #0
 800af32:	d002      	beq.n	800af3a <_dbg_check_lock_from_isr+0x1a>
    chSysHalt("SV#6");
 800af34:	4804      	ldr	r0, [pc, #16]	; (800af48 <_dbg_check_lock_from_isr+0x28>)
 800af36:	f7ff ff79 	bl	800ae2c <chSysHalt>
  }
  _dbg_enter_lock();
 800af3a:	4b02      	ldr	r3, [pc, #8]	; (800af44 <_dbg_check_lock_from_isr+0x24>)
 800af3c:	2201      	movs	r2, #1
 800af3e:	631a      	str	r2, [r3, #48]	; 0x30
}
 800af40:	bd80      	pop	{r7, pc}
 800af42:	bf00      	nop
 800af44:	20001338 	.word	0x20001338
 800af48:	0800e76c 	.word	0x0800e76c

0800af4c <_dbg_check_unlock_from_isr>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
<<<<<<< HEAD
 800aec4:	b580      	push	{r7, lr}
 800aec6:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800aec8:	4b07      	ldr	r3, [pc, #28]	; (800aee8 <_dbg_check_unlock_from_isr+0x24>)
 800aeca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aecc:	2b00      	cmp	r3, #0
 800aece:	dd03      	ble.n	800aed8 <_dbg_check_unlock_from_isr+0x14>
 800aed0:	4b05      	ldr	r3, [pc, #20]	; (800aee8 <_dbg_check_unlock_from_isr+0x24>)
 800aed2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aed4:	2b00      	cmp	r3, #0
 800aed6:	dc02      	bgt.n	800aede <_dbg_check_unlock_from_isr+0x1a>
    chSysHalt("SV#7");
 800aed8:	4804      	ldr	r0, [pc, #16]	; (800aeec <_dbg_check_unlock_from_isr+0x28>)
 800aeda:	f7ff ff63 	bl	800ada4 <chSysHalt>
  }
  _dbg_leave_lock();
 800aede:	4b02      	ldr	r3, [pc, #8]	; (800aee8 <_dbg_check_unlock_from_isr+0x24>)
 800aee0:	2200      	movs	r2, #0
 800aee2:	631a      	str	r2, [r3, #48]	; 0x30
}
 800aee4:	bd80      	pop	{r7, pc}
 800aee6:	bf00      	nop
 800aee8:	20001338 	.word	0x20001338
 800aeec:	0800e698 	.word	0x0800e698

0800aef0 <_dbg_check_enter_isr>:
=======
 800af4c:	b580      	push	{r7, lr}
 800af4e:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800af50:	4b07      	ldr	r3, [pc, #28]	; (800af70 <_dbg_check_unlock_from_isr+0x24>)
 800af52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af54:	2b00      	cmp	r3, #0
 800af56:	dd03      	ble.n	800af60 <_dbg_check_unlock_from_isr+0x14>
 800af58:	4b05      	ldr	r3, [pc, #20]	; (800af70 <_dbg_check_unlock_from_isr+0x24>)
 800af5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af5c:	2b00      	cmp	r3, #0
 800af5e:	dc02      	bgt.n	800af66 <_dbg_check_unlock_from_isr+0x1a>
    chSysHalt("SV#7");
 800af60:	4804      	ldr	r0, [pc, #16]	; (800af74 <_dbg_check_unlock_from_isr+0x28>)
 800af62:	f7ff ff63 	bl	800ae2c <chSysHalt>
  }
  _dbg_leave_lock();
 800af66:	4b02      	ldr	r3, [pc, #8]	; (800af70 <_dbg_check_unlock_from_isr+0x24>)
 800af68:	2200      	movs	r2, #0
 800af6a:	631a      	str	r2, [r3, #48]	; 0x30
}
 800af6c:	bd80      	pop	{r7, pc}
 800af6e:	bf00      	nop
 800af70:	20001338 	.word	0x20001338
 800af74:	0800e774 	.word	0x0800e774

0800af78 <_dbg_check_enter_isr>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
<<<<<<< HEAD
 800aef0:	b580      	push	{r7, lr}
 800aef2:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800aef4:	f7ff ff86 	bl	800ae04 <port_lock_from_isr.lto_priv.322>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800aef8:	4b09      	ldr	r3, [pc, #36]	; (800af20 <_dbg_check_enter_isr+0x30>)
 800aefa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aefc:	2b00      	cmp	r3, #0
 800aefe:	db03      	blt.n	800af08 <_dbg_check_enter_isr+0x18>
 800af00:	4b07      	ldr	r3, [pc, #28]	; (800af20 <_dbg_check_enter_isr+0x30>)
 800af02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af04:	2b00      	cmp	r3, #0
 800af06:	d002      	beq.n	800af0e <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
 800af08:	4806      	ldr	r0, [pc, #24]	; (800af24 <_dbg_check_enter_isr+0x34>)
 800af0a:	f7ff ff4b 	bl	800ada4 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800af0e:	4b04      	ldr	r3, [pc, #16]	; (800af20 <_dbg_check_enter_isr+0x30>)
 800af10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af12:	3301      	adds	r3, #1
 800af14:	4a02      	ldr	r2, [pc, #8]	; (800af20 <_dbg_check_enter_isr+0x30>)
 800af16:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 800af18:	f7ff ff7a 	bl	800ae10 <port_unlock_from_isr.lto_priv.320>
}
 800af1c:	bd80      	pop	{r7, pc}
 800af1e:	bf00      	nop
 800af20:	20001338 	.word	0x20001338
 800af24:	0800e6a0 	.word	0x0800e6a0

0800af28 <_dbg_check_leave_isr>:
=======
 800af78:	b580      	push	{r7, lr}
 800af7a:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800af7c:	f7ff ff86 	bl	800ae8c <port_lock_from_isr.lto_priv.319>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800af80:	4b09      	ldr	r3, [pc, #36]	; (800afa8 <_dbg_check_enter_isr+0x30>)
 800af82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af84:	2b00      	cmp	r3, #0
 800af86:	db03      	blt.n	800af90 <_dbg_check_enter_isr+0x18>
 800af88:	4b07      	ldr	r3, [pc, #28]	; (800afa8 <_dbg_check_enter_isr+0x30>)
 800af8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af8c:	2b00      	cmp	r3, #0
 800af8e:	d002      	beq.n	800af96 <_dbg_check_enter_isr+0x1e>
    chSysHalt("SV#8");
 800af90:	4806      	ldr	r0, [pc, #24]	; (800afac <_dbg_check_enter_isr+0x34>)
 800af92:	f7ff ff4b 	bl	800ae2c <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800af96:	4b04      	ldr	r3, [pc, #16]	; (800afa8 <_dbg_check_enter_isr+0x30>)
 800af98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af9a:	3301      	adds	r3, #1
 800af9c:	4a02      	ldr	r2, [pc, #8]	; (800afa8 <_dbg_check_enter_isr+0x30>)
 800af9e:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 800afa0:	f7ff ff7a 	bl	800ae98 <port_unlock_from_isr.lto_priv.317>
}
 800afa4:	bd80      	pop	{r7, pc}
 800afa6:	bf00      	nop
 800afa8:	20001338 	.word	0x20001338
 800afac:	0800e77c 	.word	0x0800e77c

0800afb0 <_dbg_check_leave_isr>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
<<<<<<< HEAD
 800af28:	b580      	push	{r7, lr}
 800af2a:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800af2c:	f7ff ff6a 	bl	800ae04 <port_lock_from_isr.lto_priv.322>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800af30:	4b09      	ldr	r3, [pc, #36]	; (800af58 <_dbg_check_leave_isr+0x30>)
 800af32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af34:	2b00      	cmp	r3, #0
 800af36:	dd03      	ble.n	800af40 <_dbg_check_leave_isr+0x18>
 800af38:	4b07      	ldr	r3, [pc, #28]	; (800af58 <_dbg_check_leave_isr+0x30>)
 800af3a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af3c:	2b00      	cmp	r3, #0
 800af3e:	d002      	beq.n	800af46 <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
 800af40:	4806      	ldr	r0, [pc, #24]	; (800af5c <_dbg_check_leave_isr+0x34>)
 800af42:	f7ff ff2f 	bl	800ada4 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800af46:	4b04      	ldr	r3, [pc, #16]	; (800af58 <_dbg_check_leave_isr+0x30>)
 800af48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af4a:	3b01      	subs	r3, #1
 800af4c:	4a02      	ldr	r2, [pc, #8]	; (800af58 <_dbg_check_leave_isr+0x30>)
 800af4e:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 800af50:	f7ff ff5e 	bl	800ae10 <port_unlock_from_isr.lto_priv.320>
}
 800af54:	bd80      	pop	{r7, pc}
 800af56:	bf00      	nop
 800af58:	20001338 	.word	0x20001338
 800af5c:	0800e6a8 	.word	0x0800e6a8

0800af60 <chDbgCheckClassI>:
=======
 800afb0:	b580      	push	{r7, lr}
 800afb2:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800afb4:	f7ff ff6a 	bl	800ae8c <port_lock_from_isr.lto_priv.319>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800afb8:	4b09      	ldr	r3, [pc, #36]	; (800afe0 <_dbg_check_leave_isr+0x30>)
 800afba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800afbc:	2b00      	cmp	r3, #0
 800afbe:	dd03      	ble.n	800afc8 <_dbg_check_leave_isr+0x18>
 800afc0:	4b07      	ldr	r3, [pc, #28]	; (800afe0 <_dbg_check_leave_isr+0x30>)
 800afc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800afc4:	2b00      	cmp	r3, #0
 800afc6:	d002      	beq.n	800afce <_dbg_check_leave_isr+0x1e>
    chSysHalt("SV#9");
 800afc8:	4806      	ldr	r0, [pc, #24]	; (800afe4 <_dbg_check_leave_isr+0x34>)
 800afca:	f7ff ff2f 	bl	800ae2c <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800afce:	4b04      	ldr	r3, [pc, #16]	; (800afe0 <_dbg_check_leave_isr+0x30>)
 800afd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800afd2:	3b01      	subs	r3, #1
 800afd4:	4a02      	ldr	r2, [pc, #8]	; (800afe0 <_dbg_check_leave_isr+0x30>)
 800afd6:	62d3      	str	r3, [r2, #44]	; 0x2c
  port_unlock_from_isr();
 800afd8:	f7ff ff5e 	bl	800ae98 <port_unlock_from_isr.lto_priv.317>
}
 800afdc:	bd80      	pop	{r7, pc}
 800afde:	bf00      	nop
 800afe0:	20001338 	.word	0x20001338
 800afe4:	0800e784 	.word	0x0800e784

0800afe8 <chDbgCheckClassI>:
>>>>>>> 752c83b... update binaries
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
<<<<<<< HEAD
 800af60:	b580      	push	{r7, lr}
 800af62:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800af64:	4b05      	ldr	r3, [pc, #20]	; (800af7c <chDbgCheckClassI+0x1c>)
 800af66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af68:	2b00      	cmp	r3, #0
 800af6a:	db03      	blt.n	800af74 <chDbgCheckClassI+0x14>
 800af6c:	4b03      	ldr	r3, [pc, #12]	; (800af7c <chDbgCheckClassI+0x1c>)
 800af6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af70:	2b00      	cmp	r3, #0
 800af72:	dc02      	bgt.n	800af7a <chDbgCheckClassI+0x1a>
    chSysHalt("SV#10");
 800af74:	4802      	ldr	r0, [pc, #8]	; (800af80 <chDbgCheckClassI+0x20>)
 800af76:	f7ff ff15 	bl	800ada4 <chSysHalt>
  }
}
 800af7a:	bd80      	pop	{r7, pc}
 800af7c:	20001338 	.word	0x20001338
 800af80:	0800e6b0 	.word	0x0800e6b0

0800af84 <chDbgCheckClassS>:
=======
 800afe8:	b580      	push	{r7, lr}
 800afea:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800afec:	4b05      	ldr	r3, [pc, #20]	; (800b004 <chDbgCheckClassI+0x1c>)
 800afee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aff0:	2b00      	cmp	r3, #0
 800aff2:	db03      	blt.n	800affc <chDbgCheckClassI+0x14>
 800aff4:	4b03      	ldr	r3, [pc, #12]	; (800b004 <chDbgCheckClassI+0x1c>)
 800aff6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aff8:	2b00      	cmp	r3, #0
 800affa:	dc02      	bgt.n	800b002 <chDbgCheckClassI+0x1a>
    chSysHalt("SV#10");
 800affc:	4802      	ldr	r0, [pc, #8]	; (800b008 <chDbgCheckClassI+0x20>)
 800affe:	f7ff ff15 	bl	800ae2c <chSysHalt>
  }
}
 800b002:	bd80      	pop	{r7, pc}
 800b004:	20001338 	.word	0x20001338
 800b008:	0800e78c 	.word	0x0800e78c

0800b00c <chDbgCheckClassS>:
>>>>>>> 752c83b... update binaries
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
<<<<<<< HEAD
 800af84:	b580      	push	{r7, lr}
 800af86:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800af88:	4b05      	ldr	r3, [pc, #20]	; (800afa0 <chDbgCheckClassS+0x1c>)
 800af8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800af8c:	2b00      	cmp	r3, #0
 800af8e:	d103      	bne.n	800af98 <chDbgCheckClassS+0x14>
 800af90:	4b03      	ldr	r3, [pc, #12]	; (800afa0 <chDbgCheckClassS+0x1c>)
 800af92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800af94:	2b00      	cmp	r3, #0
 800af96:	dc02      	bgt.n	800af9e <chDbgCheckClassS+0x1a>
    chSysHalt("SV#11");
 800af98:	4802      	ldr	r0, [pc, #8]	; (800afa4 <chDbgCheckClassS+0x20>)
 800af9a:	f7ff ff03 	bl	800ada4 <chSysHalt>
  }
}
 800af9e:	bd80      	pop	{r7, pc}
 800afa0:	20001338 	.word	0x20001338
 800afa4:	0800e6b8 	.word	0x0800e6b8

0800afa8 <st_lld_get_counter.lto_priv.307>:
=======
 800b00c:	b580      	push	{r7, lr}
 800b00e:	af00      	add	r7, sp, #0

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800b010:	4b05      	ldr	r3, [pc, #20]	; (800b028 <chDbgCheckClassS+0x1c>)
 800b012:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b014:	2b00      	cmp	r3, #0
 800b016:	d103      	bne.n	800b020 <chDbgCheckClassS+0x14>
 800b018:	4b03      	ldr	r3, [pc, #12]	; (800b028 <chDbgCheckClassS+0x1c>)
 800b01a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b01c:	2b00      	cmp	r3, #0
 800b01e:	dc02      	bgt.n	800b026 <chDbgCheckClassS+0x1a>
    chSysHalt("SV#11");
 800b020:	4802      	ldr	r0, [pc, #8]	; (800b02c <chDbgCheckClassS+0x20>)
 800b022:	f7ff ff03 	bl	800ae2c <chSysHalt>
  }
}
 800b026:	bd80      	pop	{r7, pc}
 800b028:	20001338 	.word	0x20001338
 800b02c:	0800e794 	.word	0x0800e794

0800b030 <st_lld_get_counter.lto_priv.304>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
<<<<<<< HEAD
 800afa8:	b480      	push	{r7}
 800afaa:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800afac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800afb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800afb2:	b29b      	uxth	r3, r3
}
 800afb4:	4618      	mov	r0, r3
 800afb6:	46bd      	mov	sp, r7
 800afb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800afbc:	4770      	bx	lr
 800afbe:	bf00      	nop

0800afc0 <port_timer_start_alarm>:
=======
 800b030:	b480      	push	{r7}
 800b032:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800b034:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b038:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b03a:	b29b      	uxth	r3, r3
}
 800b03c:	4618      	mov	r0, r3
 800b03e:	46bd      	mov	sp, r7
 800b040:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b044:	4770      	bx	lr
 800b046:	bf00      	nop

0800b048 <port_timer_start_alarm>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
<<<<<<< HEAD
 800afc0:	b580      	push	{r7, lr}
 800afc2:	b082      	sub	sp, #8
 800afc4:	af00      	add	r7, sp, #0
 800afc6:	4603      	mov	r3, r0
 800afc8:	80fb      	strh	r3, [r7, #6]

  stStartAlarm(time);
 800afca:	88fb      	ldrh	r3, [r7, #6]
 800afcc:	4618      	mov	r0, r3
 800afce:	f7fe f83d 	bl	800904c <stStartAlarm>
}
 800afd2:	3708      	adds	r7, #8
 800afd4:	46bd      	mov	sp, r7
 800afd6:	bd80      	pop	{r7, pc}

0800afd8 <port_timer_stop_alarm>:
=======
 800b048:	b580      	push	{r7, lr}
 800b04a:	b082      	sub	sp, #8
 800b04c:	af00      	add	r7, sp, #0
 800b04e:	4603      	mov	r3, r0
 800b050:	80fb      	strh	r3, [r7, #6]

  stStartAlarm(time);
 800b052:	88fb      	ldrh	r3, [r7, #6]
 800b054:	4618      	mov	r0, r3
 800b056:	f7fe f83b 	bl	80090d0 <stStartAlarm>
}
 800b05a:	3708      	adds	r7, #8
 800b05c:	46bd      	mov	sp, r7
 800b05e:	bd80      	pop	{r7, pc}

0800b060 <port_timer_stop_alarm>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
<<<<<<< HEAD
 800afd8:	b580      	push	{r7, lr}
 800afda:	af00      	add	r7, sp, #0

  stStopAlarm();
 800afdc:	f7fe f84c 	bl	8009078 <stStopAlarm>
}
 800afe0:	bd80      	pop	{r7, pc}
 800afe2:	bf00      	nop

0800afe4 <port_timer_set_alarm>:
=======
 800b060:	b580      	push	{r7, lr}
 800b062:	af00      	add	r7, sp, #0

  stStopAlarm();
 800b064:	f7fe f84a 	bl	80090fc <stStopAlarm>
}
 800b068:	bd80      	pop	{r7, pc}
 800b06a:	bf00      	nop

0800b06c <port_timer_set_alarm>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
<<<<<<< HEAD
 800afe4:	b580      	push	{r7, lr}
 800afe6:	b082      	sub	sp, #8
 800afe8:	af00      	add	r7, sp, #0
 800afea:	4603      	mov	r3, r0
 800afec:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 800afee:	88fb      	ldrh	r3, [r7, #6]
 800aff0:	4618      	mov	r0, r3
 800aff2:	f7fe f847 	bl	8009084 <stSetAlarm>
}
 800aff6:	3708      	adds	r7, #8
 800aff8:	46bd      	mov	sp, r7
 800affa:	bd80      	pop	{r7, pc}

0800affc <port_timer_get_time.lto_priv.305>:
=======
 800b06c:	b580      	push	{r7, lr}
 800b06e:	b082      	sub	sp, #8
 800b070:	af00      	add	r7, sp, #0
 800b072:	4603      	mov	r3, r0
 800b074:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 800b076:	88fb      	ldrh	r3, [r7, #6]
 800b078:	4618      	mov	r0, r3
 800b07a:	f7fe f845 	bl	8009108 <stSetAlarm>
}
 800b07e:	3708      	adds	r7, #8
 800b080:	46bd      	mov	sp, r7
 800b082:	bd80      	pop	{r7, pc}

0800b084 <port_timer_get_time.lto_priv.302>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
<<<<<<< HEAD
 800affc:	b580      	push	{r7, lr}
 800affe:	af00      	add	r7, sp, #0

  return stGetCounter();
 800b000:	f7ff ffd2 	bl	800afa8 <st_lld_get_counter.lto_priv.307>
 800b004:	4603      	mov	r3, r0
}
 800b006:	4618      	mov	r0, r3
 800b008:	bd80      	pop	{r7, pc}
 800b00a:	bf00      	nop

0800b00c <chVTGetSystemTimeX>:
=======
 800b084:	b580      	push	{r7, lr}
 800b086:	af00      	add	r7, sp, #0

  return stGetCounter();
 800b088:	f7ff ffd2 	bl	800b030 <st_lld_get_counter.lto_priv.304>
 800b08c:	4603      	mov	r3, r0
}
 800b08e:	4618      	mov	r0, r3
 800b090:	bd80      	pop	{r7, pc}
 800b092:	bf00      	nop

0800b094 <chVTGetSystemTimeX>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
<<<<<<< HEAD
 800b00c:	b580      	push	{r7, lr}
 800b00e:	af00      	add	r7, sp, #0
=======
 800b094:	b580      	push	{r7, lr}
 800b096:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
<<<<<<< HEAD
 800b010:	f7ff fff4 	bl	800affc <port_timer_get_time.lto_priv.305>
 800b014:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b016:	4618      	mov	r0, r3
 800b018:	bd80      	pop	{r7, pc}
 800b01a:	bf00      	nop

0800b01c <_vt_init>:
=======
 800b098:	f7ff fff4 	bl	800b084 <port_timer_get_time.lto_priv.302>
 800b09c:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b09e:	4618      	mov	r0, r3
 800b0a0:	bd80      	pop	{r7, pc}
 800b0a2:	bf00      	nop

0800b0a4 <_vt_init>:
>>>>>>> 752c83b... update binaries
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
<<<<<<< HEAD
 800b01c:	b480      	push	{r7}
 800b01e:	af00      	add	r7, sp, #0

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 800b020:	4b08      	ldr	r3, [pc, #32]	; (800b044 <_vt_init+0x28>)
 800b022:	4a09      	ldr	r2, [pc, #36]	; (800b048 <_vt_init+0x2c>)
 800b024:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800b026:	4b07      	ldr	r3, [pc, #28]	; (800b044 <_vt_init+0x28>)
 800b028:	4a07      	ldr	r2, [pc, #28]	; (800b048 <_vt_init+0x2c>)
 800b02a:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 800b02c:	4b05      	ldr	r3, [pc, #20]	; (800b044 <_vt_init+0x28>)
 800b02e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b032:	849a      	strh	r2, [r3, #36]	; 0x24
=======
 800b0a4:	b480      	push	{r7}
 800b0a6:	af00      	add	r7, sp, #0

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 800b0a8:	4b08      	ldr	r3, [pc, #32]	; (800b0cc <_vt_init+0x28>)
 800b0aa:	4a09      	ldr	r2, [pc, #36]	; (800b0d0 <_vt_init+0x2c>)
 800b0ac:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800b0ae:	4b07      	ldr	r3, [pc, #28]	; (800b0cc <_vt_init+0x28>)
 800b0b0:	4a07      	ldr	r2, [pc, #28]	; (800b0d0 <_vt_init+0x2c>)
 800b0b2:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 800b0b4:	4b05      	ldr	r3, [pc, #20]	; (800b0cc <_vt_init+0x28>)
 800b0b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b0ba:	849a      	strh	r2, [r3, #36]	; 0x24
>>>>>>> 752c83b... update binaries
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
<<<<<<< HEAD
 800b034:	4b03      	ldr	r3, [pc, #12]	; (800b044 <_vt_init+0x28>)
 800b036:	2200      	movs	r2, #0
 800b038:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b03a:	46bd      	mov	sp, r7
 800b03c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b040:	4770      	bx	lr
 800b042:	bf00      	nop
 800b044:	20001338 	.word	0x20001338
 800b048:	20001354 	.word	0x20001354

0800b04c <chVTDoSetI>:
=======
 800b0bc:	4b03      	ldr	r3, [pc, #12]	; (800b0cc <_vt_init+0x28>)
 800b0be:	2200      	movs	r2, #0
 800b0c0:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b0c2:	46bd      	mov	sp, r7
 800b0c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0c8:	4770      	bx	lr
 800b0ca:	bf00      	nop
 800b0cc:	20001338 	.word	0x20001338
 800b0d0:	20001354 	.word	0x20001354

0800b0d4 <chVTDoSetI>:
>>>>>>> 752c83b... update binaries
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
<<<<<<< HEAD
 800b04c:	b580      	push	{r7, lr}
 800b04e:	b086      	sub	sp, #24
 800b050:	af00      	add	r7, sp, #0
 800b052:	60f8      	str	r0, [r7, #12]
 800b054:	607a      	str	r2, [r7, #4]
 800b056:	603b      	str	r3, [r7, #0]
 800b058:	460b      	mov	r3, r1
 800b05a:	817b      	strh	r3, [r7, #10]
=======
 800b0d4:	b580      	push	{r7, lr}
 800b0d6:	b086      	sub	sp, #24
 800b0d8:	af00      	add	r7, sp, #0
 800b0da:	60f8      	str	r0, [r7, #12]
 800b0dc:	607a      	str	r2, [r7, #4]
 800b0de:	603b      	str	r3, [r7, #0]
 800b0e0:	460b      	mov	r3, r1
 800b0e2:	817b      	strh	r3, [r7, #10]
>>>>>>> 752c83b... update binaries
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
<<<<<<< HEAD
 800b05c:	f7ff ff80 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800b060:	68fb      	ldr	r3, [r7, #12]
 800b062:	2b00      	cmp	r3, #0
 800b064:	d005      	beq.n	800b072 <chVTDoSetI+0x26>
 800b066:	687b      	ldr	r3, [r7, #4]
 800b068:	2b00      	cmp	r3, #0
 800b06a:	d002      	beq.n	800b072 <chVTDoSetI+0x26>
 800b06c:	897b      	ldrh	r3, [r7, #10]
 800b06e:	2b00      	cmp	r3, #0
 800b070:	d102      	bne.n	800b078 <chVTDoSetI+0x2c>
 800b072:	4847      	ldr	r0, [pc, #284]	; (800b190 <chVTDoSetI+0x144>)
 800b074:	f7ff fe96 	bl	800ada4 <chSysHalt>

  vtp->par = par;
 800b078:	68fb      	ldr	r3, [r7, #12]
 800b07a:	683a      	ldr	r2, [r7, #0]
 800b07c:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 800b07e:	68fb      	ldr	r3, [r7, #12]
 800b080:	687a      	ldr	r2, [r7, #4]
 800b082:	60da      	str	r2, [r3, #12]
=======
 800b0e4:	f7ff ff80 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800b0e8:	68fb      	ldr	r3, [r7, #12]
 800b0ea:	2b00      	cmp	r3, #0
 800b0ec:	d005      	beq.n	800b0fa <chVTDoSetI+0x26>
 800b0ee:	687b      	ldr	r3, [r7, #4]
 800b0f0:	2b00      	cmp	r3, #0
 800b0f2:	d002      	beq.n	800b0fa <chVTDoSetI+0x26>
 800b0f4:	897b      	ldrh	r3, [r7, #10]
 800b0f6:	2b00      	cmp	r3, #0
 800b0f8:	d102      	bne.n	800b100 <chVTDoSetI+0x2c>
 800b0fa:	4847      	ldr	r0, [pc, #284]	; (800b218 <chVTDoSetI+0x144>)
 800b0fc:	f7ff fe96 	bl	800ae2c <chSysHalt>

  vtp->par = par;
 800b100:	68fb      	ldr	r3, [r7, #12]
 800b102:	683a      	ldr	r2, [r7, #0]
 800b104:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 800b106:	68fb      	ldr	r3, [r7, #12]
 800b108:	687a      	ldr	r2, [r7, #4]
 800b10a:	60da      	str	r2, [r3, #12]
>>>>>>> 752c83b... update binaries

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
<<<<<<< HEAD
 800b084:	f7ff ffc2 	bl	800b00c <chVTGetSystemTimeX>
 800b088:	4603      	mov	r3, r0
 800b08a:	823b      	strh	r3, [r7, #16]
=======
 800b10c:	f7ff ffc2 	bl	800b094 <chVTGetSystemTimeX>
 800b110:	4603      	mov	r3, r0
 800b112:	823b      	strh	r3, [r7, #16]
>>>>>>> 752c83b... update binaries

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
<<<<<<< HEAD
 800b08c:	897b      	ldrh	r3, [r7, #10]
 800b08e:	2b01      	cmp	r3, #1
 800b090:	d801      	bhi.n	800b096 <chVTDoSetI+0x4a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b092:	2302      	movs	r3, #2
 800b094:	817b      	strh	r3, [r7, #10]
=======
 800b114:	897b      	ldrh	r3, [r7, #10]
 800b116:	2b01      	cmp	r3, #1
 800b118:	d801      	bhi.n	800b11e <chVTDoSetI+0x4a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b11a:	2302      	movs	r3, #2
 800b11c:	817b      	strh	r3, [r7, #10]
>>>>>>> 752c83b... update binaries
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
<<<<<<< HEAD
 800b096:	4b3f      	ldr	r3, [pc, #252]	; (800b194 <chVTDoSetI+0x148>)
 800b098:	69db      	ldr	r3, [r3, #28]
 800b09a:	4a3f      	ldr	r2, [pc, #252]	; (800b198 <chVTDoSetI+0x14c>)
 800b09c:	4293      	cmp	r3, r2
 800b09e:	d11a      	bne.n	800b0d6 <chVTDoSetI+0x8a>
=======
 800b11e:	4b3f      	ldr	r3, [pc, #252]	; (800b21c <chVTDoSetI+0x148>)
 800b120:	69db      	ldr	r3, [r3, #28]
 800b122:	4a3f      	ldr	r2, [pc, #252]	; (800b220 <chVTDoSetI+0x14c>)
 800b124:	4293      	cmp	r3, r2
 800b126:	d11a      	bne.n	800b15e <chVTDoSetI+0x8a>
>>>>>>> 752c83b... update binaries

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
<<<<<<< HEAD
 800b0a0:	4a3c      	ldr	r2, [pc, #240]	; (800b194 <chVTDoSetI+0x148>)
 800b0a2:	8a3b      	ldrh	r3, [r7, #16]
 800b0a4:	84d3      	strh	r3, [r2, #38]	; 0x26
      ch.vtlist.next = vtp;
 800b0a6:	4a3b      	ldr	r2, [pc, #236]	; (800b194 <chVTDoSetI+0x148>)
 800b0a8:	68fb      	ldr	r3, [r7, #12]
 800b0aa:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 800b0ac:	4a39      	ldr	r2, [pc, #228]	; (800b194 <chVTDoSetI+0x148>)
 800b0ae:	68fb      	ldr	r3, [r7, #12]
 800b0b0:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800b0b2:	68fb      	ldr	r3, [r7, #12]
 800b0b4:	4a38      	ldr	r2, [pc, #224]	; (800b198 <chVTDoSetI+0x14c>)
 800b0b6:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800b0b8:	68fb      	ldr	r3, [r7, #12]
 800b0ba:	4a37      	ldr	r2, [pc, #220]	; (800b198 <chVTDoSetI+0x14c>)
 800b0bc:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 800b0be:	68fb      	ldr	r3, [r7, #12]
 800b0c0:	897a      	ldrh	r2, [r7, #10]
 800b0c2:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 800b0c4:	4b33      	ldr	r3, [pc, #204]	; (800b194 <chVTDoSetI+0x148>)
 800b0c6:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b0c8:	897b      	ldrh	r3, [r7, #10]
 800b0ca:	4413      	add	r3, r2
 800b0cc:	b29b      	uxth	r3, r3
 800b0ce:	4618      	mov	r0, r3
 800b0d0:	f7ff ff76 	bl	800afc0 <port_timer_start_alarm>
 800b0d4:	e059      	b.n	800b18a <chVTDoSetI+0x13e>
=======
 800b128:	4a3c      	ldr	r2, [pc, #240]	; (800b21c <chVTDoSetI+0x148>)
 800b12a:	8a3b      	ldrh	r3, [r7, #16]
 800b12c:	84d3      	strh	r3, [r2, #38]	; 0x26
      ch.vtlist.next = vtp;
 800b12e:	4a3b      	ldr	r2, [pc, #236]	; (800b21c <chVTDoSetI+0x148>)
 800b130:	68fb      	ldr	r3, [r7, #12]
 800b132:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 800b134:	4a39      	ldr	r2, [pc, #228]	; (800b21c <chVTDoSetI+0x148>)
 800b136:	68fb      	ldr	r3, [r7, #12]
 800b138:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800b13a:	68fb      	ldr	r3, [r7, #12]
 800b13c:	4a38      	ldr	r2, [pc, #224]	; (800b220 <chVTDoSetI+0x14c>)
 800b13e:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800b140:	68fb      	ldr	r3, [r7, #12]
 800b142:	4a37      	ldr	r2, [pc, #220]	; (800b220 <chVTDoSetI+0x14c>)
 800b144:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 800b146:	68fb      	ldr	r3, [r7, #12]
 800b148:	897a      	ldrh	r2, [r7, #10]
 800b14a:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 800b14c:	4b33      	ldr	r3, [pc, #204]	; (800b21c <chVTDoSetI+0x148>)
 800b14e:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b150:	897b      	ldrh	r3, [r7, #10]
 800b152:	4413      	add	r3, r2
 800b154:	b29b      	uxth	r3, r3
 800b156:	4618      	mov	r0, r3
 800b158:	f7ff ff76 	bl	800b048 <port_timer_start_alarm>
 800b15c:	e059      	b.n	800b212 <chVTDoSetI+0x13e>
>>>>>>> 752c83b... update binaries

      return;
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
<<<<<<< HEAD
 800b0d6:	4b2f      	ldr	r3, [pc, #188]	; (800b194 <chVTDoSetI+0x148>)
 800b0d8:	69db      	ldr	r3, [r3, #28]
 800b0da:	617b      	str	r3, [r7, #20]
=======
 800b15e:	4b2f      	ldr	r3, [pc, #188]	; (800b21c <chVTDoSetI+0x148>)
 800b160:	69db      	ldr	r3, [r3, #28]
 800b162:	617b      	str	r3, [r7, #20]
>>>>>>> 752c83b... update binaries

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
<<<<<<< HEAD
 800b0dc:	4b2d      	ldr	r3, [pc, #180]	; (800b194 <chVTDoSetI+0x148>)
 800b0de:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b0e0:	8a3a      	ldrh	r2, [r7, #16]
 800b0e2:	1ad3      	subs	r3, r2, r3
 800b0e4:	b29a      	uxth	r2, r3
 800b0e6:	897b      	ldrh	r3, [r7, #10]
 800b0e8:	4413      	add	r3, r2
 800b0ea:	827b      	strh	r3, [r7, #18]

    if (delta < now - ch.vtlist.lasttime) {
 800b0ec:	8a7a      	ldrh	r2, [r7, #18]
 800b0ee:	8a3b      	ldrh	r3, [r7, #16]
 800b0f0:	4928      	ldr	r1, [pc, #160]	; (800b194 <chVTDoSetI+0x148>)
 800b0f2:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 800b0f4:	1a5b      	subs	r3, r3, r1
 800b0f6:	429a      	cmp	r2, r3
 800b0f8:	da08      	bge.n	800b10c <chVTDoSetI+0xc0>
=======
 800b164:	4b2d      	ldr	r3, [pc, #180]	; (800b21c <chVTDoSetI+0x148>)
 800b166:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b168:	8a3a      	ldrh	r2, [r7, #16]
 800b16a:	1ad3      	subs	r3, r2, r3
 800b16c:	b29a      	uxth	r2, r3
 800b16e:	897b      	ldrh	r3, [r7, #10]
 800b170:	4413      	add	r3, r2
 800b172:	827b      	strh	r3, [r7, #18]

    if (delta < now - ch.vtlist.lasttime) {
 800b174:	8a7a      	ldrh	r2, [r7, #18]
 800b176:	8a3b      	ldrh	r3, [r7, #16]
 800b178:	4928      	ldr	r1, [pc, #160]	; (800b21c <chVTDoSetI+0x148>)
 800b17a:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 800b17c:	1a5b      	subs	r3, r3, r1
 800b17e:	429a      	cmp	r2, r3
 800b180:	da08      	bge.n	800b194 <chVTDoSetI+0xc0>
>>>>>>> 752c83b... update binaries
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
<<<<<<< HEAD
 800b0fa:	697b      	ldr	r3, [r7, #20]
 800b0fc:	891b      	ldrh	r3, [r3, #8]
 800b0fe:	8a7a      	ldrh	r2, [r7, #18]
 800b100:	1ad3      	subs	r3, r2, r3
 800b102:	827b      	strh	r3, [r7, #18]
      p = p->next;
 800b104:	697b      	ldr	r3, [r7, #20]
 800b106:	681b      	ldr	r3, [r3, #0]
 800b108:	617b      	str	r3, [r7, #20]
 800b10a:	e01c      	b.n	800b146 <chVTDoSetI+0xfa>
    }
    else if (delta < p->delta) {
 800b10c:	697b      	ldr	r3, [r7, #20]
 800b10e:	891b      	ldrh	r3, [r3, #8]
 800b110:	8a7a      	ldrh	r2, [r7, #18]
 800b112:	429a      	cmp	r2, r3
 800b114:	d217      	bcs.n	800b146 <chVTDoSetI+0xfa>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 800b116:	4b1f      	ldr	r3, [pc, #124]	; (800b194 <chVTDoSetI+0x148>)
 800b118:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b11a:	8a7b      	ldrh	r3, [r7, #18]
 800b11c:	4413      	add	r3, r2
 800b11e:	b29b      	uxth	r3, r3
 800b120:	4618      	mov	r0, r3
 800b122:	f7ff ff5f 	bl	800afe4 <port_timer_set_alarm>
 800b126:	e00e      	b.n	800b146 <chVTDoSetI+0xfa>
=======
 800b182:	697b      	ldr	r3, [r7, #20]
 800b184:	891b      	ldrh	r3, [r3, #8]
 800b186:	8a7a      	ldrh	r2, [r7, #18]
 800b188:	1ad3      	subs	r3, r2, r3
 800b18a:	827b      	strh	r3, [r7, #18]
      p = p->next;
 800b18c:	697b      	ldr	r3, [r7, #20]
 800b18e:	681b      	ldr	r3, [r3, #0]
 800b190:	617b      	str	r3, [r7, #20]
 800b192:	e01c      	b.n	800b1ce <chVTDoSetI+0xfa>
    }
    else if (delta < p->delta) {
 800b194:	697b      	ldr	r3, [r7, #20]
 800b196:	891b      	ldrh	r3, [r3, #8]
 800b198:	8a7a      	ldrh	r2, [r7, #18]
 800b19a:	429a      	cmp	r2, r3
 800b19c:	d217      	bcs.n	800b1ce <chVTDoSetI+0xfa>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 800b19e:	4b1f      	ldr	r3, [pc, #124]	; (800b21c <chVTDoSetI+0x148>)
 800b1a0:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b1a2:	8a7b      	ldrh	r3, [r7, #18]
 800b1a4:	4413      	add	r3, r2
 800b1a6:	b29b      	uxth	r3, r3
 800b1a8:	4618      	mov	r0, r3
 800b1aa:	f7ff ff5f 	bl	800b06c <port_timer_set_alarm>
 800b1ae:	e00e      	b.n	800b1ce <chVTDoSetI+0xfa>
>>>>>>> 752c83b... update binaries

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
<<<<<<< HEAD
 800b128:	697a      	ldr	r2, [r7, #20]
 800b12a:	68fb      	ldr	r3, [r7, #12]
 800b12c:	429a      	cmp	r2, r3
 800b12e:	d102      	bne.n	800b136 <chVTDoSetI+0xea>
 800b130:	4817      	ldr	r0, [pc, #92]	; (800b190 <chVTDoSetI+0x144>)
 800b132:	f7ff fe37 	bl	800ada4 <chSysHalt>

    delta -= p->delta;
 800b136:	697b      	ldr	r3, [r7, #20]
 800b138:	891b      	ldrh	r3, [r3, #8]
 800b13a:	8a7a      	ldrh	r2, [r7, #18]
 800b13c:	1ad3      	subs	r3, r2, r3
 800b13e:	827b      	strh	r3, [r7, #18]
    p = p->next;
 800b140:	697b      	ldr	r3, [r7, #20]
 800b142:	681b      	ldr	r3, [r3, #0]
 800b144:	617b      	str	r3, [r7, #20]
=======
 800b1b0:	697a      	ldr	r2, [r7, #20]
 800b1b2:	68fb      	ldr	r3, [r7, #12]
 800b1b4:	429a      	cmp	r2, r3
 800b1b6:	d102      	bne.n	800b1be <chVTDoSetI+0xea>
 800b1b8:	4817      	ldr	r0, [pc, #92]	; (800b218 <chVTDoSetI+0x144>)
 800b1ba:	f7ff fe37 	bl	800ae2c <chSysHalt>

    delta -= p->delta;
 800b1be:	697b      	ldr	r3, [r7, #20]
 800b1c0:	891b      	ldrh	r3, [r3, #8]
 800b1c2:	8a7a      	ldrh	r2, [r7, #18]
 800b1c4:	1ad3      	subs	r3, r2, r3
 800b1c6:	827b      	strh	r3, [r7, #18]
    p = p->next;
 800b1c8:	697b      	ldr	r3, [r7, #20]
 800b1ca:	681b      	ldr	r3, [r3, #0]
 800b1cc:	617b      	str	r3, [r7, #20]
>>>>>>> 752c83b... update binaries
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
<<<<<<< HEAD
 800b146:	697b      	ldr	r3, [r7, #20]
 800b148:	891b      	ldrh	r3, [r3, #8]
 800b14a:	8a7a      	ldrh	r2, [r7, #18]
 800b14c:	429a      	cmp	r2, r3
 800b14e:	d8eb      	bhi.n	800b128 <chVTDoSetI+0xdc>
=======
 800b1ce:	697b      	ldr	r3, [r7, #20]
 800b1d0:	891b      	ldrh	r3, [r3, #8]
 800b1d2:	8a7a      	ldrh	r2, [r7, #18]
 800b1d4:	429a      	cmp	r2, r3
 800b1d6:	d8eb      	bhi.n	800b1b0 <chVTDoSetI+0xdc>
>>>>>>> 752c83b... update binaries
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
<<<<<<< HEAD
 800b150:	68fb      	ldr	r3, [r7, #12]
 800b152:	697a      	ldr	r2, [r7, #20]
 800b154:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 800b156:	68fb      	ldr	r3, [r7, #12]
 800b158:	681b      	ldr	r3, [r3, #0]
 800b15a:	685a      	ldr	r2, [r3, #4]
 800b15c:	68fb      	ldr	r3, [r7, #12]
 800b15e:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 800b160:	68fb      	ldr	r3, [r7, #12]
 800b162:	685b      	ldr	r3, [r3, #4]
 800b164:	68fa      	ldr	r2, [r7, #12]
 800b166:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 800b168:	697b      	ldr	r3, [r7, #20]
 800b16a:	68fa      	ldr	r2, [r7, #12]
 800b16c:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 800b16e:	68fb      	ldr	r3, [r7, #12]
 800b170:	8a7a      	ldrh	r2, [r7, #18]
 800b172:	811a      	strh	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 800b174:	697b      	ldr	r3, [r7, #20]
 800b176:	891a      	ldrh	r2, [r3, #8]
 800b178:	8a7b      	ldrh	r3, [r7, #18]
 800b17a:	1ad3      	subs	r3, r2, r3
 800b17c:	b29a      	uxth	r2, r3
 800b17e:	697b      	ldr	r3, [r7, #20]
 800b180:	811a      	strh	r2, [r3, #8]
=======
 800b1d8:	68fb      	ldr	r3, [r7, #12]
 800b1da:	697a      	ldr	r2, [r7, #20]
 800b1dc:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 800b1de:	68fb      	ldr	r3, [r7, #12]
 800b1e0:	681b      	ldr	r3, [r3, #0]
 800b1e2:	685a      	ldr	r2, [r3, #4]
 800b1e4:	68fb      	ldr	r3, [r7, #12]
 800b1e6:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 800b1e8:	68fb      	ldr	r3, [r7, #12]
 800b1ea:	685b      	ldr	r3, [r3, #4]
 800b1ec:	68fa      	ldr	r2, [r7, #12]
 800b1ee:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 800b1f0:	697b      	ldr	r3, [r7, #20]
 800b1f2:	68fa      	ldr	r2, [r7, #12]
 800b1f4:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 800b1f6:	68fb      	ldr	r3, [r7, #12]
 800b1f8:	8a7a      	ldrh	r2, [r7, #18]
 800b1fa:	811a      	strh	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 800b1fc:	697b      	ldr	r3, [r7, #20]
 800b1fe:	891a      	ldrh	r2, [r3, #8]
 800b200:	8a7b      	ldrh	r3, [r7, #18]
 800b202:	1ad3      	subs	r3, r2, r3
 800b204:	b29a      	uxth	r2, r3
 800b206:	697b      	ldr	r3, [r7, #20]
 800b208:	811a      	strh	r2, [r3, #8]
>>>>>>> 752c83b... update binaries

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (systime_t)-1;
<<<<<<< HEAD
 800b182:	4b04      	ldr	r3, [pc, #16]	; (800b194 <chVTDoSetI+0x148>)
 800b184:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b188:	849a      	strh	r2, [r3, #36]	; 0x24
}
 800b18a:	3718      	adds	r7, #24
 800b18c:	46bd      	mov	sp, r7
 800b18e:	bd80      	pop	{r7, pc}
 800b190:	0800e87c 	.word	0x0800e87c
 800b194:	20001338 	.word	0x20001338
 800b198:	20001354 	.word	0x20001354

0800b19c <chVTDoResetI>:
=======
 800b20a:	4b04      	ldr	r3, [pc, #16]	; (800b21c <chVTDoSetI+0x148>)
 800b20c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b210:	849a      	strh	r2, [r3, #36]	; 0x24
}
 800b212:	3718      	adds	r7, #24
 800b214:	46bd      	mov	sp, r7
 800b216:	bd80      	pop	{r7, pc}
 800b218:	0800e954 	.word	0x0800e954
 800b21c:	20001338 	.word	0x20001338
 800b220:	20001354 	.word	0x20001354

0800b224 <chVTDoResetI>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
<<<<<<< HEAD
 800b19c:	b580      	push	{r7, lr}
 800b19e:	b084      	sub	sp, #16
 800b1a0:	af00      	add	r7, sp, #0
 800b1a2:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800b1a4:	f7ff fedc 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800b1a8:	687b      	ldr	r3, [r7, #4]
 800b1aa:	2b00      	cmp	r3, #0
 800b1ac:	d102      	bne.n	800b1b4 <chVTDoResetI+0x18>
 800b1ae:	4838      	ldr	r0, [pc, #224]	; (800b290 <chVTDoResetI+0xf4>)
 800b1b0:	f7ff fdf8 	bl	800ada4 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 800b1b4:	687b      	ldr	r3, [r7, #4]
 800b1b6:	68db      	ldr	r3, [r3, #12]
 800b1b8:	2b00      	cmp	r3, #0
 800b1ba:	d102      	bne.n	800b1c2 <chVTDoResetI+0x26>
 800b1bc:	4834      	ldr	r0, [pc, #208]	; (800b290 <chVTDoResetI+0xf4>)
 800b1be:	f7ff fdf1 	bl	800ada4 <chSysHalt>
=======
 800b224:	b580      	push	{r7, lr}
 800b226:	b084      	sub	sp, #16
 800b228:	af00      	add	r7, sp, #0
 800b22a:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800b22c:	f7ff fedc 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800b230:	687b      	ldr	r3, [r7, #4]
 800b232:	2b00      	cmp	r3, #0
 800b234:	d102      	bne.n	800b23c <chVTDoResetI+0x18>
 800b236:	4838      	ldr	r0, [pc, #224]	; (800b318 <chVTDoResetI+0xf4>)
 800b238:	f7ff fdf8 	bl	800ae2c <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 800b23c:	687b      	ldr	r3, [r7, #4]
 800b23e:	68db      	ldr	r3, [r3, #12]
 800b240:	2b00      	cmp	r3, #0
 800b242:	d102      	bne.n	800b24a <chVTDoResetI+0x26>
 800b244:	4834      	ldr	r0, [pc, #208]	; (800b318 <chVTDoResetI+0xf4>)
 800b246:	f7ff fdf1 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
<<<<<<< HEAD
 800b1c2:	4b34      	ldr	r3, [pc, #208]	; (800b294 <chVTDoResetI+0xf8>)
 800b1c4:	69da      	ldr	r2, [r3, #28]
 800b1c6:	687b      	ldr	r3, [r7, #4]
 800b1c8:	429a      	cmp	r2, r3
 800b1ca:	d01c      	beq.n	800b206 <chVTDoResetI+0x6a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800b1cc:	687b      	ldr	r3, [r7, #4]
 800b1ce:	685b      	ldr	r3, [r3, #4]
 800b1d0:	687a      	ldr	r2, [r7, #4]
 800b1d2:	6812      	ldr	r2, [r2, #0]
 800b1d4:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 800b1d6:	687b      	ldr	r3, [r7, #4]
 800b1d8:	681b      	ldr	r3, [r3, #0]
 800b1da:	687a      	ldr	r2, [r7, #4]
 800b1dc:	6852      	ldr	r2, [r2, #4]
 800b1de:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 800b1e0:	687b      	ldr	r3, [r7, #4]
 800b1e2:	2200      	movs	r2, #0
 800b1e4:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800b1e6:	687b      	ldr	r3, [r7, #4]
 800b1e8:	681b      	ldr	r3, [r3, #0]
 800b1ea:	4a2b      	ldr	r2, [pc, #172]	; (800b298 <chVTDoResetI+0xfc>)
 800b1ec:	4293      	cmp	r3, r2
 800b1ee:	d04b      	beq.n	800b288 <chVTDoResetI+0xec>
      vtp->next->delta += vtp->delta;
 800b1f0:	687b      	ldr	r3, [r7, #4]
 800b1f2:	681b      	ldr	r3, [r3, #0]
 800b1f4:	687a      	ldr	r2, [r7, #4]
 800b1f6:	6812      	ldr	r2, [r2, #0]
 800b1f8:	8911      	ldrh	r1, [r2, #8]
 800b1fa:	687a      	ldr	r2, [r7, #4]
 800b1fc:	8912      	ldrh	r2, [r2, #8]
 800b1fe:	440a      	add	r2, r1
 800b200:	b292      	uxth	r2, r2
 800b202:	811a      	strh	r2, [r3, #8]
 800b204:	e040      	b.n	800b288 <chVTDoResetI+0xec>
=======
 800b24a:	4b34      	ldr	r3, [pc, #208]	; (800b31c <chVTDoResetI+0xf8>)
 800b24c:	69da      	ldr	r2, [r3, #28]
 800b24e:	687b      	ldr	r3, [r7, #4]
 800b250:	429a      	cmp	r2, r3
 800b252:	d01c      	beq.n	800b28e <chVTDoResetI+0x6a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800b254:	687b      	ldr	r3, [r7, #4]
 800b256:	685b      	ldr	r3, [r3, #4]
 800b258:	687a      	ldr	r2, [r7, #4]
 800b25a:	6812      	ldr	r2, [r2, #0]
 800b25c:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 800b25e:	687b      	ldr	r3, [r7, #4]
 800b260:	681b      	ldr	r3, [r3, #0]
 800b262:	687a      	ldr	r2, [r7, #4]
 800b264:	6852      	ldr	r2, [r2, #4]
 800b266:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 800b268:	687b      	ldr	r3, [r7, #4]
 800b26a:	2200      	movs	r2, #0
 800b26c:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800b26e:	687b      	ldr	r3, [r7, #4]
 800b270:	681b      	ldr	r3, [r3, #0]
 800b272:	4a2b      	ldr	r2, [pc, #172]	; (800b320 <chVTDoResetI+0xfc>)
 800b274:	4293      	cmp	r3, r2
 800b276:	d04b      	beq.n	800b310 <chVTDoResetI+0xec>
      vtp->next->delta += vtp->delta;
 800b278:	687b      	ldr	r3, [r7, #4]
 800b27a:	681b      	ldr	r3, [r3, #0]
 800b27c:	687a      	ldr	r2, [r7, #4]
 800b27e:	6812      	ldr	r2, [r2, #0]
 800b280:	8911      	ldrh	r1, [r2, #8]
 800b282:	687a      	ldr	r2, [r7, #4]
 800b284:	8912      	ldrh	r2, [r2, #8]
 800b286:	440a      	add	r2, r1
 800b288:	b292      	uxth	r2, r2
 800b28a:	811a      	strh	r2, [r3, #8]
 800b28c:	e040      	b.n	800b310 <chVTDoResetI+0xec>
>>>>>>> 752c83b... update binaries

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
<<<<<<< HEAD
 800b206:	687b      	ldr	r3, [r7, #4]
 800b208:	681b      	ldr	r3, [r3, #0]
 800b20a:	4a22      	ldr	r2, [pc, #136]	; (800b294 <chVTDoResetI+0xf8>)
 800b20c:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800b20e:	4b21      	ldr	r3, [pc, #132]	; (800b294 <chVTDoResetI+0xf8>)
 800b210:	69db      	ldr	r3, [r3, #28]
 800b212:	4a21      	ldr	r2, [pc, #132]	; (800b298 <chVTDoResetI+0xfc>)
 800b214:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 800b216:	687b      	ldr	r3, [r7, #4]
 800b218:	2200      	movs	r2, #0
 800b21a:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800b21c:	4b1d      	ldr	r3, [pc, #116]	; (800b294 <chVTDoResetI+0xf8>)
 800b21e:	69db      	ldr	r3, [r3, #28]
 800b220:	4a1d      	ldr	r2, [pc, #116]	; (800b298 <chVTDoResetI+0xfc>)
 800b222:	4293      	cmp	r3, r2
 800b224:	d102      	bne.n	800b22c <chVTDoResetI+0x90>
    port_timer_stop_alarm();
 800b226:	f7ff fed7 	bl	800afd8 <port_timer_stop_alarm>
 800b22a:	e02d      	b.n	800b288 <chVTDoResetI+0xec>
=======
 800b28e:	687b      	ldr	r3, [r7, #4]
 800b290:	681b      	ldr	r3, [r3, #0]
 800b292:	4a22      	ldr	r2, [pc, #136]	; (800b31c <chVTDoResetI+0xf8>)
 800b294:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800b296:	4b21      	ldr	r3, [pc, #132]	; (800b31c <chVTDoResetI+0xf8>)
 800b298:	69db      	ldr	r3, [r3, #28]
 800b29a:	4a21      	ldr	r2, [pc, #132]	; (800b320 <chVTDoResetI+0xfc>)
 800b29c:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 800b29e:	687b      	ldr	r3, [r7, #4]
 800b2a0:	2200      	movs	r2, #0
 800b2a2:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800b2a4:	4b1d      	ldr	r3, [pc, #116]	; (800b31c <chVTDoResetI+0xf8>)
 800b2a6:	69db      	ldr	r3, [r3, #28]
 800b2a8:	4a1d      	ldr	r2, [pc, #116]	; (800b320 <chVTDoResetI+0xfc>)
 800b2aa:	4293      	cmp	r3, r2
 800b2ac:	d102      	bne.n	800b2b4 <chVTDoResetI+0x90>
    port_timer_stop_alarm();
 800b2ae:	f7ff fed7 	bl	800b060 <port_timer_stop_alarm>
 800b2b2:	e02d      	b.n	800b310 <chVTDoResetI+0xec>
>>>>>>> 752c83b... update binaries

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
<<<<<<< HEAD
 800b22c:	4b19      	ldr	r3, [pc, #100]	; (800b294 <chVTDoResetI+0xf8>)
 800b22e:	69db      	ldr	r3, [r3, #28]
 800b230:	4a18      	ldr	r2, [pc, #96]	; (800b294 <chVTDoResetI+0xf8>)
 800b232:	69d2      	ldr	r2, [r2, #28]
 800b234:	8911      	ldrh	r1, [r2, #8]
 800b236:	687a      	ldr	r2, [r7, #4]
 800b238:	8912      	ldrh	r2, [r2, #8]
 800b23a:	440a      	add	r2, r1
 800b23c:	b292      	uxth	r2, r2
 800b23e:	811a      	strh	r2, [r3, #8]
=======
 800b2b4:	4b19      	ldr	r3, [pc, #100]	; (800b31c <chVTDoResetI+0xf8>)
 800b2b6:	69db      	ldr	r3, [r3, #28]
 800b2b8:	4a18      	ldr	r2, [pc, #96]	; (800b31c <chVTDoResetI+0xf8>)
 800b2ba:	69d2      	ldr	r2, [r2, #28]
 800b2bc:	8911      	ldrh	r1, [r2, #8]
 800b2be:	687a      	ldr	r2, [r7, #4]
 800b2c0:	8912      	ldrh	r2, [r2, #8]
 800b2c2:	440a      	add	r2, r1
 800b2c4:	b292      	uxth	r2, r2
 800b2c6:	811a      	strh	r2, [r3, #8]
>>>>>>> 752c83b... update binaries
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
<<<<<<< HEAD
 800b240:	f7ff fee4 	bl	800b00c <chVTGetSystemTimeX>
 800b244:	4603      	mov	r3, r0
 800b246:	461a      	mov	r2, r3
 800b248:	4b12      	ldr	r3, [pc, #72]	; (800b294 <chVTDoResetI+0xf8>)
 800b24a:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b24c:	1ad3      	subs	r3, r2, r3
 800b24e:	81bb      	strh	r3, [r7, #12]
=======
 800b2c8:	f7ff fee4 	bl	800b094 <chVTGetSystemTimeX>
 800b2cc:	4603      	mov	r3, r0
 800b2ce:	461a      	mov	r2, r3
 800b2d0:	4b12      	ldr	r3, [pc, #72]	; (800b31c <chVTDoResetI+0xf8>)
 800b2d2:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800b2d4:	1ad3      	subs	r3, r2, r3
 800b2d6:	81bb      	strh	r3, [r7, #12]
>>>>>>> 752c83b... update binaries

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
<<<<<<< HEAD
 800b250:	4b10      	ldr	r3, [pc, #64]	; (800b294 <chVTDoResetI+0xf8>)
 800b252:	69db      	ldr	r3, [r3, #28]
 800b254:	891b      	ldrh	r3, [r3, #8]
 800b256:	89ba      	ldrh	r2, [r7, #12]
 800b258:	429a      	cmp	r2, r3
 800b25a:	d215      	bcs.n	800b288 <chVTDoResetI+0xec>
=======
 800b2d8:	4b10      	ldr	r3, [pc, #64]	; (800b31c <chVTDoResetI+0xf8>)
 800b2da:	69db      	ldr	r3, [r3, #28]
 800b2dc:	891b      	ldrh	r3, [r3, #8]
 800b2de:	89ba      	ldrh	r2, [r7, #12]
 800b2e0:	429a      	cmp	r2, r3
 800b2e2:	d215      	bcs.n	800b310 <chVTDoResetI+0xec>
>>>>>>> 752c83b... update binaries
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
<<<<<<< HEAD
 800b25c:	4b0d      	ldr	r3, [pc, #52]	; (800b294 <chVTDoResetI+0xf8>)
 800b25e:	69db      	ldr	r3, [r3, #28]
 800b260:	891a      	ldrh	r2, [r3, #8]
 800b262:	89bb      	ldrh	r3, [r7, #12]
 800b264:	1ad3      	subs	r3, r2, r3
 800b266:	81fb      	strh	r3, [r7, #14]
=======
 800b2e4:	4b0d      	ldr	r3, [pc, #52]	; (800b31c <chVTDoResetI+0xf8>)
 800b2e6:	69db      	ldr	r3, [r3, #28]
 800b2e8:	891a      	ldrh	r2, [r3, #8]
 800b2ea:	89bb      	ldrh	r3, [r7, #12]
 800b2ec:	1ad3      	subs	r3, r2, r3
 800b2ee:	81fb      	strh	r3, [r7, #14]
>>>>>>> 752c83b... update binaries

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
<<<<<<< HEAD
 800b268:	89fb      	ldrh	r3, [r7, #14]
 800b26a:	2b01      	cmp	r3, #1
 800b26c:	d801      	bhi.n	800b272 <chVTDoResetI+0xd6>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b26e:	2302      	movs	r3, #2
 800b270:	81fb      	strh	r3, [r7, #14]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 800b272:	4b08      	ldr	r3, [pc, #32]	; (800b294 <chVTDoResetI+0xf8>)
 800b274:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b276:	89bb      	ldrh	r3, [r7, #12]
 800b278:	4413      	add	r3, r2
 800b27a:	b29a      	uxth	r2, r3
 800b27c:	89fb      	ldrh	r3, [r7, #14]
 800b27e:	4413      	add	r3, r2
 800b280:	b29b      	uxth	r3, r3
 800b282:	4618      	mov	r0, r3
 800b284:	f7ff feae 	bl	800afe4 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b288:	3710      	adds	r7, #16
 800b28a:	46bd      	mov	sp, r7
 800b28c:	bd80      	pop	{r7, pc}
 800b28e:	bf00      	nop
 800b290:	0800e888 	.word	0x0800e888
 800b294:	20001338 	.word	0x20001338
 800b298:	20001354 	.word	0x20001354

0800b29c <port_lock.lto_priv.313>:
=======
 800b2f0:	89fb      	ldrh	r3, [r7, #14]
 800b2f2:	2b01      	cmp	r3, #1
 800b2f4:	d801      	bhi.n	800b2fa <chVTDoResetI+0xd6>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b2f6:	2302      	movs	r3, #2
 800b2f8:	81fb      	strh	r3, [r7, #14]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 800b2fa:	4b08      	ldr	r3, [pc, #32]	; (800b31c <chVTDoResetI+0xf8>)
 800b2fc:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800b2fe:	89bb      	ldrh	r3, [r7, #12]
 800b300:	4413      	add	r3, r2
 800b302:	b29a      	uxth	r2, r3
 800b304:	89fb      	ldrh	r3, [r7, #14]
 800b306:	4413      	add	r3, r2
 800b308:	b29b      	uxth	r3, r3
 800b30a:	4618      	mov	r0, r3
 800b30c:	f7ff feae 	bl	800b06c <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b310:	3710      	adds	r7, #16
 800b312:	46bd      	mov	sp, r7
 800b314:	bd80      	pop	{r7, pc}
 800b316:	bf00      	nop
 800b318:	0800e960 	.word	0x0800e960
 800b31c:	20001338 	.word	0x20001338
 800b320:	20001354 	.word	0x20001354

0800b324 <port_lock.lto_priv.310>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800b29c:	b480      	push	{r7}
 800b29e:	b083      	sub	sp, #12
 800b2a0:	af00      	add	r7, sp, #0
 800b2a2:	2320      	movs	r3, #32
 800b2a4:	607b      	str	r3, [r7, #4]
 800b2a6:	687b      	ldr	r3, [r7, #4]
 800b2a8:	f383 8811 	msr	BASEPRI, r3
=======
 800b324:	b480      	push	{r7}
 800b326:	b083      	sub	sp, #12
 800b328:	af00      	add	r7, sp, #0
 800b32a:	2320      	movs	r3, #32
 800b32c:	607b      	str	r3, [r7, #4]
 800b32e:	687b      	ldr	r3, [r7, #4]
 800b330:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800b2ac:	370c      	adds	r7, #12
 800b2ae:	46bd      	mov	sp, r7
 800b2b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2b4:	4770      	bx	lr
 800b2b6:	bf00      	nop

0800b2b8 <port_unlock.lto_priv.310>:
=======
 800b334:	370c      	adds	r7, #12
 800b336:	46bd      	mov	sp, r7
 800b338:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b33c:	4770      	bx	lr
 800b33e:	bf00      	nop

0800b340 <port_unlock.lto_priv.307>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800b2b8:	b480      	push	{r7}
 800b2ba:	b083      	sub	sp, #12
 800b2bc:	af00      	add	r7, sp, #0
 800b2be:	2300      	movs	r3, #0
 800b2c0:	607b      	str	r3, [r7, #4]
 800b2c2:	687b      	ldr	r3, [r7, #4]
 800b2c4:	f383 8811 	msr	BASEPRI, r3
=======
 800b340:	b480      	push	{r7}
 800b342:	b083      	sub	sp, #12
 800b344:	af00      	add	r7, sp, #0
 800b346:	2300      	movs	r3, #0
 800b348:	607b      	str	r3, [r7, #4]
 800b34a:	687b      	ldr	r3, [r7, #4]
 800b34c:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800b2c8:	370c      	adds	r7, #12
 800b2ca:	46bd      	mov	sp, r7
 800b2cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2d0:	4770      	bx	lr
 800b2d2:	bf00      	nop

0800b2d4 <port_lock_from_isr.lto_priv.323>:
=======
 800b350:	370c      	adds	r7, #12
 800b352:	46bd      	mov	sp, r7
 800b354:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b358:	4770      	bx	lr
 800b35a:	bf00      	nop

0800b35c <port_lock_from_isr.lto_priv.320>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
<<<<<<< HEAD
 800b2d4:	b580      	push	{r7, lr}
 800b2d6:	af00      	add	r7, sp, #0

  port_lock();
 800b2d8:	f7ff ffe0 	bl	800b29c <port_lock.lto_priv.313>
}
 800b2dc:	bd80      	pop	{r7, pc}
 800b2de:	bf00      	nop

0800b2e0 <port_unlock_from_isr.lto_priv.321>:
=======
 800b35c:	b580      	push	{r7, lr}
 800b35e:	af00      	add	r7, sp, #0

  port_lock();
 800b360:	f7ff ffe0 	bl	800b324 <port_lock.lto_priv.310>
}
 800b364:	bd80      	pop	{r7, pc}
 800b366:	bf00      	nop

0800b368 <port_unlock_from_isr.lto_priv.318>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
<<<<<<< HEAD
 800b2e0:	b580      	push	{r7, lr}
 800b2e2:	af00      	add	r7, sp, #0

  port_unlock();
 800b2e4:	f7ff ffe8 	bl	800b2b8 <port_unlock.lto_priv.310>
}
 800b2e8:	bd80      	pop	{r7, pc}
 800b2ea:	bf00      	nop

0800b2ec <queue_init>:
=======
 800b368:	b580      	push	{r7, lr}
 800b36a:	af00      	add	r7, sp, #0

  port_unlock();
 800b36c:	f7ff ffe8 	bl	800b340 <port_unlock.lto_priv.307>
}
 800b370:	bd80      	pop	{r7, pc}
 800b372:	bf00      	nop

0800b374 <queue_init>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
<<<<<<< HEAD
 800b2ec:	b480      	push	{r7}
 800b2ee:	b083      	sub	sp, #12
 800b2f0:	af00      	add	r7, sp, #0
 800b2f2:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800b2f4:	687b      	ldr	r3, [r7, #4]
 800b2f6:	687a      	ldr	r2, [r7, #4]
 800b2f8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800b2fa:	687b      	ldr	r3, [r7, #4]
 800b2fc:	687a      	ldr	r2, [r7, #4]
 800b2fe:	605a      	str	r2, [r3, #4]
}
 800b300:	370c      	adds	r7, #12
 800b302:	46bd      	mov	sp, r7
 800b304:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b308:	4770      	bx	lr
 800b30a:	bf00      	nop

0800b30c <chSchIsRescRequiredI>:
=======
 800b374:	b480      	push	{r7}
 800b376:	b083      	sub	sp, #12
 800b378:	af00      	add	r7, sp, #0
 800b37a:	6078      	str	r0, [r7, #4]

  tqp->next = (thread_t *)tqp;
 800b37c:	687b      	ldr	r3, [r7, #4]
 800b37e:	687a      	ldr	r2, [r7, #4]
 800b380:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800b382:	687b      	ldr	r3, [r7, #4]
 800b384:	687a      	ldr	r2, [r7, #4]
 800b386:	605a      	str	r2, [r3, #4]
}
 800b388:	370c      	adds	r7, #12
 800b38a:	46bd      	mov	sp, r7
 800b38c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b390:	4770      	bx	lr
 800b392:	bf00      	nop

0800b394 <chSchIsRescRequiredI>:
>>>>>>> 752c83b... update binaries
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
<<<<<<< HEAD
 800b30c:	b580      	push	{r7, lr}
 800b30e:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800b310:	f7ff fe26 	bl	800af60 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 800b314:	4b06      	ldr	r3, [pc, #24]	; (800b330 <chSchIsRescRequiredI+0x24>)
 800b316:	681b      	ldr	r3, [r3, #0]
 800b318:	689a      	ldr	r2, [r3, #8]
 800b31a:	4b05      	ldr	r3, [pc, #20]	; (800b330 <chSchIsRescRequiredI+0x24>)
 800b31c:	699b      	ldr	r3, [r3, #24]
 800b31e:	689b      	ldr	r3, [r3, #8]
 800b320:	429a      	cmp	r2, r3
 800b322:	bf8c      	ite	hi
 800b324:	2301      	movhi	r3, #1
 800b326:	2300      	movls	r3, #0
 800b328:	b2db      	uxtb	r3, r3
}
 800b32a:	4618      	mov	r0, r3
 800b32c:	bd80      	pop	{r7, pc}
 800b32e:	bf00      	nop
 800b330:	20001338 	.word	0x20001338

0800b334 <chSysLockFromISR.lto_priv.319>:
=======
 800b394:	b580      	push	{r7, lr}
 800b396:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800b398:	f7ff fe26 	bl	800afe8 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 800b39c:	4b06      	ldr	r3, [pc, #24]	; (800b3b8 <chSchIsRescRequiredI+0x24>)
 800b39e:	681b      	ldr	r3, [r3, #0]
 800b3a0:	689a      	ldr	r2, [r3, #8]
 800b3a2:	4b05      	ldr	r3, [pc, #20]	; (800b3b8 <chSchIsRescRequiredI+0x24>)
 800b3a4:	699b      	ldr	r3, [r3, #24]
 800b3a6:	689b      	ldr	r3, [r3, #8]
 800b3a8:	429a      	cmp	r2, r3
 800b3aa:	bf8c      	ite	hi
 800b3ac:	2301      	movhi	r3, #1
 800b3ae:	2300      	movls	r3, #0
 800b3b0:	b2db      	uxtb	r3, r3
}
 800b3b2:	4618      	mov	r0, r3
 800b3b4:	bd80      	pop	{r7, pc}
 800b3b6:	bf00      	nop
 800b3b8:	20001338 	.word	0x20001338

0800b3bc <chSysLockFromISR.lto_priv.316>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
<<<<<<< HEAD
 800b334:	b580      	push	{r7, lr}
 800b336:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800b338:	f7ff ffcc 	bl	800b2d4 <port_lock_from_isr.lto_priv.323>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b33c:	f7ff fdac 	bl	800ae98 <_dbg_check_lock_from_isr>
}
 800b340:	bd80      	pop	{r7, pc}
 800b342:	bf00      	nop

0800b344 <chSysUnlockFromISR.lto_priv.317>:
=======
 800b3bc:	b580      	push	{r7, lr}
 800b3be:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800b3c0:	f7ff ffcc 	bl	800b35c <port_lock_from_isr.lto_priv.320>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b3c4:	f7ff fdac 	bl	800af20 <_dbg_check_lock_from_isr>
}
 800b3c8:	bd80      	pop	{r7, pc}
 800b3ca:	bf00      	nop

0800b3cc <chSysUnlockFromISR.lto_priv.314>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
<<<<<<< HEAD
 800b344:	b580      	push	{r7, lr}
 800b346:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800b348:	f7ff fdbc 	bl	800aec4 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800b34c:	f7ff ffc8 	bl	800b2e0 <port_unlock_from_isr.lto_priv.321>
}
 800b350:	bd80      	pop	{r7, pc}
 800b352:	bf00      	nop

0800b354 <chVTIsArmedI>:
=======
 800b3cc:	b580      	push	{r7, lr}
 800b3ce:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800b3d0:	f7ff fdbc 	bl	800af4c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800b3d4:	f7ff ffc8 	bl	800b368 <port_unlock_from_isr.lto_priv.318>
}
 800b3d8:	bd80      	pop	{r7, pc}
 800b3da:	bf00      	nop

0800b3dc <chVTIsArmedI>:
>>>>>>> 752c83b... update binaries
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
<<<<<<< HEAD
 800b354:	b580      	push	{r7, lr}
 800b356:	b082      	sub	sp, #8
 800b358:	af00      	add	r7, sp, #0
 800b35a:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800b35c:	f7ff fe00 	bl	800af60 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 800b360:	687b      	ldr	r3, [r7, #4]
 800b362:	68db      	ldr	r3, [r3, #12]
 800b364:	2b00      	cmp	r3, #0
 800b366:	bf14      	ite	ne
 800b368:	2301      	movne	r3, #1
 800b36a:	2300      	moveq	r3, #0
 800b36c:	b2db      	uxtb	r3, r3
}
 800b36e:	4618      	mov	r0, r3
 800b370:	3708      	adds	r7, #8
 800b372:	46bd      	mov	sp, r7
 800b374:	bd80      	pop	{r7, pc}
 800b376:	bf00      	nop

0800b378 <_scheduler_init>:
=======
 800b3dc:	b580      	push	{r7, lr}
 800b3de:	b082      	sub	sp, #8
 800b3e0:	af00      	add	r7, sp, #0
 800b3e2:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 800b3e4:	f7ff fe00 	bl	800afe8 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 800b3e8:	687b      	ldr	r3, [r7, #4]
 800b3ea:	68db      	ldr	r3, [r3, #12]
 800b3ec:	2b00      	cmp	r3, #0
 800b3ee:	bf14      	ite	ne
 800b3f0:	2301      	movne	r3, #1
 800b3f2:	2300      	moveq	r3, #0
 800b3f4:	b2db      	uxtb	r3, r3
}
 800b3f6:	4618      	mov	r0, r3
 800b3f8:	3708      	adds	r7, #8
 800b3fa:	46bd      	mov	sp, r7
 800b3fc:	bd80      	pop	{r7, pc}
 800b3fe:	bf00      	nop

0800b400 <_scheduler_init>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
<<<<<<< HEAD
 800b378:	b580      	push	{r7, lr}
 800b37a:	af00      	add	r7, sp, #0

  queue_init(&ch.rlist.queue);
 800b37c:	4806      	ldr	r0, [pc, #24]	; (800b398 <_scheduler_init+0x20>)
 800b37e:	f7ff ffb5 	bl	800b2ec <queue_init>
  ch.rlist.prio = NOPRIO;
 800b382:	4b05      	ldr	r3, [pc, #20]	; (800b398 <_scheduler_init+0x20>)
 800b384:	2200      	movs	r2, #0
 800b386:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800b388:	4b03      	ldr	r3, [pc, #12]	; (800b398 <_scheduler_init+0x20>)
 800b38a:	4a03      	ldr	r2, [pc, #12]	; (800b398 <_scheduler_init+0x20>)
 800b38c:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 800b38e:	4b02      	ldr	r3, [pc, #8]	; (800b398 <_scheduler_init+0x20>)
 800b390:	4a01      	ldr	r2, [pc, #4]	; (800b398 <_scheduler_init+0x20>)
 800b392:	615a      	str	r2, [r3, #20]
#endif
}
 800b394:	bd80      	pop	{r7, pc}
 800b396:	bf00      	nop
 800b398:	20001338 	.word	0x20001338

0800b39c <queue_prio_insert>:
=======
 800b400:	b580      	push	{r7, lr}
 800b402:	af00      	add	r7, sp, #0

  queue_init(&ch.rlist.queue);
 800b404:	4806      	ldr	r0, [pc, #24]	; (800b420 <_scheduler_init+0x20>)
 800b406:	f7ff ffb5 	bl	800b374 <queue_init>
  ch.rlist.prio = NOPRIO;
 800b40a:	4b05      	ldr	r3, [pc, #20]	; (800b420 <_scheduler_init+0x20>)
 800b40c:	2200      	movs	r2, #0
 800b40e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800b410:	4b03      	ldr	r3, [pc, #12]	; (800b420 <_scheduler_init+0x20>)
 800b412:	4a03      	ldr	r2, [pc, #12]	; (800b420 <_scheduler_init+0x20>)
 800b414:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 800b416:	4b02      	ldr	r3, [pc, #8]	; (800b420 <_scheduler_init+0x20>)
 800b418:	4a01      	ldr	r2, [pc, #4]	; (800b420 <_scheduler_init+0x20>)
 800b41a:	615a      	str	r2, [r3, #20]
#endif
}
 800b41c:	bd80      	pop	{r7, pc}
 800b41e:	bf00      	nop
 800b420:	20001338 	.word	0x20001338

0800b424 <queue_prio_insert>:
>>>>>>> 752c83b... update binaries
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
<<<<<<< HEAD
 800b39c:	b480      	push	{r7}
 800b39e:	b085      	sub	sp, #20
 800b3a0:	af00      	add	r7, sp, #0
 800b3a2:	6078      	str	r0, [r7, #4]
 800b3a4:	6039      	str	r1, [r7, #0]

  thread_t *cp = (thread_t *)tqp;
 800b3a6:	683b      	ldr	r3, [r7, #0]
 800b3a8:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b3aa:	68fb      	ldr	r3, [r7, #12]
 800b3ac:	681b      	ldr	r3, [r3, #0]
 800b3ae:	60fb      	str	r3, [r7, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800b3b0:	68fa      	ldr	r2, [r7, #12]
 800b3b2:	683b      	ldr	r3, [r7, #0]
 800b3b4:	429a      	cmp	r2, r3
 800b3b6:	d005      	beq.n	800b3c4 <queue_prio_insert+0x28>
 800b3b8:	68fb      	ldr	r3, [r7, #12]
 800b3ba:	689a      	ldr	r2, [r3, #8]
 800b3bc:	687b      	ldr	r3, [r7, #4]
 800b3be:	689b      	ldr	r3, [r3, #8]
 800b3c0:	429a      	cmp	r2, r3
 800b3c2:	d2f2      	bcs.n	800b3aa <queue_prio_insert+0xe>
  tp->queue.next             = cp;
 800b3c4:	687b      	ldr	r3, [r7, #4]
 800b3c6:	68fa      	ldr	r2, [r7, #12]
 800b3c8:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b3ca:	68fb      	ldr	r3, [r7, #12]
 800b3cc:	685a      	ldr	r2, [r3, #4]
 800b3ce:	687b      	ldr	r3, [r7, #4]
 800b3d0:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b3d2:	687b      	ldr	r3, [r7, #4]
 800b3d4:	685b      	ldr	r3, [r3, #4]
 800b3d6:	687a      	ldr	r2, [r7, #4]
 800b3d8:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b3da:	68fb      	ldr	r3, [r7, #12]
 800b3dc:	687a      	ldr	r2, [r7, #4]
 800b3de:	605a      	str	r2, [r3, #4]
}
 800b3e0:	3714      	adds	r7, #20
 800b3e2:	46bd      	mov	sp, r7
 800b3e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3e8:	4770      	bx	lr
 800b3ea:	bf00      	nop

0800b3ec <queue_insert>:
=======
 800b424:	b480      	push	{r7}
 800b426:	b085      	sub	sp, #20
 800b428:	af00      	add	r7, sp, #0
 800b42a:	6078      	str	r0, [r7, #4]
 800b42c:	6039      	str	r1, [r7, #0]

  thread_t *cp = (thread_t *)tqp;
 800b42e:	683b      	ldr	r3, [r7, #0]
 800b430:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b432:	68fb      	ldr	r3, [r7, #12]
 800b434:	681b      	ldr	r3, [r3, #0]
 800b436:	60fb      	str	r3, [r7, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800b438:	68fa      	ldr	r2, [r7, #12]
 800b43a:	683b      	ldr	r3, [r7, #0]
 800b43c:	429a      	cmp	r2, r3
 800b43e:	d005      	beq.n	800b44c <queue_prio_insert+0x28>
 800b440:	68fb      	ldr	r3, [r7, #12]
 800b442:	689a      	ldr	r2, [r3, #8]
 800b444:	687b      	ldr	r3, [r7, #4]
 800b446:	689b      	ldr	r3, [r3, #8]
 800b448:	429a      	cmp	r2, r3
 800b44a:	d2f2      	bcs.n	800b432 <queue_prio_insert+0xe>
  tp->queue.next             = cp;
 800b44c:	687b      	ldr	r3, [r7, #4]
 800b44e:	68fa      	ldr	r2, [r7, #12]
 800b450:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b452:	68fb      	ldr	r3, [r7, #12]
 800b454:	685a      	ldr	r2, [r3, #4]
 800b456:	687b      	ldr	r3, [r7, #4]
 800b458:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b45a:	687b      	ldr	r3, [r7, #4]
 800b45c:	685b      	ldr	r3, [r3, #4]
 800b45e:	687a      	ldr	r2, [r7, #4]
 800b460:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b462:	68fb      	ldr	r3, [r7, #12]
 800b464:	687a      	ldr	r2, [r7, #4]
 800b466:	605a      	str	r2, [r3, #4]
}
 800b468:	3714      	adds	r7, #20
 800b46a:	46bd      	mov	sp, r7
 800b46c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b470:	4770      	bx	lr
 800b472:	bf00      	nop

0800b474 <queue_insert>:
>>>>>>> 752c83b... update binaries
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_insert(thread_t *tp, threads_queue_t *tqp) {
<<<<<<< HEAD
 800b3ec:	b480      	push	{r7}
 800b3ee:	b083      	sub	sp, #12
 800b3f0:	af00      	add	r7, sp, #0
 800b3f2:	6078      	str	r0, [r7, #4]
 800b3f4:	6039      	str	r1, [r7, #0]

  tp->queue.next             = (thread_t *)tqp;
 800b3f6:	687b      	ldr	r3, [r7, #4]
 800b3f8:	683a      	ldr	r2, [r7, #0]
 800b3fa:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800b3fc:	683b      	ldr	r3, [r7, #0]
 800b3fe:	685a      	ldr	r2, [r3, #4]
 800b400:	687b      	ldr	r3, [r7, #4]
 800b402:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b404:	687b      	ldr	r3, [r7, #4]
 800b406:	685b      	ldr	r3, [r3, #4]
 800b408:	687a      	ldr	r2, [r7, #4]
 800b40a:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 800b40c:	683b      	ldr	r3, [r7, #0]
 800b40e:	687a      	ldr	r2, [r7, #4]
 800b410:	605a      	str	r2, [r3, #4]
}
 800b412:	370c      	adds	r7, #12
 800b414:	46bd      	mov	sp, r7
 800b416:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b41a:	4770      	bx	lr

0800b41c <queue_fifo_remove>:
=======
 800b474:	b480      	push	{r7}
 800b476:	b083      	sub	sp, #12
 800b478:	af00      	add	r7, sp, #0
 800b47a:	6078      	str	r0, [r7, #4]
 800b47c:	6039      	str	r1, [r7, #0]

  tp->queue.next             = (thread_t *)tqp;
 800b47e:	687b      	ldr	r3, [r7, #4]
 800b480:	683a      	ldr	r2, [r7, #0]
 800b482:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800b484:	683b      	ldr	r3, [r7, #0]
 800b486:	685a      	ldr	r2, [r3, #4]
 800b488:	687b      	ldr	r3, [r7, #4]
 800b48a:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b48c:	687b      	ldr	r3, [r7, #4]
 800b48e:	685b      	ldr	r3, [r3, #4]
 800b490:	687a      	ldr	r2, [r7, #4]
 800b492:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 800b494:	683b      	ldr	r3, [r7, #0]
 800b496:	687a      	ldr	r2, [r7, #4]
 800b498:	605a      	str	r2, [r3, #4]
}
 800b49a:	370c      	adds	r7, #12
 800b49c:	46bd      	mov	sp, r7
 800b49e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4a2:	4770      	bx	lr

0800b4a4 <queue_fifo_remove>:
>>>>>>> 752c83b... update binaries
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_fifo_remove(threads_queue_t *tqp) {
<<<<<<< HEAD
 800b41c:	b480      	push	{r7}
 800b41e:	b085      	sub	sp, #20
 800b420:	af00      	add	r7, sp, #0
 800b422:	6078      	str	r0, [r7, #4]
  thread_t *tp = tqp->next;
 800b424:	687b      	ldr	r3, [r7, #4]
 800b426:	681b      	ldr	r3, [r3, #0]
 800b428:	60fb      	str	r3, [r7, #12]

  tqp->next             = tp->queue.next;
 800b42a:	68fb      	ldr	r3, [r7, #12]
 800b42c:	681a      	ldr	r2, [r3, #0]
 800b42e:	687b      	ldr	r3, [r7, #4]
 800b430:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b432:	687b      	ldr	r3, [r7, #4]
 800b434:	681b      	ldr	r3, [r3, #0]
 800b436:	687a      	ldr	r2, [r7, #4]
 800b438:	605a      	str	r2, [r3, #4]

  return tp;
 800b43a:	68fb      	ldr	r3, [r7, #12]
}
 800b43c:	4618      	mov	r0, r3
 800b43e:	3714      	adds	r7, #20
 800b440:	46bd      	mov	sp, r7
 800b442:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b446:	4770      	bx	lr

0800b448 <queue_dequeue>:
=======
 800b4a4:	b480      	push	{r7}
 800b4a6:	b085      	sub	sp, #20
 800b4a8:	af00      	add	r7, sp, #0
 800b4aa:	6078      	str	r0, [r7, #4]
  thread_t *tp = tqp->next;
 800b4ac:	687b      	ldr	r3, [r7, #4]
 800b4ae:	681b      	ldr	r3, [r3, #0]
 800b4b0:	60fb      	str	r3, [r7, #12]

  tqp->next             = tp->queue.next;
 800b4b2:	68fb      	ldr	r3, [r7, #12]
 800b4b4:	681a      	ldr	r2, [r3, #0]
 800b4b6:	687b      	ldr	r3, [r7, #4]
 800b4b8:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b4ba:	687b      	ldr	r3, [r7, #4]
 800b4bc:	681b      	ldr	r3, [r3, #0]
 800b4be:	687a      	ldr	r2, [r7, #4]
 800b4c0:	605a      	str	r2, [r3, #4]

  return tp;
 800b4c2:	68fb      	ldr	r3, [r7, #12]
}
 800b4c4:	4618      	mov	r0, r3
 800b4c6:	3714      	adds	r7, #20
 800b4c8:	46bd      	mov	sp, r7
 800b4ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4ce:	4770      	bx	lr

0800b4d0 <queue_dequeue>:
>>>>>>> 752c83b... update binaries
 * @param[in] tp        the pointer to the thread to be removed from the queue
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_dequeue(thread_t *tp) {
<<<<<<< HEAD
 800b448:	b480      	push	{r7}
 800b44a:	b083      	sub	sp, #12
 800b44c:	af00      	add	r7, sp, #0
 800b44e:	6078      	str	r0, [r7, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 800b450:	687b      	ldr	r3, [r7, #4]
 800b452:	685b      	ldr	r3, [r3, #4]
 800b454:	687a      	ldr	r2, [r7, #4]
 800b456:	6812      	ldr	r2, [r2, #0]
 800b458:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800b45a:	687b      	ldr	r3, [r7, #4]
 800b45c:	681b      	ldr	r3, [r3, #0]
 800b45e:	687a      	ldr	r2, [r7, #4]
 800b460:	6852      	ldr	r2, [r2, #4]
 800b462:	605a      	str	r2, [r3, #4]

  return tp;
 800b464:	687b      	ldr	r3, [r7, #4]
}
 800b466:	4618      	mov	r0, r3
 800b468:	370c      	adds	r7, #12
 800b46a:	46bd      	mov	sp, r7
 800b46c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b470:	4770      	bx	lr
 800b472:	bf00      	nop

0800b474 <list_remove>:
=======
 800b4d0:	b480      	push	{r7}
 800b4d2:	b083      	sub	sp, #12
 800b4d4:	af00      	add	r7, sp, #0
 800b4d6:	6078      	str	r0, [r7, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 800b4d8:	687b      	ldr	r3, [r7, #4]
 800b4da:	685b      	ldr	r3, [r3, #4]
 800b4dc:	687a      	ldr	r2, [r7, #4]
 800b4de:	6812      	ldr	r2, [r2, #0]
 800b4e0:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800b4e2:	687b      	ldr	r3, [r7, #4]
 800b4e4:	681b      	ldr	r3, [r3, #0]
 800b4e6:	687a      	ldr	r2, [r7, #4]
 800b4e8:	6852      	ldr	r2, [r2, #4]
 800b4ea:	605a      	str	r2, [r3, #4]

  return tp;
 800b4ec:	687b      	ldr	r3, [r7, #4]
}
 800b4ee:	4618      	mov	r0, r3
 800b4f0:	370c      	adds	r7, #12
 800b4f2:	46bd      	mov	sp, r7
 800b4f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4f8:	4770      	bx	lr
 800b4fa:	bf00      	nop

0800b4fc <list_remove>:
>>>>>>> 752c83b... update binaries
 * @param[in] tlp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *list_remove(threads_list_t *tlp) {
<<<<<<< HEAD
 800b474:	b480      	push	{r7}
 800b476:	b085      	sub	sp, #20
 800b478:	af00      	add	r7, sp, #0
 800b47a:	6078      	str	r0, [r7, #4]

  thread_t *tp = tlp->next;
 800b47c:	687b      	ldr	r3, [r7, #4]
 800b47e:	681b      	ldr	r3, [r3, #0]
 800b480:	60fb      	str	r3, [r7, #12]
  tlp->next = tp->queue.next;
 800b482:	68fb      	ldr	r3, [r7, #12]
 800b484:	681a      	ldr	r2, [r3, #0]
 800b486:	687b      	ldr	r3, [r7, #4]
 800b488:	601a      	str	r2, [r3, #0]

  return tp;
 800b48a:	68fb      	ldr	r3, [r7, #12]
}
 800b48c:	4618      	mov	r0, r3
 800b48e:	3714      	adds	r7, #20
 800b490:	46bd      	mov	sp, r7
 800b492:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b496:	4770      	bx	lr

0800b498 <chSchReadyI>:
=======
 800b4fc:	b480      	push	{r7}
 800b4fe:	b085      	sub	sp, #20
 800b500:	af00      	add	r7, sp, #0
 800b502:	6078      	str	r0, [r7, #4]

  thread_t *tp = tlp->next;
 800b504:	687b      	ldr	r3, [r7, #4]
 800b506:	681b      	ldr	r3, [r3, #0]
 800b508:	60fb      	str	r3, [r7, #12]
  tlp->next = tp->queue.next;
 800b50a:	68fb      	ldr	r3, [r7, #12]
 800b50c:	681a      	ldr	r2, [r3, #0]
 800b50e:	687b      	ldr	r3, [r7, #4]
 800b510:	601a      	str	r2, [r3, #0]

  return tp;
 800b512:	68fb      	ldr	r3, [r7, #12]
}
 800b514:	4618      	mov	r0, r3
 800b516:	3714      	adds	r7, #20
 800b518:	46bd      	mov	sp, r7
 800b51a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b51e:	4770      	bx	lr

0800b520 <chSchReadyI>:
>>>>>>> 752c83b... update binaries
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
<<<<<<< HEAD
 800b498:	b580      	push	{r7, lr}
 800b49a:	b084      	sub	sp, #16
 800b49c:	af00      	add	r7, sp, #0
 800b49e:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800b4a0:	f7ff fd5e 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800b4a4:	687b      	ldr	r3, [r7, #4]
 800b4a6:	2b00      	cmp	r3, #0
 800b4a8:	d102      	bne.n	800b4b0 <chSchReadyI+0x18>
 800b4aa:	4819      	ldr	r0, [pc, #100]	; (800b510 <chSchReadyI+0x78>)
 800b4ac:	f7ff fc7a 	bl	800ada4 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800b4b0:	687b      	ldr	r3, [r7, #4]
 800b4b2:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b4b6:	2b00      	cmp	r3, #0
 800b4b8:	d004      	beq.n	800b4c4 <chSchReadyI+0x2c>
 800b4ba:	687b      	ldr	r3, [r7, #4]
 800b4bc:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b4c0:	2b0f      	cmp	r3, #15
 800b4c2:	d102      	bne.n	800b4ca <chSchReadyI+0x32>
 800b4c4:	4812      	ldr	r0, [pc, #72]	; (800b510 <chSchReadyI+0x78>)
 800b4c6:	f7ff fc6d 	bl	800ada4 <chSysHalt>
=======
 800b520:	b580      	push	{r7, lr}
 800b522:	b084      	sub	sp, #16
 800b524:	af00      	add	r7, sp, #0
 800b526:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800b528:	f7ff fd5e 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800b52c:	687b      	ldr	r3, [r7, #4]
 800b52e:	2b00      	cmp	r3, #0
 800b530:	d102      	bne.n	800b538 <chSchReadyI+0x18>
 800b532:	4819      	ldr	r0, [pc, #100]	; (800b598 <chSchReadyI+0x78>)
 800b534:	f7ff fc7a 	bl	800ae2c <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800b538:	687b      	ldr	r3, [r7, #4]
 800b53a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b53e:	2b00      	cmp	r3, #0
 800b540:	d004      	beq.n	800b54c <chSchReadyI+0x2c>
 800b542:	687b      	ldr	r3, [r7, #4]
 800b544:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b548:	2b0f      	cmp	r3, #15
 800b54a:	d102      	bne.n	800b552 <chSchReadyI+0x32>
 800b54c:	4812      	ldr	r0, [pc, #72]	; (800b598 <chSchReadyI+0x78>)
 800b54e:	f7ff fc6d 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
<<<<<<< HEAD
 800b4ca:	687b      	ldr	r3, [r7, #4]
 800b4cc:	2200      	movs	r2, #0
 800b4ce:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800b4d2:	4b10      	ldr	r3, [pc, #64]	; (800b514 <chSchReadyI+0x7c>)
 800b4d4:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b4d6:	68fb      	ldr	r3, [r7, #12]
 800b4d8:	681b      	ldr	r3, [r3, #0]
 800b4da:	60fb      	str	r3, [r7, #12]
  } while (cp->prio >= tp->prio);
 800b4dc:	68fb      	ldr	r3, [r7, #12]
 800b4de:	689a      	ldr	r2, [r3, #8]
 800b4e0:	687b      	ldr	r3, [r7, #4]
 800b4e2:	689b      	ldr	r3, [r3, #8]
 800b4e4:	429a      	cmp	r2, r3
 800b4e6:	d2f6      	bcs.n	800b4d6 <chSchReadyI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800b4e8:	687b      	ldr	r3, [r7, #4]
 800b4ea:	68fa      	ldr	r2, [r7, #12]
 800b4ec:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b4ee:	68fb      	ldr	r3, [r7, #12]
 800b4f0:	685a      	ldr	r2, [r3, #4]
 800b4f2:	687b      	ldr	r3, [r7, #4]
 800b4f4:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b4f6:	687b      	ldr	r3, [r7, #4]
 800b4f8:	685b      	ldr	r3, [r3, #4]
 800b4fa:	687a      	ldr	r2, [r7, #4]
 800b4fc:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b4fe:	68fb      	ldr	r3, [r7, #12]
 800b500:	687a      	ldr	r2, [r7, #4]
 800b502:	605a      	str	r2, [r3, #4]

  return tp;
 800b504:	687b      	ldr	r3, [r7, #4]
}
 800b506:	4618      	mov	r0, r3
 800b508:	3710      	adds	r7, #16
 800b50a:	46bd      	mov	sp, r7
 800b50c:	bd80      	pop	{r7, pc}
 800b50e:	bf00      	nop
 800b510:	0800e898 	.word	0x0800e898
 800b514:	20001338 	.word	0x20001338

0800b518 <chSchReadyAheadI>:
=======
 800b552:	687b      	ldr	r3, [r7, #4]
 800b554:	2200      	movs	r2, #0
 800b556:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800b55a:	4b10      	ldr	r3, [pc, #64]	; (800b59c <chSchReadyI+0x7c>)
 800b55c:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b55e:	68fb      	ldr	r3, [r7, #12]
 800b560:	681b      	ldr	r3, [r3, #0]
 800b562:	60fb      	str	r3, [r7, #12]
  } while (cp->prio >= tp->prio);
 800b564:	68fb      	ldr	r3, [r7, #12]
 800b566:	689a      	ldr	r2, [r3, #8]
 800b568:	687b      	ldr	r3, [r7, #4]
 800b56a:	689b      	ldr	r3, [r3, #8]
 800b56c:	429a      	cmp	r2, r3
 800b56e:	d2f6      	bcs.n	800b55e <chSchReadyI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800b570:	687b      	ldr	r3, [r7, #4]
 800b572:	68fa      	ldr	r2, [r7, #12]
 800b574:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b576:	68fb      	ldr	r3, [r7, #12]
 800b578:	685a      	ldr	r2, [r3, #4]
 800b57a:	687b      	ldr	r3, [r7, #4]
 800b57c:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b57e:	687b      	ldr	r3, [r7, #4]
 800b580:	685b      	ldr	r3, [r3, #4]
 800b582:	687a      	ldr	r2, [r7, #4]
 800b584:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b586:	68fb      	ldr	r3, [r7, #12]
 800b588:	687a      	ldr	r2, [r7, #4]
 800b58a:	605a      	str	r2, [r3, #4]

  return tp;
 800b58c:	687b      	ldr	r3, [r7, #4]
}
 800b58e:	4618      	mov	r0, r3
 800b590:	3710      	adds	r7, #16
 800b592:	46bd      	mov	sp, r7
 800b594:	bd80      	pop	{r7, pc}
 800b596:	bf00      	nop
 800b598:	0800e970 	.word	0x0800e970
 800b59c:	20001338 	.word	0x20001338

0800b5a0 <chSchReadyAheadI>:
>>>>>>> 752c83b... update binaries
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
<<<<<<< HEAD
 800b518:	b580      	push	{r7, lr}
 800b51a:	b084      	sub	sp, #16
 800b51c:	af00      	add	r7, sp, #0
 800b51e:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800b520:	f7ff fd1e 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800b524:	687b      	ldr	r3, [r7, #4]
 800b526:	2b00      	cmp	r3, #0
 800b528:	d102      	bne.n	800b530 <chSchReadyAheadI+0x18>
 800b52a:	4819      	ldr	r0, [pc, #100]	; (800b590 <chSchReadyAheadI+0x78>)
 800b52c:	f7ff fc3a 	bl	800ada4 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800b530:	687b      	ldr	r3, [r7, #4]
 800b532:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b536:	2b00      	cmp	r3, #0
 800b538:	d004      	beq.n	800b544 <chSchReadyAheadI+0x2c>
 800b53a:	687b      	ldr	r3, [r7, #4]
 800b53c:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b540:	2b0f      	cmp	r3, #15
 800b542:	d102      	bne.n	800b54a <chSchReadyAheadI+0x32>
 800b544:	4812      	ldr	r0, [pc, #72]	; (800b590 <chSchReadyAheadI+0x78>)
 800b546:	f7ff fc2d 	bl	800ada4 <chSysHalt>
=======
 800b5a0:	b580      	push	{r7, lr}
 800b5a2:	b084      	sub	sp, #16
 800b5a4:	af00      	add	r7, sp, #0
 800b5a6:	6078      	str	r0, [r7, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800b5a8:	f7ff fd1e 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800b5ac:	687b      	ldr	r3, [r7, #4]
 800b5ae:	2b00      	cmp	r3, #0
 800b5b0:	d102      	bne.n	800b5b8 <chSchReadyAheadI+0x18>
 800b5b2:	4819      	ldr	r0, [pc, #100]	; (800b618 <chSchReadyAheadI+0x78>)
 800b5b4:	f7ff fc3a 	bl	800ae2c <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800b5b8:	687b      	ldr	r3, [r7, #4]
 800b5ba:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b5be:	2b00      	cmp	r3, #0
 800b5c0:	d004      	beq.n	800b5cc <chSchReadyAheadI+0x2c>
 800b5c2:	687b      	ldr	r3, [r7, #4]
 800b5c4:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b5c8:	2b0f      	cmp	r3, #15
 800b5ca:	d102      	bne.n	800b5d2 <chSchReadyAheadI+0x32>
 800b5cc:	4812      	ldr	r0, [pc, #72]	; (800b618 <chSchReadyAheadI+0x78>)
 800b5ce:	f7ff fc2d 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
<<<<<<< HEAD
 800b54a:	687b      	ldr	r3, [r7, #4]
 800b54c:	2200      	movs	r2, #0
 800b54e:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800b552:	4b10      	ldr	r3, [pc, #64]	; (800b594 <chSchReadyAheadI+0x7c>)
 800b554:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b556:	68fb      	ldr	r3, [r7, #12]
 800b558:	681b      	ldr	r3, [r3, #0]
 800b55a:	60fb      	str	r3, [r7, #12]
  } while (cp->prio > tp->prio);
 800b55c:	68fb      	ldr	r3, [r7, #12]
 800b55e:	689a      	ldr	r2, [r3, #8]
 800b560:	687b      	ldr	r3, [r7, #4]
 800b562:	689b      	ldr	r3, [r3, #8]
 800b564:	429a      	cmp	r2, r3
 800b566:	d8f6      	bhi.n	800b556 <chSchReadyAheadI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800b568:	687b      	ldr	r3, [r7, #4]
 800b56a:	68fa      	ldr	r2, [r7, #12]
 800b56c:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b56e:	68fb      	ldr	r3, [r7, #12]
 800b570:	685a      	ldr	r2, [r3, #4]
 800b572:	687b      	ldr	r3, [r7, #4]
 800b574:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b576:	687b      	ldr	r3, [r7, #4]
 800b578:	685b      	ldr	r3, [r3, #4]
 800b57a:	687a      	ldr	r2, [r7, #4]
 800b57c:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b57e:	68fb      	ldr	r3, [r7, #12]
 800b580:	687a      	ldr	r2, [r7, #4]
 800b582:	605a      	str	r2, [r3, #4]

  return tp;
 800b584:	687b      	ldr	r3, [r7, #4]
}
 800b586:	4618      	mov	r0, r3
 800b588:	3710      	adds	r7, #16
 800b58a:	46bd      	mov	sp, r7
 800b58c:	bd80      	pop	{r7, pc}
 800b58e:	bf00      	nop
 800b590:	0800e8a4 	.word	0x0800e8a4
 800b594:	20001338 	.word	0x20001338

0800b598 <chSchGoSleepS>:
=======
 800b5d2:	687b      	ldr	r3, [r7, #4]
 800b5d4:	2200      	movs	r2, #0
 800b5d6:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 800b5da:	4b10      	ldr	r3, [pc, #64]	; (800b61c <chSchReadyAheadI+0x7c>)
 800b5dc:	60fb      	str	r3, [r7, #12]
  do {
    cp = cp->queue.next;
 800b5de:	68fb      	ldr	r3, [r7, #12]
 800b5e0:	681b      	ldr	r3, [r3, #0]
 800b5e2:	60fb      	str	r3, [r7, #12]
  } while (cp->prio > tp->prio);
 800b5e4:	68fb      	ldr	r3, [r7, #12]
 800b5e6:	689a      	ldr	r2, [r3, #8]
 800b5e8:	687b      	ldr	r3, [r7, #4]
 800b5ea:	689b      	ldr	r3, [r3, #8]
 800b5ec:	429a      	cmp	r2, r3
 800b5ee:	d8f6      	bhi.n	800b5de <chSchReadyAheadI+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800b5f0:	687b      	ldr	r3, [r7, #4]
 800b5f2:	68fa      	ldr	r2, [r7, #12]
 800b5f4:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 800b5f6:	68fb      	ldr	r3, [r7, #12]
 800b5f8:	685a      	ldr	r2, [r3, #4]
 800b5fa:	687b      	ldr	r3, [r7, #4]
 800b5fc:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b5fe:	687b      	ldr	r3, [r7, #4]
 800b600:	685b      	ldr	r3, [r3, #4]
 800b602:	687a      	ldr	r2, [r7, #4]
 800b604:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 800b606:	68fb      	ldr	r3, [r7, #12]
 800b608:	687a      	ldr	r2, [r7, #4]
 800b60a:	605a      	str	r2, [r3, #4]

  return tp;
 800b60c:	687b      	ldr	r3, [r7, #4]
}
 800b60e:	4618      	mov	r0, r3
 800b610:	3710      	adds	r7, #16
 800b612:	46bd      	mov	sp, r7
 800b614:	bd80      	pop	{r7, pc}
 800b616:	bf00      	nop
 800b618:	0800e97c 	.word	0x0800e97c
 800b61c:	20001338 	.word	0x20001338

0800b620 <chSchGoSleepS>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
<<<<<<< HEAD
 800b598:	b590      	push	{r4, r7, lr}
 800b59a:	b085      	sub	sp, #20
 800b59c:	af00      	add	r7, sp, #0
 800b59e:	4603      	mov	r3, r0
 800b5a0:	71fb      	strb	r3, [r7, #7]
  thread_t *otp = currp;
 800b5a2:	4b16      	ldr	r3, [pc, #88]	; (800b5fc <chSchGoSleepS+0x64>)
 800b5a4:	699b      	ldr	r3, [r3, #24]
 800b5a6:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800b5a8:	f7ff fcec 	bl	800af84 <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 800b5ac:	68fb      	ldr	r3, [r7, #12]
 800b5ae:	79fa      	ldrb	r2, [r7, #7]
 800b5b0:	f883 2020 	strb.w	r2, [r3, #32]
=======
 800b620:	b590      	push	{r4, r7, lr}
 800b622:	b085      	sub	sp, #20
 800b624:	af00      	add	r7, sp, #0
 800b626:	4603      	mov	r3, r0
 800b628:	71fb      	strb	r3, [r7, #7]
  thread_t *otp = currp;
 800b62a:	4b16      	ldr	r3, [pc, #88]	; (800b684 <chSchGoSleepS+0x64>)
 800b62c:	699b      	ldr	r3, [r3, #24]
 800b62e:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800b630:	f7ff fcec 	bl	800b00c <chDbgCheckClassS>

  /* New state.*/
  otp->state = newstate;
 800b634:	68fb      	ldr	r3, [r7, #12]
 800b636:	79fa      	ldrb	r2, [r7, #7]
 800b638:	f883 2020 	strb.w	r2, [r3, #32]
>>>>>>> 752c83b... update binaries
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
<<<<<<< HEAD
 800b5b4:	4811      	ldr	r0, [pc, #68]	; (800b5fc <chSchGoSleepS+0x64>)
 800b5b6:	f7ff ff31 	bl	800b41c <queue_fifo_remove>
 800b5ba:	4602      	mov	r2, r0
 800b5bc:	4b0f      	ldr	r3, [pc, #60]	; (800b5fc <chSchGoSleepS+0x64>)
 800b5be:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b5c0:	4b0e      	ldr	r3, [pc, #56]	; (800b5fc <chSchGoSleepS+0x64>)
 800b5c2:	699b      	ldr	r3, [r3, #24]
 800b5c4:	2201      	movs	r2, #1
 800b5c6:	f883 2020 	strb.w	r2, [r3, #32]
=======
 800b63c:	4811      	ldr	r0, [pc, #68]	; (800b684 <chSchGoSleepS+0x64>)
 800b63e:	f7ff ff31 	bl	800b4a4 <queue_fifo_remove>
 800b642:	4602      	mov	r2, r0
 800b644:	4b0f      	ldr	r3, [pc, #60]	; (800b684 <chSchGoSleepS+0x64>)
 800b646:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b648:	4b0e      	ldr	r3, [pc, #56]	; (800b684 <chSchGoSleepS+0x64>)
 800b64a:	699b      	ldr	r3, [r3, #24]
 800b64c:	2201      	movs	r2, #1
 800b64e:	f883 2020 	strb.w	r2, [r3, #32]
>>>>>>> 752c83b... update binaries
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
<<<<<<< HEAD
 800b5ca:	f3ef 8309 	mrs	r3, PSP
 800b5ce:	461c      	mov	r4, r3
  return(result);
 800b5d0:	4623      	mov	r3, r4
=======
 800b652:	f3ef 8309 	mrs	r3, PSP
 800b656:	461c      	mov	r4, r3
  return(result);
 800b658:	4623      	mov	r3, r4
>>>>>>> 752c83b... update binaries
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
<<<<<<< HEAD
 800b5d2:	60bb      	str	r3, [r7, #8]
 800b5d4:	68bb      	ldr	r3, [r7, #8]
 800b5d6:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b5da:	68fb      	ldr	r3, [r7, #12]
 800b5dc:	69db      	ldr	r3, [r3, #28]
 800b5de:	429a      	cmp	r2, r3
 800b5e0:	d202      	bcs.n	800b5e8 <chSchGoSleepS+0x50>
 800b5e2:	4807      	ldr	r0, [pc, #28]	; (800b600 <chSchGoSleepS+0x68>)
 800b5e4:	f7ff fbde 	bl	800ada4 <chSysHalt>
 800b5e8:	4b04      	ldr	r3, [pc, #16]	; (800b5fc <chSchGoSleepS+0x64>)
 800b5ea:	699b      	ldr	r3, [r3, #24]
 800b5ec:	4618      	mov	r0, r3
 800b5ee:	68f9      	ldr	r1, [r7, #12]
 800b5f0:	f7f7 fe58 	bl	80032a4 <_port_switch>
}
 800b5f4:	3714      	adds	r7, #20
 800b5f6:	46bd      	mov	sp, r7
 800b5f8:	bd90      	pop	{r4, r7, pc}
 800b5fa:	bf00      	nop
 800b5fc:	20001338 	.word	0x20001338
 800b600:	0800e6c0 	.word	0x0800e6c0

0800b604 <wakeup>:
=======
 800b65a:	60bb      	str	r3, [r7, #8]
 800b65c:	68bb      	ldr	r3, [r7, #8]
 800b65e:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b662:	68fb      	ldr	r3, [r7, #12]
 800b664:	69db      	ldr	r3, [r3, #28]
 800b666:	429a      	cmp	r2, r3
 800b668:	d202      	bcs.n	800b670 <chSchGoSleepS+0x50>
 800b66a:	4807      	ldr	r0, [pc, #28]	; (800b688 <chSchGoSleepS+0x68>)
 800b66c:	f7ff fbde 	bl	800ae2c <chSysHalt>
 800b670:	4b04      	ldr	r3, [pc, #16]	; (800b684 <chSchGoSleepS+0x64>)
 800b672:	699b      	ldr	r3, [r3, #24]
 800b674:	4618      	mov	r0, r3
 800b676:	68f9      	ldr	r1, [r7, #12]
 800b678:	f7f7 fe14 	bl	80032a4 <_port_switch>
}
 800b67c:	3714      	adds	r7, #20
 800b67e:	46bd      	mov	sp, r7
 800b680:	bd90      	pop	{r4, r7, pc}
 800b682:	bf00      	nop
 800b684:	20001338 	.word	0x20001338
 800b688:	0800e79c 	.word	0x0800e79c

0800b68c <wakeup>:
>>>>>>> 752c83b... update binaries

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
<<<<<<< HEAD
 800b604:	b580      	push	{r7, lr}
 800b606:	b084      	sub	sp, #16
 800b608:	af00      	add	r7, sp, #0
 800b60a:	6078      	str	r0, [r7, #4]
  thread_t *tp = (thread_t *)p;
 800b60c:	687b      	ldr	r3, [r7, #4]
 800b60e:	60fb      	str	r3, [r7, #12]

  chSysLockFromISR();
 800b610:	f7ff fe90 	bl	800b334 <chSysLockFromISR.lto_priv.319>
  switch (tp->state) {
 800b614:	68fb      	ldr	r3, [r7, #12]
 800b616:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b61a:	2b03      	cmp	r3, #3
 800b61c:	d006      	beq.n	800b62c <wakeup+0x28>
 800b61e:	2b04      	cmp	r3, #4
 800b620:	d009      	beq.n	800b636 <wakeup+0x32>
 800b622:	2b00      	cmp	r3, #0
 800b624:	d10a      	bne.n	800b63c <wakeup+0x38>
=======
 800b68c:	b580      	push	{r7, lr}
 800b68e:	b084      	sub	sp, #16
 800b690:	af00      	add	r7, sp, #0
 800b692:	6078      	str	r0, [r7, #4]
  thread_t *tp = (thread_t *)p;
 800b694:	687b      	ldr	r3, [r7, #4]
 800b696:	60fb      	str	r3, [r7, #12]

  chSysLockFromISR();
 800b698:	f7ff fe90 	bl	800b3bc <chSysLockFromISR.lto_priv.316>
  switch (tp->state) {
 800b69c:	68fb      	ldr	r3, [r7, #12]
 800b69e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b6a2:	2b03      	cmp	r3, #3
 800b6a4:	d006      	beq.n	800b6b4 <wakeup+0x28>
 800b6a6:	2b04      	cmp	r3, #4
 800b6a8:	d009      	beq.n	800b6be <wakeup+0x32>
 800b6aa:	2b00      	cmp	r3, #0
 800b6ac:	d10a      	bne.n	800b6c4 <wakeup+0x38>
>>>>>>> 752c83b... update binaries
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
<<<<<<< HEAD
 800b626:	f7ff fe8d 	bl	800b344 <chSysUnlockFromISR.lto_priv.317>
 800b62a:	e010      	b.n	800b64e <wakeup+0x4a>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800b62c:	68fb      	ldr	r3, [r7, #12]
 800b62e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b630:	2200      	movs	r2, #0
 800b632:	601a      	str	r2, [r3, #0]
 800b634:	e002      	b.n	800b63c <wakeup+0x38>
=======
 800b6ae:	f7ff fe8d 	bl	800b3cc <chSysUnlockFromISR.lto_priv.314>
 800b6b2:	e010      	b.n	800b6d6 <wakeup+0x4a>
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800b6b4:	68fb      	ldr	r3, [r7, #12]
 800b6b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b6b8:	2200      	movs	r2, #0
 800b6ba:	601a      	str	r2, [r3, #0]
 800b6bc:	e002      	b.n	800b6c4 <wakeup+0x38>
>>>>>>> 752c83b... update binaries
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
<<<<<<< HEAD
 800b636:	68f8      	ldr	r0, [r7, #12]
 800b638:	f7ff ff06 	bl	800b448 <queue_dequeue>
=======
 800b6be:	68f8      	ldr	r0, [r7, #12]
 800b6c0:	f7ff ff06 	bl	800b4d0 <queue_dequeue>
>>>>>>> 752c83b... update binaries
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
<<<<<<< HEAD
 800b63c:	68fb      	ldr	r3, [r7, #12]
 800b63e:	f04f 32ff 	mov.w	r2, #4294967295
 800b642:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800b644:	68f8      	ldr	r0, [r7, #12]
 800b646:	f7ff ff27 	bl	800b498 <chSchReadyI>
  chSysUnlockFromISR();
 800b64a:	f7ff fe7b 	bl	800b344 <chSysUnlockFromISR.lto_priv.317>
}
 800b64e:	3710      	adds	r7, #16
 800b650:	46bd      	mov	sp, r7
 800b652:	bd80      	pop	{r7, pc}

0800b654 <chSchGoSleepTimeoutS>:
=======
 800b6c4:	68fb      	ldr	r3, [r7, #12]
 800b6c6:	f04f 32ff 	mov.w	r2, #4294967295
 800b6ca:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800b6cc:	68f8      	ldr	r0, [r7, #12]
 800b6ce:	f7ff ff27 	bl	800b520 <chSchReadyI>
  chSysUnlockFromISR();
 800b6d2:	f7ff fe7b 	bl	800b3cc <chSysUnlockFromISR.lto_priv.314>
}
 800b6d6:	3710      	adds	r7, #16
 800b6d8:	46bd      	mov	sp, r7
 800b6da:	bd80      	pop	{r7, pc}

0800b6dc <chSchGoSleepTimeoutS>:
>>>>>>> 752c83b... update binaries
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
<<<<<<< HEAD
 800b654:	b580      	push	{r7, lr}
 800b656:	b088      	sub	sp, #32
 800b658:	af00      	add	r7, sp, #0
 800b65a:	4603      	mov	r3, r0
 800b65c:	460a      	mov	r2, r1
 800b65e:	71fb      	strb	r3, [r7, #7]
 800b660:	4613      	mov	r3, r2
 800b662:	80bb      	strh	r3, [r7, #4]

  chDbgCheckClassS();
 800b664:	f7ff fc8e 	bl	800af84 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800b668:	88bb      	ldrh	r3, [r7, #4]
 800b66a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b66e:	4293      	cmp	r3, r2
 800b670:	d01b      	beq.n	800b6aa <chSchGoSleepTimeoutS+0x56>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800b672:	4b13      	ldr	r3, [pc, #76]	; (800b6c0 <chSchGoSleepTimeoutS+0x6c>)
 800b674:	699b      	ldr	r3, [r3, #24]
 800b676:	f107 010c 	add.w	r1, r7, #12
 800b67a:	88ba      	ldrh	r2, [r7, #4]
 800b67c:	4608      	mov	r0, r1
 800b67e:	4611      	mov	r1, r2
 800b680:	4a10      	ldr	r2, [pc, #64]	; (800b6c4 <chSchGoSleepTimeoutS+0x70>)
 800b682:	f7ff fce3 	bl	800b04c <chVTDoSetI>
    chSchGoSleepS(newstate);
 800b686:	79fb      	ldrb	r3, [r7, #7]
 800b688:	4618      	mov	r0, r3
 800b68a:	f7ff ff85 	bl	800b598 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800b68e:	f107 030c 	add.w	r3, r7, #12
 800b692:	4618      	mov	r0, r3
 800b694:	f7ff fe5e 	bl	800b354 <chVTIsArmedI>
 800b698:	4603      	mov	r3, r0
 800b69a:	2b00      	cmp	r3, #0
 800b69c:	d009      	beq.n	800b6b2 <chSchGoSleepTimeoutS+0x5e>
      chVTDoResetI(&vt);
 800b69e:	f107 030c 	add.w	r3, r7, #12
 800b6a2:	4618      	mov	r0, r3
 800b6a4:	f7ff fd7a 	bl	800b19c <chVTDoResetI>
 800b6a8:	e003      	b.n	800b6b2 <chSchGoSleepTimeoutS+0x5e>
=======
 800b6dc:	b580      	push	{r7, lr}
 800b6de:	b088      	sub	sp, #32
 800b6e0:	af00      	add	r7, sp, #0
 800b6e2:	4603      	mov	r3, r0
 800b6e4:	460a      	mov	r2, r1
 800b6e6:	71fb      	strb	r3, [r7, #7]
 800b6e8:	4613      	mov	r3, r2
 800b6ea:	80bb      	strh	r3, [r7, #4]

  chDbgCheckClassS();
 800b6ec:	f7ff fc8e 	bl	800b00c <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800b6f0:	88bb      	ldrh	r3, [r7, #4]
 800b6f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b6f6:	4293      	cmp	r3, r2
 800b6f8:	d01b      	beq.n	800b732 <chSchGoSleepTimeoutS+0x56>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800b6fa:	4b13      	ldr	r3, [pc, #76]	; (800b748 <chSchGoSleepTimeoutS+0x6c>)
 800b6fc:	699b      	ldr	r3, [r3, #24]
 800b6fe:	f107 010c 	add.w	r1, r7, #12
 800b702:	88ba      	ldrh	r2, [r7, #4]
 800b704:	4608      	mov	r0, r1
 800b706:	4611      	mov	r1, r2
 800b708:	4a10      	ldr	r2, [pc, #64]	; (800b74c <chSchGoSleepTimeoutS+0x70>)
 800b70a:	f7ff fce3 	bl	800b0d4 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800b70e:	79fb      	ldrb	r3, [r7, #7]
 800b710:	4618      	mov	r0, r3
 800b712:	f7ff ff85 	bl	800b620 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800b716:	f107 030c 	add.w	r3, r7, #12
 800b71a:	4618      	mov	r0, r3
 800b71c:	f7ff fe5e 	bl	800b3dc <chVTIsArmedI>
 800b720:	4603      	mov	r3, r0
 800b722:	2b00      	cmp	r3, #0
 800b724:	d009      	beq.n	800b73a <chSchGoSleepTimeoutS+0x5e>
      chVTDoResetI(&vt);
 800b726:	f107 030c 	add.w	r3, r7, #12
 800b72a:	4618      	mov	r0, r3
 800b72c:	f7ff fd7a 	bl	800b224 <chVTDoResetI>
 800b730:	e003      	b.n	800b73a <chSchGoSleepTimeoutS+0x5e>
>>>>>>> 752c83b... update binaries
    }
  }
  else {
    chSchGoSleepS(newstate);
<<<<<<< HEAD
 800b6aa:	79fb      	ldrb	r3, [r7, #7]
 800b6ac:	4618      	mov	r0, r3
 800b6ae:	f7ff ff73 	bl	800b598 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800b6b2:	4b03      	ldr	r3, [pc, #12]	; (800b6c0 <chSchGoSleepTimeoutS+0x6c>)
 800b6b4:	699b      	ldr	r3, [r3, #24]
 800b6b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800b6b8:	4618      	mov	r0, r3
 800b6ba:	3720      	adds	r7, #32
 800b6bc:	46bd      	mov	sp, r7
 800b6be:	bd80      	pop	{r7, pc}
 800b6c0:	20001338 	.word	0x20001338
 800b6c4:	0800b605 	.word	0x0800b605

0800b6c8 <chSchWakeupS>:
=======
 800b732:	79fb      	ldrb	r3, [r7, #7]
 800b734:	4618      	mov	r0, r3
 800b736:	f7ff ff73 	bl	800b620 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800b73a:	4b03      	ldr	r3, [pc, #12]	; (800b748 <chSchGoSleepTimeoutS+0x6c>)
 800b73c:	699b      	ldr	r3, [r3, #24]
 800b73e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800b740:	4618      	mov	r0, r3
 800b742:	3720      	adds	r7, #32
 800b744:	46bd      	mov	sp, r7
 800b746:	bd80      	pop	{r7, pc}
 800b748:	20001338 	.word	0x20001338
 800b74c:	0800b68d 	.word	0x0800b68d

0800b750 <chSchWakeupS>:
>>>>>>> 752c83b... update binaries
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
<<<<<<< HEAD
 800b6c8:	b590      	push	{r4, r7, lr}
 800b6ca:	b085      	sub	sp, #20
 800b6cc:	af00      	add	r7, sp, #0
 800b6ce:	6078      	str	r0, [r7, #4]
 800b6d0:	6039      	str	r1, [r7, #0]
  thread_t *otp = currp;
 800b6d2:	4b21      	ldr	r3, [pc, #132]	; (800b758 <chSchWakeupS+0x90>)
 800b6d4:	699b      	ldr	r3, [r3, #24]
 800b6d6:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800b6d8:	f7ff fc54 	bl	800af84 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b6dc:	4b1e      	ldr	r3, [pc, #120]	; (800b758 <chSchWakeupS+0x90>)
 800b6de:	681b      	ldr	r3, [r3, #0]
 800b6e0:	4a1d      	ldr	r2, [pc, #116]	; (800b758 <chSchWakeupS+0x90>)
 800b6e2:	4293      	cmp	r3, r2
 800b6e4:	d00a      	beq.n	800b6fc <chSchWakeupS+0x34>
 800b6e6:	4b1c      	ldr	r3, [pc, #112]	; (800b758 <chSchWakeupS+0x90>)
 800b6e8:	699b      	ldr	r3, [r3, #24]
 800b6ea:	689a      	ldr	r2, [r3, #8]
 800b6ec:	4b1a      	ldr	r3, [pc, #104]	; (800b758 <chSchWakeupS+0x90>)
 800b6ee:	681b      	ldr	r3, [r3, #0]
 800b6f0:	689b      	ldr	r3, [r3, #8]
 800b6f2:	429a      	cmp	r2, r3
 800b6f4:	d202      	bcs.n	800b6fc <chSchWakeupS+0x34>
 800b6f6:	4819      	ldr	r0, [pc, #100]	; (800b75c <chSchWakeupS+0x94>)
 800b6f8:	f7ff fb54 	bl	800ada4 <chSysHalt>
=======
 800b750:	b590      	push	{r4, r7, lr}
 800b752:	b085      	sub	sp, #20
 800b754:	af00      	add	r7, sp, #0
 800b756:	6078      	str	r0, [r7, #4]
 800b758:	6039      	str	r1, [r7, #0]
  thread_t *otp = currp;
 800b75a:	4b21      	ldr	r3, [pc, #132]	; (800b7e0 <chSchWakeupS+0x90>)
 800b75c:	699b      	ldr	r3, [r3, #24]
 800b75e:	60fb      	str	r3, [r7, #12]

  chDbgCheckClassS();
 800b760:	f7ff fc54 	bl	800b00c <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b764:	4b1e      	ldr	r3, [pc, #120]	; (800b7e0 <chSchWakeupS+0x90>)
 800b766:	681b      	ldr	r3, [r3, #0]
 800b768:	4a1d      	ldr	r2, [pc, #116]	; (800b7e0 <chSchWakeupS+0x90>)
 800b76a:	4293      	cmp	r3, r2
 800b76c:	d00a      	beq.n	800b784 <chSchWakeupS+0x34>
 800b76e:	4b1c      	ldr	r3, [pc, #112]	; (800b7e0 <chSchWakeupS+0x90>)
 800b770:	699b      	ldr	r3, [r3, #24]
 800b772:	689a      	ldr	r2, [r3, #8]
 800b774:	4b1a      	ldr	r3, [pc, #104]	; (800b7e0 <chSchWakeupS+0x90>)
 800b776:	681b      	ldr	r3, [r3, #0]
 800b778:	689b      	ldr	r3, [r3, #8]
 800b77a:	429a      	cmp	r2, r3
 800b77c:	d202      	bcs.n	800b784 <chSchWakeupS+0x34>
 800b77e:	4819      	ldr	r0, [pc, #100]	; (800b7e4 <chSchWakeupS+0x94>)
 800b780:	f7ff fb54 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
<<<<<<< HEAD
 800b6fc:	687b      	ldr	r3, [r7, #4]
 800b6fe:	683a      	ldr	r2, [r7, #0]
 800b700:	625a      	str	r2, [r3, #36]	; 0x24
=======
 800b784:	687b      	ldr	r3, [r7, #4]
 800b786:	683a      	ldr	r2, [r7, #0]
 800b788:	625a      	str	r2, [r3, #36]	; 0x24
>>>>>>> 752c83b... update binaries

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
<<<<<<< HEAD
 800b702:	687b      	ldr	r3, [r7, #4]
 800b704:	689a      	ldr	r2, [r3, #8]
 800b706:	68fb      	ldr	r3, [r7, #12]
 800b708:	689b      	ldr	r3, [r3, #8]
 800b70a:	429a      	cmp	r2, r3
 800b70c:	d803      	bhi.n	800b716 <chSchWakeupS+0x4e>
    (void) chSchReadyI(ntp);
 800b70e:	6878      	ldr	r0, [r7, #4]
 800b710:	f7ff fec2 	bl	800b498 <chSchReadyI>
 800b714:	e01d      	b.n	800b752 <chSchWakeupS+0x8a>
  }
  else {
    otp = chSchReadyI(otp);
 800b716:	68f8      	ldr	r0, [r7, #12]
 800b718:	f7ff febe 	bl	800b498 <chSchReadyI>
 800b71c:	60f8      	str	r0, [r7, #12]
=======
 800b78a:	687b      	ldr	r3, [r7, #4]
 800b78c:	689a      	ldr	r2, [r3, #8]
 800b78e:	68fb      	ldr	r3, [r7, #12]
 800b790:	689b      	ldr	r3, [r3, #8]
 800b792:	429a      	cmp	r2, r3
 800b794:	d803      	bhi.n	800b79e <chSchWakeupS+0x4e>
    (void) chSchReadyI(ntp);
 800b796:	6878      	ldr	r0, [r7, #4]
 800b798:	f7ff fec2 	bl	800b520 <chSchReadyI>
 800b79c:	e01d      	b.n	800b7da <chSchWakeupS+0x8a>
  }
  else {
    otp = chSchReadyI(otp);
 800b79e:	68f8      	ldr	r0, [r7, #12]
 800b7a0:	f7ff febe 	bl	800b520 <chSchReadyI>
 800b7a4:	60f8      	str	r0, [r7, #12]
>>>>>>> 752c83b... update binaries
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
<<<<<<< HEAD
 800b71e:	4a0e      	ldr	r2, [pc, #56]	; (800b758 <chSchWakeupS+0x90>)
 800b720:	687b      	ldr	r3, [r7, #4]
 800b722:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 800b724:	687b      	ldr	r3, [r7, #4]
 800b726:	2201      	movs	r2, #1
 800b728:	f883 2020 	strb.w	r2, [r3, #32]
=======
 800b7a6:	4a0e      	ldr	r2, [pc, #56]	; (800b7e0 <chSchWakeupS+0x90>)
 800b7a8:	687b      	ldr	r3, [r7, #4]
 800b7aa:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 800b7ac:	687b      	ldr	r3, [r7, #4]
 800b7ae:	2201      	movs	r2, #1
 800b7b0:	f883 2020 	strb.w	r2, [r3, #32]
>>>>>>> 752c83b... update binaries
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
<<<<<<< HEAD
 800b72c:	f3ef 8309 	mrs	r3, PSP
 800b730:	461c      	mov	r4, r3
  return(result);
 800b732:	4623      	mov	r3, r4

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800b734:	60bb      	str	r3, [r7, #8]
 800b736:	68bb      	ldr	r3, [r7, #8]
 800b738:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b73c:	68fb      	ldr	r3, [r7, #12]
 800b73e:	69db      	ldr	r3, [r3, #28]
 800b740:	429a      	cmp	r2, r3
 800b742:	d202      	bcs.n	800b74a <chSchWakeupS+0x82>
 800b744:	4806      	ldr	r0, [pc, #24]	; (800b760 <chSchWakeupS+0x98>)
 800b746:	f7ff fb2d 	bl	800ada4 <chSysHalt>
 800b74a:	6878      	ldr	r0, [r7, #4]
 800b74c:	68f9      	ldr	r1, [r7, #12]
 800b74e:	f7f7 fda9 	bl	80032a4 <_port_switch>
  }
}
 800b752:	3714      	adds	r7, #20
 800b754:	46bd      	mov	sp, r7
 800b756:	bd90      	pop	{r4, r7, pc}
 800b758:	20001338 	.word	0x20001338
 800b75c:	0800e8b8 	.word	0x0800e8b8
 800b760:	0800e6c0 	.word	0x0800e6c0

0800b764 <chSchRescheduleS>:
=======
 800b7b4:	f3ef 8309 	mrs	r3, PSP
 800b7b8:	461c      	mov	r4, r3
  return(result);
 800b7ba:	4623      	mov	r3, r4

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800b7bc:	60bb      	str	r3, [r7, #8]
 800b7be:	68bb      	ldr	r3, [r7, #8]
 800b7c0:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b7c4:	68fb      	ldr	r3, [r7, #12]
 800b7c6:	69db      	ldr	r3, [r3, #28]
 800b7c8:	429a      	cmp	r2, r3
 800b7ca:	d202      	bcs.n	800b7d2 <chSchWakeupS+0x82>
 800b7cc:	4806      	ldr	r0, [pc, #24]	; (800b7e8 <chSchWakeupS+0x98>)
 800b7ce:	f7ff fb2d 	bl	800ae2c <chSysHalt>
 800b7d2:	6878      	ldr	r0, [r7, #4]
 800b7d4:	68f9      	ldr	r1, [r7, #12]
 800b7d6:	f7f7 fd65 	bl	80032a4 <_port_switch>
  }
}
 800b7da:	3714      	adds	r7, #20
 800b7dc:	46bd      	mov	sp, r7
 800b7de:	bd90      	pop	{r4, r7, pc}
 800b7e0:	20001338 	.word	0x20001338
 800b7e4:	0800e990 	.word	0x0800e990
 800b7e8:	0800e79c 	.word	0x0800e79c

0800b7ec <chSchRescheduleS>:
>>>>>>> 752c83b... update binaries
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
<<<<<<< HEAD
 800b764:	b580      	push	{r7, lr}
 800b766:	af00      	add	r7, sp, #0

  chDbgCheckClassS();
 800b768:	f7ff fc0c 	bl	800af84 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 800b76c:	f7ff fdce 	bl	800b30c <chSchIsRescRequiredI>
 800b770:	4603      	mov	r3, r0
 800b772:	2b00      	cmp	r3, #0
 800b774:	d001      	beq.n	800b77a <chSchRescheduleS+0x16>
    chSchDoRescheduleAhead();
 800b776:	f000 f81b 	bl	800b7b0 <chSchDoRescheduleAhead>
  }
}
 800b77a:	bd80      	pop	{r7, pc}

0800b77c <chSchIsPreemptionRequired>:
=======
 800b7ec:	b580      	push	{r7, lr}
 800b7ee:	af00      	add	r7, sp, #0

  chDbgCheckClassS();
 800b7f0:	f7ff fc0c 	bl	800b00c <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 800b7f4:	f7ff fdce 	bl	800b394 <chSchIsRescRequiredI>
 800b7f8:	4603      	mov	r3, r0
 800b7fa:	2b00      	cmp	r3, #0
 800b7fc:	d001      	beq.n	800b802 <chSchRescheduleS+0x16>
    chSchDoRescheduleAhead();
 800b7fe:	f000 f81b 	bl	800b838 <chSchDoRescheduleAhead>
  }
}
 800b802:	bd80      	pop	{r7, pc}

0800b804 <chSchIsPreemptionRequired>:
>>>>>>> 752c83b... update binaries
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
<<<<<<< HEAD
 800b77c:	b480      	push	{r7}
 800b77e:	b083      	sub	sp, #12
 800b780:	af00      	add	r7, sp, #0
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800b782:	4b0a      	ldr	r3, [pc, #40]	; (800b7ac <chSchIsPreemptionRequired+0x30>)
 800b784:	681b      	ldr	r3, [r3, #0]
 800b786:	689b      	ldr	r3, [r3, #8]
 800b788:	607b      	str	r3, [r7, #4]
  tprio_t p2 = currp->prio;
 800b78a:	4b08      	ldr	r3, [pc, #32]	; (800b7ac <chSchIsPreemptionRequired+0x30>)
 800b78c:	699b      	ldr	r3, [r3, #24]
 800b78e:	689b      	ldr	r3, [r3, #8]
 800b790:	603b      	str	r3, [r7, #0]
=======
 800b804:	b480      	push	{r7}
 800b806:	b083      	sub	sp, #12
 800b808:	af00      	add	r7, sp, #0
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800b80a:	4b0a      	ldr	r3, [pc, #40]	; (800b834 <chSchIsPreemptionRequired+0x30>)
 800b80c:	681b      	ldr	r3, [r3, #0]
 800b80e:	689b      	ldr	r3, [r3, #8]
 800b810:	607b      	str	r3, [r7, #4]
  tprio_t p2 = currp->prio;
 800b812:	4b08      	ldr	r3, [pc, #32]	; (800b834 <chSchIsPreemptionRequired+0x30>)
 800b814:	699b      	ldr	r3, [r3, #24]
 800b816:	689b      	ldr	r3, [r3, #8]
 800b818:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
<<<<<<< HEAD
 800b792:	687a      	ldr	r2, [r7, #4]
 800b794:	683b      	ldr	r3, [r7, #0]
 800b796:	429a      	cmp	r2, r3
 800b798:	bf8c      	ite	hi
 800b79a:	2301      	movhi	r3, #1
 800b79c:	2300      	movls	r3, #0
 800b79e:	b2db      	uxtb	r3, r3
#endif
}
 800b7a0:	4618      	mov	r0, r3
 800b7a2:	370c      	adds	r7, #12
 800b7a4:	46bd      	mov	sp, r7
 800b7a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b7aa:	4770      	bx	lr
 800b7ac:	20001338 	.word	0x20001338

0800b7b0 <chSchDoRescheduleAhead>:
=======
 800b81a:	687a      	ldr	r2, [r7, #4]
 800b81c:	683b      	ldr	r3, [r7, #0]
 800b81e:	429a      	cmp	r2, r3
 800b820:	bf8c      	ite	hi
 800b822:	2301      	movhi	r3, #1
 800b824:	2300      	movls	r3, #0
 800b826:	b2db      	uxtb	r3, r3
#endif
}
 800b828:	4618      	mov	r0, r3
 800b82a:	370c      	adds	r7, #12
 800b82c:	46bd      	mov	sp, r7
 800b82e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b832:	4770      	bx	lr
 800b834:	20001338 	.word	0x20001338

0800b838 <chSchDoRescheduleAhead>:
>>>>>>> 752c83b... update binaries
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
<<<<<<< HEAD
 800b7b0:	b590      	push	{r4, r7, lr}
 800b7b2:	b083      	sub	sp, #12
 800b7b4:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800b7b6:	4b15      	ldr	r3, [pc, #84]	; (800b80c <chSchDoRescheduleAhead+0x5c>)
 800b7b8:	699b      	ldr	r3, [r3, #24]
 800b7ba:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b7bc:	4813      	ldr	r0, [pc, #76]	; (800b80c <chSchDoRescheduleAhead+0x5c>)
 800b7be:	f7ff fe2d 	bl	800b41c <queue_fifo_remove>
 800b7c2:	4602      	mov	r2, r0
 800b7c4:	4b11      	ldr	r3, [pc, #68]	; (800b80c <chSchDoRescheduleAhead+0x5c>)
 800b7c6:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b7c8:	4b10      	ldr	r3, [pc, #64]	; (800b80c <chSchDoRescheduleAhead+0x5c>)
 800b7ca:	699b      	ldr	r3, [r3, #24]
 800b7cc:	2201      	movs	r2, #1
 800b7ce:	f883 2020 	strb.w	r2, [r3, #32]
=======
 800b838:	b590      	push	{r4, r7, lr}
 800b83a:	b083      	sub	sp, #12
 800b83c:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800b83e:	4b15      	ldr	r3, [pc, #84]	; (800b894 <chSchDoRescheduleAhead+0x5c>)
 800b840:	699b      	ldr	r3, [r3, #24]
 800b842:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b844:	4813      	ldr	r0, [pc, #76]	; (800b894 <chSchDoRescheduleAhead+0x5c>)
 800b846:	f7ff fe2d 	bl	800b4a4 <queue_fifo_remove>
 800b84a:	4602      	mov	r2, r0
 800b84c:	4b11      	ldr	r3, [pc, #68]	; (800b894 <chSchDoRescheduleAhead+0x5c>)
 800b84e:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b850:	4b10      	ldr	r3, [pc, #64]	; (800b894 <chSchDoRescheduleAhead+0x5c>)
 800b852:	699b      	ldr	r3, [r3, #24]
 800b854:	2201      	movs	r2, #1
 800b856:	f883 2020 	strb.w	r2, [r3, #32]
>>>>>>> 752c83b... update binaries
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
<<<<<<< HEAD
 800b7d2:	6878      	ldr	r0, [r7, #4]
 800b7d4:	f7ff fea0 	bl	800b518 <chSchReadyAheadI>
 800b7d8:	6078      	str	r0, [r7, #4]
=======
 800b85a:	6878      	ldr	r0, [r7, #4]
 800b85c:	f7ff fea0 	bl	800b5a0 <chSchReadyAheadI>
 800b860:	6078      	str	r0, [r7, #4]
>>>>>>> 752c83b... update binaries
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
<<<<<<< HEAD
 800b7da:	f3ef 8309 	mrs	r3, PSP
 800b7de:	461c      	mov	r4, r3
  return(result);
 800b7e0:	4623      	mov	r3, r4

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b7e2:	603b      	str	r3, [r7, #0]
 800b7e4:	683b      	ldr	r3, [r7, #0]
 800b7e6:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b7ea:	687b      	ldr	r3, [r7, #4]
 800b7ec:	69db      	ldr	r3, [r3, #28]
 800b7ee:	429a      	cmp	r2, r3
 800b7f0:	d202      	bcs.n	800b7f8 <chSchDoRescheduleAhead+0x48>
 800b7f2:	4807      	ldr	r0, [pc, #28]	; (800b810 <chSchDoRescheduleAhead+0x60>)
 800b7f4:	f7ff fad6 	bl	800ada4 <chSysHalt>
 800b7f8:	4b04      	ldr	r3, [pc, #16]	; (800b80c <chSchDoRescheduleAhead+0x5c>)
 800b7fa:	699b      	ldr	r3, [r3, #24]
 800b7fc:	4618      	mov	r0, r3
 800b7fe:	6879      	ldr	r1, [r7, #4]
 800b800:	f7f7 fd50 	bl	80032a4 <_port_switch>
}
 800b804:	370c      	adds	r7, #12
 800b806:	46bd      	mov	sp, r7
 800b808:	bd90      	pop	{r4, r7, pc}
 800b80a:	bf00      	nop
 800b80c:	20001338 	.word	0x20001338
 800b810:	0800e6c0 	.word	0x0800e6c0

0800b814 <chSchDoReschedule>:
=======
 800b862:	f3ef 8309 	mrs	r3, PSP
 800b866:	461c      	mov	r4, r3
  return(result);
 800b868:	4623      	mov	r3, r4

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b86a:	603b      	str	r3, [r7, #0]
 800b86c:	683b      	ldr	r3, [r7, #0]
 800b86e:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b872:	687b      	ldr	r3, [r7, #4]
 800b874:	69db      	ldr	r3, [r3, #28]
 800b876:	429a      	cmp	r2, r3
 800b878:	d202      	bcs.n	800b880 <chSchDoRescheduleAhead+0x48>
 800b87a:	4807      	ldr	r0, [pc, #28]	; (800b898 <chSchDoRescheduleAhead+0x60>)
 800b87c:	f7ff fad6 	bl	800ae2c <chSysHalt>
 800b880:	4b04      	ldr	r3, [pc, #16]	; (800b894 <chSchDoRescheduleAhead+0x5c>)
 800b882:	699b      	ldr	r3, [r3, #24]
 800b884:	4618      	mov	r0, r3
 800b886:	6879      	ldr	r1, [r7, #4]
 800b888:	f7f7 fd0c 	bl	80032a4 <_port_switch>
}
 800b88c:	370c      	adds	r7, #12
 800b88e:	46bd      	mov	sp, r7
 800b890:	bd90      	pop	{r4, r7, pc}
 800b892:	bf00      	nop
 800b894:	20001338 	.word	0x20001338
 800b898:	0800e79c 	.word	0x0800e79c

0800b89c <chSchDoReschedule>:
>>>>>>> 752c83b... update binaries
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
<<<<<<< HEAD
 800b814:	b590      	push	{r4, r7, lr}
 800b816:	b083      	sub	sp, #12
 800b818:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800b81a:	4b15      	ldr	r3, [pc, #84]	; (800b870 <chSchDoReschedule+0x5c>)
 800b81c:	699b      	ldr	r3, [r3, #24]
 800b81e:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b820:	4813      	ldr	r0, [pc, #76]	; (800b870 <chSchDoReschedule+0x5c>)
 800b822:	f7ff fdfb 	bl	800b41c <queue_fifo_remove>
 800b826:	4602      	mov	r2, r0
 800b828:	4b11      	ldr	r3, [pc, #68]	; (800b870 <chSchDoReschedule+0x5c>)
 800b82a:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b82c:	4b10      	ldr	r3, [pc, #64]	; (800b870 <chSchDoReschedule+0x5c>)
 800b82e:	699b      	ldr	r3, [r3, #24]
 800b830:	2201      	movs	r2, #1
 800b832:	f883 2020 	strb.w	r2, [r3, #32]
=======
 800b89c:	b590      	push	{r4, r7, lr}
 800b89e:	b083      	sub	sp, #12
 800b8a0:	af00      	add	r7, sp, #0
  thread_t *otp = currp;
 800b8a2:	4b15      	ldr	r3, [pc, #84]	; (800b8f8 <chSchDoReschedule+0x5c>)
 800b8a4:	699b      	ldr	r3, [r3, #24]
 800b8a6:	607b      	str	r3, [r7, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b8a8:	4813      	ldr	r0, [pc, #76]	; (800b8f8 <chSchDoReschedule+0x5c>)
 800b8aa:	f7ff fdfb 	bl	800b4a4 <queue_fifo_remove>
 800b8ae:	4602      	mov	r2, r0
 800b8b0:	4b11      	ldr	r3, [pc, #68]	; (800b8f8 <chSchDoReschedule+0x5c>)
 800b8b2:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b8b4:	4b10      	ldr	r3, [pc, #64]	; (800b8f8 <chSchDoReschedule+0x5c>)
 800b8b6:	699b      	ldr	r3, [r3, #24]
 800b8b8:	2201      	movs	r2, #1
 800b8ba:	f883 2020 	strb.w	r2, [r3, #32]
>>>>>>> 752c83b... update binaries
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
<<<<<<< HEAD
 800b836:	6878      	ldr	r0, [r7, #4]
 800b838:	f7ff fe6e 	bl	800b518 <chSchReadyAheadI>
 800b83c:	6078      	str	r0, [r7, #4]
=======
 800b8be:	6878      	ldr	r0, [r7, #4]
 800b8c0:	f7ff fe6e 	bl	800b5a0 <chSchReadyAheadI>
 800b8c4:	6078      	str	r0, [r7, #4]
>>>>>>> 752c83b... update binaries
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
<<<<<<< HEAD
 800b83e:	f3ef 8309 	mrs	r3, PSP
 800b842:	461c      	mov	r4, r3
  return(result);
 800b844:	4623      	mov	r3, r4
=======
 800b8c6:	f3ef 8309 	mrs	r3, PSP
 800b8ca:	461c      	mov	r4, r3
  return(result);
 800b8cc:	4623      	mov	r3, r4
>>>>>>> 752c83b... update binaries
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
<<<<<<< HEAD
 800b846:	603b      	str	r3, [r7, #0]
 800b848:	683b      	ldr	r3, [r7, #0]
 800b84a:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b84e:	687b      	ldr	r3, [r7, #4]
 800b850:	69db      	ldr	r3, [r3, #28]
 800b852:	429a      	cmp	r2, r3
 800b854:	d202      	bcs.n	800b85c <chSchDoReschedule+0x48>
 800b856:	4807      	ldr	r0, [pc, #28]	; (800b874 <chSchDoReschedule+0x60>)
 800b858:	f7ff faa4 	bl	800ada4 <chSysHalt>
 800b85c:	4b04      	ldr	r3, [pc, #16]	; (800b870 <chSchDoReschedule+0x5c>)
 800b85e:	699b      	ldr	r3, [r3, #24]
 800b860:	4618      	mov	r0, r3
 800b862:	6879      	ldr	r1, [r7, #4]
 800b864:	f7f7 fd1e 	bl	80032a4 <_port_switch>
}
 800b868:	370c      	adds	r7, #12
 800b86a:	46bd      	mov	sp, r7
 800b86c:	bd90      	pop	{r4, r7, pc}
 800b86e:	bf00      	nop
 800b870:	20001338 	.word	0x20001338
 800b874:	0800e6c0 	.word	0x0800e6c0

0800b878 <port_lock.lto_priv.314>:
=======
 800b8ce:	603b      	str	r3, [r7, #0]
 800b8d0:	683b      	ldr	r3, [r7, #0]
 800b8d2:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800b8d6:	687b      	ldr	r3, [r7, #4]
 800b8d8:	69db      	ldr	r3, [r3, #28]
 800b8da:	429a      	cmp	r2, r3
 800b8dc:	d202      	bcs.n	800b8e4 <chSchDoReschedule+0x48>
 800b8de:	4807      	ldr	r0, [pc, #28]	; (800b8fc <chSchDoReschedule+0x60>)
 800b8e0:	f7ff faa4 	bl	800ae2c <chSysHalt>
 800b8e4:	4b04      	ldr	r3, [pc, #16]	; (800b8f8 <chSchDoReschedule+0x5c>)
 800b8e6:	699b      	ldr	r3, [r3, #24]
 800b8e8:	4618      	mov	r0, r3
 800b8ea:	6879      	ldr	r1, [r7, #4]
 800b8ec:	f7f7 fcda 	bl	80032a4 <_port_switch>
}
 800b8f0:	370c      	adds	r7, #12
 800b8f2:	46bd      	mov	sp, r7
 800b8f4:	bd90      	pop	{r4, r7, pc}
 800b8f6:	bf00      	nop
 800b8f8:	20001338 	.word	0x20001338
 800b8fc:	0800e79c 	.word	0x0800e79c

0800b900 <port_lock.lto_priv.311>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800b878:	b480      	push	{r7}
 800b87a:	b083      	sub	sp, #12
 800b87c:	af00      	add	r7, sp, #0
 800b87e:	2320      	movs	r3, #32
 800b880:	607b      	str	r3, [r7, #4]
=======
 800b900:	b480      	push	{r7}
 800b902:	b083      	sub	sp, #12
 800b904:	af00      	add	r7, sp, #0
 800b906:	2320      	movs	r3, #32
 800b908:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
<<<<<<< HEAD
 800b882:	687b      	ldr	r3, [r7, #4]
 800b884:	f383 8811 	msr	BASEPRI, r3
=======
 800b90a:	687b      	ldr	r3, [r7, #4]
 800b90c:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800b888:	370c      	adds	r7, #12
 800b88a:	46bd      	mov	sp, r7
 800b88c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b890:	4770      	bx	lr
 800b892:	bf00      	nop

0800b894 <port_unlock.lto_priv.311>:
=======
 800b910:	370c      	adds	r7, #12
 800b912:	46bd      	mov	sp, r7
 800b914:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b918:	4770      	bx	lr
 800b91a:	bf00      	nop

0800b91c <port_unlock.lto_priv.308>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800b894:	b480      	push	{r7}
 800b896:	b083      	sub	sp, #12
 800b898:	af00      	add	r7, sp, #0
 800b89a:	2300      	movs	r3, #0
 800b89c:	607b      	str	r3, [r7, #4]
 800b89e:	687b      	ldr	r3, [r7, #4]
 800b8a0:	f383 8811 	msr	BASEPRI, r3
=======
 800b91c:	b480      	push	{r7}
 800b91e:	b083      	sub	sp, #12
 800b920:	af00      	add	r7, sp, #0
 800b922:	2300      	movs	r3, #0
 800b924:	607b      	str	r3, [r7, #4]
 800b926:	687b      	ldr	r3, [r7, #4]
 800b928:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800b8a4:	370c      	adds	r7, #12
 800b8a6:	46bd      	mov	sp, r7
 800b8a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8ac:	4770      	bx	lr
 800b8ae:	bf00      	nop

0800b8b0 <list_init>:
=======
 800b92c:	370c      	adds	r7, #12
 800b92e:	46bd      	mov	sp, r7
 800b930:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b934:	4770      	bx	lr
 800b936:	bf00      	nop

0800b938 <list_init>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
<<<<<<< HEAD
 800b8b0:	b480      	push	{r7}
 800b8b2:	b083      	sub	sp, #12
 800b8b4:	af00      	add	r7, sp, #0
 800b8b6:	6078      	str	r0, [r7, #4]

  tlp->next = (thread_t *)tlp;
 800b8b8:	687b      	ldr	r3, [r7, #4]
 800b8ba:	687a      	ldr	r2, [r7, #4]
 800b8bc:	601a      	str	r2, [r3, #0]
}
 800b8be:	370c      	adds	r7, #12
 800b8c0:	46bd      	mov	sp, r7
 800b8c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8c6:	4770      	bx	lr

0800b8c8 <list_notempty.lto_priv.296>:
=======
 800b938:	b480      	push	{r7}
 800b93a:	b083      	sub	sp, #12
 800b93c:	af00      	add	r7, sp, #0
 800b93e:	6078      	str	r0, [r7, #4]

  tlp->next = (thread_t *)tlp;
 800b940:	687b      	ldr	r3, [r7, #4]
 800b942:	687a      	ldr	r2, [r7, #4]
 800b944:	601a      	str	r2, [r3, #0]
}
 800b946:	370c      	adds	r7, #12
 800b948:	46bd      	mov	sp, r7
 800b94a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b94e:	4770      	bx	lr

0800b950 <list_notempty.lto_priv.293>:
>>>>>>> 752c83b... update binaries
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
<<<<<<< HEAD
 800b8c8:	b480      	push	{r7}
 800b8ca:	b083      	sub	sp, #12
 800b8cc:	af00      	add	r7, sp, #0
 800b8ce:	6078      	str	r0, [r7, #4]

  return (bool)(tlp->next != (thread_t *)tlp);
 800b8d0:	687b      	ldr	r3, [r7, #4]
 800b8d2:	681a      	ldr	r2, [r3, #0]
 800b8d4:	687b      	ldr	r3, [r7, #4]
 800b8d6:	429a      	cmp	r2, r3
 800b8d8:	bf14      	ite	ne
 800b8da:	2301      	movne	r3, #1
 800b8dc:	2300      	moveq	r3, #0
 800b8de:	b2db      	uxtb	r3, r3
}
 800b8e0:	4618      	mov	r0, r3
 800b8e2:	370c      	adds	r7, #12
 800b8e4:	46bd      	mov	sp, r7
 800b8e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8ea:	4770      	bx	lr

0800b8ec <queue_notempty.lto_priv.278>:
=======
 800b950:	b480      	push	{r7}
 800b952:	b083      	sub	sp, #12
 800b954:	af00      	add	r7, sp, #0
 800b956:	6078      	str	r0, [r7, #4]

  return (bool)(tlp->next != (thread_t *)tlp);
 800b958:	687b      	ldr	r3, [r7, #4]
 800b95a:	681a      	ldr	r2, [r3, #0]
 800b95c:	687b      	ldr	r3, [r7, #4]
 800b95e:	429a      	cmp	r2, r3
 800b960:	bf14      	ite	ne
 800b962:	2301      	movne	r3, #1
 800b964:	2300      	moveq	r3, #0
 800b966:	b2db      	uxtb	r3, r3
}
 800b968:	4618      	mov	r0, r3
 800b96a:	370c      	adds	r7, #12
 800b96c:	46bd      	mov	sp, r7
 800b96e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b972:	4770      	bx	lr

0800b974 <queue_notempty.lto_priv.275>:
>>>>>>> 752c83b... update binaries
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
<<<<<<< HEAD
 800b8ec:	b480      	push	{r7}
 800b8ee:	b083      	sub	sp, #12
 800b8f0:	af00      	add	r7, sp, #0
 800b8f2:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 800b8f4:	687b      	ldr	r3, [r7, #4]
 800b8f6:	681a      	ldr	r2, [r3, #0]
 800b8f8:	687b      	ldr	r3, [r7, #4]
 800b8fa:	429a      	cmp	r2, r3
 800b8fc:	bf14      	ite	ne
 800b8fe:	2301      	movne	r3, #1
 800b900:	2300      	moveq	r3, #0
 800b902:	b2db      	uxtb	r3, r3
}
 800b904:	4618      	mov	r0, r3
 800b906:	370c      	adds	r7, #12
 800b908:	46bd      	mov	sp, r7
 800b90a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b90e:	4770      	bx	lr

0800b910 <chSysLock.lto_priv.258>:
=======
 800b974:	b480      	push	{r7}
 800b976:	b083      	sub	sp, #12
 800b978:	af00      	add	r7, sp, #0
 800b97a:	6078      	str	r0, [r7, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 800b97c:	687b      	ldr	r3, [r7, #4]
 800b97e:	681a      	ldr	r2, [r3, #0]
 800b980:	687b      	ldr	r3, [r7, #4]
 800b982:	429a      	cmp	r2, r3
 800b984:	bf14      	ite	ne
 800b986:	2301      	movne	r3, #1
 800b988:	2300      	moveq	r3, #0
 800b98a:	b2db      	uxtb	r3, r3
}
 800b98c:	4618      	mov	r0, r3
 800b98e:	370c      	adds	r7, #12
 800b990:	46bd      	mov	sp, r7
 800b992:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b996:	4770      	bx	lr

0800b998 <chSysLock.lto_priv.255>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
<<<<<<< HEAD
 800b910:	b580      	push	{r7, lr}
 800b912:	af00      	add	r7, sp, #0

  port_lock();
 800b914:	f7ff ffb0 	bl	800b878 <port_lock.lto_priv.314>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b918:	f7ff fa92 	bl	800ae40 <_dbg_check_lock>
}
 800b91c:	bd80      	pop	{r7, pc}
 800b91e:	bf00      	nop

0800b920 <chSysUnlock.lto_priv.253>:
=======
 800b998:	b580      	push	{r7, lr}
 800b99a:	af00      	add	r7, sp, #0

  port_lock();
 800b99c:	f7ff ffb0 	bl	800b900 <port_lock.lto_priv.311>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b9a0:	f7ff fa92 	bl	800aec8 <_dbg_check_lock>
}
 800b9a4:	bd80      	pop	{r7, pc}
 800b9a6:	bf00      	nop

0800b9a8 <chSysUnlock.lto_priv.250>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
<<<<<<< HEAD
 800b920:	b580      	push	{r7, lr}
 800b922:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800b924:	f7ff faa2 	bl	800ae6c <_dbg_check_unlock>
=======
 800b9a8:	b580      	push	{r7, lr}
 800b9aa:	af00      	add	r7, sp, #0

  _dbg_check_unlock();
 800b9ac:	f7ff faa2 	bl	800aef4 <_dbg_check_unlock>
>>>>>>> 752c83b... update binaries

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
<<<<<<< HEAD
 800b928:	4b09      	ldr	r3, [pc, #36]	; (800b950 <chSysUnlock.lto_priv.253+0x30>)
 800b92a:	681b      	ldr	r3, [r3, #0]
 800b92c:	4a08      	ldr	r2, [pc, #32]	; (800b950 <chSysUnlock.lto_priv.253+0x30>)
 800b92e:	4293      	cmp	r3, r2
 800b930:	d00a      	beq.n	800b948 <chSysUnlock.lto_priv.253+0x28>
 800b932:	4b07      	ldr	r3, [pc, #28]	; (800b950 <chSysUnlock.lto_priv.253+0x30>)
 800b934:	699b      	ldr	r3, [r3, #24]
 800b936:	689a      	ldr	r2, [r3, #8]
 800b938:	4b05      	ldr	r3, [pc, #20]	; (800b950 <chSysUnlock.lto_priv.253+0x30>)
 800b93a:	681b      	ldr	r3, [r3, #0]
 800b93c:	689b      	ldr	r3, [r3, #8]
 800b93e:	429a      	cmp	r2, r3
 800b940:	d202      	bcs.n	800b948 <chSysUnlock.lto_priv.253+0x28>
 800b942:	4804      	ldr	r0, [pc, #16]	; (800b954 <chSysUnlock.lto_priv.253+0x34>)
 800b944:	f7ff fa2e 	bl	800ada4 <chSysHalt>
=======
 800b9b0:	4b09      	ldr	r3, [pc, #36]	; (800b9d8 <chSysUnlock.lto_priv.250+0x30>)
 800b9b2:	681b      	ldr	r3, [r3, #0]
 800b9b4:	4a08      	ldr	r2, [pc, #32]	; (800b9d8 <chSysUnlock.lto_priv.250+0x30>)
 800b9b6:	4293      	cmp	r3, r2
 800b9b8:	d00a      	beq.n	800b9d0 <chSysUnlock.lto_priv.250+0x28>
 800b9ba:	4b07      	ldr	r3, [pc, #28]	; (800b9d8 <chSysUnlock.lto_priv.250+0x30>)
 800b9bc:	699b      	ldr	r3, [r3, #24]
 800b9be:	689a      	ldr	r2, [r3, #8]
 800b9c0:	4b05      	ldr	r3, [pc, #20]	; (800b9d8 <chSysUnlock.lto_priv.250+0x30>)
 800b9c2:	681b      	ldr	r3, [r3, #0]
 800b9c4:	689b      	ldr	r3, [r3, #8]
 800b9c6:	429a      	cmp	r2, r3
 800b9c8:	d202      	bcs.n	800b9d0 <chSysUnlock.lto_priv.250+0x28>
 800b9ca:	4804      	ldr	r0, [pc, #16]	; (800b9dc <chSysUnlock.lto_priv.250+0x34>)
 800b9cc:	f7ff fa2e 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
<<<<<<< HEAD
 800b948:	f7ff ffa4 	bl	800b894 <port_unlock.lto_priv.311>
}
 800b94c:	bd80      	pop	{r7, pc}
 800b94e:	bf00      	nop
 800b950:	20001338 	.word	0x20001338
 800b954:	0800e8e0 	.word	0x0800e8e0

0800b958 <chThdGetSelfX.lto_priv.291>:
=======
 800b9d0:	f7ff ffa4 	bl	800b91c <port_unlock.lto_priv.308>
}
 800b9d4:	bd80      	pop	{r7, pc}
 800b9d6:	bf00      	nop
 800b9d8:	20001338 	.word	0x20001338
 800b9dc:	0800e9b8 	.word	0x0800e9b8

0800b9e0 <chThdGetSelfX.lto_priv.288>:
>>>>>>> 752c83b... update binaries
  *
  * @return             A pointer to the current thread.
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {
<<<<<<< HEAD
 800b958:	b480      	push	{r7}
 800b95a:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 800b95c:	4b03      	ldr	r3, [pc, #12]	; (800b96c <chThdGetSelfX.lto_priv.291+0x14>)
 800b95e:	699b      	ldr	r3, [r3, #24]
}
 800b960:	4618      	mov	r0, r3
 800b962:	46bd      	mov	sp, r7
 800b964:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b968:	4770      	bx	lr
 800b96a:	bf00      	nop
 800b96c:	20001338 	.word	0x20001338

0800b970 <chThdGetWorkingAreaX.lto_priv.281>:
=======
 800b9e0:	b480      	push	{r7}
 800b9e2:	af00      	add	r7, sp, #0

  return ch.rlist.current;
 800b9e4:	4b03      	ldr	r3, [pc, #12]	; (800b9f4 <chThdGetSelfX.lto_priv.288+0x14>)
 800b9e6:	699b      	ldr	r3, [r3, #24]
}
 800b9e8:	4618      	mov	r0, r3
 800b9ea:	46bd      	mov	sp, r7
 800b9ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b9f0:	4770      	bx	lr
 800b9f2:	bf00      	nop
 800b9f4:	20001338 	.word	0x20001338

0800b9f8 <chThdGetWorkingAreaX.lto_priv.278>:
>>>>>>> 752c83b... update binaries
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
<<<<<<< HEAD
 800b970:	b480      	push	{r7}
 800b972:	b083      	sub	sp, #12
 800b974:	af00      	add	r7, sp, #0
 800b976:	6078      	str	r0, [r7, #4]

  return tp->wabase;
 800b978:	687b      	ldr	r3, [r7, #4]
 800b97a:	69db      	ldr	r3, [r3, #28]
}
 800b97c:	4618      	mov	r0, r3
 800b97e:	370c      	adds	r7, #12
 800b980:	46bd      	mov	sp, r7
 800b982:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b986:	4770      	bx	lr

0800b988 <chThdDoDequeueNextI.lto_priv.290>:
=======
 800b9f8:	b480      	push	{r7}
 800b9fa:	b083      	sub	sp, #12
 800b9fc:	af00      	add	r7, sp, #0
 800b9fe:	6078      	str	r0, [r7, #4]

  return tp->wabase;
 800ba00:	687b      	ldr	r3, [r7, #4]
 800ba02:	69db      	ldr	r3, [r3, #28]
}
 800ba04:	4618      	mov	r0, r3
 800ba06:	370c      	adds	r7, #12
 800ba08:	46bd      	mov	sp, r7
 800ba0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba0e:	4770      	bx	lr

0800ba10 <chThdDoDequeueNextI.lto_priv.287>:
>>>>>>> 752c83b... update binaries
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
<<<<<<< HEAD
 800b988:	b580      	push	{r7, lr}
 800b98a:	b084      	sub	sp, #16
 800b98c:	af00      	add	r7, sp, #0
 800b98e:	6078      	str	r0, [r7, #4]
 800b990:	6039      	str	r1, [r7, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 800b992:	6878      	ldr	r0, [r7, #4]
 800b994:	f7ff ffaa 	bl	800b8ec <queue_notempty.lto_priv.278>
 800b998:	4603      	mov	r3, r0
 800b99a:	f083 0301 	eor.w	r3, r3, #1
 800b99e:	b2db      	uxtb	r3, r3
 800b9a0:	2b00      	cmp	r3, #0
 800b9a2:	d002      	beq.n	800b9aa <chThdDoDequeueNextI.lto_priv.290+0x22>
 800b9a4:	480b      	ldr	r0, [pc, #44]	; (800b9d4 <chThdDoDequeueNextI.lto_priv.290+0x4c>)
 800b9a6:	f7ff f9fd 	bl	800ada4 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 800b9aa:	6878      	ldr	r0, [r7, #4]
 800b9ac:	f7ff fd36 	bl	800b41c <queue_fifo_remove>
 800b9b0:	60f8      	str	r0, [r7, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800b9b2:	68fb      	ldr	r3, [r7, #12]
 800b9b4:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b9b8:	2b04      	cmp	r3, #4
 800b9ba:	d002      	beq.n	800b9c2 <chThdDoDequeueNextI.lto_priv.290+0x3a>
 800b9bc:	4805      	ldr	r0, [pc, #20]	; (800b9d4 <chThdDoDequeueNextI.lto_priv.290+0x4c>)
 800b9be:	f7ff f9f1 	bl	800ada4 <chSysHalt>

  tp->u.rdymsg = msg;
 800b9c2:	68fb      	ldr	r3, [r7, #12]
 800b9c4:	683a      	ldr	r2, [r7, #0]
 800b9c6:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800b9c8:	68f8      	ldr	r0, [r7, #12]
 800b9ca:	f7ff fd65 	bl	800b498 <chSchReadyI>
}
 800b9ce:	3710      	adds	r7, #16
 800b9d0:	46bd      	mov	sp, r7
 800b9d2:	bd80      	pop	{r7, pc}
 800b9d4:	0800e960 	.word	0x0800e960

0800b9d8 <_thread_init>:
=======
 800ba10:	b580      	push	{r7, lr}
 800ba12:	b084      	sub	sp, #16
 800ba14:	af00      	add	r7, sp, #0
 800ba16:	6078      	str	r0, [r7, #4]
 800ba18:	6039      	str	r1, [r7, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 800ba1a:	6878      	ldr	r0, [r7, #4]
 800ba1c:	f7ff ffaa 	bl	800b974 <queue_notempty.lto_priv.275>
 800ba20:	4603      	mov	r3, r0
 800ba22:	f083 0301 	eor.w	r3, r3, #1
 800ba26:	b2db      	uxtb	r3, r3
 800ba28:	2b00      	cmp	r3, #0
 800ba2a:	d002      	beq.n	800ba32 <chThdDoDequeueNextI.lto_priv.287+0x22>
 800ba2c:	480b      	ldr	r0, [pc, #44]	; (800ba5c <chThdDoDequeueNextI.lto_priv.287+0x4c>)
 800ba2e:	f7ff f9fd 	bl	800ae2c <chSysHalt>

  tp = queue_fifo_remove(tqp);
 800ba32:	6878      	ldr	r0, [r7, #4]
 800ba34:	f7ff fd36 	bl	800b4a4 <queue_fifo_remove>
 800ba38:	60f8      	str	r0, [r7, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800ba3a:	68fb      	ldr	r3, [r7, #12]
 800ba3c:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ba40:	2b04      	cmp	r3, #4
 800ba42:	d002      	beq.n	800ba4a <chThdDoDequeueNextI.lto_priv.287+0x3a>
 800ba44:	4805      	ldr	r0, [pc, #20]	; (800ba5c <chThdDoDequeueNextI.lto_priv.287+0x4c>)
 800ba46:	f7ff f9f1 	bl	800ae2c <chSysHalt>

  tp->u.rdymsg = msg;
 800ba4a:	68fb      	ldr	r3, [r7, #12]
 800ba4c:	683a      	ldr	r2, [r7, #0]
 800ba4e:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800ba50:	68f8      	ldr	r0, [r7, #12]
 800ba52:	f7ff fd65 	bl	800b520 <chSchReadyI>
}
 800ba56:	3710      	adds	r7, #16
 800ba58:	46bd      	mov	sp, r7
 800ba5a:	bd80      	pop	{r7, pc}
 800ba5c:	0800ea38 	.word	0x0800ea38

0800ba60 <_thread_init>:
>>>>>>> 752c83b... update binaries
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
<<<<<<< HEAD
 800b9d8:	b580      	push	{r7, lr}
 800b9da:	b084      	sub	sp, #16
 800b9dc:	af00      	add	r7, sp, #0
 800b9de:	60f8      	str	r0, [r7, #12]
 800b9e0:	60b9      	str	r1, [r7, #8]
 800b9e2:	607a      	str	r2, [r7, #4]

  tp->prio      = prio;
 800b9e4:	68fb      	ldr	r3, [r7, #12]
 800b9e6:	687a      	ldr	r2, [r7, #4]
 800b9e8:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 800b9ea:	68fb      	ldr	r3, [r7, #12]
 800b9ec:	2202      	movs	r2, #2
 800b9ee:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800b9f2:	68fb      	ldr	r3, [r7, #12]
 800b9f4:	2200      	movs	r2, #0
 800b9f6:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
=======
 800ba60:	b580      	push	{r7, lr}
 800ba62:	b084      	sub	sp, #16
 800ba64:	af00      	add	r7, sp, #0
 800ba66:	60f8      	str	r0, [r7, #12]
 800ba68:	60b9      	str	r1, [r7, #8]
 800ba6a:	607a      	str	r2, [r7, #4]

  tp->prio      = prio;
 800ba6c:	68fb      	ldr	r3, [r7, #12]
 800ba6e:	687a      	ldr	r2, [r7, #4]
 800ba70:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 800ba72:	68fb      	ldr	r3, [r7, #12]
 800ba74:	2202      	movs	r2, #2
 800ba76:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800ba7a:	68fb      	ldr	r3, [r7, #12]
 800ba7c:	2200      	movs	r2, #0
 800ba7e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
>>>>>>> 752c83b... update binaries
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
<<<<<<< HEAD
 800b9fa:	68fb      	ldr	r3, [r7, #12]
 800b9fc:	687a      	ldr	r2, [r7, #4]
 800b9fe:	631a      	str	r2, [r3, #48]	; 0x30
  tp->mtxlist   = NULL;
 800ba00:	68fb      	ldr	r3, [r7, #12]
 800ba02:	2200      	movs	r2, #0
 800ba04:	62da      	str	r2, [r3, #44]	; 0x2c
=======
 800ba82:	68fb      	ldr	r3, [r7, #12]
 800ba84:	687a      	ldr	r2, [r7, #4]
 800ba86:	631a      	str	r2, [r3, #48]	; 0x30
  tp->mtxlist   = NULL;
 800ba88:	68fb      	ldr	r3, [r7, #12]
 800ba8a:	2200      	movs	r2, #0
 800ba8c:	62da      	str	r2, [r3, #44]	; 0x2c
>>>>>>> 752c83b... update binaries
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
<<<<<<< HEAD
 800ba06:	68fb      	ldr	r3, [r7, #12]
 800ba08:	2201      	movs	r2, #1
 800ba0a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 800ba0e:	68fb      	ldr	r3, [r7, #12]
 800ba10:	68ba      	ldr	r2, [r7, #8]
 800ba12:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800ba14:	68fb      	ldr	r3, [r7, #12]
 800ba16:	4a0b      	ldr	r2, [pc, #44]	; (800ba44 <_thread_init+0x6c>)
 800ba18:	611a      	str	r2, [r3, #16]
 800ba1a:	4b0a      	ldr	r3, [pc, #40]	; (800ba44 <_thread_init+0x6c>)
 800ba1c:	695a      	ldr	r2, [r3, #20]
 800ba1e:	68fb      	ldr	r3, [r7, #12]
 800ba20:	615a      	str	r2, [r3, #20]
 800ba22:	68fb      	ldr	r3, [r7, #12]
 800ba24:	695b      	ldr	r3, [r3, #20]
 800ba26:	68fa      	ldr	r2, [r7, #12]
 800ba28:	611a      	str	r2, [r3, #16]
 800ba2a:	4a06      	ldr	r2, [pc, #24]	; (800ba44 <_thread_init+0x6c>)
 800ba2c:	68fb      	ldr	r3, [r7, #12]
 800ba2e:	6153      	str	r3, [r2, #20]
=======
 800ba8e:	68fb      	ldr	r3, [r7, #12]
 800ba90:	2201      	movs	r2, #1
 800ba92:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 800ba96:	68fb      	ldr	r3, [r7, #12]
 800ba98:	68ba      	ldr	r2, [r7, #8]
 800ba9a:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800ba9c:	68fb      	ldr	r3, [r7, #12]
 800ba9e:	4a0b      	ldr	r2, [pc, #44]	; (800bacc <_thread_init+0x6c>)
 800baa0:	611a      	str	r2, [r3, #16]
 800baa2:	4b0a      	ldr	r3, [pc, #40]	; (800bacc <_thread_init+0x6c>)
 800baa4:	695a      	ldr	r2, [r3, #20]
 800baa6:	68fb      	ldr	r3, [r7, #12]
 800baa8:	615a      	str	r2, [r3, #20]
 800baaa:	68fb      	ldr	r3, [r7, #12]
 800baac:	695b      	ldr	r3, [r3, #20]
 800baae:	68fa      	ldr	r2, [r7, #12]
 800bab0:	611a      	str	r2, [r3, #16]
 800bab2:	4a06      	ldr	r2, [pc, #24]	; (800bacc <_thread_init+0x6c>)
 800bab4:	68fb      	ldr	r3, [r7, #12]
 800bab6:	6153      	str	r3, [r2, #20]
>>>>>>> 752c83b... update binaries
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
<<<<<<< HEAD
 800ba30:	68fb      	ldr	r3, [r7, #12]
 800ba32:	3328      	adds	r3, #40	; 0x28
 800ba34:	4618      	mov	r0, r3
 800ba36:	f7ff ff3b 	bl	800b8b0 <list_init>
=======
 800bab8:	68fb      	ldr	r3, [r7, #12]
 800baba:	3328      	adds	r3, #40	; 0x28
 800babc:	4618      	mov	r0, r3
 800babe:	f7ff ff3b 	bl	800b938 <list_init>
>>>>>>> 752c83b... update binaries
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
<<<<<<< HEAD
 800ba3a:	68fb      	ldr	r3, [r7, #12]
}
 800ba3c:	4618      	mov	r0, r3
 800ba3e:	3710      	adds	r7, #16
 800ba40:	46bd      	mov	sp, r7
 800ba42:	bd80      	pop	{r7, pc}
 800ba44:	20001338 	.word	0x20001338

0800ba48 <_thread_memfill>:
=======
 800bac2:	68fb      	ldr	r3, [r7, #12]
}
 800bac4:	4618      	mov	r0, r3
 800bac6:	3710      	adds	r7, #16
 800bac8:	46bd      	mov	sp, r7
 800baca:	bd80      	pop	{r7, pc}
 800bacc:	20001338 	.word	0x20001338

0800bad0 <_thread_memfill>:
>>>>>>> 752c83b... update binaries
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
<<<<<<< HEAD
 800ba48:	b480      	push	{r7}
 800ba4a:	b085      	sub	sp, #20
 800ba4c:	af00      	add	r7, sp, #0
 800ba4e:	60f8      	str	r0, [r7, #12]
 800ba50:	60b9      	str	r1, [r7, #8]
 800ba52:	4613      	mov	r3, r2
 800ba54:	71fb      	strb	r3, [r7, #7]
 800ba56:	e004      	b.n	800ba62 <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 800ba58:	68fb      	ldr	r3, [r7, #12]
 800ba5a:	1c5a      	adds	r2, r3, #1
 800ba5c:	60fa      	str	r2, [r7, #12]
 800ba5e:	79fa      	ldrb	r2, [r7, #7]
 800ba60:	701a      	strb	r2, [r3, #0]
=======
 800bad0:	b480      	push	{r7}
 800bad2:	b085      	sub	sp, #20
 800bad4:	af00      	add	r7, sp, #0
 800bad6:	60f8      	str	r0, [r7, #12]
 800bad8:	60b9      	str	r1, [r7, #8]
 800bada:	4613      	mov	r3, r2
 800badc:	71fb      	strb	r3, [r7, #7]
 800bade:	e004      	b.n	800baea <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 800bae0:	68fb      	ldr	r3, [r7, #12]
 800bae2:	1c5a      	adds	r2, r3, #1
 800bae4:	60fa      	str	r2, [r7, #12]
 800bae6:	79fa      	ldrb	r2, [r7, #7]
 800bae8:	701a      	strb	r2, [r3, #0]
>>>>>>> 752c83b... update binaries
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
<<<<<<< HEAD
 800ba62:	68fa      	ldr	r2, [r7, #12]
 800ba64:	68bb      	ldr	r3, [r7, #8]
 800ba66:	429a      	cmp	r2, r3
 800ba68:	d3f6      	bcc.n	800ba58 <_thread_memfill+0x10>
    *startp++ = v;
  }
}
 800ba6a:	3714      	adds	r7, #20
 800ba6c:	46bd      	mov	sp, r7
 800ba6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba72:	4770      	bx	lr

0800ba74 <chThdCreateSuspendedI>:
=======
 800baea:	68fa      	ldr	r2, [r7, #12]
 800baec:	68bb      	ldr	r3, [r7, #8]
 800baee:	429a      	cmp	r2, r3
 800baf0:	d3f6      	bcc.n	800bae0 <_thread_memfill+0x10>
    *startp++ = v;
  }
}
 800baf2:	3714      	adds	r7, #20
 800baf4:	46bd      	mov	sp, r7
 800baf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bafa:	4770      	bx	lr

0800bafc <chThdCreateSuspendedI>:
>>>>>>> 752c83b... update binaries
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
<<<<<<< HEAD
 800ba74:	b580      	push	{r7, lr}
 800ba76:	b084      	sub	sp, #16
 800ba78:	af00      	add	r7, sp, #0
 800ba7a:	6078      	str	r0, [r7, #4]
  thread_t *tp;

  chDbgCheckClassI();
 800ba7c:	f7ff fa70 	bl	800af60 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800ba80:	687b      	ldr	r3, [r7, #4]
 800ba82:	2b00      	cmp	r3, #0
 800ba84:	d102      	bne.n	800ba8c <chThdCreateSuspendedI+0x18>
 800ba86:	482a      	ldr	r0, [pc, #168]	; (800bb30 <chThdCreateSuspendedI+0xbc>)
 800ba88:	f7ff f98c 	bl	800ada4 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 800ba8c:	687b      	ldr	r3, [r7, #4]
 800ba8e:	685b      	ldr	r3, [r3, #4]
 800ba90:	f003 0307 	and.w	r3, r3, #7
 800ba94:	2b00      	cmp	r3, #0
 800ba96:	d113      	bne.n	800bac0 <chThdCreateSuspendedI+0x4c>
 800ba98:	687b      	ldr	r3, [r7, #4]
 800ba9a:	689b      	ldr	r3, [r3, #8]
 800ba9c:	f003 0307 	and.w	r3, r3, #7
 800baa0:	2b00      	cmp	r3, #0
 800baa2:	d10d      	bne.n	800bac0 <chThdCreateSuspendedI+0x4c>
 800baa4:	687b      	ldr	r3, [r7, #4]
 800baa6:	689a      	ldr	r2, [r3, #8]
 800baa8:	687b      	ldr	r3, [r7, #4]
 800baaa:	685b      	ldr	r3, [r3, #4]
 800baac:	429a      	cmp	r2, r3
 800baae:	d907      	bls.n	800bac0 <chThdCreateSuspendedI+0x4c>
 800bab0:	687b      	ldr	r3, [r7, #4]
 800bab2:	689b      	ldr	r3, [r3, #8]
 800bab4:	461a      	mov	r2, r3
 800bab6:	687b      	ldr	r3, [r7, #4]
 800bab8:	685b      	ldr	r3, [r3, #4]
 800baba:	1ad3      	subs	r3, r2, r3
 800babc:	2bbf      	cmp	r3, #191	; 0xbf
 800babe:	d802      	bhi.n	800bac6 <chThdCreateSuspendedI+0x52>
 800bac0:	481b      	ldr	r0, [pc, #108]	; (800bb30 <chThdCreateSuspendedI+0xbc>)
 800bac2:	f7ff f96f 	bl	800ada4 <chSysHalt>
=======
 800bafc:	b580      	push	{r7, lr}
 800bafe:	b084      	sub	sp, #16
 800bb00:	af00      	add	r7, sp, #0
 800bb02:	6078      	str	r0, [r7, #4]
  thread_t *tp;

  chDbgCheckClassI();
 800bb04:	f7ff fa70 	bl	800afe8 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800bb08:	687b      	ldr	r3, [r7, #4]
 800bb0a:	2b00      	cmp	r3, #0
 800bb0c:	d102      	bne.n	800bb14 <chThdCreateSuspendedI+0x18>
 800bb0e:	482a      	ldr	r0, [pc, #168]	; (800bbb8 <chThdCreateSuspendedI+0xbc>)
 800bb10:	f7ff f98c 	bl	800ae2c <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 800bb14:	687b      	ldr	r3, [r7, #4]
 800bb16:	685b      	ldr	r3, [r3, #4]
 800bb18:	f003 0307 	and.w	r3, r3, #7
 800bb1c:	2b00      	cmp	r3, #0
 800bb1e:	d113      	bne.n	800bb48 <chThdCreateSuspendedI+0x4c>
 800bb20:	687b      	ldr	r3, [r7, #4]
 800bb22:	689b      	ldr	r3, [r3, #8]
 800bb24:	f003 0307 	and.w	r3, r3, #7
 800bb28:	2b00      	cmp	r3, #0
 800bb2a:	d10d      	bne.n	800bb48 <chThdCreateSuspendedI+0x4c>
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	689a      	ldr	r2, [r3, #8]
 800bb30:	687b      	ldr	r3, [r7, #4]
 800bb32:	685b      	ldr	r3, [r3, #4]
 800bb34:	429a      	cmp	r2, r3
 800bb36:	d907      	bls.n	800bb48 <chThdCreateSuspendedI+0x4c>
 800bb38:	687b      	ldr	r3, [r7, #4]
 800bb3a:	689b      	ldr	r3, [r3, #8]
 800bb3c:	461a      	mov	r2, r3
 800bb3e:	687b      	ldr	r3, [r7, #4]
 800bb40:	685b      	ldr	r3, [r3, #4]
 800bb42:	1ad3      	subs	r3, r2, r3
 800bb44:	2bbf      	cmp	r3, #191	; 0xbf
 800bb46:	d802      	bhi.n	800bb4e <chThdCreateSuspendedI+0x52>
 800bb48:	481b      	ldr	r0, [pc, #108]	; (800bbb8 <chThdCreateSuspendedI+0xbc>)
 800bb4a:	f7ff f96f 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
<<<<<<< HEAD
 800bac6:	687b      	ldr	r3, [r7, #4]
 800bac8:	68db      	ldr	r3, [r3, #12]
 800baca:	2bff      	cmp	r3, #255	; 0xff
 800bacc:	d803      	bhi.n	800bad6 <chThdCreateSuspendedI+0x62>
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	691b      	ldr	r3, [r3, #16]
 800bad2:	2b00      	cmp	r3, #0
 800bad4:	d102      	bne.n	800badc <chThdCreateSuspendedI+0x68>
 800bad6:	4816      	ldr	r0, [pc, #88]	; (800bb30 <chThdCreateSuspendedI+0xbc>)
 800bad8:	f7ff f964 	bl	800ada4 <chSysHalt>
=======
 800bb4e:	687b      	ldr	r3, [r7, #4]
 800bb50:	68db      	ldr	r3, [r3, #12]
 800bb52:	2bff      	cmp	r3, #255	; 0xff
 800bb54:	d803      	bhi.n	800bb5e <chThdCreateSuspendedI+0x62>
 800bb56:	687b      	ldr	r3, [r7, #4]
 800bb58:	691b      	ldr	r3, [r3, #16]
 800bb5a:	2b00      	cmp	r3, #0
 800bb5c:	d102      	bne.n	800bb64 <chThdCreateSuspendedI+0x68>
 800bb5e:	4816      	ldr	r0, [pc, #88]	; (800bbb8 <chThdCreateSuspendedI+0xbc>)
 800bb60:	f7ff f964 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
<<<<<<< HEAD
 800badc:	687b      	ldr	r3, [r7, #4]
 800bade:	689b      	ldr	r3, [r3, #8]
 800bae0:	3b38      	subs	r3, #56	; 0x38
 800bae2:	60fb      	str	r3, [r7, #12]
=======
 800bb64:	687b      	ldr	r3, [r7, #4]
 800bb66:	689b      	ldr	r3, [r3, #8]
 800bb68:	3b38      	subs	r3, #56	; 0x38
 800bb6a:	60fb      	str	r3, [r7, #12]
>>>>>>> 752c83b... update binaries
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
<<<<<<< HEAD
 800bae4:	687b      	ldr	r3, [r7, #4]
 800bae6:	685a      	ldr	r2, [r3, #4]
 800bae8:	68fb      	ldr	r3, [r7, #12]
 800baea:	61da      	str	r2, [r3, #28]
=======
 800bb6c:	687b      	ldr	r3, [r7, #4]
 800bb6e:	685a      	ldr	r2, [r3, #4]
 800bb70:	68fb      	ldr	r3, [r7, #12]
 800bb72:	61da      	str	r2, [r3, #28]
>>>>>>> 752c83b... update binaries
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
<<<<<<< HEAD
 800baec:	68fb      	ldr	r3, [r7, #12]
 800baee:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800baf2:	68fb      	ldr	r3, [r7, #12]
 800baf4:	60da      	str	r2, [r3, #12]
 800baf6:	68fb      	ldr	r3, [r7, #12]
 800baf8:	68db      	ldr	r3, [r3, #12]
 800bafa:	687a      	ldr	r2, [r7, #4]
 800bafc:	6912      	ldr	r2, [r2, #16]
 800bafe:	601a      	str	r2, [r3, #0]
 800bb00:	68fb      	ldr	r3, [r7, #12]
 800bb02:	68db      	ldr	r3, [r3, #12]
 800bb04:	687a      	ldr	r2, [r7, #4]
 800bb06:	6952      	ldr	r2, [r2, #20]
 800bb08:	605a      	str	r2, [r3, #4]
 800bb0a:	68fb      	ldr	r3, [r7, #12]
 800bb0c:	68db      	ldr	r3, [r3, #12]
 800bb0e:	4a09      	ldr	r2, [pc, #36]	; (800bb34 <chThdCreateSuspendedI+0xc0>)
 800bb10:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800bb12:	687b      	ldr	r3, [r7, #4]
 800bb14:	681a      	ldr	r2, [r3, #0]
 800bb16:	687b      	ldr	r3, [r7, #4]
 800bb18:	68db      	ldr	r3, [r3, #12]
 800bb1a:	68f8      	ldr	r0, [r7, #12]
 800bb1c:	4611      	mov	r1, r2
 800bb1e:	461a      	mov	r2, r3
 800bb20:	f7ff ff5a 	bl	800b9d8 <_thread_init>
 800bb24:	4603      	mov	r3, r0
}
 800bb26:	4618      	mov	r0, r3
 800bb28:	3710      	adds	r7, #16
 800bb2a:	46bd      	mov	sp, r7
 800bb2c:	bd80      	pop	{r7, pc}
 800bb2e:	bf00      	nop
 800bb30:	0800e8c8 	.word	0x0800e8c8
 800bb34:	080032b5 	.word	0x080032b5

0800bb38 <chThdCreate>:
=======
 800bb74:	68fb      	ldr	r3, [r7, #12]
 800bb76:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800bb7a:	68fb      	ldr	r3, [r7, #12]
 800bb7c:	60da      	str	r2, [r3, #12]
 800bb7e:	68fb      	ldr	r3, [r7, #12]
 800bb80:	68db      	ldr	r3, [r3, #12]
 800bb82:	687a      	ldr	r2, [r7, #4]
 800bb84:	6912      	ldr	r2, [r2, #16]
 800bb86:	601a      	str	r2, [r3, #0]
 800bb88:	68fb      	ldr	r3, [r7, #12]
 800bb8a:	68db      	ldr	r3, [r3, #12]
 800bb8c:	687a      	ldr	r2, [r7, #4]
 800bb8e:	6952      	ldr	r2, [r2, #20]
 800bb90:	605a      	str	r2, [r3, #4]
 800bb92:	68fb      	ldr	r3, [r7, #12]
 800bb94:	68db      	ldr	r3, [r3, #12]
 800bb96:	4a09      	ldr	r2, [pc, #36]	; (800bbbc <chThdCreateSuspendedI+0xc0>)
 800bb98:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800bb9a:	687b      	ldr	r3, [r7, #4]
 800bb9c:	681a      	ldr	r2, [r3, #0]
 800bb9e:	687b      	ldr	r3, [r7, #4]
 800bba0:	68db      	ldr	r3, [r3, #12]
 800bba2:	68f8      	ldr	r0, [r7, #12]
 800bba4:	4611      	mov	r1, r2
 800bba6:	461a      	mov	r2, r3
 800bba8:	f7ff ff5a 	bl	800ba60 <_thread_init>
 800bbac:	4603      	mov	r3, r0
}
 800bbae:	4618      	mov	r0, r3
 800bbb0:	3710      	adds	r7, #16
 800bbb2:	46bd      	mov	sp, r7
 800bbb4:	bd80      	pop	{r7, pc}
 800bbb6:	bf00      	nop
 800bbb8:	0800e9a0 	.word	0x0800e9a0
 800bbbc:	080032b5 	.word	0x080032b5

0800bbc0 <chThdCreate>:
>>>>>>> 752c83b... update binaries
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
<<<<<<< HEAD
 800bb38:	b580      	push	{r7, lr}
 800bb3a:	b084      	sub	sp, #16
 800bb3c:	af00      	add	r7, sp, #0
 800bb3e:	6078      	str	r0, [r7, #4]
=======
 800bbc0:	b580      	push	{r7, lr}
 800bbc2:	b084      	sub	sp, #16
 800bbc4:	af00      	add	r7, sp, #0
 800bbc6:	6078      	str	r0, [r7, #4]
>>>>>>> 752c83b... update binaries
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
<<<<<<< HEAD
 800bb40:	687b      	ldr	r3, [r7, #4]
 800bb42:	685b      	ldr	r3, [r3, #4]
 800bb44:	4618      	mov	r0, r3
 800bb46:	f7fe fd5d 	bl	800a604 <chRegFindThreadByWorkingArea>
 800bb4a:	4603      	mov	r3, r0
 800bb4c:	2b00      	cmp	r3, #0
 800bb4e:	d002      	beq.n	800bb56 <chThdCreate+0x1e>
 800bb50:	480e      	ldr	r0, [pc, #56]	; (800bb8c <chThdCreate+0x54>)
 800bb52:	f7ff f927 	bl	800ada4 <chSysHalt>
=======
 800bbc8:	687b      	ldr	r3, [r7, #4]
 800bbca:	685b      	ldr	r3, [r3, #4]
 800bbcc:	4618      	mov	r0, r3
 800bbce:	f7fe fd5d 	bl	800a68c <chRegFindThreadByWorkingArea>
 800bbd2:	4603      	mov	r3, r0
 800bbd4:	2b00      	cmp	r3, #0
 800bbd6:	d002      	beq.n	800bbde <chThdCreate+0x1e>
 800bbd8:	480e      	ldr	r0, [pc, #56]	; (800bc14 <chThdCreate+0x54>)
 800bbda:	f7ff f927 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
<<<<<<< HEAD
 800bb56:	687b      	ldr	r3, [r7, #4]
 800bb58:	685a      	ldr	r2, [r3, #4]
                  (uint8_t *)tdp->wend,
 800bb5a:	687b      	ldr	r3, [r7, #4]
 800bb5c:	689b      	ldr	r3, [r3, #8]
=======
 800bbde:	687b      	ldr	r3, [r7, #4]
 800bbe0:	685a      	ldr	r2, [r3, #4]
                  (uint8_t *)tdp->wend,
 800bbe2:	687b      	ldr	r3, [r7, #4]
 800bbe4:	689b      	ldr	r3, [r3, #8]
>>>>>>> 752c83b... update binaries
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
<<<<<<< HEAD
 800bb5e:	4610      	mov	r0, r2
 800bb60:	4619      	mov	r1, r3
 800bb62:	2255      	movs	r2, #85	; 0x55
 800bb64:	f7ff ff70 	bl	800ba48 <_thread_memfill>
=======
 800bbe6:	4610      	mov	r0, r2
 800bbe8:	4619      	mov	r1, r3
 800bbea:	2255      	movs	r2, #85	; 0x55
 800bbec:	f7ff ff70 	bl	800bad0 <_thread_memfill>
>>>>>>> 752c83b... update binaries
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
<<<<<<< HEAD
 800bb68:	f7ff fed2 	bl	800b910 <chSysLock.lto_priv.258>
  tp = chThdCreateSuspendedI(tdp);
 800bb6c:	6878      	ldr	r0, [r7, #4]
 800bb6e:	f7ff ff81 	bl	800ba74 <chThdCreateSuspendedI>
 800bb72:	60f8      	str	r0, [r7, #12]
  chSchWakeupS(tp, MSG_OK);
 800bb74:	68f8      	ldr	r0, [r7, #12]
 800bb76:	2100      	movs	r1, #0
 800bb78:	f7ff fda6 	bl	800b6c8 <chSchWakeupS>
  chSysUnlock();
 800bb7c:	f7ff fed0 	bl	800b920 <chSysUnlock.lto_priv.253>

  return tp;
 800bb80:	68fb      	ldr	r3, [r7, #12]
}
 800bb82:	4618      	mov	r0, r3
 800bb84:	3710      	adds	r7, #16
 800bb86:	46bd      	mov	sp, r7
 800bb88:	bd80      	pop	{r7, pc}
 800bb8a:	bf00      	nop
 800bb8c:	0800e8ec 	.word	0x0800e8ec

0800bb90 <_decode_uavcan_protocol_dynamic_node_id_Allocation>:
=======
 800bbf0:	f7ff fed2 	bl	800b998 <chSysLock.lto_priv.255>
  tp = chThdCreateSuspendedI(tdp);
 800bbf4:	6878      	ldr	r0, [r7, #4]
 800bbf6:	f7ff ff81 	bl	800bafc <chThdCreateSuspendedI>
 800bbfa:	60f8      	str	r0, [r7, #12]
  chSchWakeupS(tp, MSG_OK);
 800bbfc:	68f8      	ldr	r0, [r7, #12]
 800bbfe:	2100      	movs	r1, #0
 800bc00:	f7ff fda6 	bl	800b750 <chSchWakeupS>
  chSysUnlock();
 800bc04:	f7ff fed0 	bl	800b9a8 <chSysUnlock.lto_priv.250>

  return tp;
 800bc08:	68fb      	ldr	r3, [r7, #12]
}
 800bc0a:	4618      	mov	r0, r3
 800bc0c:	3710      	adds	r7, #16
 800bc0e:	46bd      	mov	sp, r7
 800bc10:	bd80      	pop	{r7, pc}
 800bc12:	bf00      	nop
 800bc14:	0800e9c4 	.word	0x0800e9c4

0800bc18 <_decode_uavcan_protocol_dynamic_node_id_Allocation>:
>>>>>>> 752c83b... update binaries
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
}

void _decode_uavcan_protocol_dynamic_node_id_Allocation(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, bool tao) {
<<<<<<< HEAD
 800bb90:	b580      	push	{r7, lr}
 800bb92:	b088      	sub	sp, #32
 800bb94:	af02      	add	r7, sp, #8
 800bb96:	60f8      	str	r0, [r7, #12]
 800bb98:	60b9      	str	r1, [r7, #8]
 800bb9a:	607a      	str	r2, [r7, #4]
 800bb9c:	70fb      	strb	r3, [r7, #3]
=======
 800bc18:	b580      	push	{r7, lr}
 800bc1a:	b088      	sub	sp, #32
 800bc1c:	af02      	add	r7, sp, #8
 800bc1e:	60f8      	str	r0, [r7, #12]
 800bc20:	60b9      	str	r1, [r7, #8]
 800bc22:	607a      	str	r2, [r7, #4]
 800bc24:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->node_id);
<<<<<<< HEAD
 800bb9e:	68bb      	ldr	r3, [r7, #8]
 800bba0:	681a      	ldr	r2, [r3, #0]
 800bba2:	687b      	ldr	r3, [r7, #4]
 800bba4:	9300      	str	r3, [sp, #0]
 800bba6:	68f8      	ldr	r0, [r7, #12]
 800bba8:	4611      	mov	r1, r2
 800bbaa:	2207      	movs	r2, #7
 800bbac:	2300      	movs	r3, #0
 800bbae:	f001 fb1b 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 7;
 800bbb2:	68bb      	ldr	r3, [r7, #8]
 800bbb4:	681b      	ldr	r3, [r3, #0]
 800bbb6:	1dda      	adds	r2, r3, #7
 800bbb8:	68bb      	ldr	r3, [r7, #8]
 800bbba:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 1, false, &msg->first_part_of_unique_id);
 800bbbc:	68bb      	ldr	r3, [r7, #8]
 800bbbe:	681a      	ldr	r2, [r3, #0]
 800bbc0:	687b      	ldr	r3, [r7, #4]
 800bbc2:	3301      	adds	r3, #1
 800bbc4:	9300      	str	r3, [sp, #0]
 800bbc6:	68f8      	ldr	r0, [r7, #12]
 800bbc8:	4611      	mov	r1, r2
 800bbca:	2201      	movs	r2, #1
 800bbcc:	2300      	movs	r3, #0
 800bbce:	f001 fb0b 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 1;
 800bbd2:	68bb      	ldr	r3, [r7, #8]
 800bbd4:	681b      	ldr	r3, [r3, #0]
 800bbd6:	1c5a      	adds	r2, r3, #1
 800bbd8:	68bb      	ldr	r3, [r7, #8]
 800bbda:	601a      	str	r2, [r3, #0]

    if (!tao) {
 800bbdc:	78fb      	ldrb	r3, [r7, #3]
 800bbde:	f083 0301 	eor.w	r3, r3, #1
 800bbe2:	b2db      	uxtb	r3, r3
 800bbe4:	2b00      	cmp	r3, #0
 800bbe6:	d010      	beq.n	800bc0a <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x7a>
        canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->unique_id_len);
 800bbe8:	68bb      	ldr	r3, [r7, #8]
 800bbea:	681a      	ldr	r2, [r3, #0]
 800bbec:	687b      	ldr	r3, [r7, #4]
 800bbee:	3302      	adds	r3, #2
 800bbf0:	9300      	str	r3, [sp, #0]
 800bbf2:	68f8      	ldr	r0, [r7, #12]
 800bbf4:	4611      	mov	r1, r2
 800bbf6:	2205      	movs	r2, #5
 800bbf8:	2300      	movs	r3, #0
 800bbfa:	f001 faf5 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 5;
 800bbfe:	68bb      	ldr	r3, [r7, #8]
 800bc00:	681b      	ldr	r3, [r3, #0]
 800bc02:	1d5a      	adds	r2, r3, #5
 800bc04:	68bb      	ldr	r3, [r7, #8]
 800bc06:	601a      	str	r2, [r3, #0]
 800bc08:	e00a      	b.n	800bc20 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x90>
    } else {
        msg->unique_id_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800bc0a:	68fb      	ldr	r3, [r7, #12]
 800bc0c:	8a9b      	ldrh	r3, [r3, #20]
 800bc0e:	00db      	lsls	r3, r3, #3
 800bc10:	461a      	mov	r2, r3
 800bc12:	68bb      	ldr	r3, [r7, #8]
 800bc14:	681b      	ldr	r3, [r3, #0]
 800bc16:	1ad3      	subs	r3, r2, r3
 800bc18:	08db      	lsrs	r3, r3, #3
 800bc1a:	b2da      	uxtb	r2, r3
 800bc1c:	687b      	ldr	r3, [r7, #4]
 800bc1e:	709a      	strb	r2, [r3, #2]
    }

    for (size_t i=0; i < msg->unique_id_len; i++) {
 800bc20:	2300      	movs	r3, #0
 800bc22:	617b      	str	r3, [r7, #20]
 800bc24:	e014      	b.n	800bc50 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0xc0>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800bc26:	68bb      	ldr	r3, [r7, #8]
 800bc28:	6819      	ldr	r1, [r3, #0]
 800bc2a:	687a      	ldr	r2, [r7, #4]
 800bc2c:	697b      	ldr	r3, [r7, #20]
 800bc2e:	4413      	add	r3, r2
 800bc30:	3303      	adds	r3, #3
 800bc32:	9300      	str	r3, [sp, #0]
 800bc34:	68f8      	ldr	r0, [r7, #12]
 800bc36:	2208      	movs	r2, #8
 800bc38:	2300      	movs	r3, #0
 800bc3a:	f001 fad5 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 8;
 800bc3e:	68bb      	ldr	r3, [r7, #8]
 800bc40:	681b      	ldr	r3, [r3, #0]
 800bc42:	f103 0208 	add.w	r2, r3, #8
 800bc46:	68bb      	ldr	r3, [r7, #8]
 800bc48:	601a      	str	r2, [r3, #0]
=======
 800bc26:	68bb      	ldr	r3, [r7, #8]
 800bc28:	681a      	ldr	r2, [r3, #0]
 800bc2a:	687b      	ldr	r3, [r7, #4]
 800bc2c:	9300      	str	r3, [sp, #0]
 800bc2e:	68f8      	ldr	r0, [r7, #12]
 800bc30:	4611      	mov	r1, r2
 800bc32:	2207      	movs	r2, #7
 800bc34:	2300      	movs	r3, #0
 800bc36:	f001 fb1b 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 7;
 800bc3a:	68bb      	ldr	r3, [r7, #8]
 800bc3c:	681b      	ldr	r3, [r3, #0]
 800bc3e:	1dda      	adds	r2, r3, #7
 800bc40:	68bb      	ldr	r3, [r7, #8]
 800bc42:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 1, false, &msg->first_part_of_unique_id);
 800bc44:	68bb      	ldr	r3, [r7, #8]
 800bc46:	681a      	ldr	r2, [r3, #0]
 800bc48:	687b      	ldr	r3, [r7, #4]
 800bc4a:	3301      	adds	r3, #1
 800bc4c:	9300      	str	r3, [sp, #0]
 800bc4e:	68f8      	ldr	r0, [r7, #12]
 800bc50:	4611      	mov	r1, r2
 800bc52:	2201      	movs	r2, #1
 800bc54:	2300      	movs	r3, #0
 800bc56:	f001 fb0b 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 1;
 800bc5a:	68bb      	ldr	r3, [r7, #8]
 800bc5c:	681b      	ldr	r3, [r3, #0]
 800bc5e:	1c5a      	adds	r2, r3, #1
 800bc60:	68bb      	ldr	r3, [r7, #8]
 800bc62:	601a      	str	r2, [r3, #0]

    if (!tao) {
 800bc64:	78fb      	ldrb	r3, [r7, #3]
 800bc66:	f083 0301 	eor.w	r3, r3, #1
 800bc6a:	b2db      	uxtb	r3, r3
 800bc6c:	2b00      	cmp	r3, #0
 800bc6e:	d010      	beq.n	800bc92 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x7a>
        canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->unique_id_len);
 800bc70:	68bb      	ldr	r3, [r7, #8]
 800bc72:	681a      	ldr	r2, [r3, #0]
 800bc74:	687b      	ldr	r3, [r7, #4]
 800bc76:	3302      	adds	r3, #2
 800bc78:	9300      	str	r3, [sp, #0]
 800bc7a:	68f8      	ldr	r0, [r7, #12]
 800bc7c:	4611      	mov	r1, r2
 800bc7e:	2205      	movs	r2, #5
 800bc80:	2300      	movs	r3, #0
 800bc82:	f001 faf5 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 5;
 800bc86:	68bb      	ldr	r3, [r7, #8]
 800bc88:	681b      	ldr	r3, [r3, #0]
 800bc8a:	1d5a      	adds	r2, r3, #5
 800bc8c:	68bb      	ldr	r3, [r7, #8]
 800bc8e:	601a      	str	r2, [r3, #0]
 800bc90:	e00a      	b.n	800bca8 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x90>
    } else {
        msg->unique_id_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800bc92:	68fb      	ldr	r3, [r7, #12]
 800bc94:	8a9b      	ldrh	r3, [r3, #20]
 800bc96:	00db      	lsls	r3, r3, #3
 800bc98:	461a      	mov	r2, r3
 800bc9a:	68bb      	ldr	r3, [r7, #8]
 800bc9c:	681b      	ldr	r3, [r3, #0]
 800bc9e:	1ad3      	subs	r3, r2, r3
 800bca0:	08db      	lsrs	r3, r3, #3
 800bca2:	b2da      	uxtb	r2, r3
 800bca4:	687b      	ldr	r3, [r7, #4]
 800bca6:	709a      	strb	r2, [r3, #2]
    }

    for (size_t i=0; i < msg->unique_id_len; i++) {
 800bca8:	2300      	movs	r3, #0
 800bcaa:	617b      	str	r3, [r7, #20]
 800bcac:	e014      	b.n	800bcd8 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0xc0>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800bcae:	68bb      	ldr	r3, [r7, #8]
 800bcb0:	6819      	ldr	r1, [r3, #0]
 800bcb2:	687a      	ldr	r2, [r7, #4]
 800bcb4:	697b      	ldr	r3, [r7, #20]
 800bcb6:	4413      	add	r3, r2
 800bcb8:	3303      	adds	r3, #3
 800bcba:	9300      	str	r3, [sp, #0]
 800bcbc:	68f8      	ldr	r0, [r7, #12]
 800bcbe:	2208      	movs	r2, #8
 800bcc0:	2300      	movs	r3, #0
 800bcc2:	f001 fad5 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 8;
 800bcc6:	68bb      	ldr	r3, [r7, #8]
 800bcc8:	681b      	ldr	r3, [r3, #0]
 800bcca:	f103 0208 	add.w	r2, r3, #8
 800bcce:	68bb      	ldr	r3, [r7, #8]
 800bcd0:	601a      	str	r2, [r3, #0]
>>>>>>> 752c83b... update binaries
        *bit_ofs += 5;
    } else {
        msg->unique_id_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->unique_id_len; i++) {
<<<<<<< HEAD
 800bc4a:	697b      	ldr	r3, [r7, #20]
 800bc4c:	3301      	adds	r3, #1
 800bc4e:	617b      	str	r3, [r7, #20]
 800bc50:	687b      	ldr	r3, [r7, #4]
 800bc52:	789b      	ldrb	r3, [r3, #2]
 800bc54:	461a      	mov	r2, r3
 800bc56:	697b      	ldr	r3, [r7, #20]
 800bc58:	429a      	cmp	r2, r3
 800bc5a:	d8e4      	bhi.n	800bc26 <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x96>
=======
 800bcd2:	697b      	ldr	r3, [r7, #20]
 800bcd4:	3301      	adds	r3, #1
 800bcd6:	617b      	str	r3, [r7, #20]
 800bcd8:	687b      	ldr	r3, [r7, #4]
 800bcda:	789b      	ldrb	r3, [r3, #2]
 800bcdc:	461a      	mov	r2, r3
 800bcde:	697b      	ldr	r3, [r7, #20]
 800bce0:	429a      	cmp	r2, r3
 800bce2:	d8e4      	bhi.n	800bcae <_decode_uavcan_protocol_dynamic_node_id_Allocation+0x96>
>>>>>>> 752c83b... update binaries
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
        *bit_ofs += 8;
    }

}
<<<<<<< HEAD
 800bc5c:	3718      	adds	r7, #24
 800bc5e:	46bd      	mov	sp, r7
 800bc60:	bd80      	pop	{r7, pc}
 800bc62:	bf00      	nop

0800bc64 <_encode_uavcan_protocol_debug_LogLevel>:
=======
 800bce4:	3718      	adds	r7, #24
 800bce6:	46bd      	mov	sp, r7
 800bce8:	bd80      	pop	{r7, pc}
 800bcea:	bf00      	nop

0800bcec <_encode_uavcan_protocol_debug_LogLevel>:
>>>>>>> 752c83b... update binaries
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_debug_LogLevel(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_debug_LogLevel(uint8_t* buffer, struct uavcan_protocol_debug_LogLevel_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
<<<<<<< HEAD
 800bc64:	b580      	push	{r7, lr}
 800bc66:	b084      	sub	sp, #16
 800bc68:	af00      	add	r7, sp, #0
 800bc6a:	60f8      	str	r0, [r7, #12]
 800bc6c:	60b9      	str	r1, [r7, #8]
 800bc6e:	607a      	str	r2, [r7, #4]
 800bc70:	603b      	str	r3, [r7, #0]
=======
 800bcec:	b580      	push	{r7, lr}
 800bcee:	b084      	sub	sp, #16
 800bcf0:	af00      	add	r7, sp, #0
 800bcf2:	60f8      	str	r0, [r7, #12]
 800bcf4:	60b9      	str	r1, [r7, #8]
 800bcf6:	607a      	str	r2, [r7, #4]
 800bcf8:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
<<<<<<< HEAD
 800bc72:	68f8      	ldr	r0, [r7, #12]
 800bc74:	2100      	movs	r1, #0
 800bc76:	2208      	movs	r2, #8
 800bc78:	f002 fca6 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->value);
 800bc7c:	68bb      	ldr	r3, [r7, #8]
 800bc7e:	68f8      	ldr	r0, [r7, #12]
 800bc80:	2100      	movs	r1, #0
 800bc82:	2203      	movs	r2, #3
 800bc84:	f001 fc28 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800bc88:	687b      	ldr	r3, [r7, #4]
 800bc8a:	68f8      	ldr	r0, [r7, #12]
 800bc8c:	2103      	movs	r1, #3
 800bc8e:	683a      	ldr	r2, [r7, #0]
 800bc90:	4798      	blx	r3
}
 800bc92:	3710      	adds	r7, #16
 800bc94:	46bd      	mov	sp, r7
 800bc96:	bd80      	pop	{r7, pc}

0800bc98 <_decode_uavcan_protocol_debug_LogLevel>:

void _decode_uavcan_protocol_debug_LogLevel(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_debug_LogLevel_s* msg, bool tao) {
 800bc98:	b580      	push	{r7, lr}
 800bc9a:	b086      	sub	sp, #24
 800bc9c:	af02      	add	r7, sp, #8
 800bc9e:	60f8      	str	r0, [r7, #12]
 800bca0:	60b9      	str	r1, [r7, #8]
 800bca2:	607a      	str	r2, [r7, #4]
 800bca4:	70fb      	strb	r3, [r7, #3]
=======
 800bcfa:	68f8      	ldr	r0, [r7, #12]
 800bcfc:	2100      	movs	r1, #0
 800bcfe:	2208      	movs	r2, #8
 800bd00:	f002 fca6 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->value);
 800bd04:	68bb      	ldr	r3, [r7, #8]
 800bd06:	68f8      	ldr	r0, [r7, #12]
 800bd08:	2100      	movs	r1, #0
 800bd0a:	2203      	movs	r2, #3
 800bd0c:	f001 fc28 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800bd10:	687b      	ldr	r3, [r7, #4]
 800bd12:	68f8      	ldr	r0, [r7, #12]
 800bd14:	2103      	movs	r1, #3
 800bd16:	683a      	ldr	r2, [r7, #0]
 800bd18:	4798      	blx	r3
}
 800bd1a:	3710      	adds	r7, #16
 800bd1c:	46bd      	mov	sp, r7
 800bd1e:	bd80      	pop	{r7, pc}

0800bd20 <_decode_uavcan_protocol_debug_LogLevel>:

void _decode_uavcan_protocol_debug_LogLevel(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_debug_LogLevel_s* msg, bool tao) {
 800bd20:	b580      	push	{r7, lr}
 800bd22:	b086      	sub	sp, #24
 800bd24:	af02      	add	r7, sp, #8
 800bd26:	60f8      	str	r0, [r7, #12]
 800bd28:	60b9      	str	r1, [r7, #8]
 800bd2a:	607a      	str	r2, [r7, #4]
 800bd2c:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->value);
<<<<<<< HEAD
 800bca6:	68bb      	ldr	r3, [r7, #8]
 800bca8:	681a      	ldr	r2, [r3, #0]
 800bcaa:	687b      	ldr	r3, [r7, #4]
 800bcac:	9300      	str	r3, [sp, #0]
 800bcae:	68f8      	ldr	r0, [r7, #12]
 800bcb0:	4611      	mov	r1, r2
 800bcb2:	2203      	movs	r2, #3
 800bcb4:	2300      	movs	r3, #0
 800bcb6:	f001 fa97 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 3;
 800bcba:	68bb      	ldr	r3, [r7, #8]
 800bcbc:	681b      	ldr	r3, [r3, #0]
 800bcbe:	1cda      	adds	r2, r3, #3
 800bcc0:	68bb      	ldr	r3, [r7, #8]
 800bcc2:	601a      	str	r2, [r3, #0]

}
 800bcc4:	3710      	adds	r7, #16
 800bcc6:	46bd      	mov	sp, r7
 800bcc8:	bd80      	pop	{r7, pc}
 800bcca:	bf00      	nop

0800bccc <encode_func.lto_priv.52>:
=======
 800bd2e:	68bb      	ldr	r3, [r7, #8]
 800bd30:	681a      	ldr	r2, [r3, #0]
 800bd32:	687b      	ldr	r3, [r7, #4]
 800bd34:	9300      	str	r3, [sp, #0]
 800bd36:	68f8      	ldr	r0, [r7, #12]
 800bd38:	4611      	mov	r1, r2
 800bd3a:	2203      	movs	r2, #3
 800bd3c:	2300      	movs	r3, #0
 800bd3e:	f001 fa97 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 3;
 800bd42:	68bb      	ldr	r3, [r7, #8]
 800bd44:	681b      	ldr	r3, [r3, #0]
 800bd46:	1cda      	adds	r2, r3, #3
 800bd48:	68bb      	ldr	r3, [r7, #8]
 800bd4a:	601a      	str	r2, [r3, #0]

}
 800bd4c:	3710      	adds	r7, #16
 800bd4e:	46bd      	mov	sp, r7
 800bd50:	bd80      	pop	{r7, pc}
 800bd52:	bf00      	nop

0800bd54 <encode_func.lto_priv.52>:
>>>>>>> 752c83b... update binaries
#include <uavcan.protocol.debug.LogMessage.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800bccc:	b580      	push	{r7, lr}
 800bcce:	b084      	sub	sp, #16
 800bcd0:	af00      	add	r7, sp, #0
 800bcd2:	60f8      	str	r0, [r7, #12]
 800bcd4:	60b9      	str	r1, [r7, #8]
 800bcd6:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_debug_LogMessage(msg, chunk_cb, ctx);
 800bcd8:	68f8      	ldr	r0, [r7, #12]
 800bcda:	68b9      	ldr	r1, [r7, #8]
 800bcdc:	687a      	ldr	r2, [r7, #4]
 800bcde:	f000 f811 	bl	800bd04 <encode_uavcan_protocol_debug_LogMessage>
}
 800bce2:	3710      	adds	r7, #16
 800bce4:	46bd      	mov	sp, r7
 800bce6:	bd80      	pop	{r7, pc}

0800bce8 <decode_func.lto_priv.60>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800bce8:	b580      	push	{r7, lr}
 800bcea:	b082      	sub	sp, #8
 800bcec:	af00      	add	r7, sp, #0
 800bcee:	6078      	str	r0, [r7, #4]
 800bcf0:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_debug_LogMessage(transfer, msg);
 800bcf2:	6878      	ldr	r0, [r7, #4]
 800bcf4:	6839      	ldr	r1, [r7, #0]
 800bcf6:	f000 f819 	bl	800bd2c <decode_uavcan_protocol_debug_LogMessage>
 800bcfa:	4603      	mov	r3, r0
}
 800bcfc:	4618      	mov	r0, r3
 800bcfe:	3708      	adds	r7, #8
 800bd00:	46bd      	mov	sp, r7
 800bd02:	bd80      	pop	{r7, pc}

0800bd04 <encode_uavcan_protocol_debug_LogMessage>:
=======
 800bd54:	b580      	push	{r7, lr}
 800bd56:	b084      	sub	sp, #16
 800bd58:	af00      	add	r7, sp, #0
 800bd5a:	60f8      	str	r0, [r7, #12]
 800bd5c:	60b9      	str	r1, [r7, #8]
 800bd5e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_debug_LogMessage(msg, chunk_cb, ctx);
 800bd60:	68f8      	ldr	r0, [r7, #12]
 800bd62:	68b9      	ldr	r1, [r7, #8]
 800bd64:	687a      	ldr	r2, [r7, #4]
 800bd66:	f000 f811 	bl	800bd8c <encode_uavcan_protocol_debug_LogMessage>
}
 800bd6a:	3710      	adds	r7, #16
 800bd6c:	46bd      	mov	sp, r7
 800bd6e:	bd80      	pop	{r7, pc}

0800bd70 <decode_func.lto_priv.60>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800bd70:	b580      	push	{r7, lr}
 800bd72:	b082      	sub	sp, #8
 800bd74:	af00      	add	r7, sp, #0
 800bd76:	6078      	str	r0, [r7, #4]
 800bd78:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_debug_LogMessage(transfer, msg);
 800bd7a:	6878      	ldr	r0, [r7, #4]
 800bd7c:	6839      	ldr	r1, [r7, #0]
 800bd7e:	f000 f819 	bl	800bdb4 <decode_uavcan_protocol_debug_LogMessage>
 800bd82:	4603      	mov	r3, r0
}
 800bd84:	4618      	mov	r0, r3
 800bd86:	3708      	adds	r7, #8
 800bd88:	46bd      	mov	sp, r7
 800bd8a:	bd80      	pop	{r7, pc}

0800bd8c <encode_uavcan_protocol_debug_LogMessage>:
>>>>>>> 752c83b... update binaries
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_debug_LogMessage(struct uavcan_protocol_debug_LogMessage_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800bd04:	b580      	push	{r7, lr}
 800bd06:	b088      	sub	sp, #32
 800bd08:	af02      	add	r7, sp, #8
 800bd0a:	60f8      	str	r0, [r7, #12]
 800bd0c:	60b9      	str	r1, [r7, #8]
 800bd0e:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_debug_LogMessage(buffer, msg, chunk_cb, ctx, true);
 800bd10:	f107 0210 	add.w	r2, r7, #16
 800bd14:	2301      	movs	r3, #1
 800bd16:	9300      	str	r3, [sp, #0]
 800bd18:	4610      	mov	r0, r2
 800bd1a:	68f9      	ldr	r1, [r7, #12]
 800bd1c:	68ba      	ldr	r2, [r7, #8]
 800bd1e:	687b      	ldr	r3, [r7, #4]
 800bd20:	f000 f81a 	bl	800bd58 <_encode_uavcan_protocol_debug_LogMessage>
}
 800bd24:	3718      	adds	r7, #24
 800bd26:	46bd      	mov	sp, r7
 800bd28:	bd80      	pop	{r7, pc}
 800bd2a:	bf00      	nop

0800bd2c <decode_uavcan_protocol_debug_LogMessage>:

uint32_t decode_uavcan_protocol_debug_LogMessage(const CanardRxTransfer* transfer, struct uavcan_protocol_debug_LogMessage_s* msg) {
 800bd2c:	b580      	push	{r7, lr}
 800bd2e:	b084      	sub	sp, #16
 800bd30:	af00      	add	r7, sp, #0
 800bd32:	6078      	str	r0, [r7, #4]
 800bd34:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800bd36:	2300      	movs	r3, #0
 800bd38:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_debug_LogMessage(transfer, &bit_ofs, msg, true);
 800bd3a:	f107 030c 	add.w	r3, r7, #12
 800bd3e:	6878      	ldr	r0, [r7, #4]
 800bd40:	4619      	mov	r1, r3
 800bd42:	683a      	ldr	r2, [r7, #0]
 800bd44:	2301      	movs	r3, #1
 800bd46:	f000 f883 	bl	800be50 <_decode_uavcan_protocol_debug_LogMessage>
    return (bit_ofs+7)/8;
 800bd4a:	68fb      	ldr	r3, [r7, #12]
 800bd4c:	3307      	adds	r3, #7
 800bd4e:	08db      	lsrs	r3, r3, #3
}
 800bd50:	4618      	mov	r0, r3
 800bd52:	3710      	adds	r7, #16
 800bd54:	46bd      	mov	sp, r7
 800bd56:	bd80      	pop	{r7, pc}

0800bd58 <_encode_uavcan_protocol_debug_LogMessage>:

void _encode_uavcan_protocol_debug_LogMessage(uint8_t* buffer, struct uavcan_protocol_debug_LogMessage_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800bd58:	b580      	push	{r7, lr}
 800bd5a:	b088      	sub	sp, #32
 800bd5c:	af02      	add	r7, sp, #8
 800bd5e:	60f8      	str	r0, [r7, #12]
 800bd60:	60b9      	str	r1, [r7, #8]
 800bd62:	607a      	str	r2, [r7, #4]
 800bd64:	603b      	str	r3, [r7, #0]
=======
 800bd8c:	b580      	push	{r7, lr}
 800bd8e:	b088      	sub	sp, #32
 800bd90:	af02      	add	r7, sp, #8
 800bd92:	60f8      	str	r0, [r7, #12]
 800bd94:	60b9      	str	r1, [r7, #8]
 800bd96:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_debug_LogMessage(buffer, msg, chunk_cb, ctx, true);
 800bd98:	f107 0210 	add.w	r2, r7, #16
 800bd9c:	2301      	movs	r3, #1
 800bd9e:	9300      	str	r3, [sp, #0]
 800bda0:	4610      	mov	r0, r2
 800bda2:	68f9      	ldr	r1, [r7, #12]
 800bda4:	68ba      	ldr	r2, [r7, #8]
 800bda6:	687b      	ldr	r3, [r7, #4]
 800bda8:	f000 f81a 	bl	800bde0 <_encode_uavcan_protocol_debug_LogMessage>
}
 800bdac:	3718      	adds	r7, #24
 800bdae:	46bd      	mov	sp, r7
 800bdb0:	bd80      	pop	{r7, pc}
 800bdb2:	bf00      	nop

0800bdb4 <decode_uavcan_protocol_debug_LogMessage>:

uint32_t decode_uavcan_protocol_debug_LogMessage(const CanardRxTransfer* transfer, struct uavcan_protocol_debug_LogMessage_s* msg) {
 800bdb4:	b580      	push	{r7, lr}
 800bdb6:	b084      	sub	sp, #16
 800bdb8:	af00      	add	r7, sp, #0
 800bdba:	6078      	str	r0, [r7, #4]
 800bdbc:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800bdbe:	2300      	movs	r3, #0
 800bdc0:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_debug_LogMessage(transfer, &bit_ofs, msg, true);
 800bdc2:	f107 030c 	add.w	r3, r7, #12
 800bdc6:	6878      	ldr	r0, [r7, #4]
 800bdc8:	4619      	mov	r1, r3
 800bdca:	683a      	ldr	r2, [r7, #0]
 800bdcc:	2301      	movs	r3, #1
 800bdce:	f000 f883 	bl	800bed8 <_decode_uavcan_protocol_debug_LogMessage>
    return (bit_ofs+7)/8;
 800bdd2:	68fb      	ldr	r3, [r7, #12]
 800bdd4:	3307      	adds	r3, #7
 800bdd6:	08db      	lsrs	r3, r3, #3
}
 800bdd8:	4618      	mov	r0, r3
 800bdda:	3710      	adds	r7, #16
 800bddc:	46bd      	mov	sp, r7
 800bdde:	bd80      	pop	{r7, pc}

0800bde0 <_encode_uavcan_protocol_debug_LogMessage>:

void _encode_uavcan_protocol_debug_LogMessage(uint8_t* buffer, struct uavcan_protocol_debug_LogMessage_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800bde0:	b580      	push	{r7, lr}
 800bde2:	b088      	sub	sp, #32
 800bde4:	af02      	add	r7, sp, #8
 800bde6:	60f8      	str	r0, [r7, #12]
 800bde8:	60b9      	str	r1, [r7, #8]
 800bdea:	607a      	str	r2, [r7, #4]
 800bdec:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    _encode_uavcan_protocol_debug_LogLevel(buffer, &msg->level, chunk_cb, ctx, false);
<<<<<<< HEAD
 800bd66:	68ba      	ldr	r2, [r7, #8]
 800bd68:	2300      	movs	r3, #0
 800bd6a:	9300      	str	r3, [sp, #0]
 800bd6c:	68f8      	ldr	r0, [r7, #12]
 800bd6e:	4611      	mov	r1, r2
 800bd70:	687a      	ldr	r2, [r7, #4]
 800bd72:	683b      	ldr	r3, [r7, #0]
 800bd74:	f7ff ff76 	bl	800bc64 <_encode_uavcan_protocol_debug_LogLevel>
    memset(buffer,0,8);
 800bd78:	68f8      	ldr	r0, [r7, #12]
 800bd7a:	2100      	movs	r1, #0
 800bd7c:	2208      	movs	r2, #8
 800bd7e:	f002 fc23 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 5, &msg->source_len);
 800bd82:	68bb      	ldr	r3, [r7, #8]
 800bd84:	3301      	adds	r3, #1
 800bd86:	68f8      	ldr	r0, [r7, #12]
 800bd88:	2100      	movs	r1, #0
 800bd8a:	2205      	movs	r2, #5
 800bd8c:	f001 fba4 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 5, ctx);
 800bd90:	687b      	ldr	r3, [r7, #4]
 800bd92:	68f8      	ldr	r0, [r7, #12]
 800bd94:	2105      	movs	r1, #5
 800bd96:	683a      	ldr	r2, [r7, #0]
 800bd98:	4798      	blx	r3
    for (size_t i=0; i < msg->source_len; i++) {
 800bd9a:	2300      	movs	r3, #0
 800bd9c:	617b      	str	r3, [r7, #20]
 800bd9e:	e015      	b.n	800bdcc <_encode_uavcan_protocol_debug_LogMessage+0x74>
            memset(buffer,0,8);
 800bda0:	68f8      	ldr	r0, [r7, #12]
 800bda2:	2100      	movs	r1, #0
 800bda4:	2208      	movs	r2, #8
 800bda6:	f002 fc0f 	bl	800e5c8 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->source[i]);
 800bdaa:	68ba      	ldr	r2, [r7, #8]
 800bdac:	697b      	ldr	r3, [r7, #20]
 800bdae:	4413      	add	r3, r2
 800bdb0:	3302      	adds	r3, #2
 800bdb2:	68f8      	ldr	r0, [r7, #12]
 800bdb4:	2100      	movs	r1, #0
 800bdb6:	2208      	movs	r2, #8
 800bdb8:	f001 fb8e 	bl	800d4d8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800bdbc:	687b      	ldr	r3, [r7, #4]
 800bdbe:	68f8      	ldr	r0, [r7, #12]
 800bdc0:	2108      	movs	r1, #8
 800bdc2:	683a      	ldr	r2, [r7, #0]
 800bdc4:	4798      	blx	r3
=======
 800bdee:	68ba      	ldr	r2, [r7, #8]
 800bdf0:	2300      	movs	r3, #0
 800bdf2:	9300      	str	r3, [sp, #0]
 800bdf4:	68f8      	ldr	r0, [r7, #12]
 800bdf6:	4611      	mov	r1, r2
 800bdf8:	687a      	ldr	r2, [r7, #4]
 800bdfa:	683b      	ldr	r3, [r7, #0]
 800bdfc:	f7ff ff76 	bl	800bcec <_encode_uavcan_protocol_debug_LogLevel>
    memset(buffer,0,8);
 800be00:	68f8      	ldr	r0, [r7, #12]
 800be02:	2100      	movs	r1, #0
 800be04:	2208      	movs	r2, #8
 800be06:	f002 fc23 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 5, &msg->source_len);
 800be0a:	68bb      	ldr	r3, [r7, #8]
 800be0c:	3301      	adds	r3, #1
 800be0e:	68f8      	ldr	r0, [r7, #12]
 800be10:	2100      	movs	r1, #0
 800be12:	2205      	movs	r2, #5
 800be14:	f001 fba4 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 5, ctx);
 800be18:	687b      	ldr	r3, [r7, #4]
 800be1a:	68f8      	ldr	r0, [r7, #12]
 800be1c:	2105      	movs	r1, #5
 800be1e:	683a      	ldr	r2, [r7, #0]
 800be20:	4798      	blx	r3
    for (size_t i=0; i < msg->source_len; i++) {
 800be22:	2300      	movs	r3, #0
 800be24:	617b      	str	r3, [r7, #20]
 800be26:	e015      	b.n	800be54 <_encode_uavcan_protocol_debug_LogMessage+0x74>
            memset(buffer,0,8);
 800be28:	68f8      	ldr	r0, [r7, #12]
 800be2a:	2100      	movs	r1, #0
 800be2c:	2208      	movs	r2, #8
 800be2e:	f002 fc0f 	bl	800e650 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->source[i]);
 800be32:	68ba      	ldr	r2, [r7, #8]
 800be34:	697b      	ldr	r3, [r7, #20]
 800be36:	4413      	add	r3, r2
 800be38:	3302      	adds	r3, #2
 800be3a:	68f8      	ldr	r0, [r7, #12]
 800be3c:	2100      	movs	r1, #0
 800be3e:	2208      	movs	r2, #8
 800be40:	f001 fb8e 	bl	800d560 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800be44:	687b      	ldr	r3, [r7, #4]
 800be46:	68f8      	ldr	r0, [r7, #12]
 800be48:	2108      	movs	r1, #8
 800be4a:	683a      	ldr	r2, [r7, #0]
 800be4c:	4798      	blx	r3
>>>>>>> 752c83b... update binaries

    _encode_uavcan_protocol_debug_LogLevel(buffer, &msg->level, chunk_cb, ctx, false);
    memset(buffer,0,8);
    canardEncodeScalar(buffer, 0, 5, &msg->source_len);
    chunk_cb(buffer, 5, ctx);
    for (size_t i=0; i < msg->source_len; i++) {
<<<<<<< HEAD
 800bdc6:	697b      	ldr	r3, [r7, #20]
 800bdc8:	3301      	adds	r3, #1
 800bdca:	617b      	str	r3, [r7, #20]
 800bdcc:	68bb      	ldr	r3, [r7, #8]
 800bdce:	785b      	ldrb	r3, [r3, #1]
 800bdd0:	461a      	mov	r2, r3
 800bdd2:	697b      	ldr	r3, [r7, #20]
 800bdd4:	429a      	cmp	r2, r3
 800bdd6:	d8e3      	bhi.n	800bda0 <_encode_uavcan_protocol_debug_LogMessage+0x48>
=======
 800be4e:	697b      	ldr	r3, [r7, #20]
 800be50:	3301      	adds	r3, #1
 800be52:	617b      	str	r3, [r7, #20]
 800be54:	68bb      	ldr	r3, [r7, #8]
 800be56:	785b      	ldrb	r3, [r3, #1]
 800be58:	461a      	mov	r2, r3
 800be5a:	697b      	ldr	r3, [r7, #20]
 800be5c:	429a      	cmp	r2, r3
 800be5e:	d8e3      	bhi.n	800be28 <_encode_uavcan_protocol_debug_LogMessage+0x48>
>>>>>>> 752c83b... update binaries
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->source[i]);
            chunk_cb(buffer, 8, ctx);
    }
    if (!tao) {
<<<<<<< HEAD
 800bdd8:	f897 3020 	ldrb.w	r3, [r7, #32]
 800bddc:	f083 0301 	eor.w	r3, r3, #1
 800bde0:	b2db      	uxtb	r3, r3
 800bde2:	2b00      	cmp	r3, #0
 800bde4:	d010      	beq.n	800be08 <_encode_uavcan_protocol_debug_LogMessage+0xb0>
        memset(buffer,0,8);
 800bde6:	68f8      	ldr	r0, [r7, #12]
 800bde8:	2100      	movs	r1, #0
 800bdea:	2208      	movs	r2, #8
 800bdec:	f002 fbec 	bl	800e5c8 <memset>
        canardEncodeScalar(buffer, 0, 7, &msg->text_len);
 800bdf0:	68bb      	ldr	r3, [r7, #8]
 800bdf2:	3321      	adds	r3, #33	; 0x21
 800bdf4:	68f8      	ldr	r0, [r7, #12]
 800bdf6:	2100      	movs	r1, #0
 800bdf8:	2207      	movs	r2, #7
 800bdfa:	f001 fb6d 	bl	800d4d8 <canardEncodeScalar>
        chunk_cb(buffer, 7, ctx);
 800bdfe:	687b      	ldr	r3, [r7, #4]
 800be00:	68f8      	ldr	r0, [r7, #12]
 800be02:	2107      	movs	r1, #7
 800be04:	683a      	ldr	r2, [r7, #0]
 800be06:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->text_len; i++) {
 800be08:	2300      	movs	r3, #0
 800be0a:	613b      	str	r3, [r7, #16]
 800be0c:	e016      	b.n	800be3c <_encode_uavcan_protocol_debug_LogMessage+0xe4>
            memset(buffer,0,8);
 800be0e:	68f8      	ldr	r0, [r7, #12]
 800be10:	2100      	movs	r1, #0
 800be12:	2208      	movs	r2, #8
 800be14:	f002 fbd8 	bl	800e5c8 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->text[i]);
 800be18:	693b      	ldr	r3, [r7, #16]
 800be1a:	3320      	adds	r3, #32
 800be1c:	68ba      	ldr	r2, [r7, #8]
 800be1e:	4413      	add	r3, r2
 800be20:	3302      	adds	r3, #2
 800be22:	68f8      	ldr	r0, [r7, #12]
 800be24:	2100      	movs	r1, #0
 800be26:	2208      	movs	r2, #8
 800be28:	f001 fb56 	bl	800d4d8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800be2c:	687b      	ldr	r3, [r7, #4]
 800be2e:	68f8      	ldr	r0, [r7, #12]
 800be30:	2108      	movs	r1, #8
 800be32:	683a      	ldr	r2, [r7, #0]
 800be34:	4798      	blx	r3
=======
 800be60:	f897 3020 	ldrb.w	r3, [r7, #32]
 800be64:	f083 0301 	eor.w	r3, r3, #1
 800be68:	b2db      	uxtb	r3, r3
 800be6a:	2b00      	cmp	r3, #0
 800be6c:	d010      	beq.n	800be90 <_encode_uavcan_protocol_debug_LogMessage+0xb0>
        memset(buffer,0,8);
 800be6e:	68f8      	ldr	r0, [r7, #12]
 800be70:	2100      	movs	r1, #0
 800be72:	2208      	movs	r2, #8
 800be74:	f002 fbec 	bl	800e650 <memset>
        canardEncodeScalar(buffer, 0, 7, &msg->text_len);
 800be78:	68bb      	ldr	r3, [r7, #8]
 800be7a:	3321      	adds	r3, #33	; 0x21
 800be7c:	68f8      	ldr	r0, [r7, #12]
 800be7e:	2100      	movs	r1, #0
 800be80:	2207      	movs	r2, #7
 800be82:	f001 fb6d 	bl	800d560 <canardEncodeScalar>
        chunk_cb(buffer, 7, ctx);
 800be86:	687b      	ldr	r3, [r7, #4]
 800be88:	68f8      	ldr	r0, [r7, #12]
 800be8a:	2107      	movs	r1, #7
 800be8c:	683a      	ldr	r2, [r7, #0]
 800be8e:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->text_len; i++) {
 800be90:	2300      	movs	r3, #0
 800be92:	613b      	str	r3, [r7, #16]
 800be94:	e016      	b.n	800bec4 <_encode_uavcan_protocol_debug_LogMessage+0xe4>
            memset(buffer,0,8);
 800be96:	68f8      	ldr	r0, [r7, #12]
 800be98:	2100      	movs	r1, #0
 800be9a:	2208      	movs	r2, #8
 800be9c:	f002 fbd8 	bl	800e650 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->text[i]);
 800bea0:	693b      	ldr	r3, [r7, #16]
 800bea2:	3320      	adds	r3, #32
 800bea4:	68ba      	ldr	r2, [r7, #8]
 800bea6:	4413      	add	r3, r2
 800bea8:	3302      	adds	r3, #2
 800beaa:	68f8      	ldr	r0, [r7, #12]
 800beac:	2100      	movs	r1, #0
 800beae:	2208      	movs	r2, #8
 800beb0:	f001 fb56 	bl	800d560 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800beb4:	687b      	ldr	r3, [r7, #4]
 800beb6:	68f8      	ldr	r0, [r7, #12]
 800beb8:	2108      	movs	r1, #8
 800beba:	683a      	ldr	r2, [r7, #0]
 800bebc:	4798      	blx	r3
>>>>>>> 752c83b... update binaries
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 7, &msg->text_len);
        chunk_cb(buffer, 7, ctx);
    }
    for (size_t i=0; i < msg->text_len; i++) {
<<<<<<< HEAD
 800be36:	693b      	ldr	r3, [r7, #16]
 800be38:	3301      	adds	r3, #1
 800be3a:	613b      	str	r3, [r7, #16]
 800be3c:	68bb      	ldr	r3, [r7, #8]
 800be3e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800be42:	461a      	mov	r2, r3
 800be44:	693b      	ldr	r3, [r7, #16]
 800be46:	429a      	cmp	r2, r3
 800be48:	d8e1      	bhi.n	800be0e <_encode_uavcan_protocol_debug_LogMessage+0xb6>
=======
 800bebe:	693b      	ldr	r3, [r7, #16]
 800bec0:	3301      	adds	r3, #1
 800bec2:	613b      	str	r3, [r7, #16]
 800bec4:	68bb      	ldr	r3, [r7, #8]
 800bec6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800beca:	461a      	mov	r2, r3
 800becc:	693b      	ldr	r3, [r7, #16]
 800bece:	429a      	cmp	r2, r3
 800bed0:	d8e1      	bhi.n	800be96 <_encode_uavcan_protocol_debug_LogMessage+0xb6>
>>>>>>> 752c83b... update binaries
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->text[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
<<<<<<< HEAD
 800be4a:	3718      	adds	r7, #24
 800be4c:	46bd      	mov	sp, r7
 800be4e:	bd80      	pop	{r7, pc}

0800be50 <_decode_uavcan_protocol_debug_LogMessage>:

void _decode_uavcan_protocol_debug_LogMessage(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_debug_LogMessage_s* msg, bool tao) {
 800be50:	b580      	push	{r7, lr}
 800be52:	b088      	sub	sp, #32
 800be54:	af02      	add	r7, sp, #8
 800be56:	60f8      	str	r0, [r7, #12]
 800be58:	60b9      	str	r1, [r7, #8]
 800be5a:	607a      	str	r2, [r7, #4]
 800be5c:	70fb      	strb	r3, [r7, #3]
=======
 800bed2:	3718      	adds	r7, #24
 800bed4:	46bd      	mov	sp, r7
 800bed6:	bd80      	pop	{r7, pc}

0800bed8 <_decode_uavcan_protocol_debug_LogMessage>:

void _decode_uavcan_protocol_debug_LogMessage(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_debug_LogMessage_s* msg, bool tao) {
 800bed8:	b580      	push	{r7, lr}
 800beda:	b088      	sub	sp, #32
 800bedc:	af02      	add	r7, sp, #8
 800bede:	60f8      	str	r0, [r7, #12]
 800bee0:	60b9      	str	r1, [r7, #8]
 800bee2:	607a      	str	r2, [r7, #4]
 800bee4:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    _decode_uavcan_protocol_debug_LogLevel(transfer, bit_ofs, &msg->level, false);
<<<<<<< HEAD
 800be5e:	687b      	ldr	r3, [r7, #4]
 800be60:	68f8      	ldr	r0, [r7, #12]
 800be62:	68b9      	ldr	r1, [r7, #8]
 800be64:	461a      	mov	r2, r3
 800be66:	2300      	movs	r3, #0
 800be68:	f7ff ff16 	bl	800bc98 <_decode_uavcan_protocol_debug_LogLevel>

    canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->source_len);
 800be6c:	68bb      	ldr	r3, [r7, #8]
 800be6e:	681a      	ldr	r2, [r3, #0]
 800be70:	687b      	ldr	r3, [r7, #4]
 800be72:	3301      	adds	r3, #1
 800be74:	9300      	str	r3, [sp, #0]
 800be76:	68f8      	ldr	r0, [r7, #12]
 800be78:	4611      	mov	r1, r2
 800be7a:	2205      	movs	r2, #5
 800be7c:	2300      	movs	r3, #0
 800be7e:	f001 f9b3 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 5;
 800be82:	68bb      	ldr	r3, [r7, #8]
 800be84:	681b      	ldr	r3, [r3, #0]
 800be86:	1d5a      	adds	r2, r3, #5
 800be88:	68bb      	ldr	r3, [r7, #8]
 800be8a:	601a      	str	r2, [r3, #0]
    for (size_t i=0; i < msg->source_len; i++) {
 800be8c:	2300      	movs	r3, #0
 800be8e:	617b      	str	r3, [r7, #20]
 800be90:	e014      	b.n	800bebc <_decode_uavcan_protocol_debug_LogMessage+0x6c>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->source[i]);
 800be92:	68bb      	ldr	r3, [r7, #8]
 800be94:	6819      	ldr	r1, [r3, #0]
 800be96:	687a      	ldr	r2, [r7, #4]
 800be98:	697b      	ldr	r3, [r7, #20]
 800be9a:	4413      	add	r3, r2
 800be9c:	3302      	adds	r3, #2
 800be9e:	9300      	str	r3, [sp, #0]
 800bea0:	68f8      	ldr	r0, [r7, #12]
 800bea2:	2208      	movs	r2, #8
 800bea4:	2300      	movs	r3, #0
 800bea6:	f001 f99f 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 8;
 800beaa:	68bb      	ldr	r3, [r7, #8]
 800beac:	681b      	ldr	r3, [r3, #0]
 800beae:	f103 0208 	add.w	r2, r3, #8
 800beb2:	68bb      	ldr	r3, [r7, #8]
 800beb4:	601a      	str	r2, [r3, #0]
=======
 800bee6:	687b      	ldr	r3, [r7, #4]
 800bee8:	68f8      	ldr	r0, [r7, #12]
 800beea:	68b9      	ldr	r1, [r7, #8]
 800beec:	461a      	mov	r2, r3
 800beee:	2300      	movs	r3, #0
 800bef0:	f7ff ff16 	bl	800bd20 <_decode_uavcan_protocol_debug_LogLevel>

    canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->source_len);
 800bef4:	68bb      	ldr	r3, [r7, #8]
 800bef6:	681a      	ldr	r2, [r3, #0]
 800bef8:	687b      	ldr	r3, [r7, #4]
 800befa:	3301      	adds	r3, #1
 800befc:	9300      	str	r3, [sp, #0]
 800befe:	68f8      	ldr	r0, [r7, #12]
 800bf00:	4611      	mov	r1, r2
 800bf02:	2205      	movs	r2, #5
 800bf04:	2300      	movs	r3, #0
 800bf06:	f001 f9b3 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 5;
 800bf0a:	68bb      	ldr	r3, [r7, #8]
 800bf0c:	681b      	ldr	r3, [r3, #0]
 800bf0e:	1d5a      	adds	r2, r3, #5
 800bf10:	68bb      	ldr	r3, [r7, #8]
 800bf12:	601a      	str	r2, [r3, #0]
    for (size_t i=0; i < msg->source_len; i++) {
 800bf14:	2300      	movs	r3, #0
 800bf16:	617b      	str	r3, [r7, #20]
 800bf18:	e014      	b.n	800bf44 <_decode_uavcan_protocol_debug_LogMessage+0x6c>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->source[i]);
 800bf1a:	68bb      	ldr	r3, [r7, #8]
 800bf1c:	6819      	ldr	r1, [r3, #0]
 800bf1e:	687a      	ldr	r2, [r7, #4]
 800bf20:	697b      	ldr	r3, [r7, #20]
 800bf22:	4413      	add	r3, r2
 800bf24:	3302      	adds	r3, #2
 800bf26:	9300      	str	r3, [sp, #0]
 800bf28:	68f8      	ldr	r0, [r7, #12]
 800bf2a:	2208      	movs	r2, #8
 800bf2c:	2300      	movs	r3, #0
 800bf2e:	f001 f99f 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 8;
 800bf32:	68bb      	ldr	r3, [r7, #8]
 800bf34:	681b      	ldr	r3, [r3, #0]
 800bf36:	f103 0208 	add.w	r2, r3, #8
 800bf3a:	68bb      	ldr	r3, [r7, #8]
 800bf3c:	601a      	str	r2, [r3, #0]
>>>>>>> 752c83b... update binaries

    _decode_uavcan_protocol_debug_LogLevel(transfer, bit_ofs, &msg->level, false);

    canardDecodeScalar(transfer, *bit_ofs, 5, false, &msg->source_len);
    *bit_ofs += 5;
    for (size_t i=0; i < msg->source_len; i++) {
<<<<<<< HEAD
 800beb6:	697b      	ldr	r3, [r7, #20]
 800beb8:	3301      	adds	r3, #1
 800beba:	617b      	str	r3, [r7, #20]
 800bebc:	687b      	ldr	r3, [r7, #4]
 800bebe:	785b      	ldrb	r3, [r3, #1]
 800bec0:	461a      	mov	r2, r3
 800bec2:	697b      	ldr	r3, [r7, #20]
 800bec4:	429a      	cmp	r2, r3
 800bec6:	d8e4      	bhi.n	800be92 <_decode_uavcan_protocol_debug_LogMessage+0x42>
=======
 800bf3e:	697b      	ldr	r3, [r7, #20]
 800bf40:	3301      	adds	r3, #1
 800bf42:	617b      	str	r3, [r7, #20]
 800bf44:	687b      	ldr	r3, [r7, #4]
 800bf46:	785b      	ldrb	r3, [r3, #1]
 800bf48:	461a      	mov	r2, r3
 800bf4a:	697b      	ldr	r3, [r7, #20]
 800bf4c:	429a      	cmp	r2, r3
 800bf4e:	d8e4      	bhi.n	800bf1a <_decode_uavcan_protocol_debug_LogMessage+0x42>
>>>>>>> 752c83b... update binaries
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->source[i]);
        *bit_ofs += 8;
    }

    if (!tao) {
<<<<<<< HEAD
 800bec8:	78fb      	ldrb	r3, [r7, #3]
 800beca:	f083 0301 	eor.w	r3, r3, #1
 800bece:	b2db      	uxtb	r3, r3
 800bed0:	2b00      	cmp	r3, #0
 800bed2:	d010      	beq.n	800bef6 <_decode_uavcan_protocol_debug_LogMessage+0xa6>
        canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->text_len);
 800bed4:	68bb      	ldr	r3, [r7, #8]
 800bed6:	681a      	ldr	r2, [r3, #0]
 800bed8:	687b      	ldr	r3, [r7, #4]
 800beda:	3321      	adds	r3, #33	; 0x21
 800bedc:	9300      	str	r3, [sp, #0]
 800bede:	68f8      	ldr	r0, [r7, #12]
 800bee0:	4611      	mov	r1, r2
 800bee2:	2207      	movs	r2, #7
 800bee4:	2300      	movs	r3, #0
 800bee6:	f001 f97f 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 7;
 800beea:	68bb      	ldr	r3, [r7, #8]
 800beec:	681b      	ldr	r3, [r3, #0]
 800beee:	1dda      	adds	r2, r3, #7
 800bef0:	68bb      	ldr	r3, [r7, #8]
 800bef2:	601a      	str	r2, [r3, #0]
 800bef4:	e00b      	b.n	800bf0e <_decode_uavcan_protocol_debug_LogMessage+0xbe>
    } else {
        msg->text_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800bef6:	68fb      	ldr	r3, [r7, #12]
 800bef8:	8a9b      	ldrh	r3, [r3, #20]
 800befa:	00db      	lsls	r3, r3, #3
 800befc:	461a      	mov	r2, r3
 800befe:	68bb      	ldr	r3, [r7, #8]
 800bf00:	681b      	ldr	r3, [r3, #0]
 800bf02:	1ad3      	subs	r3, r2, r3
 800bf04:	08db      	lsrs	r3, r3, #3
 800bf06:	b2da      	uxtb	r2, r3
 800bf08:	687b      	ldr	r3, [r7, #4]
 800bf0a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    }

    for (size_t i=0; i < msg->text_len; i++) {
 800bf0e:	2300      	movs	r3, #0
 800bf10:	613b      	str	r3, [r7, #16]
 800bf12:	e015      	b.n	800bf40 <_decode_uavcan_protocol_debug_LogMessage+0xf0>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->text[i]);
 800bf14:	68bb      	ldr	r3, [r7, #8]
 800bf16:	6819      	ldr	r1, [r3, #0]
 800bf18:	693b      	ldr	r3, [r7, #16]
 800bf1a:	3320      	adds	r3, #32
 800bf1c:	687a      	ldr	r2, [r7, #4]
 800bf1e:	4413      	add	r3, r2
 800bf20:	3302      	adds	r3, #2
 800bf22:	9300      	str	r3, [sp, #0]
 800bf24:	68f8      	ldr	r0, [r7, #12]
 800bf26:	2208      	movs	r2, #8
 800bf28:	2300      	movs	r3, #0
 800bf2a:	f001 f95d 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 8;
 800bf2e:	68bb      	ldr	r3, [r7, #8]
 800bf30:	681b      	ldr	r3, [r3, #0]
 800bf32:	f103 0208 	add.w	r2, r3, #8
 800bf36:	68bb      	ldr	r3, [r7, #8]
 800bf38:	601a      	str	r2, [r3, #0]
=======
 800bf50:	78fb      	ldrb	r3, [r7, #3]
 800bf52:	f083 0301 	eor.w	r3, r3, #1
 800bf56:	b2db      	uxtb	r3, r3
 800bf58:	2b00      	cmp	r3, #0
 800bf5a:	d010      	beq.n	800bf7e <_decode_uavcan_protocol_debug_LogMessage+0xa6>
        canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->text_len);
 800bf5c:	68bb      	ldr	r3, [r7, #8]
 800bf5e:	681a      	ldr	r2, [r3, #0]
 800bf60:	687b      	ldr	r3, [r7, #4]
 800bf62:	3321      	adds	r3, #33	; 0x21
 800bf64:	9300      	str	r3, [sp, #0]
 800bf66:	68f8      	ldr	r0, [r7, #12]
 800bf68:	4611      	mov	r1, r2
 800bf6a:	2207      	movs	r2, #7
 800bf6c:	2300      	movs	r3, #0
 800bf6e:	f001 f97f 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 7;
 800bf72:	68bb      	ldr	r3, [r7, #8]
 800bf74:	681b      	ldr	r3, [r3, #0]
 800bf76:	1dda      	adds	r2, r3, #7
 800bf78:	68bb      	ldr	r3, [r7, #8]
 800bf7a:	601a      	str	r2, [r3, #0]
 800bf7c:	e00b      	b.n	800bf96 <_decode_uavcan_protocol_debug_LogMessage+0xbe>
    } else {
        msg->text_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800bf7e:	68fb      	ldr	r3, [r7, #12]
 800bf80:	8a9b      	ldrh	r3, [r3, #20]
 800bf82:	00db      	lsls	r3, r3, #3
 800bf84:	461a      	mov	r2, r3
 800bf86:	68bb      	ldr	r3, [r7, #8]
 800bf88:	681b      	ldr	r3, [r3, #0]
 800bf8a:	1ad3      	subs	r3, r2, r3
 800bf8c:	08db      	lsrs	r3, r3, #3
 800bf8e:	b2da      	uxtb	r2, r3
 800bf90:	687b      	ldr	r3, [r7, #4]
 800bf92:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    }

    for (size_t i=0; i < msg->text_len; i++) {
 800bf96:	2300      	movs	r3, #0
 800bf98:	613b      	str	r3, [r7, #16]
 800bf9a:	e015      	b.n	800bfc8 <_decode_uavcan_protocol_debug_LogMessage+0xf0>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->text[i]);
 800bf9c:	68bb      	ldr	r3, [r7, #8]
 800bf9e:	6819      	ldr	r1, [r3, #0]
 800bfa0:	693b      	ldr	r3, [r7, #16]
 800bfa2:	3320      	adds	r3, #32
 800bfa4:	687a      	ldr	r2, [r7, #4]
 800bfa6:	4413      	add	r3, r2
 800bfa8:	3302      	adds	r3, #2
 800bfaa:	9300      	str	r3, [sp, #0]
 800bfac:	68f8      	ldr	r0, [r7, #12]
 800bfae:	2208      	movs	r2, #8
 800bfb0:	2300      	movs	r3, #0
 800bfb2:	f001 f95d 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 8;
 800bfb6:	68bb      	ldr	r3, [r7, #8]
 800bfb8:	681b      	ldr	r3, [r3, #0]
 800bfba:	f103 0208 	add.w	r2, r3, #8
 800bfbe:	68bb      	ldr	r3, [r7, #8]
 800bfc0:	601a      	str	r2, [r3, #0]
>>>>>>> 752c83b... update binaries
        *bit_ofs += 7;
    } else {
        msg->text_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->text_len; i++) {
<<<<<<< HEAD
 800bf3a:	693b      	ldr	r3, [r7, #16]
 800bf3c:	3301      	adds	r3, #1
 800bf3e:	613b      	str	r3, [r7, #16]
 800bf40:	687b      	ldr	r3, [r7, #4]
 800bf42:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800bf46:	461a      	mov	r2, r3
 800bf48:	693b      	ldr	r3, [r7, #16]
 800bf4a:	429a      	cmp	r2, r3
 800bf4c:	d8e2      	bhi.n	800bf14 <_decode_uavcan_protocol_debug_LogMessage+0xc4>
=======
 800bfc2:	693b      	ldr	r3, [r7, #16]
 800bfc4:	3301      	adds	r3, #1
 800bfc6:	613b      	str	r3, [r7, #16]
 800bfc8:	687b      	ldr	r3, [r7, #4]
 800bfca:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800bfce:	461a      	mov	r2, r3
 800bfd0:	693b      	ldr	r3, [r7, #16]
 800bfd2:	429a      	cmp	r2, r3
 800bfd4:	d8e2      	bhi.n	800bf9c <_decode_uavcan_protocol_debug_LogMessage+0xc4>
>>>>>>> 752c83b... update binaries
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->text[i]);
        *bit_ofs += 8;
    }

}
<<<<<<< HEAD
 800bf4e:	3718      	adds	r7, #24
 800bf50:	46bd      	mov	sp, r7
 800bf52:	bd80      	pop	{r7, pc}

0800bf54 <encode_func.lto_priv.54>:
=======
 800bfd6:	3718      	adds	r7, #24
 800bfd8:	46bd      	mov	sp, r7
 800bfda:	bd80      	pop	{r7, pc}

0800bfdc <encode_func.lto_priv.54>:
>>>>>>> 752c83b... update binaries
#include <uavcan.protocol.GetNodeInfo_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800bf54:	b580      	push	{r7, lr}
 800bf56:	b084      	sub	sp, #16
 800bf58:	af00      	add	r7, sp, #0
 800bf5a:	60f8      	str	r0, [r7, #12]
 800bf5c:	60b9      	str	r1, [r7, #8]
 800bf5e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_res(msg, chunk_cb, ctx);
 800bf60:	68f8      	ldr	r0, [r7, #12]
 800bf62:	68b9      	ldr	r1, [r7, #8]
 800bf64:	687a      	ldr	r2, [r7, #4]
 800bf66:	f000 f811 	bl	800bf8c <encode_uavcan_protocol_GetNodeInfo_res>
}
 800bf6a:	3710      	adds	r7, #16
 800bf6c:	46bd      	mov	sp, r7
 800bf6e:	bd80      	pop	{r7, pc}

0800bf70 <decode_func.lto_priv.62>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800bf70:	b580      	push	{r7, lr}
 800bf72:	b082      	sub	sp, #8
 800bf74:	af00      	add	r7, sp, #0
 800bf76:	6078      	str	r0, [r7, #4]
 800bf78:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_res(transfer, msg);
 800bf7a:	6878      	ldr	r0, [r7, #4]
 800bf7c:	6839      	ldr	r1, [r7, #0]
 800bf7e:	f000 f819 	bl	800bfb4 <decode_uavcan_protocol_GetNodeInfo_res>
 800bf82:	4603      	mov	r3, r0
}
 800bf84:	4618      	mov	r0, r3
 800bf86:	3708      	adds	r7, #8
 800bf88:	46bd      	mov	sp, r7
 800bf8a:	bd80      	pop	{r7, pc}

0800bf8c <encode_uavcan_protocol_GetNodeInfo_res>:
=======
 800bfdc:	b580      	push	{r7, lr}
 800bfde:	b084      	sub	sp, #16
 800bfe0:	af00      	add	r7, sp, #0
 800bfe2:	60f8      	str	r0, [r7, #12]
 800bfe4:	60b9      	str	r1, [r7, #8]
 800bfe6:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_res(msg, chunk_cb, ctx);
 800bfe8:	68f8      	ldr	r0, [r7, #12]
 800bfea:	68b9      	ldr	r1, [r7, #8]
 800bfec:	687a      	ldr	r2, [r7, #4]
 800bfee:	f000 f811 	bl	800c014 <encode_uavcan_protocol_GetNodeInfo_res>
}
 800bff2:	3710      	adds	r7, #16
 800bff4:	46bd      	mov	sp, r7
 800bff6:	bd80      	pop	{r7, pc}

0800bff8 <decode_func.lto_priv.62>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800bff8:	b580      	push	{r7, lr}
 800bffa:	b082      	sub	sp, #8
 800bffc:	af00      	add	r7, sp, #0
 800bffe:	6078      	str	r0, [r7, #4]
 800c000:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_res(transfer, msg);
 800c002:	6878      	ldr	r0, [r7, #4]
 800c004:	6839      	ldr	r1, [r7, #0]
 800c006:	f000 f819 	bl	800c03c <decode_uavcan_protocol_GetNodeInfo_res>
 800c00a:	4603      	mov	r3, r0
}
 800c00c:	4618      	mov	r0, r3
 800c00e:	3708      	adds	r7, #8
 800c010:	46bd      	mov	sp, r7
 800c012:	bd80      	pop	{r7, pc}

0800c014 <encode_uavcan_protocol_GetNodeInfo_res>:
>>>>>>> 752c83b... update binaries
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_GetNodeInfo_res(struct uavcan_protocol_GetNodeInfo_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800bf8c:	b580      	push	{r7, lr}
 800bf8e:	b088      	sub	sp, #32
 800bf90:	af02      	add	r7, sp, #8
 800bf92:	60f8      	str	r0, [r7, #12]
 800bf94:	60b9      	str	r1, [r7, #8]
 800bf96:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_res(buffer, msg, chunk_cb, ctx, true);
 800bf98:	f107 0210 	add.w	r2, r7, #16
 800bf9c:	2301      	movs	r3, #1
 800bf9e:	9300      	str	r3, [sp, #0]
 800bfa0:	4610      	mov	r0, r2
 800bfa2:	68f9      	ldr	r1, [r7, #12]
 800bfa4:	68ba      	ldr	r2, [r7, #8]
 800bfa6:	687b      	ldr	r3, [r7, #4]
 800bfa8:	f000 f81a 	bl	800bfe0 <_encode_uavcan_protocol_GetNodeInfo_res>
}
 800bfac:	3718      	adds	r7, #24
 800bfae:	46bd      	mov	sp, r7
 800bfb0:	bd80      	pop	{r7, pc}
 800bfb2:	bf00      	nop

0800bfb4 <decode_uavcan_protocol_GetNodeInfo_res>:

uint32_t decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_res_s* msg) {
 800bfb4:	b580      	push	{r7, lr}
 800bfb6:	b084      	sub	sp, #16
 800bfb8:	af00      	add	r7, sp, #0
 800bfba:	6078      	str	r0, [r7, #4]
 800bfbc:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800bfbe:	2300      	movs	r3, #0
 800bfc0:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_res(transfer, &bit_ofs, msg, true);
 800bfc2:	f107 030c 	add.w	r3, r7, #12
 800bfc6:	6878      	ldr	r0, [r7, #4]
 800bfc8:	4619      	mov	r1, r3
 800bfca:	683a      	ldr	r2, [r7, #0]
 800bfcc:	2301      	movs	r3, #1
 800bfce:	f000 f86b 	bl	800c0a8 <_decode_uavcan_protocol_GetNodeInfo_res>
    return (bit_ofs+7)/8;
 800bfd2:	68fb      	ldr	r3, [r7, #12]
 800bfd4:	3307      	adds	r3, #7
 800bfd6:	08db      	lsrs	r3, r3, #3
}
 800bfd8:	4618      	mov	r0, r3
 800bfda:	3710      	adds	r7, #16
 800bfdc:	46bd      	mov	sp, r7
 800bfde:	bd80      	pop	{r7, pc}

0800bfe0 <_encode_uavcan_protocol_GetNodeInfo_res>:

void _encode_uavcan_protocol_GetNodeInfo_res(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800bfe0:	b580      	push	{r7, lr}
 800bfe2:	b088      	sub	sp, #32
 800bfe4:	af02      	add	r7, sp, #8
 800bfe6:	60f8      	str	r0, [r7, #12]
 800bfe8:	60b9      	str	r1, [r7, #8]
 800bfea:	607a      	str	r2, [r7, #4]
 800bfec:	603b      	str	r3, [r7, #0]
=======
 800c014:	b580      	push	{r7, lr}
 800c016:	b088      	sub	sp, #32
 800c018:	af02      	add	r7, sp, #8
 800c01a:	60f8      	str	r0, [r7, #12]
 800c01c:	60b9      	str	r1, [r7, #8]
 800c01e:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_res(buffer, msg, chunk_cb, ctx, true);
 800c020:	f107 0210 	add.w	r2, r7, #16
 800c024:	2301      	movs	r3, #1
 800c026:	9300      	str	r3, [sp, #0]
 800c028:	4610      	mov	r0, r2
 800c02a:	68f9      	ldr	r1, [r7, #12]
 800c02c:	68ba      	ldr	r2, [r7, #8]
 800c02e:	687b      	ldr	r3, [r7, #4]
 800c030:	f000 f81a 	bl	800c068 <_encode_uavcan_protocol_GetNodeInfo_res>
}
 800c034:	3718      	adds	r7, #24
 800c036:	46bd      	mov	sp, r7
 800c038:	bd80      	pop	{r7, pc}
 800c03a:	bf00      	nop

0800c03c <decode_uavcan_protocol_GetNodeInfo_res>:

uint32_t decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_res_s* msg) {
 800c03c:	b580      	push	{r7, lr}
 800c03e:	b084      	sub	sp, #16
 800c040:	af00      	add	r7, sp, #0
 800c042:	6078      	str	r0, [r7, #4]
 800c044:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800c046:	2300      	movs	r3, #0
 800c048:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_res(transfer, &bit_ofs, msg, true);
 800c04a:	f107 030c 	add.w	r3, r7, #12
 800c04e:	6878      	ldr	r0, [r7, #4]
 800c050:	4619      	mov	r1, r3
 800c052:	683a      	ldr	r2, [r7, #0]
 800c054:	2301      	movs	r3, #1
 800c056:	f000 f86b 	bl	800c130 <_decode_uavcan_protocol_GetNodeInfo_res>
    return (bit_ofs+7)/8;
 800c05a:	68fb      	ldr	r3, [r7, #12]
 800c05c:	3307      	adds	r3, #7
 800c05e:	08db      	lsrs	r3, r3, #3
}
 800c060:	4618      	mov	r0, r3
 800c062:	3710      	adds	r7, #16
 800c064:	46bd      	mov	sp, r7
 800c066:	bd80      	pop	{r7, pc}

0800c068 <_encode_uavcan_protocol_GetNodeInfo_res>:

void _encode_uavcan_protocol_GetNodeInfo_res(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800c068:	b580      	push	{r7, lr}
 800c06a:	b088      	sub	sp, #32
 800c06c:	af02      	add	r7, sp, #8
 800c06e:	60f8      	str	r0, [r7, #12]
 800c070:	60b9      	str	r1, [r7, #8]
 800c072:	607a      	str	r2, [r7, #4]
 800c074:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    _encode_uavcan_protocol_NodeStatus(buffer, &msg->status, chunk_cb, ctx, false);
<<<<<<< HEAD
 800bfee:	68ba      	ldr	r2, [r7, #8]
 800bff0:	2300      	movs	r3, #0
 800bff2:	9300      	str	r3, [sp, #0]
 800bff4:	68f8      	ldr	r0, [r7, #12]
 800bff6:	4611      	mov	r1, r2
 800bff8:	687a      	ldr	r2, [r7, #4]
 800bffa:	683b      	ldr	r3, [r7, #0]
 800bffc:	f002 f858 	bl	800e0b0 <_encode_uavcan_protocol_NodeStatus>
    _encode_uavcan_protocol_SoftwareVersion(buffer, &msg->software_version, chunk_cb, ctx, false);
 800c000:	68bb      	ldr	r3, [r7, #8]
 800c002:	f103 0210 	add.w	r2, r3, #16
 800c006:	2300      	movs	r3, #0
 800c008:	9300      	str	r3, [sp, #0]
 800c00a:	68f8      	ldr	r0, [r7, #12]
 800c00c:	4611      	mov	r1, r2
 800c00e:	687a      	ldr	r2, [r7, #4]
 800c010:	683b      	ldr	r3, [r7, #0]
 800c012:	f000 f9b7 	bl	800c384 <_encode_uavcan_protocol_SoftwareVersion>
    _encode_uavcan_protocol_HardwareVersion(buffer, &msg->hardware_version, chunk_cb, ctx, false);
 800c016:	68bb      	ldr	r3, [r7, #8]
 800c018:	f103 0220 	add.w	r2, r3, #32
 800c01c:	2300      	movs	r3, #0
 800c01e:	9300      	str	r3, [sp, #0]
 800c020:	68f8      	ldr	r0, [r7, #12]
 800c022:	4611      	mov	r1, r2
 800c024:	687a      	ldr	r2, [r7, #4]
 800c026:	683b      	ldr	r3, [r7, #0]
 800c028:	f000 f8a4 	bl	800c174 <_encode_uavcan_protocol_HardwareVersion>
    if (!tao) {
 800c02c:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c030:	f083 0301 	eor.w	r3, r3, #1
 800c034:	b2db      	uxtb	r3, r3
 800c036:	2b00      	cmp	r3, #0
 800c038:	d011      	beq.n	800c05e <_encode_uavcan_protocol_GetNodeInfo_res+0x7e>
        memset(buffer,0,8);
 800c03a:	68f8      	ldr	r0, [r7, #12]
 800c03c:	2100      	movs	r1, #0
 800c03e:	2208      	movs	r2, #8
 800c040:	f002 fac2 	bl	800e5c8 <memset>
        canardEncodeScalar(buffer, 0, 7, &msg->name_len);
 800c044:	68bb      	ldr	r3, [r7, #8]
 800c046:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800c04a:	68f8      	ldr	r0, [r7, #12]
 800c04c:	2100      	movs	r1, #0
 800c04e:	2207      	movs	r2, #7
 800c050:	f001 fa42 	bl	800d4d8 <canardEncodeScalar>
        chunk_cb(buffer, 7, ctx);
 800c054:	687b      	ldr	r3, [r7, #4]
 800c056:	68f8      	ldr	r0, [r7, #12]
 800c058:	2107      	movs	r1, #7
 800c05a:	683a      	ldr	r2, [r7, #0]
 800c05c:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->name_len; i++) {
 800c05e:	2300      	movs	r3, #0
 800c060:	617b      	str	r3, [r7, #20]
 800c062:	e017      	b.n	800c094 <_encode_uavcan_protocol_GetNodeInfo_res+0xb4>
            memset(buffer,0,8);
 800c064:	68f8      	ldr	r0, [r7, #12]
 800c066:	2100      	movs	r1, #0
 800c068:	2208      	movs	r2, #8
 800c06a:	f002 faad 	bl	800e5c8 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->name[i]);
 800c06e:	697b      	ldr	r3, [r7, #20]
 800c070:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800c074:	68ba      	ldr	r2, [r7, #8]
 800c076:	4413      	add	r3, r2
 800c078:	3303      	adds	r3, #3
 800c07a:	68f8      	ldr	r0, [r7, #12]
 800c07c:	2100      	movs	r1, #0
 800c07e:	2208      	movs	r2, #8
 800c080:	f001 fa2a 	bl	800d4d8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c084:	687b      	ldr	r3, [r7, #4]
 800c086:	68f8      	ldr	r0, [r7, #12]
 800c088:	2108      	movs	r1, #8
 800c08a:	683a      	ldr	r2, [r7, #0]
 800c08c:	4798      	blx	r3
=======
 800c076:	68ba      	ldr	r2, [r7, #8]
 800c078:	2300      	movs	r3, #0
 800c07a:	9300      	str	r3, [sp, #0]
 800c07c:	68f8      	ldr	r0, [r7, #12]
 800c07e:	4611      	mov	r1, r2
 800c080:	687a      	ldr	r2, [r7, #4]
 800c082:	683b      	ldr	r3, [r7, #0]
 800c084:	f002 f858 	bl	800e138 <_encode_uavcan_protocol_NodeStatus>
    _encode_uavcan_protocol_SoftwareVersion(buffer, &msg->software_version, chunk_cb, ctx, false);
 800c088:	68bb      	ldr	r3, [r7, #8]
 800c08a:	f103 0210 	add.w	r2, r3, #16
 800c08e:	2300      	movs	r3, #0
 800c090:	9300      	str	r3, [sp, #0]
 800c092:	68f8      	ldr	r0, [r7, #12]
 800c094:	4611      	mov	r1, r2
 800c096:	687a      	ldr	r2, [r7, #4]
 800c098:	683b      	ldr	r3, [r7, #0]
 800c09a:	f000 f9b7 	bl	800c40c <_encode_uavcan_protocol_SoftwareVersion>
    _encode_uavcan_protocol_HardwareVersion(buffer, &msg->hardware_version, chunk_cb, ctx, false);
 800c09e:	68bb      	ldr	r3, [r7, #8]
 800c0a0:	f103 0220 	add.w	r2, r3, #32
 800c0a4:	2300      	movs	r3, #0
 800c0a6:	9300      	str	r3, [sp, #0]
 800c0a8:	68f8      	ldr	r0, [r7, #12]
 800c0aa:	4611      	mov	r1, r2
 800c0ac:	687a      	ldr	r2, [r7, #4]
 800c0ae:	683b      	ldr	r3, [r7, #0]
 800c0b0:	f000 f8a4 	bl	800c1fc <_encode_uavcan_protocol_HardwareVersion>
    if (!tao) {
 800c0b4:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c0b8:	f083 0301 	eor.w	r3, r3, #1
 800c0bc:	b2db      	uxtb	r3, r3
 800c0be:	2b00      	cmp	r3, #0
 800c0c0:	d011      	beq.n	800c0e6 <_encode_uavcan_protocol_GetNodeInfo_res+0x7e>
        memset(buffer,0,8);
 800c0c2:	68f8      	ldr	r0, [r7, #12]
 800c0c4:	2100      	movs	r1, #0
 800c0c6:	2208      	movs	r2, #8
 800c0c8:	f002 fac2 	bl	800e650 <memset>
        canardEncodeScalar(buffer, 0, 7, &msg->name_len);
 800c0cc:	68bb      	ldr	r3, [r7, #8]
 800c0ce:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800c0d2:	68f8      	ldr	r0, [r7, #12]
 800c0d4:	2100      	movs	r1, #0
 800c0d6:	2207      	movs	r2, #7
 800c0d8:	f001 fa42 	bl	800d560 <canardEncodeScalar>
        chunk_cb(buffer, 7, ctx);
 800c0dc:	687b      	ldr	r3, [r7, #4]
 800c0de:	68f8      	ldr	r0, [r7, #12]
 800c0e0:	2107      	movs	r1, #7
 800c0e2:	683a      	ldr	r2, [r7, #0]
 800c0e4:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->name_len; i++) {
 800c0e6:	2300      	movs	r3, #0
 800c0e8:	617b      	str	r3, [r7, #20]
 800c0ea:	e017      	b.n	800c11c <_encode_uavcan_protocol_GetNodeInfo_res+0xb4>
            memset(buffer,0,8);
 800c0ec:	68f8      	ldr	r0, [r7, #12]
 800c0ee:	2100      	movs	r1, #0
 800c0f0:	2208      	movs	r2, #8
 800c0f2:	f002 faad 	bl	800e650 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->name[i]);
 800c0f6:	697b      	ldr	r3, [r7, #20]
 800c0f8:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800c0fc:	68ba      	ldr	r2, [r7, #8]
 800c0fe:	4413      	add	r3, r2
 800c100:	3303      	adds	r3, #3
 800c102:	68f8      	ldr	r0, [r7, #12]
 800c104:	2100      	movs	r1, #0
 800c106:	2208      	movs	r2, #8
 800c108:	f001 fa2a 	bl	800d560 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c10c:	687b      	ldr	r3, [r7, #4]
 800c10e:	68f8      	ldr	r0, [r7, #12]
 800c110:	2108      	movs	r1, #8
 800c112:	683a      	ldr	r2, [r7, #0]
 800c114:	4798      	blx	r3
>>>>>>> 752c83b... update binaries
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 7, &msg->name_len);
        chunk_cb(buffer, 7, ctx);
    }
    for (size_t i=0; i < msg->name_len; i++) {
<<<<<<< HEAD
 800c08e:	697b      	ldr	r3, [r7, #20]
 800c090:	3301      	adds	r3, #1
 800c092:	617b      	str	r3, [r7, #20]
 800c094:	68bb      	ldr	r3, [r7, #8]
 800c096:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800c09a:	461a      	mov	r2, r3
 800c09c:	697b      	ldr	r3, [r7, #20]
 800c09e:	429a      	cmp	r2, r3
 800c0a0:	d8e0      	bhi.n	800c064 <_encode_uavcan_protocol_GetNodeInfo_res+0x84>
=======
 800c116:	697b      	ldr	r3, [r7, #20]
 800c118:	3301      	adds	r3, #1
 800c11a:	617b      	str	r3, [r7, #20]
 800c11c:	68bb      	ldr	r3, [r7, #8]
 800c11e:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800c122:	461a      	mov	r2, r3
 800c124:	697b      	ldr	r3, [r7, #20]
 800c126:	429a      	cmp	r2, r3
 800c128:	d8e0      	bhi.n	800c0ec <_encode_uavcan_protocol_GetNodeInfo_res+0x84>
>>>>>>> 752c83b... update binaries
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->name[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
<<<<<<< HEAD
 800c0a2:	3718      	adds	r7, #24
 800c0a4:	46bd      	mov	sp, r7
 800c0a6:	bd80      	pop	{r7, pc}

0800c0a8 <_decode_uavcan_protocol_GetNodeInfo_res>:

void _decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_res_s* msg, bool tao) {
 800c0a8:	b580      	push	{r7, lr}
 800c0aa:	b088      	sub	sp, #32
 800c0ac:	af02      	add	r7, sp, #8
 800c0ae:	60f8      	str	r0, [r7, #12]
 800c0b0:	60b9      	str	r1, [r7, #8]
 800c0b2:	607a      	str	r2, [r7, #4]
 800c0b4:	70fb      	strb	r3, [r7, #3]
=======
 800c12a:	3718      	adds	r7, #24
 800c12c:	46bd      	mov	sp, r7
 800c12e:	bd80      	pop	{r7, pc}

0800c130 <_decode_uavcan_protocol_GetNodeInfo_res>:

void _decode_uavcan_protocol_GetNodeInfo_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_res_s* msg, bool tao) {
 800c130:	b580      	push	{r7, lr}
 800c132:	b088      	sub	sp, #32
 800c134:	af02      	add	r7, sp, #8
 800c136:	60f8      	str	r0, [r7, #12]
 800c138:	60b9      	str	r1, [r7, #8]
 800c13a:	607a      	str	r2, [r7, #4]
 800c13c:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    _decode_uavcan_protocol_NodeStatus(transfer, bit_ofs, &msg->status, false);
<<<<<<< HEAD
 800c0b6:	687b      	ldr	r3, [r7, #4]
 800c0b8:	68f8      	ldr	r0, [r7, #12]
 800c0ba:	68b9      	ldr	r1, [r7, #8]
 800c0bc:	461a      	mov	r2, r3
 800c0be:	2300      	movs	r3, #0
 800c0c0:	f002 f854 	bl	800e16c <_decode_uavcan_protocol_NodeStatus>

    _decode_uavcan_protocol_SoftwareVersion(transfer, bit_ofs, &msg->software_version, false);
 800c0c4:	687b      	ldr	r3, [r7, #4]
 800c0c6:	3310      	adds	r3, #16
 800c0c8:	68f8      	ldr	r0, [r7, #12]
 800c0ca:	68b9      	ldr	r1, [r7, #8]
 800c0cc:	461a      	mov	r2, r3
 800c0ce:	2300      	movs	r3, #0
 800c0d0:	f000 f9b6 	bl	800c440 <_decode_uavcan_protocol_SoftwareVersion>

    _decode_uavcan_protocol_HardwareVersion(transfer, bit_ofs, &msg->hardware_version, false);
 800c0d4:	687b      	ldr	r3, [r7, #4]
 800c0d6:	3320      	adds	r3, #32
 800c0d8:	68f8      	ldr	r0, [r7, #12]
 800c0da:	68b9      	ldr	r1, [r7, #8]
 800c0dc:	461a      	mov	r2, r3
 800c0de:	2300      	movs	r3, #0
 800c0e0:	f000 f8c8 	bl	800c274 <_decode_uavcan_protocol_HardwareVersion>

    if (!tao) {
 800c0e4:	78fb      	ldrb	r3, [r7, #3]
 800c0e6:	f083 0301 	eor.w	r3, r3, #1
 800c0ea:	b2db      	uxtb	r3, r3
 800c0ec:	2b00      	cmp	r3, #0
 800c0ee:	d011      	beq.n	800c114 <_decode_uavcan_protocol_GetNodeInfo_res+0x6c>
        canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->name_len);
 800c0f0:	68bb      	ldr	r3, [r7, #8]
 800c0f2:	681a      	ldr	r2, [r3, #0]
 800c0f4:	687b      	ldr	r3, [r7, #4]
 800c0f6:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800c0fa:	9300      	str	r3, [sp, #0]
 800c0fc:	68f8      	ldr	r0, [r7, #12]
 800c0fe:	4611      	mov	r1, r2
 800c100:	2207      	movs	r2, #7
 800c102:	2300      	movs	r3, #0
 800c104:	f001 f870 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 7;
 800c108:	68bb      	ldr	r3, [r7, #8]
 800c10a:	681b      	ldr	r3, [r3, #0]
 800c10c:	1dda      	adds	r2, r3, #7
 800c10e:	68bb      	ldr	r3, [r7, #8]
 800c110:	601a      	str	r2, [r3, #0]
 800c112:	e00b      	b.n	800c12c <_decode_uavcan_protocol_GetNodeInfo_res+0x84>
    } else {
        msg->name_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800c114:	68fb      	ldr	r3, [r7, #12]
 800c116:	8a9b      	ldrh	r3, [r3, #20]
 800c118:	00db      	lsls	r3, r3, #3
 800c11a:	461a      	mov	r2, r3
 800c11c:	68bb      	ldr	r3, [r7, #8]
 800c11e:	681b      	ldr	r3, [r3, #0]
 800c120:	1ad3      	subs	r3, r2, r3
 800c122:	08db      	lsrs	r3, r3, #3
 800c124:	b2da      	uxtb	r2, r3
 800c126:	687b      	ldr	r3, [r7, #4]
 800c128:	f883 2132 	strb.w	r2, [r3, #306]	; 0x132
    }

    for (size_t i=0; i < msg->name_len; i++) {
 800c12c:	2300      	movs	r3, #0
 800c12e:	617b      	str	r3, [r7, #20]
 800c130:	e016      	b.n	800c160 <_decode_uavcan_protocol_GetNodeInfo_res+0xb8>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->name[i]);
 800c132:	68bb      	ldr	r3, [r7, #8]
 800c134:	6819      	ldr	r1, [r3, #0]
 800c136:	697b      	ldr	r3, [r7, #20]
 800c138:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800c13c:	687a      	ldr	r2, [r7, #4]
 800c13e:	4413      	add	r3, r2
 800c140:	3303      	adds	r3, #3
 800c142:	9300      	str	r3, [sp, #0]
 800c144:	68f8      	ldr	r0, [r7, #12]
 800c146:	2208      	movs	r2, #8
 800c148:	2300      	movs	r3, #0
 800c14a:	f001 f84d 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 8;
 800c14e:	68bb      	ldr	r3, [r7, #8]
 800c150:	681b      	ldr	r3, [r3, #0]
 800c152:	f103 0208 	add.w	r2, r3, #8
 800c156:	68bb      	ldr	r3, [r7, #8]
 800c158:	601a      	str	r2, [r3, #0]
=======
 800c13e:	687b      	ldr	r3, [r7, #4]
 800c140:	68f8      	ldr	r0, [r7, #12]
 800c142:	68b9      	ldr	r1, [r7, #8]
 800c144:	461a      	mov	r2, r3
 800c146:	2300      	movs	r3, #0
 800c148:	f002 f854 	bl	800e1f4 <_decode_uavcan_protocol_NodeStatus>

    _decode_uavcan_protocol_SoftwareVersion(transfer, bit_ofs, &msg->software_version, false);
 800c14c:	687b      	ldr	r3, [r7, #4]
 800c14e:	3310      	adds	r3, #16
 800c150:	68f8      	ldr	r0, [r7, #12]
 800c152:	68b9      	ldr	r1, [r7, #8]
 800c154:	461a      	mov	r2, r3
 800c156:	2300      	movs	r3, #0
 800c158:	f000 f9b6 	bl	800c4c8 <_decode_uavcan_protocol_SoftwareVersion>

    _decode_uavcan_protocol_HardwareVersion(transfer, bit_ofs, &msg->hardware_version, false);
 800c15c:	687b      	ldr	r3, [r7, #4]
 800c15e:	3320      	adds	r3, #32
 800c160:	68f8      	ldr	r0, [r7, #12]
 800c162:	68b9      	ldr	r1, [r7, #8]
 800c164:	461a      	mov	r2, r3
 800c166:	2300      	movs	r3, #0
 800c168:	f000 f8c8 	bl	800c2fc <_decode_uavcan_protocol_HardwareVersion>

    if (!tao) {
 800c16c:	78fb      	ldrb	r3, [r7, #3]
 800c16e:	f083 0301 	eor.w	r3, r3, #1
 800c172:	b2db      	uxtb	r3, r3
 800c174:	2b00      	cmp	r3, #0
 800c176:	d011      	beq.n	800c19c <_decode_uavcan_protocol_GetNodeInfo_res+0x6c>
        canardDecodeScalar(transfer, *bit_ofs, 7, false, &msg->name_len);
 800c178:	68bb      	ldr	r3, [r7, #8]
 800c17a:	681a      	ldr	r2, [r3, #0]
 800c17c:	687b      	ldr	r3, [r7, #4]
 800c17e:	f503 7399 	add.w	r3, r3, #306	; 0x132
 800c182:	9300      	str	r3, [sp, #0]
 800c184:	68f8      	ldr	r0, [r7, #12]
 800c186:	4611      	mov	r1, r2
 800c188:	2207      	movs	r2, #7
 800c18a:	2300      	movs	r3, #0
 800c18c:	f001 f870 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 7;
 800c190:	68bb      	ldr	r3, [r7, #8]
 800c192:	681b      	ldr	r3, [r3, #0]
 800c194:	1dda      	adds	r2, r3, #7
 800c196:	68bb      	ldr	r3, [r7, #8]
 800c198:	601a      	str	r2, [r3, #0]
 800c19a:	e00b      	b.n	800c1b4 <_decode_uavcan_protocol_GetNodeInfo_res+0x84>
    } else {
        msg->name_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800c19c:	68fb      	ldr	r3, [r7, #12]
 800c19e:	8a9b      	ldrh	r3, [r3, #20]
 800c1a0:	00db      	lsls	r3, r3, #3
 800c1a2:	461a      	mov	r2, r3
 800c1a4:	68bb      	ldr	r3, [r7, #8]
 800c1a6:	681b      	ldr	r3, [r3, #0]
 800c1a8:	1ad3      	subs	r3, r2, r3
 800c1aa:	08db      	lsrs	r3, r3, #3
 800c1ac:	b2da      	uxtb	r2, r3
 800c1ae:	687b      	ldr	r3, [r7, #4]
 800c1b0:	f883 2132 	strb.w	r2, [r3, #306]	; 0x132
    }

    for (size_t i=0; i < msg->name_len; i++) {
 800c1b4:	2300      	movs	r3, #0
 800c1b6:	617b      	str	r3, [r7, #20]
 800c1b8:	e016      	b.n	800c1e8 <_decode_uavcan_protocol_GetNodeInfo_res+0xb8>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->name[i]);
 800c1ba:	68bb      	ldr	r3, [r7, #8]
 800c1bc:	6819      	ldr	r1, [r3, #0]
 800c1be:	697b      	ldr	r3, [r7, #20]
 800c1c0:	f503 7398 	add.w	r3, r3, #304	; 0x130
 800c1c4:	687a      	ldr	r2, [r7, #4]
 800c1c6:	4413      	add	r3, r2
 800c1c8:	3303      	adds	r3, #3
 800c1ca:	9300      	str	r3, [sp, #0]
 800c1cc:	68f8      	ldr	r0, [r7, #12]
 800c1ce:	2208      	movs	r2, #8
 800c1d0:	2300      	movs	r3, #0
 800c1d2:	f001 f84d 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 8;
 800c1d6:	68bb      	ldr	r3, [r7, #8]
 800c1d8:	681b      	ldr	r3, [r3, #0]
 800c1da:	f103 0208 	add.w	r2, r3, #8
 800c1de:	68bb      	ldr	r3, [r7, #8]
 800c1e0:	601a      	str	r2, [r3, #0]
>>>>>>> 752c83b... update binaries
        *bit_ofs += 7;
    } else {
        msg->name_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->name_len; i++) {
<<<<<<< HEAD
 800c15a:	697b      	ldr	r3, [r7, #20]
 800c15c:	3301      	adds	r3, #1
 800c15e:	617b      	str	r3, [r7, #20]
 800c160:	687b      	ldr	r3, [r7, #4]
 800c162:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800c166:	461a      	mov	r2, r3
 800c168:	697b      	ldr	r3, [r7, #20]
 800c16a:	429a      	cmp	r2, r3
 800c16c:	d8e1      	bhi.n	800c132 <_decode_uavcan_protocol_GetNodeInfo_res+0x8a>
=======
 800c1e2:	697b      	ldr	r3, [r7, #20]
 800c1e4:	3301      	adds	r3, #1
 800c1e6:	617b      	str	r3, [r7, #20]
 800c1e8:	687b      	ldr	r3, [r7, #4]
 800c1ea:	f893 3132 	ldrb.w	r3, [r3, #306]	; 0x132
 800c1ee:	461a      	mov	r2, r3
 800c1f0:	697b      	ldr	r3, [r7, #20]
 800c1f2:	429a      	cmp	r2, r3
 800c1f4:	d8e1      	bhi.n	800c1ba <_decode_uavcan_protocol_GetNodeInfo_res+0x8a>
>>>>>>> 752c83b... update binaries
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->name[i]);
        *bit_ofs += 8;
    }

}
<<<<<<< HEAD
 800c16e:	3718      	adds	r7, #24
 800c170:	46bd      	mov	sp, r7
 800c172:	bd80      	pop	{r7, pc}

0800c174 <_encode_uavcan_protocol_HardwareVersion>:
=======
 800c1f6:	3718      	adds	r7, #24
 800c1f8:	46bd      	mov	sp, r7
 800c1fa:	bd80      	pop	{r7, pc}

0800c1fc <_encode_uavcan_protocol_HardwareVersion>:
>>>>>>> 752c83b... update binaries
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_HardwareVersion(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_HardwareVersion(uint8_t* buffer, struct uavcan_protocol_HardwareVersion_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
<<<<<<< HEAD
 800c174:	b580      	push	{r7, lr}
 800c176:	b086      	sub	sp, #24
 800c178:	af00      	add	r7, sp, #0
 800c17a:	60f8      	str	r0, [r7, #12]
 800c17c:	60b9      	str	r1, [r7, #8]
 800c17e:	607a      	str	r2, [r7, #4]
 800c180:	603b      	str	r3, [r7, #0]
=======
 800c1fc:	b580      	push	{r7, lr}
 800c1fe:	b086      	sub	sp, #24
 800c200:	af00      	add	r7, sp, #0
 800c202:	60f8      	str	r0, [r7, #12]
 800c204:	60b9      	str	r1, [r7, #8]
 800c206:	607a      	str	r2, [r7, #4]
 800c208:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
<<<<<<< HEAD
 800c182:	68f8      	ldr	r0, [r7, #12]
 800c184:	2100      	movs	r1, #0
 800c186:	2208      	movs	r2, #8
 800c188:	f002 fa1e 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800c18c:	68bb      	ldr	r3, [r7, #8]
 800c18e:	68f8      	ldr	r0, [r7, #12]
 800c190:	2100      	movs	r1, #0
 800c192:	2208      	movs	r2, #8
 800c194:	f001 f9a0 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c198:	687b      	ldr	r3, [r7, #4]
 800c19a:	68f8      	ldr	r0, [r7, #12]
 800c19c:	2108      	movs	r1, #8
 800c19e:	683a      	ldr	r2, [r7, #0]
 800c1a0:	4798      	blx	r3
    memset(buffer,0,8);
 800c1a2:	68f8      	ldr	r0, [r7, #12]
 800c1a4:	2100      	movs	r1, #0
 800c1a6:	2208      	movs	r2, #8
 800c1a8:	f002 fa0e 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800c1ac:	68bb      	ldr	r3, [r7, #8]
 800c1ae:	3301      	adds	r3, #1
 800c1b0:	68f8      	ldr	r0, [r7, #12]
 800c1b2:	2100      	movs	r1, #0
 800c1b4:	2208      	movs	r2, #8
 800c1b6:	f001 f98f 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c1ba:	687b      	ldr	r3, [r7, #4]
 800c1bc:	68f8      	ldr	r0, [r7, #12]
 800c1be:	2108      	movs	r1, #8
 800c1c0:	683a      	ldr	r2, [r7, #0]
 800c1c2:	4798      	blx	r3
    for (size_t i=0; i < 16; i++) {
 800c1c4:	2300      	movs	r3, #0
 800c1c6:	617b      	str	r3, [r7, #20]
 800c1c8:	e015      	b.n	800c1f6 <_encode_uavcan_protocol_HardwareVersion+0x82>
            memset(buffer,0,8);
 800c1ca:	68f8      	ldr	r0, [r7, #12]
 800c1cc:	2100      	movs	r1, #0
 800c1ce:	2208      	movs	r2, #8
 800c1d0:	f002 f9fa 	bl	800e5c8 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800c1d4:	68ba      	ldr	r2, [r7, #8]
 800c1d6:	697b      	ldr	r3, [r7, #20]
 800c1d8:	4413      	add	r3, r2
 800c1da:	3302      	adds	r3, #2
 800c1dc:	68f8      	ldr	r0, [r7, #12]
 800c1de:	2100      	movs	r1, #0
 800c1e0:	2208      	movs	r2, #8
 800c1e2:	f001 f979 	bl	800d4d8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c1e6:	687b      	ldr	r3, [r7, #4]
 800c1e8:	68f8      	ldr	r0, [r7, #12]
 800c1ea:	2108      	movs	r1, #8
 800c1ec:	683a      	ldr	r2, [r7, #0]
 800c1ee:	4798      	blx	r3
=======
 800c20a:	68f8      	ldr	r0, [r7, #12]
 800c20c:	2100      	movs	r1, #0
 800c20e:	2208      	movs	r2, #8
 800c210:	f002 fa1e 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800c214:	68bb      	ldr	r3, [r7, #8]
 800c216:	68f8      	ldr	r0, [r7, #12]
 800c218:	2100      	movs	r1, #0
 800c21a:	2208      	movs	r2, #8
 800c21c:	f001 f9a0 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c220:	687b      	ldr	r3, [r7, #4]
 800c222:	68f8      	ldr	r0, [r7, #12]
 800c224:	2108      	movs	r1, #8
 800c226:	683a      	ldr	r2, [r7, #0]
 800c228:	4798      	blx	r3
    memset(buffer,0,8);
 800c22a:	68f8      	ldr	r0, [r7, #12]
 800c22c:	2100      	movs	r1, #0
 800c22e:	2208      	movs	r2, #8
 800c230:	f002 fa0e 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800c234:	68bb      	ldr	r3, [r7, #8]
 800c236:	3301      	adds	r3, #1
 800c238:	68f8      	ldr	r0, [r7, #12]
 800c23a:	2100      	movs	r1, #0
 800c23c:	2208      	movs	r2, #8
 800c23e:	f001 f98f 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c242:	687b      	ldr	r3, [r7, #4]
 800c244:	68f8      	ldr	r0, [r7, #12]
 800c246:	2108      	movs	r1, #8
 800c248:	683a      	ldr	r2, [r7, #0]
 800c24a:	4798      	blx	r3
    for (size_t i=0; i < 16; i++) {
 800c24c:	2300      	movs	r3, #0
 800c24e:	617b      	str	r3, [r7, #20]
 800c250:	e015      	b.n	800c27e <_encode_uavcan_protocol_HardwareVersion+0x82>
            memset(buffer,0,8);
 800c252:	68f8      	ldr	r0, [r7, #12]
 800c254:	2100      	movs	r1, #0
 800c256:	2208      	movs	r2, #8
 800c258:	f002 f9fa 	bl	800e650 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800c25c:	68ba      	ldr	r2, [r7, #8]
 800c25e:	697b      	ldr	r3, [r7, #20]
 800c260:	4413      	add	r3, r2
 800c262:	3302      	adds	r3, #2
 800c264:	68f8      	ldr	r0, [r7, #12]
 800c266:	2100      	movs	r1, #0
 800c268:	2208      	movs	r2, #8
 800c26a:	f001 f979 	bl	800d560 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c26e:	687b      	ldr	r3, [r7, #4]
 800c270:	68f8      	ldr	r0, [r7, #12]
 800c272:	2108      	movs	r1, #8
 800c274:	683a      	ldr	r2, [r7, #0]
 800c276:	4798      	blx	r3
>>>>>>> 752c83b... update binaries
    canardEncodeScalar(buffer, 0, 8, &msg->major);
    chunk_cb(buffer, 8, ctx);
    memset(buffer,0,8);
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
    chunk_cb(buffer, 8, ctx);
    for (size_t i=0; i < 16; i++) {
<<<<<<< HEAD
 800c1f0:	697b      	ldr	r3, [r7, #20]
 800c1f2:	3301      	adds	r3, #1
 800c1f4:	617b      	str	r3, [r7, #20]
 800c1f6:	697b      	ldr	r3, [r7, #20]
 800c1f8:	2b0f      	cmp	r3, #15
 800c1fa:	d9e6      	bls.n	800c1ca <_encode_uavcan_protocol_HardwareVersion+0x56>
=======
 800c278:	697b      	ldr	r3, [r7, #20]
 800c27a:	3301      	adds	r3, #1
 800c27c:	617b      	str	r3, [r7, #20]
 800c27e:	697b      	ldr	r3, [r7, #20]
 800c280:	2b0f      	cmp	r3, #15
 800c282:	d9e6      	bls.n	800c252 <_encode_uavcan_protocol_HardwareVersion+0x56>
>>>>>>> 752c83b... update binaries
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
    if (!tao) {
<<<<<<< HEAD
 800c1fc:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c200:	f083 0301 	eor.w	r3, r3, #1
 800c204:	b2db      	uxtb	r3, r3
 800c206:	2b00      	cmp	r3, #0
 800c208:	d010      	beq.n	800c22c <_encode_uavcan_protocol_HardwareVersion+0xb8>
        memset(buffer,0,8);
 800c20a:	68f8      	ldr	r0, [r7, #12]
 800c20c:	2100      	movs	r1, #0
 800c20e:	2208      	movs	r2, #8
 800c210:	f002 f9da 	bl	800e5c8 <memset>
        canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity_len);
 800c214:	68bb      	ldr	r3, [r7, #8]
 800c216:	3312      	adds	r3, #18
 800c218:	68f8      	ldr	r0, [r7, #12]
 800c21a:	2100      	movs	r1, #0
 800c21c:	2208      	movs	r2, #8
 800c21e:	f001 f95b 	bl	800d4d8 <canardEncodeScalar>
        chunk_cb(buffer, 8, ctx);
 800c222:	687b      	ldr	r3, [r7, #4]
 800c224:	68f8      	ldr	r0, [r7, #12]
 800c226:	2108      	movs	r1, #8
 800c228:	683a      	ldr	r2, [r7, #0]
 800c22a:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c22c:	2300      	movs	r3, #0
 800c22e:	613b      	str	r3, [r7, #16]
 800c230:	e016      	b.n	800c260 <_encode_uavcan_protocol_HardwareVersion+0xec>
            memset(buffer,0,8);
 800c232:	68f8      	ldr	r0, [r7, #12]
 800c234:	2100      	movs	r1, #0
 800c236:	2208      	movs	r2, #8
 800c238:	f002 f9c6 	bl	800e5c8 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity[i]);
 800c23c:	693b      	ldr	r3, [r7, #16]
 800c23e:	3310      	adds	r3, #16
 800c240:	68ba      	ldr	r2, [r7, #8]
 800c242:	4413      	add	r3, r2
 800c244:	3303      	adds	r3, #3
 800c246:	68f8      	ldr	r0, [r7, #12]
 800c248:	2100      	movs	r1, #0
 800c24a:	2208      	movs	r2, #8
 800c24c:	f001 f944 	bl	800d4d8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c250:	687b      	ldr	r3, [r7, #4]
 800c252:	68f8      	ldr	r0, [r7, #12]
 800c254:	2108      	movs	r1, #8
 800c256:	683a      	ldr	r2, [r7, #0]
 800c258:	4798      	blx	r3
=======
 800c284:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c288:	f083 0301 	eor.w	r3, r3, #1
 800c28c:	b2db      	uxtb	r3, r3
 800c28e:	2b00      	cmp	r3, #0
 800c290:	d010      	beq.n	800c2b4 <_encode_uavcan_protocol_HardwareVersion+0xb8>
        memset(buffer,0,8);
 800c292:	68f8      	ldr	r0, [r7, #12]
 800c294:	2100      	movs	r1, #0
 800c296:	2208      	movs	r2, #8
 800c298:	f002 f9da 	bl	800e650 <memset>
        canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity_len);
 800c29c:	68bb      	ldr	r3, [r7, #8]
 800c29e:	3312      	adds	r3, #18
 800c2a0:	68f8      	ldr	r0, [r7, #12]
 800c2a2:	2100      	movs	r1, #0
 800c2a4:	2208      	movs	r2, #8
 800c2a6:	f001 f95b 	bl	800d560 <canardEncodeScalar>
        chunk_cb(buffer, 8, ctx);
 800c2aa:	687b      	ldr	r3, [r7, #4]
 800c2ac:	68f8      	ldr	r0, [r7, #12]
 800c2ae:	2108      	movs	r1, #8
 800c2b0:	683a      	ldr	r2, [r7, #0]
 800c2b2:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c2b4:	2300      	movs	r3, #0
 800c2b6:	613b      	str	r3, [r7, #16]
 800c2b8:	e016      	b.n	800c2e8 <_encode_uavcan_protocol_HardwareVersion+0xec>
            memset(buffer,0,8);
 800c2ba:	68f8      	ldr	r0, [r7, #12]
 800c2bc:	2100      	movs	r1, #0
 800c2be:	2208      	movs	r2, #8
 800c2c0:	f002 f9c6 	bl	800e650 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity[i]);
 800c2c4:	693b      	ldr	r3, [r7, #16]
 800c2c6:	3310      	adds	r3, #16
 800c2c8:	68ba      	ldr	r2, [r7, #8]
 800c2ca:	4413      	add	r3, r2
 800c2cc:	3303      	adds	r3, #3
 800c2ce:	68f8      	ldr	r0, [r7, #12]
 800c2d0:	2100      	movs	r1, #0
 800c2d2:	2208      	movs	r2, #8
 800c2d4:	f001 f944 	bl	800d560 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800c2d8:	687b      	ldr	r3, [r7, #4]
 800c2da:	68f8      	ldr	r0, [r7, #12]
 800c2dc:	2108      	movs	r1, #8
 800c2de:	683a      	ldr	r2, [r7, #0]
 800c2e0:	4798      	blx	r3
>>>>>>> 752c83b... update binaries
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity_len);
        chunk_cb(buffer, 8, ctx);
    }
    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
<<<<<<< HEAD
 800c25a:	693b      	ldr	r3, [r7, #16]
 800c25c:	3301      	adds	r3, #1
 800c25e:	613b      	str	r3, [r7, #16]
 800c260:	68bb      	ldr	r3, [r7, #8]
 800c262:	7c9b      	ldrb	r3, [r3, #18]
 800c264:	461a      	mov	r2, r3
 800c266:	693b      	ldr	r3, [r7, #16]
 800c268:	429a      	cmp	r2, r3
 800c26a:	d8e2      	bhi.n	800c232 <_encode_uavcan_protocol_HardwareVersion+0xbe>
=======
 800c2e2:	693b      	ldr	r3, [r7, #16]
 800c2e4:	3301      	adds	r3, #1
 800c2e6:	613b      	str	r3, [r7, #16]
 800c2e8:	68bb      	ldr	r3, [r7, #8]
 800c2ea:	7c9b      	ldrb	r3, [r3, #18]
 800c2ec:	461a      	mov	r2, r3
 800c2ee:	693b      	ldr	r3, [r7, #16]
 800c2f0:	429a      	cmp	r2, r3
 800c2f2:	d8e2      	bhi.n	800c2ba <_encode_uavcan_protocol_HardwareVersion+0xbe>
>>>>>>> 752c83b... update binaries
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->certificate_of_authenticity[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
<<<<<<< HEAD
 800c26c:	3718      	adds	r7, #24
 800c26e:	46bd      	mov	sp, r7
 800c270:	bd80      	pop	{r7, pc}
 800c272:	bf00      	nop

0800c274 <_decode_uavcan_protocol_HardwareVersion>:

void _decode_uavcan_protocol_HardwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_HardwareVersion_s* msg, bool tao) {
 800c274:	b580      	push	{r7, lr}
 800c276:	b088      	sub	sp, #32
 800c278:	af02      	add	r7, sp, #8
 800c27a:	60f8      	str	r0, [r7, #12]
 800c27c:	60b9      	str	r1, [r7, #8]
 800c27e:	607a      	str	r2, [r7, #4]
 800c280:	70fb      	strb	r3, [r7, #3]
=======
 800c2f4:	3718      	adds	r7, #24
 800c2f6:	46bd      	mov	sp, r7
 800c2f8:	bd80      	pop	{r7, pc}
 800c2fa:	bf00      	nop

0800c2fc <_decode_uavcan_protocol_HardwareVersion>:

void _decode_uavcan_protocol_HardwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_HardwareVersion_s* msg, bool tao) {
 800c2fc:	b580      	push	{r7, lr}
 800c2fe:	b088      	sub	sp, #32
 800c300:	af02      	add	r7, sp, #8
 800c302:	60f8      	str	r0, [r7, #12]
 800c304:	60b9      	str	r1, [r7, #8]
 800c306:	607a      	str	r2, [r7, #4]
 800c308:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->major);
<<<<<<< HEAD
 800c282:	68bb      	ldr	r3, [r7, #8]
 800c284:	681a      	ldr	r2, [r3, #0]
 800c286:	687b      	ldr	r3, [r7, #4]
 800c288:	9300      	str	r3, [sp, #0]
 800c28a:	68f8      	ldr	r0, [r7, #12]
 800c28c:	4611      	mov	r1, r2
 800c28e:	2208      	movs	r2, #8
 800c290:	2300      	movs	r3, #0
 800c292:	f000 ffa9 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 8;
 800c296:	68bb      	ldr	r3, [r7, #8]
 800c298:	681b      	ldr	r3, [r3, #0]
 800c29a:	f103 0208 	add.w	r2, r3, #8
 800c29e:	68bb      	ldr	r3, [r7, #8]
 800c2a0:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800c2a2:	68bb      	ldr	r3, [r7, #8]
 800c2a4:	681a      	ldr	r2, [r3, #0]
 800c2a6:	687b      	ldr	r3, [r7, #4]
 800c2a8:	3301      	adds	r3, #1
 800c2aa:	9300      	str	r3, [sp, #0]
 800c2ac:	68f8      	ldr	r0, [r7, #12]
 800c2ae:	4611      	mov	r1, r2
 800c2b0:	2208      	movs	r2, #8
 800c2b2:	2300      	movs	r3, #0
 800c2b4:	f000 ff98 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 8;
 800c2b8:	68bb      	ldr	r3, [r7, #8]
 800c2ba:	681b      	ldr	r3, [r3, #0]
 800c2bc:	f103 0208 	add.w	r2, r3, #8
 800c2c0:	68bb      	ldr	r3, [r7, #8]
 800c2c2:	601a      	str	r2, [r3, #0]

    for (size_t i=0; i < 16; i++) {
 800c2c4:	2300      	movs	r3, #0
 800c2c6:	617b      	str	r3, [r7, #20]
 800c2c8:	e014      	b.n	800c2f4 <_decode_uavcan_protocol_HardwareVersion+0x80>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800c2ca:	68bb      	ldr	r3, [r7, #8]
 800c2cc:	6819      	ldr	r1, [r3, #0]
 800c2ce:	687a      	ldr	r2, [r7, #4]
 800c2d0:	697b      	ldr	r3, [r7, #20]
 800c2d2:	4413      	add	r3, r2
 800c2d4:	3302      	adds	r3, #2
 800c2d6:	9300      	str	r3, [sp, #0]
 800c2d8:	68f8      	ldr	r0, [r7, #12]
 800c2da:	2208      	movs	r2, #8
 800c2dc:	2300      	movs	r3, #0
 800c2de:	f000 ff83 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 8;
 800c2e2:	68bb      	ldr	r3, [r7, #8]
 800c2e4:	681b      	ldr	r3, [r3, #0]
 800c2e6:	f103 0208 	add.w	r2, r3, #8
 800c2ea:	68bb      	ldr	r3, [r7, #8]
 800c2ec:	601a      	str	r2, [r3, #0]
=======
 800c30a:	68bb      	ldr	r3, [r7, #8]
 800c30c:	681a      	ldr	r2, [r3, #0]
 800c30e:	687b      	ldr	r3, [r7, #4]
 800c310:	9300      	str	r3, [sp, #0]
 800c312:	68f8      	ldr	r0, [r7, #12]
 800c314:	4611      	mov	r1, r2
 800c316:	2208      	movs	r2, #8
 800c318:	2300      	movs	r3, #0
 800c31a:	f000 ffa9 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 8;
 800c31e:	68bb      	ldr	r3, [r7, #8]
 800c320:	681b      	ldr	r3, [r3, #0]
 800c322:	f103 0208 	add.w	r2, r3, #8
 800c326:	68bb      	ldr	r3, [r7, #8]
 800c328:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800c32a:	68bb      	ldr	r3, [r7, #8]
 800c32c:	681a      	ldr	r2, [r3, #0]
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	3301      	adds	r3, #1
 800c332:	9300      	str	r3, [sp, #0]
 800c334:	68f8      	ldr	r0, [r7, #12]
 800c336:	4611      	mov	r1, r2
 800c338:	2208      	movs	r2, #8
 800c33a:	2300      	movs	r3, #0
 800c33c:	f000 ff98 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 8;
 800c340:	68bb      	ldr	r3, [r7, #8]
 800c342:	681b      	ldr	r3, [r3, #0]
 800c344:	f103 0208 	add.w	r2, r3, #8
 800c348:	68bb      	ldr	r3, [r7, #8]
 800c34a:	601a      	str	r2, [r3, #0]

    for (size_t i=0; i < 16; i++) {
 800c34c:	2300      	movs	r3, #0
 800c34e:	617b      	str	r3, [r7, #20]
 800c350:	e014      	b.n	800c37c <_decode_uavcan_protocol_HardwareVersion+0x80>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
 800c352:	68bb      	ldr	r3, [r7, #8]
 800c354:	6819      	ldr	r1, [r3, #0]
 800c356:	687a      	ldr	r2, [r7, #4]
 800c358:	697b      	ldr	r3, [r7, #20]
 800c35a:	4413      	add	r3, r2
 800c35c:	3302      	adds	r3, #2
 800c35e:	9300      	str	r3, [sp, #0]
 800c360:	68f8      	ldr	r0, [r7, #12]
 800c362:	2208      	movs	r2, #8
 800c364:	2300      	movs	r3, #0
 800c366:	f000 ff83 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 8;
 800c36a:	68bb      	ldr	r3, [r7, #8]
 800c36c:	681b      	ldr	r3, [r3, #0]
 800c36e:	f103 0208 	add.w	r2, r3, #8
 800c372:	68bb      	ldr	r3, [r7, #8]
 800c374:	601a      	str	r2, [r3, #0]
>>>>>>> 752c83b... update binaries
    *bit_ofs += 8;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
    *bit_ofs += 8;

    for (size_t i=0; i < 16; i++) {
<<<<<<< HEAD
 800c2ee:	697b      	ldr	r3, [r7, #20]
 800c2f0:	3301      	adds	r3, #1
 800c2f2:	617b      	str	r3, [r7, #20]
 800c2f4:	697b      	ldr	r3, [r7, #20]
 800c2f6:	2b0f      	cmp	r3, #15
 800c2f8:	d9e7      	bls.n	800c2ca <_decode_uavcan_protocol_HardwareVersion+0x56>
=======
 800c376:	697b      	ldr	r3, [r7, #20]
 800c378:	3301      	adds	r3, #1
 800c37a:	617b      	str	r3, [r7, #20]
 800c37c:	697b      	ldr	r3, [r7, #20]
 800c37e:	2b0f      	cmp	r3, #15
 800c380:	d9e7      	bls.n	800c352 <_decode_uavcan_protocol_HardwareVersion+0x56>
>>>>>>> 752c83b... update binaries
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->unique_id[i]);
        *bit_ofs += 8;
    }

    if (!tao) {
<<<<<<< HEAD
 800c2fa:	78fb      	ldrb	r3, [r7, #3]
 800c2fc:	f083 0301 	eor.w	r3, r3, #1
 800c300:	b2db      	uxtb	r3, r3
 800c302:	2b00      	cmp	r3, #0
 800c304:	d011      	beq.n	800c32a <_decode_uavcan_protocol_HardwareVersion+0xb6>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity_len);
 800c306:	68bb      	ldr	r3, [r7, #8]
 800c308:	681a      	ldr	r2, [r3, #0]
 800c30a:	687b      	ldr	r3, [r7, #4]
 800c30c:	3312      	adds	r3, #18
 800c30e:	9300      	str	r3, [sp, #0]
 800c310:	68f8      	ldr	r0, [r7, #12]
 800c312:	4611      	mov	r1, r2
 800c314:	2208      	movs	r2, #8
 800c316:	2300      	movs	r3, #0
 800c318:	f000 ff66 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 8;
 800c31c:	68bb      	ldr	r3, [r7, #8]
 800c31e:	681b      	ldr	r3, [r3, #0]
 800c320:	f103 0208 	add.w	r2, r3, #8
 800c324:	68bb      	ldr	r3, [r7, #8]
 800c326:	601a      	str	r2, [r3, #0]
 800c328:	e00a      	b.n	800c340 <_decode_uavcan_protocol_HardwareVersion+0xcc>
    } else {
        msg->certificate_of_authenticity_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800c32a:	68fb      	ldr	r3, [r7, #12]
 800c32c:	8a9b      	ldrh	r3, [r3, #20]
 800c32e:	00db      	lsls	r3, r3, #3
 800c330:	461a      	mov	r2, r3
 800c332:	68bb      	ldr	r3, [r7, #8]
 800c334:	681b      	ldr	r3, [r3, #0]
 800c336:	1ad3      	subs	r3, r2, r3
 800c338:	08db      	lsrs	r3, r3, #3
 800c33a:	b2da      	uxtb	r2, r3
 800c33c:	687b      	ldr	r3, [r7, #4]
 800c33e:	749a      	strb	r2, [r3, #18]
    }

    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c340:	2300      	movs	r3, #0
 800c342:	613b      	str	r3, [r7, #16]
 800c344:	e015      	b.n	800c372 <_decode_uavcan_protocol_HardwareVersion+0xfe>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity[i]);
 800c346:	68bb      	ldr	r3, [r7, #8]
 800c348:	6819      	ldr	r1, [r3, #0]
 800c34a:	693b      	ldr	r3, [r7, #16]
 800c34c:	3310      	adds	r3, #16
 800c34e:	687a      	ldr	r2, [r7, #4]
 800c350:	4413      	add	r3, r2
 800c352:	3303      	adds	r3, #3
 800c354:	9300      	str	r3, [sp, #0]
 800c356:	68f8      	ldr	r0, [r7, #12]
 800c358:	2208      	movs	r2, #8
 800c35a:	2300      	movs	r3, #0
 800c35c:	f000 ff44 	bl	800d1e8 <canardDecodeScalar>
        *bit_ofs += 8;
 800c360:	68bb      	ldr	r3, [r7, #8]
 800c362:	681b      	ldr	r3, [r3, #0]
 800c364:	f103 0208 	add.w	r2, r3, #8
 800c368:	68bb      	ldr	r3, [r7, #8]
 800c36a:	601a      	str	r2, [r3, #0]
=======
 800c382:	78fb      	ldrb	r3, [r7, #3]
 800c384:	f083 0301 	eor.w	r3, r3, #1
 800c388:	b2db      	uxtb	r3, r3
 800c38a:	2b00      	cmp	r3, #0
 800c38c:	d011      	beq.n	800c3b2 <_decode_uavcan_protocol_HardwareVersion+0xb6>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity_len);
 800c38e:	68bb      	ldr	r3, [r7, #8]
 800c390:	681a      	ldr	r2, [r3, #0]
 800c392:	687b      	ldr	r3, [r7, #4]
 800c394:	3312      	adds	r3, #18
 800c396:	9300      	str	r3, [sp, #0]
 800c398:	68f8      	ldr	r0, [r7, #12]
 800c39a:	4611      	mov	r1, r2
 800c39c:	2208      	movs	r2, #8
 800c39e:	2300      	movs	r3, #0
 800c3a0:	f000 ff66 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 8;
 800c3a4:	68bb      	ldr	r3, [r7, #8]
 800c3a6:	681b      	ldr	r3, [r3, #0]
 800c3a8:	f103 0208 	add.w	r2, r3, #8
 800c3ac:	68bb      	ldr	r3, [r7, #8]
 800c3ae:	601a      	str	r2, [r3, #0]
 800c3b0:	e00a      	b.n	800c3c8 <_decode_uavcan_protocol_HardwareVersion+0xcc>
    } else {
        msg->certificate_of_authenticity_len = ((transfer->payload_len*8)-*bit_ofs)/8;
 800c3b2:	68fb      	ldr	r3, [r7, #12]
 800c3b4:	8a9b      	ldrh	r3, [r3, #20]
 800c3b6:	00db      	lsls	r3, r3, #3
 800c3b8:	461a      	mov	r2, r3
 800c3ba:	68bb      	ldr	r3, [r7, #8]
 800c3bc:	681b      	ldr	r3, [r3, #0]
 800c3be:	1ad3      	subs	r3, r2, r3
 800c3c0:	08db      	lsrs	r3, r3, #3
 800c3c2:	b2da      	uxtb	r2, r3
 800c3c4:	687b      	ldr	r3, [r7, #4]
 800c3c6:	749a      	strb	r2, [r3, #18]
    }

    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
 800c3c8:	2300      	movs	r3, #0
 800c3ca:	613b      	str	r3, [r7, #16]
 800c3cc:	e015      	b.n	800c3fa <_decode_uavcan_protocol_HardwareVersion+0xfe>
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity[i]);
 800c3ce:	68bb      	ldr	r3, [r7, #8]
 800c3d0:	6819      	ldr	r1, [r3, #0]
 800c3d2:	693b      	ldr	r3, [r7, #16]
 800c3d4:	3310      	adds	r3, #16
 800c3d6:	687a      	ldr	r2, [r7, #4]
 800c3d8:	4413      	add	r3, r2
 800c3da:	3303      	adds	r3, #3
 800c3dc:	9300      	str	r3, [sp, #0]
 800c3de:	68f8      	ldr	r0, [r7, #12]
 800c3e0:	2208      	movs	r2, #8
 800c3e2:	2300      	movs	r3, #0
 800c3e4:	f000 ff44 	bl	800d270 <canardDecodeScalar>
        *bit_ofs += 8;
 800c3e8:	68bb      	ldr	r3, [r7, #8]
 800c3ea:	681b      	ldr	r3, [r3, #0]
 800c3ec:	f103 0208 	add.w	r2, r3, #8
 800c3f0:	68bb      	ldr	r3, [r7, #8]
 800c3f2:	601a      	str	r2, [r3, #0]
>>>>>>> 752c83b... update binaries
        *bit_ofs += 8;
    } else {
        msg->certificate_of_authenticity_len = ((transfer->payload_len*8)-*bit_ofs)/8;
    }

    for (size_t i=0; i < msg->certificate_of_authenticity_len; i++) {
<<<<<<< HEAD
 800c36c:	693b      	ldr	r3, [r7, #16]
 800c36e:	3301      	adds	r3, #1
 800c370:	613b      	str	r3, [r7, #16]
 800c372:	687b      	ldr	r3, [r7, #4]
 800c374:	7c9b      	ldrb	r3, [r3, #18]
 800c376:	461a      	mov	r2, r3
 800c378:	693b      	ldr	r3, [r7, #16]
 800c37a:	429a      	cmp	r2, r3
 800c37c:	d8e3      	bhi.n	800c346 <_decode_uavcan_protocol_HardwareVersion+0xd2>
=======
 800c3f4:	693b      	ldr	r3, [r7, #16]
 800c3f6:	3301      	adds	r3, #1
 800c3f8:	613b      	str	r3, [r7, #16]
 800c3fa:	687b      	ldr	r3, [r7, #4]
 800c3fc:	7c9b      	ldrb	r3, [r3, #18]
 800c3fe:	461a      	mov	r2, r3
 800c400:	693b      	ldr	r3, [r7, #16]
 800c402:	429a      	cmp	r2, r3
 800c404:	d8e3      	bhi.n	800c3ce <_decode_uavcan_protocol_HardwareVersion+0xd2>
>>>>>>> 752c83b... update binaries
        canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->certificate_of_authenticity[i]);
        *bit_ofs += 8;
    }

}
<<<<<<< HEAD
 800c37e:	3718      	adds	r7, #24
 800c380:	46bd      	mov	sp, r7
 800c382:	bd80      	pop	{r7, pc}

0800c384 <_encode_uavcan_protocol_SoftwareVersion>:
=======
 800c406:	3718      	adds	r7, #24
 800c408:	46bd      	mov	sp, r7
 800c40a:	bd80      	pop	{r7, pc}

0800c40c <_encode_uavcan_protocol_SoftwareVersion>:
>>>>>>> 752c83b... update binaries
    uint32_t bit_ofs = 0;
    _decode_uavcan_protocol_SoftwareVersion(transfer, &bit_ofs, msg, true);
    return (bit_ofs+7)/8;
}

void _encode_uavcan_protocol_SoftwareVersion(uint8_t* buffer, struct uavcan_protocol_SoftwareVersion_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
<<<<<<< HEAD
 800c384:	b580      	push	{r7, lr}
 800c386:	b084      	sub	sp, #16
 800c388:	af00      	add	r7, sp, #0
 800c38a:	60f8      	str	r0, [r7, #12]
 800c38c:	60b9      	str	r1, [r7, #8]
 800c38e:	607a      	str	r2, [r7, #4]
 800c390:	603b      	str	r3, [r7, #0]
=======
 800c40c:	b580      	push	{r7, lr}
 800c40e:	b084      	sub	sp, #16
 800c410:	af00      	add	r7, sp, #0
 800c412:	60f8      	str	r0, [r7, #12]
 800c414:	60b9      	str	r1, [r7, #8]
 800c416:	607a      	str	r2, [r7, #4]
 800c418:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
<<<<<<< HEAD
 800c392:	68f8      	ldr	r0, [r7, #12]
 800c394:	2100      	movs	r1, #0
 800c396:	2208      	movs	r2, #8
 800c398:	f002 f916 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800c39c:	68bb      	ldr	r3, [r7, #8]
 800c39e:	68f8      	ldr	r0, [r7, #12]
 800c3a0:	2100      	movs	r1, #0
 800c3a2:	2208      	movs	r2, #8
 800c3a4:	f001 f898 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c3a8:	687b      	ldr	r3, [r7, #4]
 800c3aa:	68f8      	ldr	r0, [r7, #12]
 800c3ac:	2108      	movs	r1, #8
 800c3ae:	683a      	ldr	r2, [r7, #0]
 800c3b0:	4798      	blx	r3
    memset(buffer,0,8);
 800c3b2:	68f8      	ldr	r0, [r7, #12]
 800c3b4:	2100      	movs	r1, #0
 800c3b6:	2208      	movs	r2, #8
 800c3b8:	f002 f906 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800c3bc:	68bb      	ldr	r3, [r7, #8]
 800c3be:	3301      	adds	r3, #1
 800c3c0:	68f8      	ldr	r0, [r7, #12]
 800c3c2:	2100      	movs	r1, #0
 800c3c4:	2208      	movs	r2, #8
 800c3c6:	f001 f887 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	68f8      	ldr	r0, [r7, #12]
 800c3ce:	2108      	movs	r1, #8
 800c3d0:	683a      	ldr	r2, [r7, #0]
 800c3d2:	4798      	blx	r3
    memset(buffer,0,8);
 800c3d4:	68f8      	ldr	r0, [r7, #12]
 800c3d6:	2100      	movs	r1, #0
 800c3d8:	2208      	movs	r2, #8
 800c3da:	f002 f8f5 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->optional_field_flags);
 800c3de:	68bb      	ldr	r3, [r7, #8]
 800c3e0:	3302      	adds	r3, #2
 800c3e2:	68f8      	ldr	r0, [r7, #12]
 800c3e4:	2100      	movs	r1, #0
 800c3e6:	2208      	movs	r2, #8
 800c3e8:	f001 f876 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c3ec:	687b      	ldr	r3, [r7, #4]
 800c3ee:	68f8      	ldr	r0, [r7, #12]
 800c3f0:	2108      	movs	r1, #8
 800c3f2:	683a      	ldr	r2, [r7, #0]
 800c3f4:	4798      	blx	r3
    memset(buffer,0,8);
 800c3f6:	68f8      	ldr	r0, [r7, #12]
 800c3f8:	2100      	movs	r1, #0
 800c3fa:	2208      	movs	r2, #8
 800c3fc:	f002 f8e4 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->vcs_commit);
 800c400:	68bb      	ldr	r3, [r7, #8]
 800c402:	3304      	adds	r3, #4
 800c404:	68f8      	ldr	r0, [r7, #12]
 800c406:	2100      	movs	r1, #0
 800c408:	2220      	movs	r2, #32
 800c40a:	f001 f865 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800c40e:	687b      	ldr	r3, [r7, #4]
 800c410:	68f8      	ldr	r0, [r7, #12]
 800c412:	2120      	movs	r1, #32
 800c414:	683a      	ldr	r2, [r7, #0]
 800c416:	4798      	blx	r3
    memset(buffer,0,8);
 800c418:	68f8      	ldr	r0, [r7, #12]
 800c41a:	2100      	movs	r1, #0
 800c41c:	2208      	movs	r2, #8
 800c41e:	f002 f8d3 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 64, &msg->image_crc);
 800c422:	68bb      	ldr	r3, [r7, #8]
 800c424:	3308      	adds	r3, #8
 800c426:	68f8      	ldr	r0, [r7, #12]
 800c428:	2100      	movs	r1, #0
 800c42a:	2240      	movs	r2, #64	; 0x40
 800c42c:	f001 f854 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 64, ctx);
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	68f8      	ldr	r0, [r7, #12]
 800c434:	2140      	movs	r1, #64	; 0x40
 800c436:	683a      	ldr	r2, [r7, #0]
 800c438:	4798      	blx	r3
}
 800c43a:	3710      	adds	r7, #16
 800c43c:	46bd      	mov	sp, r7
 800c43e:	bd80      	pop	{r7, pc}

0800c440 <_decode_uavcan_protocol_SoftwareVersion>:

void _decode_uavcan_protocol_SoftwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_SoftwareVersion_s* msg, bool tao) {
 800c440:	b580      	push	{r7, lr}
 800c442:	b086      	sub	sp, #24
 800c444:	af02      	add	r7, sp, #8
 800c446:	60f8      	str	r0, [r7, #12]
 800c448:	60b9      	str	r1, [r7, #8]
 800c44a:	607a      	str	r2, [r7, #4]
 800c44c:	70fb      	strb	r3, [r7, #3]
=======
 800c41a:	68f8      	ldr	r0, [r7, #12]
 800c41c:	2100      	movs	r1, #0
 800c41e:	2208      	movs	r2, #8
 800c420:	f002 f916 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->major);
 800c424:	68bb      	ldr	r3, [r7, #8]
 800c426:	68f8      	ldr	r0, [r7, #12]
 800c428:	2100      	movs	r1, #0
 800c42a:	2208      	movs	r2, #8
 800c42c:	f001 f898 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	68f8      	ldr	r0, [r7, #12]
 800c434:	2108      	movs	r1, #8
 800c436:	683a      	ldr	r2, [r7, #0]
 800c438:	4798      	blx	r3
    memset(buffer,0,8);
 800c43a:	68f8      	ldr	r0, [r7, #12]
 800c43c:	2100      	movs	r1, #0
 800c43e:	2208      	movs	r2, #8
 800c440:	f002 f906 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->minor);
 800c444:	68bb      	ldr	r3, [r7, #8]
 800c446:	3301      	adds	r3, #1
 800c448:	68f8      	ldr	r0, [r7, #12]
 800c44a:	2100      	movs	r1, #0
 800c44c:	2208      	movs	r2, #8
 800c44e:	f001 f887 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c452:	687b      	ldr	r3, [r7, #4]
 800c454:	68f8      	ldr	r0, [r7, #12]
 800c456:	2108      	movs	r1, #8
 800c458:	683a      	ldr	r2, [r7, #0]
 800c45a:	4798      	blx	r3
    memset(buffer,0,8);
 800c45c:	68f8      	ldr	r0, [r7, #12]
 800c45e:	2100      	movs	r1, #0
 800c460:	2208      	movs	r2, #8
 800c462:	f002 f8f5 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 8, &msg->optional_field_flags);
 800c466:	68bb      	ldr	r3, [r7, #8]
 800c468:	3302      	adds	r3, #2
 800c46a:	68f8      	ldr	r0, [r7, #12]
 800c46c:	2100      	movs	r1, #0
 800c46e:	2208      	movs	r2, #8
 800c470:	f001 f876 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 8, ctx);
 800c474:	687b      	ldr	r3, [r7, #4]
 800c476:	68f8      	ldr	r0, [r7, #12]
 800c478:	2108      	movs	r1, #8
 800c47a:	683a      	ldr	r2, [r7, #0]
 800c47c:	4798      	blx	r3
    memset(buffer,0,8);
 800c47e:	68f8      	ldr	r0, [r7, #12]
 800c480:	2100      	movs	r1, #0
 800c482:	2208      	movs	r2, #8
 800c484:	f002 f8e4 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->vcs_commit);
 800c488:	68bb      	ldr	r3, [r7, #8]
 800c48a:	3304      	adds	r3, #4
 800c48c:	68f8      	ldr	r0, [r7, #12]
 800c48e:	2100      	movs	r1, #0
 800c490:	2220      	movs	r2, #32
 800c492:	f001 f865 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800c496:	687b      	ldr	r3, [r7, #4]
 800c498:	68f8      	ldr	r0, [r7, #12]
 800c49a:	2120      	movs	r1, #32
 800c49c:	683a      	ldr	r2, [r7, #0]
 800c49e:	4798      	blx	r3
    memset(buffer,0,8);
 800c4a0:	68f8      	ldr	r0, [r7, #12]
 800c4a2:	2100      	movs	r1, #0
 800c4a4:	2208      	movs	r2, #8
 800c4a6:	f002 f8d3 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 64, &msg->image_crc);
 800c4aa:	68bb      	ldr	r3, [r7, #8]
 800c4ac:	3308      	adds	r3, #8
 800c4ae:	68f8      	ldr	r0, [r7, #12]
 800c4b0:	2100      	movs	r1, #0
 800c4b2:	2240      	movs	r2, #64	; 0x40
 800c4b4:	f001 f854 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 64, ctx);
 800c4b8:	687b      	ldr	r3, [r7, #4]
 800c4ba:	68f8      	ldr	r0, [r7, #12]
 800c4bc:	2140      	movs	r1, #64	; 0x40
 800c4be:	683a      	ldr	r2, [r7, #0]
 800c4c0:	4798      	blx	r3
}
 800c4c2:	3710      	adds	r7, #16
 800c4c4:	46bd      	mov	sp, r7
 800c4c6:	bd80      	pop	{r7, pc}

0800c4c8 <_decode_uavcan_protocol_SoftwareVersion>:

void _decode_uavcan_protocol_SoftwareVersion(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_SoftwareVersion_s* msg, bool tao) {
 800c4c8:	b580      	push	{r7, lr}
 800c4ca:	b086      	sub	sp, #24
 800c4cc:	af02      	add	r7, sp, #8
 800c4ce:	60f8      	str	r0, [r7, #12]
 800c4d0:	60b9      	str	r1, [r7, #8]
 800c4d2:	607a      	str	r2, [r7, #4]
 800c4d4:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->major);
<<<<<<< HEAD
 800c44e:	68bb      	ldr	r3, [r7, #8]
 800c450:	681a      	ldr	r2, [r3, #0]
 800c452:	687b      	ldr	r3, [r7, #4]
 800c454:	9300      	str	r3, [sp, #0]
 800c456:	68f8      	ldr	r0, [r7, #12]
 800c458:	4611      	mov	r1, r2
 800c45a:	2208      	movs	r2, #8
 800c45c:	2300      	movs	r3, #0
 800c45e:	f000 fec3 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 8;
 800c462:	68bb      	ldr	r3, [r7, #8]
 800c464:	681b      	ldr	r3, [r3, #0]
 800c466:	f103 0208 	add.w	r2, r3, #8
 800c46a:	68bb      	ldr	r3, [r7, #8]
 800c46c:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800c46e:	68bb      	ldr	r3, [r7, #8]
 800c470:	681a      	ldr	r2, [r3, #0]
 800c472:	687b      	ldr	r3, [r7, #4]
 800c474:	3301      	adds	r3, #1
 800c476:	9300      	str	r3, [sp, #0]
 800c478:	68f8      	ldr	r0, [r7, #12]
 800c47a:	4611      	mov	r1, r2
 800c47c:	2208      	movs	r2, #8
 800c47e:	2300      	movs	r3, #0
 800c480:	f000 feb2 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 8;
 800c484:	68bb      	ldr	r3, [r7, #8]
 800c486:	681b      	ldr	r3, [r3, #0]
 800c488:	f103 0208 	add.w	r2, r3, #8
 800c48c:	68bb      	ldr	r3, [r7, #8]
 800c48e:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->optional_field_flags);
 800c490:	68bb      	ldr	r3, [r7, #8]
 800c492:	681a      	ldr	r2, [r3, #0]
 800c494:	687b      	ldr	r3, [r7, #4]
 800c496:	3302      	adds	r3, #2
 800c498:	9300      	str	r3, [sp, #0]
 800c49a:	68f8      	ldr	r0, [r7, #12]
 800c49c:	4611      	mov	r1, r2
 800c49e:	2208      	movs	r2, #8
 800c4a0:	2300      	movs	r3, #0
 800c4a2:	f000 fea1 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 8;
 800c4a6:	68bb      	ldr	r3, [r7, #8]
 800c4a8:	681b      	ldr	r3, [r3, #0]
 800c4aa:	f103 0208 	add.w	r2, r3, #8
 800c4ae:	68bb      	ldr	r3, [r7, #8]
 800c4b0:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 32, false, &msg->vcs_commit);
 800c4b2:	68bb      	ldr	r3, [r7, #8]
 800c4b4:	681a      	ldr	r2, [r3, #0]
 800c4b6:	687b      	ldr	r3, [r7, #4]
 800c4b8:	3304      	adds	r3, #4
 800c4ba:	9300      	str	r3, [sp, #0]
 800c4bc:	68f8      	ldr	r0, [r7, #12]
 800c4be:	4611      	mov	r1, r2
 800c4c0:	2220      	movs	r2, #32
 800c4c2:	2300      	movs	r3, #0
 800c4c4:	f000 fe90 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 32;
 800c4c8:	68bb      	ldr	r3, [r7, #8]
 800c4ca:	681b      	ldr	r3, [r3, #0]
 800c4cc:	f103 0220 	add.w	r2, r3, #32
 800c4d0:	68bb      	ldr	r3, [r7, #8]
 800c4d2:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 64, false, &msg->image_crc);
 800c4d4:	68bb      	ldr	r3, [r7, #8]
 800c4d6:	681a      	ldr	r2, [r3, #0]
 800c4d8:	687b      	ldr	r3, [r7, #4]
 800c4da:	3308      	adds	r3, #8
 800c4dc:	9300      	str	r3, [sp, #0]
 800c4de:	68f8      	ldr	r0, [r7, #12]
 800c4e0:	4611      	mov	r1, r2
 800c4e2:	2240      	movs	r2, #64	; 0x40
 800c4e4:	2300      	movs	r3, #0
 800c4e6:	f000 fe7f 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 64;
 800c4ea:	68bb      	ldr	r3, [r7, #8]
 800c4ec:	681b      	ldr	r3, [r3, #0]
 800c4ee:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800c4f2:	68bb      	ldr	r3, [r7, #8]
 800c4f4:	601a      	str	r2, [r3, #0]

}
 800c4f6:	3710      	adds	r7, #16
 800c4f8:	46bd      	mov	sp, r7
 800c4fa:	bd80      	pop	{r7, pc}

0800c4fc <encode_func.lto_priv.55>:
=======
 800c4d6:	68bb      	ldr	r3, [r7, #8]
 800c4d8:	681a      	ldr	r2, [r3, #0]
 800c4da:	687b      	ldr	r3, [r7, #4]
 800c4dc:	9300      	str	r3, [sp, #0]
 800c4de:	68f8      	ldr	r0, [r7, #12]
 800c4e0:	4611      	mov	r1, r2
 800c4e2:	2208      	movs	r2, #8
 800c4e4:	2300      	movs	r3, #0
 800c4e6:	f000 fec3 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 8;
 800c4ea:	68bb      	ldr	r3, [r7, #8]
 800c4ec:	681b      	ldr	r3, [r3, #0]
 800c4ee:	f103 0208 	add.w	r2, r3, #8
 800c4f2:	68bb      	ldr	r3, [r7, #8]
 800c4f4:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->minor);
 800c4f6:	68bb      	ldr	r3, [r7, #8]
 800c4f8:	681a      	ldr	r2, [r3, #0]
 800c4fa:	687b      	ldr	r3, [r7, #4]
 800c4fc:	3301      	adds	r3, #1
 800c4fe:	9300      	str	r3, [sp, #0]
 800c500:	68f8      	ldr	r0, [r7, #12]
 800c502:	4611      	mov	r1, r2
 800c504:	2208      	movs	r2, #8
 800c506:	2300      	movs	r3, #0
 800c508:	f000 feb2 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 8;
 800c50c:	68bb      	ldr	r3, [r7, #8]
 800c50e:	681b      	ldr	r3, [r3, #0]
 800c510:	f103 0208 	add.w	r2, r3, #8
 800c514:	68bb      	ldr	r3, [r7, #8]
 800c516:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 8, false, &msg->optional_field_flags);
 800c518:	68bb      	ldr	r3, [r7, #8]
 800c51a:	681a      	ldr	r2, [r3, #0]
 800c51c:	687b      	ldr	r3, [r7, #4]
 800c51e:	3302      	adds	r3, #2
 800c520:	9300      	str	r3, [sp, #0]
 800c522:	68f8      	ldr	r0, [r7, #12]
 800c524:	4611      	mov	r1, r2
 800c526:	2208      	movs	r2, #8
 800c528:	2300      	movs	r3, #0
 800c52a:	f000 fea1 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 8;
 800c52e:	68bb      	ldr	r3, [r7, #8]
 800c530:	681b      	ldr	r3, [r3, #0]
 800c532:	f103 0208 	add.w	r2, r3, #8
 800c536:	68bb      	ldr	r3, [r7, #8]
 800c538:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 32, false, &msg->vcs_commit);
 800c53a:	68bb      	ldr	r3, [r7, #8]
 800c53c:	681a      	ldr	r2, [r3, #0]
 800c53e:	687b      	ldr	r3, [r7, #4]
 800c540:	3304      	adds	r3, #4
 800c542:	9300      	str	r3, [sp, #0]
 800c544:	68f8      	ldr	r0, [r7, #12]
 800c546:	4611      	mov	r1, r2
 800c548:	2220      	movs	r2, #32
 800c54a:	2300      	movs	r3, #0
 800c54c:	f000 fe90 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 32;
 800c550:	68bb      	ldr	r3, [r7, #8]
 800c552:	681b      	ldr	r3, [r3, #0]
 800c554:	f103 0220 	add.w	r2, r3, #32
 800c558:	68bb      	ldr	r3, [r7, #8]
 800c55a:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 64, false, &msg->image_crc);
 800c55c:	68bb      	ldr	r3, [r7, #8]
 800c55e:	681a      	ldr	r2, [r3, #0]
 800c560:	687b      	ldr	r3, [r7, #4]
 800c562:	3308      	adds	r3, #8
 800c564:	9300      	str	r3, [sp, #0]
 800c566:	68f8      	ldr	r0, [r7, #12]
 800c568:	4611      	mov	r1, r2
 800c56a:	2240      	movs	r2, #64	; 0x40
 800c56c:	2300      	movs	r3, #0
 800c56e:	f000 fe7f 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 64;
 800c572:	68bb      	ldr	r3, [r7, #8]
 800c574:	681b      	ldr	r3, [r3, #0]
 800c576:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800c57a:	68bb      	ldr	r3, [r7, #8]
 800c57c:	601a      	str	r2, [r3, #0]

}
 800c57e:	3710      	adds	r7, #16
 800c580:	46bd      	mov	sp, r7
 800c582:	bd80      	pop	{r7, pc}

0800c584 <encode_func.lto_priv.55>:
>>>>>>> 752c83b... update binaries
#include <uavcan.protocol.GetNodeInfo_req.h>
#include <uavcan.protocol.GetNodeInfo_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800c4fc:	b580      	push	{r7, lr}
 800c4fe:	b084      	sub	sp, #16
 800c500:	af00      	add	r7, sp, #0
 800c502:	60f8      	str	r0, [r7, #12]
 800c504:	60b9      	str	r1, [r7, #8]
 800c506:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_req(msg, chunk_cb, ctx);
 800c508:	68f8      	ldr	r0, [r7, #12]
 800c50a:	68b9      	ldr	r1, [r7, #8]
 800c50c:	687a      	ldr	r2, [r7, #4]
 800c50e:	f000 f811 	bl	800c534 <encode_uavcan_protocol_GetNodeInfo_req>
}
 800c512:	3710      	adds	r7, #16
 800c514:	46bd      	mov	sp, r7
 800c516:	bd80      	pop	{r7, pc}

0800c518 <decode_func.lto_priv.63>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800c518:	b580      	push	{r7, lr}
 800c51a:	b082      	sub	sp, #8
 800c51c:	af00      	add	r7, sp, #0
 800c51e:	6078      	str	r0, [r7, #4]
 800c520:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_req(transfer, msg);
 800c522:	6878      	ldr	r0, [r7, #4]
 800c524:	6839      	ldr	r1, [r7, #0]
 800c526:	f000 f819 	bl	800c55c <decode_uavcan_protocol_GetNodeInfo_req>
 800c52a:	4603      	mov	r3, r0
}
 800c52c:	4618      	mov	r0, r3
 800c52e:	3708      	adds	r7, #8
 800c530:	46bd      	mov	sp, r7
 800c532:	bd80      	pop	{r7, pc}

0800c534 <encode_uavcan_protocol_GetNodeInfo_req>:
=======
 800c584:	b580      	push	{r7, lr}
 800c586:	b084      	sub	sp, #16
 800c588:	af00      	add	r7, sp, #0
 800c58a:	60f8      	str	r0, [r7, #12]
 800c58c:	60b9      	str	r1, [r7, #8]
 800c58e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_GetNodeInfo_req(msg, chunk_cb, ctx);
 800c590:	68f8      	ldr	r0, [r7, #12]
 800c592:	68b9      	ldr	r1, [r7, #8]
 800c594:	687a      	ldr	r2, [r7, #4]
 800c596:	f000 f811 	bl	800c5bc <encode_uavcan_protocol_GetNodeInfo_req>
}
 800c59a:	3710      	adds	r7, #16
 800c59c:	46bd      	mov	sp, r7
 800c59e:	bd80      	pop	{r7, pc}

0800c5a0 <decode_func.lto_priv.63>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800c5a0:	b580      	push	{r7, lr}
 800c5a2:	b082      	sub	sp, #8
 800c5a4:	af00      	add	r7, sp, #0
 800c5a6:	6078      	str	r0, [r7, #4]
 800c5a8:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_GetNodeInfo_req(transfer, msg);
 800c5aa:	6878      	ldr	r0, [r7, #4]
 800c5ac:	6839      	ldr	r1, [r7, #0]
 800c5ae:	f000 f819 	bl	800c5e4 <decode_uavcan_protocol_GetNodeInfo_req>
 800c5b2:	4603      	mov	r3, r0
}
 800c5b4:	4618      	mov	r0, r3
 800c5b6:	3708      	adds	r7, #8
 800c5b8:	46bd      	mov	sp, r7
 800c5ba:	bd80      	pop	{r7, pc}

0800c5bc <encode_uavcan_protocol_GetNodeInfo_req>:
>>>>>>> 752c83b... update binaries
    encode_func,
    decode_func,
    &uavcan_protocol_GetNodeInfo_res_descriptor
};

void encode_uavcan_protocol_GetNodeInfo_req(struct uavcan_protocol_GetNodeInfo_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800c534:	b580      	push	{r7, lr}
 800c536:	b088      	sub	sp, #32
 800c538:	af02      	add	r7, sp, #8
 800c53a:	60f8      	str	r0, [r7, #12]
 800c53c:	60b9      	str	r1, [r7, #8]
 800c53e:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_req(buffer, msg, chunk_cb, ctx, true);
 800c540:	f107 0210 	add.w	r2, r7, #16
 800c544:	2301      	movs	r3, #1
 800c546:	9300      	str	r3, [sp, #0]
 800c548:	4610      	mov	r0, r2
 800c54a:	68f9      	ldr	r1, [r7, #12]
 800c54c:	68ba      	ldr	r2, [r7, #8]
 800c54e:	687b      	ldr	r3, [r7, #4]
 800c550:	f000 f81a 	bl	800c588 <_encode_uavcan_protocol_GetNodeInfo_req>
}
 800c554:	3718      	adds	r7, #24
 800c556:	46bd      	mov	sp, r7
 800c558:	bd80      	pop	{r7, pc}
 800c55a:	bf00      	nop

0800c55c <decode_uavcan_protocol_GetNodeInfo_req>:

uint32_t decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_req_s* msg) {
 800c55c:	b580      	push	{r7, lr}
 800c55e:	b084      	sub	sp, #16
 800c560:	af00      	add	r7, sp, #0
 800c562:	6078      	str	r0, [r7, #4]
 800c564:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800c566:	2300      	movs	r3, #0
 800c568:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_req(transfer, &bit_ofs, msg, true);
 800c56a:	f107 030c 	add.w	r3, r7, #12
 800c56e:	6878      	ldr	r0, [r7, #4]
 800c570:	4619      	mov	r1, r3
 800c572:	683a      	ldr	r2, [r7, #0]
 800c574:	2301      	movs	r3, #1
 800c576:	f000 f813 	bl	800c5a0 <_decode_uavcan_protocol_GetNodeInfo_req>
    return (bit_ofs+7)/8;
 800c57a:	68fb      	ldr	r3, [r7, #12]
 800c57c:	3307      	adds	r3, #7
 800c57e:	08db      	lsrs	r3, r3, #3
}
 800c580:	4618      	mov	r0, r3
 800c582:	3710      	adds	r7, #16
 800c584:	46bd      	mov	sp, r7
 800c586:	bd80      	pop	{r7, pc}

0800c588 <_encode_uavcan_protocol_GetNodeInfo_req>:

void _encode_uavcan_protocol_GetNodeInfo_req(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800c588:	b480      	push	{r7}
 800c58a:	b085      	sub	sp, #20
 800c58c:	af00      	add	r7, sp, #0
 800c58e:	60f8      	str	r0, [r7, #12]
 800c590:	60b9      	str	r1, [r7, #8]
 800c592:	607a      	str	r2, [r7, #4]
 800c594:	603b      	str	r3, [r7, #0]
=======
 800c5bc:	b580      	push	{r7, lr}
 800c5be:	b088      	sub	sp, #32
 800c5c0:	af02      	add	r7, sp, #8
 800c5c2:	60f8      	str	r0, [r7, #12]
 800c5c4:	60b9      	str	r1, [r7, #8]
 800c5c6:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_GetNodeInfo_req(buffer, msg, chunk_cb, ctx, true);
 800c5c8:	f107 0210 	add.w	r2, r7, #16
 800c5cc:	2301      	movs	r3, #1
 800c5ce:	9300      	str	r3, [sp, #0]
 800c5d0:	4610      	mov	r0, r2
 800c5d2:	68f9      	ldr	r1, [r7, #12]
 800c5d4:	68ba      	ldr	r2, [r7, #8]
 800c5d6:	687b      	ldr	r3, [r7, #4]
 800c5d8:	f000 f81a 	bl	800c610 <_encode_uavcan_protocol_GetNodeInfo_req>
}
 800c5dc:	3718      	adds	r7, #24
 800c5de:	46bd      	mov	sp, r7
 800c5e0:	bd80      	pop	{r7, pc}
 800c5e2:	bf00      	nop

0800c5e4 <decode_uavcan_protocol_GetNodeInfo_req>:

uint32_t decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, struct uavcan_protocol_GetNodeInfo_req_s* msg) {
 800c5e4:	b580      	push	{r7, lr}
 800c5e6:	b084      	sub	sp, #16
 800c5e8:	af00      	add	r7, sp, #0
 800c5ea:	6078      	str	r0, [r7, #4]
 800c5ec:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800c5ee:	2300      	movs	r3, #0
 800c5f0:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_GetNodeInfo_req(transfer, &bit_ofs, msg, true);
 800c5f2:	f107 030c 	add.w	r3, r7, #12
 800c5f6:	6878      	ldr	r0, [r7, #4]
 800c5f8:	4619      	mov	r1, r3
 800c5fa:	683a      	ldr	r2, [r7, #0]
 800c5fc:	2301      	movs	r3, #1
 800c5fe:	f000 f813 	bl	800c628 <_decode_uavcan_protocol_GetNodeInfo_req>
    return (bit_ofs+7)/8;
 800c602:	68fb      	ldr	r3, [r7, #12]
 800c604:	3307      	adds	r3, #7
 800c606:	08db      	lsrs	r3, r3, #3
}
 800c608:	4618      	mov	r0, r3
 800c60a:	3710      	adds	r7, #16
 800c60c:	46bd      	mov	sp, r7
 800c60e:	bd80      	pop	{r7, pc}

0800c610 <_encode_uavcan_protocol_GetNodeInfo_req>:

void _encode_uavcan_protocol_GetNodeInfo_req(uint8_t* buffer, struct uavcan_protocol_GetNodeInfo_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800c610:	b480      	push	{r7}
 800c612:	b085      	sub	sp, #20
 800c614:	af00      	add	r7, sp, #0
 800c616:	60f8      	str	r0, [r7, #12]
 800c618:	60b9      	str	r1, [r7, #8]
 800c61a:	607a      	str	r2, [r7, #4]
 800c61c:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

}
<<<<<<< HEAD
 800c596:	3714      	adds	r7, #20
 800c598:	46bd      	mov	sp, r7
 800c59a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c59e:	4770      	bx	lr

0800c5a0 <_decode_uavcan_protocol_GetNodeInfo_req>:

void _decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_req_s* msg, bool tao) {
 800c5a0:	b480      	push	{r7}
 800c5a2:	b085      	sub	sp, #20
 800c5a4:	af00      	add	r7, sp, #0
 800c5a6:	60f8      	str	r0, [r7, #12]
 800c5a8:	60b9      	str	r1, [r7, #8]
 800c5aa:	607a      	str	r2, [r7, #4]
 800c5ac:	70fb      	strb	r3, [r7, #3]
=======
 800c61e:	3714      	adds	r7, #20
 800c620:	46bd      	mov	sp, r7
 800c622:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c626:	4770      	bx	lr

0800c628 <_decode_uavcan_protocol_GetNodeInfo_req>:

void _decode_uavcan_protocol_GetNodeInfo_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_GetNodeInfo_req_s* msg, bool tao) {
 800c628:	b480      	push	{r7}
 800c62a:	b085      	sub	sp, #20
 800c62c:	af00      	add	r7, sp, #0
 800c62e:	60f8      	str	r0, [r7, #12]
 800c630:	60b9      	str	r1, [r7, #8]
 800c632:	607a      	str	r2, [r7, #4]
 800c634:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

}
<<<<<<< HEAD
 800c5ae:	3714      	adds	r7, #20
 800c5b0:	46bd      	mov	sp, r7
 800c5b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5b6:	4770      	bx	lr

0800c5b8 <__core_init>:
=======
 800c636:	3714      	adds	r7, #20
 800c638:	46bd      	mov	sp, r7
 800c63a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c63e:	4770      	bx	lr

0800c640 <__core_init>:
>>>>>>> 752c83b... update binaries
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
<<<<<<< HEAD
 800c5b8:	b480      	push	{r7}
 800c5ba:	af00      	add	r7, sp, #0
=======
 800c640:	b480      	push	{r7}
 800c642:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
<<<<<<< HEAD
 800c5bc:	46bd      	mov	sp, r7
 800c5be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5c2:	4770      	bx	lr

0800c5c4 <__late_init>:
=======
 800c644:	46bd      	mov	sp, r7
 800c646:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c64a:	4770      	bx	lr

0800c64c <__late_init>:
>>>>>>> 752c83b... update binaries
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
<<<<<<< HEAD
 800c5c4:	b480      	push	{r7}
 800c5c6:	af00      	add	r7, sp, #0
 800c5c8:	46bd      	mov	sp, r7
 800c5ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5ce:	4770      	bx	lr

0800c5d0 <__default_exit>:
=======
 800c64c:	b480      	push	{r7}
 800c64e:	af00      	add	r7, sp, #0
 800c650:	46bd      	mov	sp, r7
 800c652:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c656:	4770      	bx	lr

0800c658 <__default_exit>:
>>>>>>> 752c83b... update binaries
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
<<<<<<< HEAD
 800c5d0:	b480      	push	{r7}
 800c5d2:	af00      	add	r7, sp, #0
 800c5d4:	e7fe      	b.n	800c5d4 <__default_exit+0x4>
 800c5d6:	bf00      	nop

0800c5d8 <__init_ram_areas>:
=======
 800c658:	b480      	push	{r7}
 800c65a:	af00      	add	r7, sp, #0
 800c65c:	e7fe      	b.n	800c65c <__default_exit+0x4>
 800c65e:	bf00      	nop

0800c660 <__init_ram_areas>:
>>>>>>> 752c83b... update binaries
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
<<<<<<< HEAD
 800c5d8:	b480      	push	{r7}
 800c5da:	b085      	sub	sp, #20
 800c5dc:	af00      	add	r7, sp, #0
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800c5de:	4b18      	ldr	r3, [pc, #96]	; (800c640 <__init_ram_areas+0x68>)
 800c5e0:	60fb      	str	r3, [r7, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 800c5e2:	68fb      	ldr	r3, [r7, #12]
 800c5e4:	681b      	ldr	r3, [r3, #0]
 800c5e6:	60bb      	str	r3, [r7, #8]
    uint32_t *p = rap->init_area;
 800c5e8:	68fb      	ldr	r3, [r7, #12]
 800c5ea:	685b      	ldr	r3, [r3, #4]
 800c5ec:	607b      	str	r3, [r7, #4]
 800c5ee:	e009      	b.n	800c604 <__init_ram_areas+0x2c>
=======
 800c660:	b480      	push	{r7}
 800c662:	b085      	sub	sp, #20
 800c664:	af00      	add	r7, sp, #0
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800c666:	4b18      	ldr	r3, [pc, #96]	; (800c6c8 <__init_ram_areas+0x68>)
 800c668:	60fb      	str	r3, [r7, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 800c66a:	68fb      	ldr	r3, [r7, #12]
 800c66c:	681b      	ldr	r3, [r3, #0]
 800c66e:	60bb      	str	r3, [r7, #8]
    uint32_t *p = rap->init_area;
 800c670:	68fb      	ldr	r3, [r7, #12]
 800c672:	685b      	ldr	r3, [r3, #4]
 800c674:	607b      	str	r3, [r7, #4]
 800c676:	e009      	b.n	800c68c <__init_ram_areas+0x2c>
>>>>>>> 752c83b... update binaries

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
<<<<<<< HEAD
 800c5f0:	68bb      	ldr	r3, [r7, #8]
 800c5f2:	681a      	ldr	r2, [r3, #0]
 800c5f4:	687b      	ldr	r3, [r7, #4]
 800c5f6:	601a      	str	r2, [r3, #0]
      p++;
 800c5f8:	687b      	ldr	r3, [r7, #4]
 800c5fa:	3304      	adds	r3, #4
 800c5fc:	607b      	str	r3, [r7, #4]
      tp++;
 800c5fe:	68bb      	ldr	r3, [r7, #8]
 800c600:	3304      	adds	r3, #4
 800c602:	60bb      	str	r3, [r7, #8]
=======
 800c678:	68bb      	ldr	r3, [r7, #8]
 800c67a:	681a      	ldr	r2, [r3, #0]
 800c67c:	687b      	ldr	r3, [r7, #4]
 800c67e:	601a      	str	r2, [r3, #0]
      p++;
 800c680:	687b      	ldr	r3, [r7, #4]
 800c682:	3304      	adds	r3, #4
 800c684:	607b      	str	r3, [r7, #4]
      tp++;
 800c686:	68bb      	ldr	r3, [r7, #8]
 800c688:	3304      	adds	r3, #4
 800c68a:	60bb      	str	r3, [r7, #8]
>>>>>>> 752c83b... update binaries
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
<<<<<<< HEAD
 800c604:	68fb      	ldr	r3, [r7, #12]
 800c606:	689a      	ldr	r2, [r3, #8]
 800c608:	687b      	ldr	r3, [r7, #4]
 800c60a:	429a      	cmp	r2, r3
 800c60c:	d8f0      	bhi.n	800c5f0 <__init_ram_areas+0x18>
 800c60e:	e005      	b.n	800c61c <__init_ram_areas+0x44>
=======
 800c68c:	68fb      	ldr	r3, [r7, #12]
 800c68e:	689a      	ldr	r2, [r3, #8]
 800c690:	687b      	ldr	r3, [r7, #4]
 800c692:	429a      	cmp	r2, r3
 800c694:	d8f0      	bhi.n	800c678 <__init_ram_areas+0x18>
 800c696:	e005      	b.n	800c6a4 <__init_ram_areas+0x44>
>>>>>>> 752c83b... update binaries
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
<<<<<<< HEAD
 800c610:	687b      	ldr	r3, [r7, #4]
 800c612:	2200      	movs	r2, #0
 800c614:	601a      	str	r2, [r3, #0]
      p++;
 800c616:	687b      	ldr	r3, [r7, #4]
 800c618:	3304      	adds	r3, #4
 800c61a:	607b      	str	r3, [r7, #4]
=======
 800c698:	687b      	ldr	r3, [r7, #4]
 800c69a:	2200      	movs	r2, #0
 800c69c:	601a      	str	r2, [r3, #0]
      p++;
 800c69e:	687b      	ldr	r3, [r7, #4]
 800c6a0:	3304      	adds	r3, #4
 800c6a2:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
<<<<<<< HEAD
 800c61c:	68fb      	ldr	r3, [r7, #12]
 800c61e:	68da      	ldr	r2, [r3, #12]
 800c620:	687b      	ldr	r3, [r7, #4]
 800c622:	429a      	cmp	r2, r3
 800c624:	d8f4      	bhi.n	800c610 <__init_ram_areas+0x38>
=======
 800c6a4:	68fb      	ldr	r3, [r7, #12]
 800c6a6:	68da      	ldr	r2, [r3, #12]
 800c6a8:	687b      	ldr	r3, [r7, #4]
 800c6aa:	429a      	cmp	r2, r3
 800c6ac:	d8f4      	bhi.n	800c698 <__init_ram_areas+0x38>
>>>>>>> 752c83b... update binaries
      *p = 0;
      p++;
    }
    rap++;
<<<<<<< HEAD
 800c626:	68fb      	ldr	r3, [r7, #12]
 800c628:	3310      	adds	r3, #16
 800c62a:	60fb      	str	r3, [r7, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800c62c:	68fb      	ldr	r3, [r7, #12]
 800c62e:	4a05      	ldr	r2, [pc, #20]	; (800c644 <__init_ram_areas+0x6c>)
 800c630:	4293      	cmp	r3, r2
 800c632:	d3d6      	bcc.n	800c5e2 <__init_ram_areas+0xa>
#endif
}
 800c634:	3714      	adds	r7, #20
 800c636:	46bd      	mov	sp, r7
 800c638:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c63c:	4770      	bx	lr
 800c63e:	bf00      	nop
 800c640:	0800e7d8 	.word	0x0800e7d8
 800c644:	0800e858 	.word	0x0800e858

0800c648 <BusFault_Handler>:
=======
 800c6ae:	68fb      	ldr	r3, [r7, #12]
 800c6b0:	3310      	adds	r3, #16
 800c6b2:	60fb      	str	r3, [r7, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800c6b4:	68fb      	ldr	r3, [r7, #12]
 800c6b6:	4a05      	ldr	r2, [pc, #20]	; (800c6cc <__init_ram_areas+0x6c>)
 800c6b8:	4293      	cmp	r3, r2
 800c6ba:	d3d6      	bcc.n	800c66a <__init_ram_areas+0xa>
#endif
}
 800c6bc:	3714      	adds	r7, #20
 800c6be:	46bd      	mov	sp, r7
 800c6c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6c4:	4770      	bx	lr
 800c6c6:	bf00      	nop
 800c6c8:	0800e8b0 	.word	0x0800e8b0
 800c6cc:	0800e930 	.word	0x0800e930

0800c6d0 <BusFault_Handler>:
>>>>>>> 752c83b... update binaries
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
<<<<<<< HEAD
 800c648:	b480      	push	{r7}
 800c64a:	af00      	add	r7, sp, #0
 800c64c:	e7fe      	b.n	800c64c <BusFault_Handler+0x4>
 800c64e:	bf00      	nop

0800c650 <NVIC_SetPriorityGrouping>:
=======
 800c6d0:	b480      	push	{r7}
 800c6d2:	af00      	add	r7, sp, #0
 800c6d4:	e7fe      	b.n	800c6d4 <BusFault_Handler+0x4>
 800c6d6:	bf00      	nop

0800c6d8 <NVIC_SetPriorityGrouping>:
>>>>>>> 752c83b... update binaries
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
<<<<<<< HEAD
 800c650:	b480      	push	{r7}
 800c652:	b085      	sub	sp, #20
 800c654:	af00      	add	r7, sp, #0
 800c656:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800c658:	687b      	ldr	r3, [r7, #4]
 800c65a:	f003 0307 	and.w	r3, r3, #7
 800c65e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800c660:	4b0c      	ldr	r3, [pc, #48]	; (800c694 <NVIC_SetPriorityGrouping+0x44>)
 800c662:	68db      	ldr	r3, [r3, #12]
 800c664:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800c666:	68ba      	ldr	r2, [r7, #8]
 800c668:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800c66c:	4013      	ands	r3, r2
 800c66e:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 800c670:	68fb      	ldr	r3, [r7, #12]
 800c672:	021a      	lsls	r2, r3, #8
=======
 800c6d8:	b480      	push	{r7}
 800c6da:	b085      	sub	sp, #20
 800c6dc:	af00      	add	r7, sp, #0
 800c6de:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800c6e0:	687b      	ldr	r3, [r7, #4]
 800c6e2:	f003 0307 	and.w	r3, r3, #7
 800c6e6:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800c6e8:	4b0c      	ldr	r3, [pc, #48]	; (800c71c <NVIC_SetPriorityGrouping+0x44>)
 800c6ea:	68db      	ldr	r3, [r3, #12]
 800c6ec:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800c6ee:	68ba      	ldr	r2, [r7, #8]
 800c6f0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800c6f4:	4013      	ands	r3, r2
 800c6f6:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 800c6f8:	68fb      	ldr	r3, [r7, #12]
 800c6fa:	021a      	lsls	r2, r3, #8
>>>>>>> 752c83b... update binaries
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
<<<<<<< HEAD
 800c674:	68bb      	ldr	r3, [r7, #8]
 800c676:	4313      	orrs	r3, r2
=======
 800c6fc:	68bb      	ldr	r3, [r7, #8]
 800c6fe:	4313      	orrs	r3, r2
>>>>>>> 752c83b... update binaries
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
<<<<<<< HEAD
 800c678:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800c67c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800c680:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800c682:	4a04      	ldr	r2, [pc, #16]	; (800c694 <NVIC_SetPriorityGrouping+0x44>)
 800c684:	68bb      	ldr	r3, [r7, #8]
 800c686:	60d3      	str	r3, [r2, #12]
}
 800c688:	3714      	adds	r7, #20
 800c68a:	46bd      	mov	sp, r7
 800c68c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c690:	4770      	bx	lr
 800c692:	bf00      	nop
 800c694:	e000ed00 	.word	0xe000ed00

0800c698 <NVIC_SetPriority>:
=======
 800c700:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800c704:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800c708:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800c70a:	4a04      	ldr	r2, [pc, #16]	; (800c71c <NVIC_SetPriorityGrouping+0x44>)
 800c70c:	68bb      	ldr	r3, [r7, #8]
 800c70e:	60d3      	str	r3, [r2, #12]
}
 800c710:	3714      	adds	r7, #20
 800c712:	46bd      	mov	sp, r7
 800c714:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c718:	4770      	bx	lr
 800c71a:	bf00      	nop
 800c71c:	e000ed00 	.word	0xe000ed00

0800c720 <NVIC_SetPriority>:
>>>>>>> 752c83b... update binaries
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
<<<<<<< HEAD
 800c698:	b480      	push	{r7}
 800c69a:	b083      	sub	sp, #12
 800c69c:	af00      	add	r7, sp, #0
 800c69e:	4603      	mov	r3, r0
 800c6a0:	6039      	str	r1, [r7, #0]
 800c6a2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
 800c6a4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c6a8:	2b00      	cmp	r3, #0
 800c6aa:	da0b      	bge.n	800c6c4 <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c6ac:	490d      	ldr	r1, [pc, #52]	; (800c6e4 <NVIC_SetPriority+0x4c>)
 800c6ae:	79fb      	ldrb	r3, [r7, #7]
 800c6b0:	f003 030f 	and.w	r3, r3, #15
 800c6b4:	3b04      	subs	r3, #4
 800c6b6:	683a      	ldr	r2, [r7, #0]
 800c6b8:	b2d2      	uxtb	r2, r2
 800c6ba:	0112      	lsls	r2, r2, #4
 800c6bc:	b2d2      	uxtb	r2, r2
 800c6be:	440b      	add	r3, r1
 800c6c0:	761a      	strb	r2, [r3, #24]
 800c6c2:	e009      	b.n	800c6d8 <NVIC_SetPriority+0x40>
=======
 800c720:	b480      	push	{r7}
 800c722:	b083      	sub	sp, #12
 800c724:	af00      	add	r7, sp, #0
 800c726:	4603      	mov	r3, r0
 800c728:	6039      	str	r1, [r7, #0]
 800c72a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
 800c72c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c730:	2b00      	cmp	r3, #0
 800c732:	da0b      	bge.n	800c74c <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c734:	490d      	ldr	r1, [pc, #52]	; (800c76c <NVIC_SetPriority+0x4c>)
 800c736:	79fb      	ldrb	r3, [r7, #7]
 800c738:	f003 030f 	and.w	r3, r3, #15
 800c73c:	3b04      	subs	r3, #4
 800c73e:	683a      	ldr	r2, [r7, #0]
 800c740:	b2d2      	uxtb	r2, r2
 800c742:	0112      	lsls	r2, r2, #4
 800c744:	b2d2      	uxtb	r2, r2
 800c746:	440b      	add	r3, r1
 800c748:	761a      	strb	r2, [r3, #24]
 800c74a:	e009      	b.n	800c760 <NVIC_SetPriority+0x40>
>>>>>>> 752c83b... update binaries
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
<<<<<<< HEAD
 800c6c4:	4908      	ldr	r1, [pc, #32]	; (800c6e8 <NVIC_SetPriority+0x50>)
 800c6c6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c6ca:	683a      	ldr	r2, [r7, #0]
 800c6cc:	b2d2      	uxtb	r2, r2
 800c6ce:	0112      	lsls	r2, r2, #4
 800c6d0:	b2d2      	uxtb	r2, r2
 800c6d2:	440b      	add	r3, r1
 800c6d4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800c6d8:	370c      	adds	r7, #12
 800c6da:	46bd      	mov	sp, r7
 800c6dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6e0:	4770      	bx	lr
 800c6e2:	bf00      	nop
 800c6e4:	e000ed00 	.word	0xe000ed00
 800c6e8:	e000e100 	.word	0xe000e100

0800c6ec <port_init>:
=======
 800c74c:	4908      	ldr	r1, [pc, #32]	; (800c770 <NVIC_SetPriority+0x50>)
 800c74e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800c752:	683a      	ldr	r2, [r7, #0]
 800c754:	b2d2      	uxtb	r2, r2
 800c756:	0112      	lsls	r2, r2, #4
 800c758:	b2d2      	uxtb	r2, r2
 800c75a:	440b      	add	r3, r1
 800c75c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800c760:	370c      	adds	r7, #12
 800c762:	46bd      	mov	sp, r7
 800c764:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c768:	4770      	bx	lr
 800c76a:	bf00      	nop
 800c76c:	e000ed00 	.word	0xe000ed00
 800c770:	e000e100 	.word	0xe000e100

0800c774 <port_init>:
>>>>>>> 752c83b... update binaries
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
<<<<<<< HEAD
 800c6ec:	b580      	push	{r7, lr}
 800c6ee:	af00      	add	r7, sp, #0

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800c6f0:	2003      	movs	r0, #3
 800c6f2:	f7ff ffad 	bl	800c650 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800c6f6:	4a0b      	ldr	r2, [pc, #44]	; (800c724 <port_init+0x38>)
 800c6f8:	4b0a      	ldr	r3, [pc, #40]	; (800c724 <port_init+0x38>)
 800c6fa:	68db      	ldr	r3, [r3, #12]
 800c6fc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800c700:	60d3      	str	r3, [r2, #12]
=======
 800c774:	b580      	push	{r7, lr}
 800c776:	af00      	add	r7, sp, #0

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800c778:	2003      	movs	r0, #3
 800c77a:	f7ff ffad 	bl	800c6d8 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800c77e:	4a0b      	ldr	r2, [pc, #44]	; (800c7ac <port_init+0x38>)
 800c780:	4b0a      	ldr	r3, [pc, #40]	; (800c7ac <port_init+0x38>)
 800c782:	68db      	ldr	r3, [r3, #12]
 800c784:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800c788:	60d3      	str	r3, [r2, #12]
>>>>>>> 752c83b... update binaries
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
<<<<<<< HEAD
 800c702:	4a09      	ldr	r2, [pc, #36]	; (800c728 <port_init+0x3c>)
 800c704:	4b08      	ldr	r3, [pc, #32]	; (800c728 <port_init+0x3c>)
 800c706:	681b      	ldr	r3, [r3, #0]
 800c708:	f043 0301 	orr.w	r3, r3, #1
 800c70c:	6013      	str	r3, [r2, #0]
=======
 800c78a:	4a09      	ldr	r2, [pc, #36]	; (800c7b0 <port_init+0x3c>)
 800c78c:	4b08      	ldr	r3, [pc, #32]	; (800c7b0 <port_init+0x3c>)
 800c78e:	681b      	ldr	r3, [r3, #0]
 800c790:	f043 0301 	orr.w	r3, r3, #1
 800c794:	6013      	str	r3, [r2, #0]
>>>>>>> 752c83b... update binaries

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
<<<<<<< HEAD
 800c70e:	f06f 0004 	mvn.w	r0, #4
 800c712:	2101      	movs	r1, #1
 800c714:	f7ff ffc0 	bl	800c698 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800c718:	f06f 0001 	mvn.w	r0, #1
 800c71c:	2102      	movs	r1, #2
 800c71e:	f7ff ffbb 	bl	800c698 <NVIC_SetPriority>
=======
 800c796:	f06f 0004 	mvn.w	r0, #4
 800c79a:	2101      	movs	r1, #1
 800c79c:	f7ff ffc0 	bl	800c720 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800c7a0:	f06f 0001 	mvn.w	r0, #1
 800c7a4:	2102      	movs	r1, #2
 800c7a6:	f7ff ffbb 	bl	800c720 <NVIC_SetPriority>
>>>>>>> 752c83b... update binaries

    /* MPU is enabled.*/
    mpuEnable(MPU_CTRL_PRIVDEFENA);
  }
#endif
}
<<<<<<< HEAD
 800c722:	bd80      	pop	{r7, pc}
 800c724:	e000edf0 	.word	0xe000edf0
 800c728:	e0001000 	.word	0xe0001000

0800c72c <port_lock>:
=======
 800c7aa:	bd80      	pop	{r7, pc}
 800c7ac:	e000edf0 	.word	0xe000edf0
 800c7b0:	e0001000 	.word	0xe0001000

0800c7b4 <port_lock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
<<<<<<< HEAD
 800c72c:	b480      	push	{r7}
 800c72e:	b083      	sub	sp, #12
 800c730:	af00      	add	r7, sp, #0
 800c732:	2320      	movs	r3, #32
 800c734:	607b      	str	r3, [r7, #4]
 800c736:	687b      	ldr	r3, [r7, #4]
 800c738:	f383 8811 	msr	BASEPRI, r3
=======
 800c7b4:	b480      	push	{r7}
 800c7b6:	b083      	sub	sp, #12
 800c7b8:	af00      	add	r7, sp, #0
 800c7ba:	2320      	movs	r3, #32
 800c7bc:	607b      	str	r3, [r7, #4]
 800c7be:	687b      	ldr	r3, [r7, #4]
 800c7c0:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800c73c:	370c      	adds	r7, #12
 800c73e:	46bd      	mov	sp, r7
 800c740:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c744:	4770      	bx	lr
 800c746:	bf00      	nop

0800c748 <port_unlock>:
=======
 800c7c4:	370c      	adds	r7, #12
 800c7c6:	46bd      	mov	sp, r7
 800c7c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7cc:	4770      	bx	lr
 800c7ce:	bf00      	nop

0800c7d0 <port_unlock>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
<<<<<<< HEAD
 800c748:	b480      	push	{r7}
 800c74a:	b083      	sub	sp, #12
 800c74c:	af00      	add	r7, sp, #0
 800c74e:	2300      	movs	r3, #0
 800c750:	607b      	str	r3, [r7, #4]
 800c752:	687b      	ldr	r3, [r7, #4]
 800c754:	f383 8811 	msr	BASEPRI, r3
=======
 800c7d0:	b480      	push	{r7}
 800c7d2:	b083      	sub	sp, #12
 800c7d4:	af00      	add	r7, sp, #0
 800c7d6:	2300      	movs	r3, #0
 800c7d8:	607b      	str	r3, [r7, #4]
 800c7da:	687b      	ldr	r3, [r7, #4]
 800c7dc:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
<<<<<<< HEAD
 800c758:	370c      	adds	r7, #12
 800c75a:	46bd      	mov	sp, r7
 800c75c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c760:	4770      	bx	lr
 800c762:	bf00      	nop

0800c764 <port_lock_from_isr>:
=======
 800c7e0:	370c      	adds	r7, #12
 800c7e2:	46bd      	mov	sp, r7
 800c7e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7e8:	4770      	bx	lr
 800c7ea:	bf00      	nop

0800c7ec <port_lock_from_isr>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
<<<<<<< HEAD
 800c764:	b580      	push	{r7, lr}
 800c766:	af00      	add	r7, sp, #0

  port_lock();
 800c768:	f7ff ffe0 	bl	800c72c <port_lock>
}
 800c76c:	bd80      	pop	{r7, pc}
 800c76e:	bf00      	nop

0800c770 <port_unlock_from_isr>:
=======
 800c7ec:	b580      	push	{r7, lr}
 800c7ee:	af00      	add	r7, sp, #0

  port_lock();
 800c7f0:	f7ff ffe0 	bl	800c7b4 <port_lock>
}
 800c7f4:	bd80      	pop	{r7, pc}
 800c7f6:	bf00      	nop

0800c7f8 <port_unlock_from_isr>:
>>>>>>> 752c83b... update binaries
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
<<<<<<< HEAD
 800c770:	b580      	push	{r7, lr}
 800c772:	af00      	add	r7, sp, #0

  port_unlock();
 800c774:	f7ff ffe8 	bl	800c748 <port_unlock>
}
 800c778:	bd80      	pop	{r7, pc}
 800c77a:	bf00      	nop

0800c77c <port_disable.lto_priv.331>:
=======
 800c7f8:	b580      	push	{r7, lr}
 800c7fa:	af00      	add	r7, sp, #0

  port_unlock();
 800c7fc:	f7ff ffe8 	bl	800c7d0 <port_unlock>
}
 800c800:	bd80      	pop	{r7, pc}
 800c802:	bf00      	nop

0800c804 <port_disable.lto_priv.328>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Disables all the interrupt sources.
 * @note    In this port it disables all the interrupt sources by raising
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {
<<<<<<< HEAD
 800c77c:	b480      	push	{r7}
 800c77e:	af00      	add	r7, sp, #0
=======
 800c804:	b480      	push	{r7}
 800c806:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
<<<<<<< HEAD
 800c780:	b672      	cpsid	i

  __disable_irq();
}
 800c782:	46bd      	mov	sp, r7
 800c784:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c788:	4770      	bx	lr
 800c78a:	bf00      	nop

0800c78c <port_enable>:
=======
 800c808:	b672      	cpsid	i

  __disable_irq();
}
 800c80a:	46bd      	mov	sp, r7
 800c80c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c810:	4770      	bx	lr
 800c812:	bf00      	nop

0800c814 <port_enable>:
>>>>>>> 752c83b... update binaries

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
<<<<<<< HEAD
 800c78c:	b480      	push	{r7}
 800c78e:	b083      	sub	sp, #12
 800c790:	af00      	add	r7, sp, #0
 800c792:	2300      	movs	r3, #0
 800c794:	607b      	str	r3, [r7, #4]
=======
 800c814:	b480      	push	{r7}
 800c816:	b083      	sub	sp, #12
 800c818:	af00      	add	r7, sp, #0
 800c81a:	2300      	movs	r3, #0
 800c81c:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
<<<<<<< HEAD
 800c796:	687b      	ldr	r3, [r7, #4]
 800c798:	f383 8811 	msr	BASEPRI, r3
=======
 800c81e:	687b      	ldr	r3, [r7, #4]
 800c820:	f383 8811 	msr	BASEPRI, r3
>>>>>>> 752c83b... update binaries
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
<<<<<<< HEAD
 800c79c:	b662      	cpsie	i
=======
 800c824:	b662      	cpsie	i
>>>>>>> 752c83b... update binaries

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
<<<<<<< HEAD
 800c79e:	370c      	adds	r7, #12
 800c7a0:	46bd      	mov	sp, r7
 800c7a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7a6:	4770      	bx	lr

0800c7a8 <port_wait_for_interrupt>:
=======
 800c826:	370c      	adds	r7, #12
 800c828:	46bd      	mov	sp, r7
 800c82a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c82e:	4770      	bx	lr

0800c830 <port_wait_for_interrupt>:
>>>>>>> 752c83b... update binaries
 *          The simplest implementation is an empty function or macro but this
 *          would not take advantage of architecture-specific power saving
 *          modes.
 * @note    Implemented as an inlined @p WFI instruction.
 */
static inline void port_wait_for_interrupt(void) {
<<<<<<< HEAD
 800c7a8:	b480      	push	{r7}
 800c7aa:	af00      	add	r7, sp, #0
=======
 800c830:	b480      	push	{r7}
 800c832:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
<<<<<<< HEAD
 800c7ac:	46bd      	mov	sp, r7
 800c7ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7b2:	4770      	bx	lr

0800c7b4 <st_lld_get_counter>:
=======
 800c834:	46bd      	mov	sp, r7
 800c836:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c83a:	4770      	bx	lr

0800c83c <st_lld_get_counter>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
<<<<<<< HEAD
 800c7b4:	b480      	push	{r7}
 800c7b6:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800c7b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800c7bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c7be:	b29b      	uxth	r3, r3
}
 800c7c0:	4618      	mov	r0, r3
 800c7c2:	46bd      	mov	sp, r7
 800c7c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7c8:	4770      	bx	lr
 800c7ca:	bf00      	nop

0800c7cc <port_timer_stop_alarm>:
=======
 800c83c:	b480      	push	{r7}
 800c83e:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 800c840:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800c844:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c846:	b29b      	uxth	r3, r3
}
 800c848:	4618      	mov	r0, r3
 800c84a:	46bd      	mov	sp, r7
 800c84c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c850:	4770      	bx	lr
 800c852:	bf00      	nop

0800c854 <port_timer_stop_alarm>:
>>>>>>> 752c83b... update binaries
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
<<<<<<< HEAD
 800c7cc:	b580      	push	{r7, lr}
 800c7ce:	af00      	add	r7, sp, #0

  stStopAlarm();
 800c7d0:	f7fc fc52 	bl	8009078 <stStopAlarm>
}
 800c7d4:	bd80      	pop	{r7, pc}
 800c7d6:	bf00      	nop

0800c7d8 <port_timer_set_alarm>:
=======
 800c854:	b580      	push	{r7, lr}
 800c856:	af00      	add	r7, sp, #0

  stStopAlarm();
 800c858:	f7fc fc50 	bl	80090fc <stStopAlarm>
}
 800c85c:	bd80      	pop	{r7, pc}
 800c85e:	bf00      	nop

0800c860 <port_timer_set_alarm>:
>>>>>>> 752c83b... update binaries
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
<<<<<<< HEAD
 800c7d8:	b580      	push	{r7, lr}
 800c7da:	b082      	sub	sp, #8
 800c7dc:	af00      	add	r7, sp, #0
 800c7de:	4603      	mov	r3, r0
 800c7e0:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 800c7e2:	88fb      	ldrh	r3, [r7, #6]
 800c7e4:	4618      	mov	r0, r3
 800c7e6:	f7fc fc4d 	bl	8009084 <stSetAlarm>
}
 800c7ea:	3708      	adds	r7, #8
 800c7ec:	46bd      	mov	sp, r7
 800c7ee:	bd80      	pop	{r7, pc}

0800c7f0 <port_timer_get_time>:
=======
 800c860:	b580      	push	{r7, lr}
 800c862:	b082      	sub	sp, #8
 800c864:	af00      	add	r7, sp, #0
 800c866:	4603      	mov	r3, r0
 800c868:	80fb      	strh	r3, [r7, #6]

  stSetAlarm(time);
 800c86a:	88fb      	ldrh	r3, [r7, #6]
 800c86c:	4618      	mov	r0, r3
 800c86e:	f7fc fc4b 	bl	8009108 <stSetAlarm>
}
 800c872:	3708      	adds	r7, #8
 800c874:	46bd      	mov	sp, r7
 800c876:	bd80      	pop	{r7, pc}

0800c878 <port_timer_get_time>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
<<<<<<< HEAD
 800c7f0:	b580      	push	{r7, lr}
 800c7f2:	af00      	add	r7, sp, #0

  return stGetCounter();
 800c7f4:	f7ff ffde 	bl	800c7b4 <st_lld_get_counter>
 800c7f8:	4603      	mov	r3, r0
}
 800c7fa:	4618      	mov	r0, r3
 800c7fc:	bd80      	pop	{r7, pc}
 800c7fe:	bf00      	nop

0800c800 <chSysEnable>:
=======
 800c878:	b580      	push	{r7, lr}
 800c87a:	af00      	add	r7, sp, #0

  return stGetCounter();
 800c87c:	f7ff ffde 	bl	800c83c <st_lld_get_counter>
 800c880:	4603      	mov	r3, r0
}
 800c882:	4618      	mov	r0, r3
 800c884:	bd80      	pop	{r7, pc}
 800c886:	bf00      	nop

0800c888 <chSysEnable>:
>>>>>>> 752c83b... update binaries
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
<<<<<<< HEAD
 800c800:	b580      	push	{r7, lr}
 800c802:	af00      	add	r7, sp, #0

  _dbg_check_enable();
 800c804:	f7fe fb0a 	bl	800ae1c <_dbg_check_enable>
  port_enable();
 800c808:	f7ff ffc0 	bl	800c78c <port_enable>
}
 800c80c:	bd80      	pop	{r7, pc}
 800c80e:	bf00      	nop

0800c810 <chSysLockFromISR.lto_priv.318>:
=======
 800c888:	b580      	push	{r7, lr}
 800c88a:	af00      	add	r7, sp, #0

  _dbg_check_enable();
 800c88c:	f7fe fb0a 	bl	800aea4 <_dbg_check_enable>
  port_enable();
 800c890:	f7ff ffc0 	bl	800c814 <port_enable>
}
 800c894:	bd80      	pop	{r7, pc}
 800c896:	bf00      	nop

0800c898 <chSysLockFromISR.lto_priv.315>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
<<<<<<< HEAD
 800c810:	b580      	push	{r7, lr}
 800c812:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800c814:	f7ff ffa6 	bl	800c764 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800c818:	f7fe fb3e 	bl	800ae98 <_dbg_check_lock_from_isr>
}
 800c81c:	bd80      	pop	{r7, pc}
 800c81e:	bf00      	nop

0800c820 <chSysUnlockFromISR.lto_priv.316>:
=======
 800c898:	b580      	push	{r7, lr}
 800c89a:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 800c89c:	f7ff ffa6 	bl	800c7ec <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800c8a0:	f7fe fb3e 	bl	800af20 <_dbg_check_lock_from_isr>
}
 800c8a4:	bd80      	pop	{r7, pc}
 800c8a6:	bf00      	nop

0800c8a8 <chSysUnlockFromISR.lto_priv.313>:
>>>>>>> 752c83b... update binaries
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
<<<<<<< HEAD
 800c820:	b580      	push	{r7, lr}
 800c822:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800c824:	f7fe fb4e 	bl	800aec4 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800c828:	f7ff ffa2 	bl	800c770 <port_unlock_from_isr>
}
 800c82c:	bd80      	pop	{r7, pc}
 800c82e:	bf00      	nop

0800c830 <chVTGetSystemTimeX>:
=======
 800c8a8:	b580      	push	{r7, lr}
 800c8aa:	af00      	add	r7, sp, #0

  _dbg_check_unlock_from_isr();
 800c8ac:	f7fe fb4e 	bl	800af4c <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800c8b0:	f7ff ffa2 	bl	800c7f8 <port_unlock_from_isr>
}
 800c8b4:	bd80      	pop	{r7, pc}
 800c8b6:	bf00      	nop

0800c8b8 <chVTGetSystemTimeX>:
>>>>>>> 752c83b... update binaries
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
<<<<<<< HEAD
 800c830:	b580      	push	{r7, lr}
 800c832:	af00      	add	r7, sp, #0
=======
 800c8b8:	b580      	push	{r7, lr}
 800c8ba:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
<<<<<<< HEAD
 800c834:	f7ff ffdc 	bl	800c7f0 <port_timer_get_time>
 800c838:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c83a:	4618      	mov	r0, r3
 800c83c:	bd80      	pop	{r7, pc}
 800c83e:	bf00      	nop

0800c840 <chVTDoTickI.lto_priv.330>:
=======
 800c8bc:	f7ff ffdc 	bl	800c878 <port_timer_get_time>
 800c8c0:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c8c2:	4618      	mov	r0, r3
 800c8c4:	bd80      	pop	{r7, pc}
 800c8c6:	bf00      	nop

0800c8c8 <chVTDoTickI.lto_priv.327>:
>>>>>>> 752c83b... update binaries
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
<<<<<<< HEAD
 800c840:	b580      	push	{r7, lr}
 800c842:	b084      	sub	sp, #16
 800c844:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800c846:	f7fe fb8b 	bl	800af60 <chDbgCheckClassI>
=======
 800c8c8:	b580      	push	{r7, lr}
 800c8ca:	b084      	sub	sp, #16
 800c8cc:	af00      	add	r7, sp, #0

  chDbgCheckClassI();
 800c8ce:	f7fe fb8b 	bl	800afe8 <chDbgCheckClassI>
>>>>>>> 752c83b... update binaries
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
<<<<<<< HEAD
 800c84a:	4b36      	ldr	r3, [pc, #216]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c84c:	69db      	ldr	r3, [r3, #28]
 800c84e:	60fb      	str	r3, [r7, #12]
  now = chVTGetSystemTimeX();
 800c850:	f7ff ffee 	bl	800c830 <chVTGetSystemTimeX>
 800c854:	4603      	mov	r3, r0
 800c856:	817b      	strh	r3, [r7, #10]
 800c858:	e02c      	b.n	800c8b4 <chVTDoTickI.lto_priv.330+0x74>
=======
 800c8d2:	4b36      	ldr	r3, [pc, #216]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c8d4:	69db      	ldr	r3, [r3, #28]
 800c8d6:	60fb      	str	r3, [r7, #12]
  now = chVTGetSystemTimeX();
 800c8d8:	f7ff ffee 	bl	800c8b8 <chVTGetSystemTimeX>
 800c8dc:	4603      	mov	r3, r0
 800c8de:	817b      	strh	r3, [r7, #10]
 800c8e0:	e02c      	b.n	800c93c <chVTDoTickI.lto_priv.327+0x74>
>>>>>>> 752c83b... update binaries
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
<<<<<<< HEAD
 800c85a:	4b32      	ldr	r3, [pc, #200]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c85c:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800c85e:	68fb      	ldr	r3, [r7, #12]
 800c860:	891b      	ldrh	r3, [r3, #8]
 800c862:	4413      	add	r3, r2
 800c864:	b29a      	uxth	r2, r3
 800c866:	4b2f      	ldr	r3, [pc, #188]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c868:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800c86a:	68fb      	ldr	r3, [r7, #12]
 800c86c:	681b      	ldr	r3, [r3, #0]
 800c86e:	4a2e      	ldr	r2, [pc, #184]	; (800c928 <chVTDoTickI.lto_priv.330+0xe8>)
 800c870:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 800c872:	68fb      	ldr	r3, [r7, #12]
 800c874:	681b      	ldr	r3, [r3, #0]
 800c876:	4a2b      	ldr	r2, [pc, #172]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c878:	61d3      	str	r3, [r2, #28]
    fn = vtp->func;
 800c87a:	68fb      	ldr	r3, [r7, #12]
 800c87c:	68db      	ldr	r3, [r3, #12]
 800c87e:	607b      	str	r3, [r7, #4]
    vtp->func = NULL;
 800c880:	68fb      	ldr	r3, [r7, #12]
 800c882:	2200      	movs	r2, #0
 800c884:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800c886:	4b27      	ldr	r3, [pc, #156]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c888:	69db      	ldr	r3, [r3, #28]
 800c88a:	4a27      	ldr	r2, [pc, #156]	; (800c928 <chVTDoTickI.lto_priv.330+0xe8>)
 800c88c:	4293      	cmp	r3, r2
 800c88e:	d101      	bne.n	800c894 <chVTDoTickI.lto_priv.330+0x54>
      port_timer_stop_alarm();
 800c890:	f7ff ff9c 	bl	800c7cc <port_timer_stop_alarm>
=======
 800c8e2:	4b32      	ldr	r3, [pc, #200]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c8e4:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800c8e6:	68fb      	ldr	r3, [r7, #12]
 800c8e8:	891b      	ldrh	r3, [r3, #8]
 800c8ea:	4413      	add	r3, r2
 800c8ec:	b29a      	uxth	r2, r3
 800c8ee:	4b2f      	ldr	r3, [pc, #188]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c8f0:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800c8f2:	68fb      	ldr	r3, [r7, #12]
 800c8f4:	681b      	ldr	r3, [r3, #0]
 800c8f6:	4a2e      	ldr	r2, [pc, #184]	; (800c9b0 <chVTDoTickI.lto_priv.327+0xe8>)
 800c8f8:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 800c8fa:	68fb      	ldr	r3, [r7, #12]
 800c8fc:	681b      	ldr	r3, [r3, #0]
 800c8fe:	4a2b      	ldr	r2, [pc, #172]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c900:	61d3      	str	r3, [r2, #28]
    fn = vtp->func;
 800c902:	68fb      	ldr	r3, [r7, #12]
 800c904:	68db      	ldr	r3, [r3, #12]
 800c906:	607b      	str	r3, [r7, #4]
    vtp->func = NULL;
 800c908:	68fb      	ldr	r3, [r7, #12]
 800c90a:	2200      	movs	r2, #0
 800c90c:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800c90e:	4b27      	ldr	r3, [pc, #156]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c910:	69db      	ldr	r3, [r3, #28]
 800c912:	4a27      	ldr	r2, [pc, #156]	; (800c9b0 <chVTDoTickI.lto_priv.327+0xe8>)
 800c914:	4293      	cmp	r3, r2
 800c916:	d101      	bne.n	800c91c <chVTDoTickI.lto_priv.327+0x54>
      port_timer_stop_alarm();
 800c918:	f7ff ff9c 	bl	800c854 <port_timer_stop_alarm>
>>>>>>> 752c83b... update binaries
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
<<<<<<< HEAD
 800c894:	f7ff ffc4 	bl	800c820 <chSysUnlockFromISR.lto_priv.316>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800c898:	68fb      	ldr	r3, [r7, #12]
 800c89a:	691a      	ldr	r2, [r3, #16]
 800c89c:	687b      	ldr	r3, [r7, #4]
 800c89e:	4610      	mov	r0, r2
 800c8a0:	4798      	blx	r3
=======
 800c91c:	f7ff ffc4 	bl	800c8a8 <chSysUnlockFromISR.lto_priv.313>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800c920:	68fb      	ldr	r3, [r7, #12]
 800c922:	691a      	ldr	r2, [r3, #16]
 800c924:	687b      	ldr	r3, [r7, #4]
 800c926:	4610      	mov	r0, r2
 800c928:	4798      	blx	r3
>>>>>>> 752c83b... update binaries

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
<<<<<<< HEAD
 800c8a2:	f7ff ffb5 	bl	800c810 <chSysLockFromISR.lto_priv.318>
=======
 800c92a:	f7ff ffb5 	bl	800c898 <chSysLockFromISR.lto_priv.315>
>>>>>>> 752c83b... update binaries

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
<<<<<<< HEAD
 800c8a6:	4b1f      	ldr	r3, [pc, #124]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c8a8:	69db      	ldr	r3, [r3, #28]
 800c8aa:	60fb      	str	r3, [r7, #12]
    now = chVTGetSystemTimeX();
 800c8ac:	f7ff ffc0 	bl	800c830 <chVTGetSystemTimeX>
 800c8b0:	4603      	mov	r3, r0
 800c8b2:	817b      	strh	r3, [r7, #10]
=======
 800c92e:	4b1f      	ldr	r3, [pc, #124]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c930:	69db      	ldr	r3, [r3, #28]
 800c932:	60fb      	str	r3, [r7, #12]
    now = chVTGetSystemTimeX();
 800c934:	f7ff ffc0 	bl	800c8b8 <chVTGetSystemTimeX>
 800c938:	4603      	mov	r3, r0
 800c93a:	817b      	strh	r3, [r7, #10]
>>>>>>> 752c83b... update binaries

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
<<<<<<< HEAD
 800c8b4:	68fb      	ldr	r3, [r7, #12]
 800c8b6:	891a      	ldrh	r2, [r3, #8]
 800c8b8:	4b1a      	ldr	r3, [pc, #104]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c8ba:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800c8bc:	8979      	ldrh	r1, [r7, #10]
 800c8be:	1acb      	subs	r3, r1, r3
 800c8c0:	b29b      	uxth	r3, r3
 800c8c2:	429a      	cmp	r2, r3
 800c8c4:	d9c9      	bls.n	800c85a <chVTDoTickI.lto_priv.330+0x1a>
=======
 800c93c:	68fb      	ldr	r3, [r7, #12]
 800c93e:	891a      	ldrh	r2, [r3, #8]
 800c940:	4b1a      	ldr	r3, [pc, #104]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c942:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800c944:	8979      	ldrh	r1, [r7, #10]
 800c946:	1acb      	subs	r3, r1, r3
 800c948:	b29b      	uxth	r3, r3
 800c94a:	429a      	cmp	r2, r3
 800c94c:	d9c9      	bls.n	800c8e2 <chVTDoTickI.lto_priv.327+0x1a>
>>>>>>> 752c83b... update binaries
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
<<<<<<< HEAD
 800c8c6:	4b17      	ldr	r3, [pc, #92]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c8c8:	69db      	ldr	r3, [r3, #28]
 800c8ca:	4a17      	ldr	r2, [pc, #92]	; (800c928 <chVTDoTickI.lto_priv.330+0xe8>)
 800c8cc:	4293      	cmp	r3, r2
 800c8ce:	d026      	beq.n	800c91e <chVTDoTickI.lto_priv.330+0xde>
=======
 800c94e:	4b17      	ldr	r3, [pc, #92]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c950:	69db      	ldr	r3, [r3, #28]
 800c952:	4a17      	ldr	r2, [pc, #92]	; (800c9b0 <chVTDoTickI.lto_priv.327+0xe8>)
 800c954:	4293      	cmp	r3, r2
 800c956:	d026      	beq.n	800c9a6 <chVTDoTickI.lto_priv.327+0xde>
>>>>>>> 752c83b... update binaries
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
<<<<<<< HEAD
 800c8d0:	4b14      	ldr	r3, [pc, #80]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c8d2:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800c8d4:	68fb      	ldr	r3, [r7, #12]
 800c8d6:	891b      	ldrh	r3, [r3, #8]
 800c8d8:	4413      	add	r3, r2
 800c8da:	b29a      	uxth	r2, r3
 800c8dc:	897b      	ldrh	r3, [r7, #10]
 800c8de:	1ad3      	subs	r3, r2, r3
 800c8e0:	813b      	strh	r3, [r7, #8]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800c8e2:	893b      	ldrh	r3, [r7, #8]
 800c8e4:	2b01      	cmp	r3, #1
 800c8e6:	d801      	bhi.n	800c8ec <chVTDoTickI.lto_priv.330+0xac>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800c8e8:	2302      	movs	r3, #2
 800c8ea:	813b      	strh	r3, [r7, #8]
  }
  port_timer_set_alarm(now + delta);
 800c8ec:	897a      	ldrh	r2, [r7, #10]
 800c8ee:	893b      	ldrh	r3, [r7, #8]
 800c8f0:	4413      	add	r3, r2
 800c8f2:	b29b      	uxth	r3, r3
 800c8f4:	4618      	mov	r0, r3
 800c8f6:	f7ff ff6f 	bl	800c7d8 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 800c8fa:	f7ff ff99 	bl	800c830 <chVTGetSystemTimeX>
 800c8fe:	4603      	mov	r3, r0
 800c900:	461a      	mov	r2, r3
 800c902:	4b08      	ldr	r3, [pc, #32]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c904:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800c906:	1ad2      	subs	r2, r2, r3
 800c908:	8979      	ldrh	r1, [r7, #10]
 800c90a:	893b      	ldrh	r3, [r7, #8]
 800c90c:	440b      	add	r3, r1
 800c90e:	4905      	ldr	r1, [pc, #20]	; (800c924 <chVTDoTickI.lto_priv.330+0xe4>)
 800c910:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 800c912:	1a5b      	subs	r3, r3, r1
 800c914:	429a      	cmp	r2, r3
 800c916:	dd02      	ble.n	800c91e <chVTDoTickI.lto_priv.330+0xde>
 800c918:	4804      	ldr	r0, [pc, #16]	; (800c92c <chVTDoTickI.lto_priv.330+0xec>)
 800c91a:	f7fe fa43 	bl	800ada4 <chSysHalt>
=======
 800c958:	4b14      	ldr	r3, [pc, #80]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c95a:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800c95c:	68fb      	ldr	r3, [r7, #12]
 800c95e:	891b      	ldrh	r3, [r3, #8]
 800c960:	4413      	add	r3, r2
 800c962:	b29a      	uxth	r2, r3
 800c964:	897b      	ldrh	r3, [r7, #10]
 800c966:	1ad3      	subs	r3, r2, r3
 800c968:	813b      	strh	r3, [r7, #8]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800c96a:	893b      	ldrh	r3, [r7, #8]
 800c96c:	2b01      	cmp	r3, #1
 800c96e:	d801      	bhi.n	800c974 <chVTDoTickI.lto_priv.327+0xac>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800c970:	2302      	movs	r3, #2
 800c972:	813b      	strh	r3, [r7, #8]
  }
  port_timer_set_alarm(now + delta);
 800c974:	897a      	ldrh	r2, [r7, #10]
 800c976:	893b      	ldrh	r3, [r7, #8]
 800c978:	4413      	add	r3, r2
 800c97a:	b29b      	uxth	r3, r3
 800c97c:	4618      	mov	r0, r3
 800c97e:	f7ff ff6f 	bl	800c860 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 800c982:	f7ff ff99 	bl	800c8b8 <chVTGetSystemTimeX>
 800c986:	4603      	mov	r3, r0
 800c988:	461a      	mov	r2, r3
 800c98a:	4b08      	ldr	r3, [pc, #32]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c98c:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 800c98e:	1ad2      	subs	r2, r2, r3
 800c990:	8979      	ldrh	r1, [r7, #10]
 800c992:	893b      	ldrh	r3, [r7, #8]
 800c994:	440b      	add	r3, r1
 800c996:	4905      	ldr	r1, [pc, #20]	; (800c9ac <chVTDoTickI.lto_priv.327+0xe4>)
 800c998:	8cc9      	ldrh	r1, [r1, #38]	; 0x26
 800c99a:	1a5b      	subs	r3, r3, r1
 800c99c:	429a      	cmp	r2, r3
 800c99e:	dd02      	ble.n	800c9a6 <chVTDoTickI.lto_priv.327+0xde>
 800c9a0:	4804      	ldr	r0, [pc, #16]	; (800c9b4 <chVTDoTickI.lto_priv.327+0xec>)
 800c9a2:	f7fe fa43 	bl	800ae2c <chSysHalt>
>>>>>>> 752c83b... update binaries
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
<<<<<<< HEAD
 800c91e:	3710      	adds	r7, #16
 800c920:	46bd      	mov	sp, r7
 800c922:	bd80      	pop	{r7, pc}
 800c924:	20001338 	.word	0x20001338
 800c928:	20001354 	.word	0x20001354
 800c92c:	0800e870 	.word	0x0800e870

0800c930 <_idle_thread.lto_priv.47>:
=======
 800c9a6:	3710      	adds	r7, #16
 800c9a8:	46bd      	mov	sp, r7
 800c9aa:	bd80      	pop	{r7, pc}
 800c9ac:	20001338 	.word	0x20001338
 800c9b0:	20001354 	.word	0x20001354
 800c9b4:	0800e948 	.word	0x0800e948

0800c9b8 <_idle_thread.lto_priv.47>:
>>>>>>> 752c83b... update binaries
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
<<<<<<< HEAD
 800c930:	b580      	push	{r7, lr}
 800c932:	b082      	sub	sp, #8
 800c934:	af00      	add	r7, sp, #0
 800c936:	6078      	str	r0, [r7, #4]
=======
 800c9b8:	b580      	push	{r7, lr}
 800c9ba:	b082      	sub	sp, #8
 800c9bc:	af00      	add	r7, sp, #0
 800c9be:	6078      	str	r0, [r7, #4]
>>>>>>> 752c83b... update binaries
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
<<<<<<< HEAD
 800c938:	f7ff ff36 	bl	800c7a8 <port_wait_for_interrupt>
 800c93c:	e7fc      	b.n	800c938 <_idle_thread.lto_priv.47+0x8>
 800c93e:	bf00      	nop

0800c940 <chSysInit>:
=======
 800c9c0:	f7ff ff36 	bl	800c830 <port_wait_for_interrupt>
 800c9c4:	e7fc      	b.n	800c9c0 <_idle_thread.lto_priv.47+0x8>
 800c9c6:	bf00      	nop

0800c9c8 <chSysInit>:
>>>>>>> 752c83b... update binaries
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
<<<<<<< HEAD
 800c940:	b580      	push	{r7, lr}
 800c942:	af00      	add	r7, sp, #0

  _scheduler_init();
 800c944:	f7fe fd18 	bl	800b378 <_scheduler_init>
  _vt_init();
 800c948:	f7fe fb68 	bl	800b01c <_vt_init>
=======
 800c9c8:	b580      	push	{r7, lr}
 800c9ca:	af00      	add	r7, sp, #0

  _scheduler_init();
 800c9cc:	f7fe fd18 	bl	800b400 <_scheduler_init>
  _vt_init();
 800c9d0:	f7fe fb68 	bl	800b0a4 <_vt_init>
>>>>>>> 752c83b... update binaries
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
<<<<<<< HEAD
 800c94c:	4b10      	ldr	r3, [pc, #64]	; (800c990 <chSysInit+0x50>)
 800c94e:	2200      	movs	r2, #0
 800c950:	62da      	str	r2, [r3, #44]	; 0x2c
  ch.dbg.lock_cnt = (cnt_t)0;
 800c952:	4b0f      	ldr	r3, [pc, #60]	; (800c990 <chSysInit+0x50>)
 800c954:	2200      	movs	r2, #0
 800c956:	631a      	str	r2, [r3, #48]	; 0x30
=======
 800c9d4:	4b10      	ldr	r3, [pc, #64]	; (800ca18 <chSysInit+0x50>)
 800c9d6:	2200      	movs	r2, #0
 800c9d8:	62da      	str	r2, [r3, #44]	; 0x2c
  ch.dbg.lock_cnt = (cnt_t)0;
 800c9da:	4b0f      	ldr	r3, [pc, #60]	; (800ca18 <chSysInit+0x50>)
 800c9dc:	2200      	movs	r2, #0
 800c9de:	631a      	str	r2, [r3, #48]	; 0x30
>>>>>>> 752c83b... update binaries
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
<<<<<<< HEAD
 800c958:	f7fd f856 	bl	8009a08 <_core_init>
=======
 800c9e0:	f7fd f856 	bl	8009a90 <_core_init>
>>>>>>> 752c83b... update binaries
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
<<<<<<< HEAD
 800c95c:	480d      	ldr	r0, [pc, #52]	; (800c994 <chSysInit+0x54>)
 800c95e:	490e      	ldr	r1, [pc, #56]	; (800c998 <chSysInit+0x58>)
 800c960:	2280      	movs	r2, #128	; 0x80
 800c962:	f7ff f839 	bl	800b9d8 <_thread_init>
 800c966:	4602      	mov	r2, r0
 800c968:	4b09      	ldr	r3, [pc, #36]	; (800c990 <chSysInit+0x50>)
 800c96a:	619a      	str	r2, [r3, #24]
=======
 800c9e4:	480d      	ldr	r0, [pc, #52]	; (800ca1c <chSysInit+0x54>)
 800c9e6:	490e      	ldr	r1, [pc, #56]	; (800ca20 <chSysInit+0x58>)
 800c9e8:	2280      	movs	r2, #128	; 0x80
 800c9ea:	f7ff f839 	bl	800ba60 <_thread_init>
 800c9ee:	4602      	mov	r2, r0
 800c9f0:	4b09      	ldr	r3, [pc, #36]	; (800ca18 <chSysInit+0x50>)
 800c9f2:	619a      	str	r2, [r3, #24]
>>>>>>> 752c83b... update binaries
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
<<<<<<< HEAD
 800c96c:	4b08      	ldr	r3, [pc, #32]	; (800c990 <chSysInit+0x50>)
 800c96e:	699b      	ldr	r3, [r3, #24]
 800c970:	4a0a      	ldr	r2, [pc, #40]	; (800c99c <chSysInit+0x5c>)
 800c972:	61da      	str	r2, [r3, #28]
=======
 800c9f4:	4b08      	ldr	r3, [pc, #32]	; (800ca18 <chSysInit+0x50>)
 800c9f6:	699b      	ldr	r3, [r3, #24]
 800c9f8:	4a0a      	ldr	r2, [pc, #40]	; (800ca24 <chSysInit+0x5c>)
 800c9fa:	61da      	str	r2, [r3, #28]
>>>>>>> 752c83b... update binaries
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
<<<<<<< HEAD
 800c974:	4b06      	ldr	r3, [pc, #24]	; (800c990 <chSysInit+0x50>)
 800c976:	699b      	ldr	r3, [r3, #24]
 800c978:	2201      	movs	r2, #1
 800c97a:	f883 2020 	strb.w	r2, [r3, #32]
=======
 800c9fc:	4b06      	ldr	r3, [pc, #24]	; (800ca18 <chSysInit+0x50>)
 800c9fe:	699b      	ldr	r3, [r3, #24]
 800ca00:	2201      	movs	r2, #1
 800ca02:	f883 2020 	strb.w	r2, [r3, #32]
>>>>>>> 752c83b... update binaries

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
<<<<<<< HEAD
 800c97e:	f7ff feb5 	bl	800c6ec <port_init>
=======
 800ca06:	f7ff feb5 	bl	800c774 <port_init>
>>>>>>> 752c83b... update binaries
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
<<<<<<< HEAD
 800c982:	f7ff ff3d 	bl	800c800 <chSysEnable>
=======
 800ca0a:	f7ff ff3d 	bl	800c888 <chSysEnable>
>>>>>>> 752c83b... update binaries
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
<<<<<<< HEAD
 800c986:	4806      	ldr	r0, [pc, #24]	; (800c9a0 <chSysInit+0x60>)
 800c988:	f7ff f8d6 	bl	800bb38 <chThdCreate>
  }
#endif
}
 800c98c:	bd80      	pop	{r7, pc}
 800c98e:	bf00      	nop
 800c990:	20001338 	.word	0x20001338
 800c994:	2000136c 	.word	0x2000136c
 800c998:	0800e974 	.word	0x0800e974
 800c99c:	20000500 	.word	0x20000500
 800c9a0:	0800e858 	.word	0x0800e858

0800c9a4 <_local_ctor_4>:
=======
 800ca0e:	4806      	ldr	r0, [pc, #24]	; (800ca28 <chSysInit+0x60>)
 800ca10:	f7ff f8d6 	bl	800bbc0 <chThdCreate>
  }
#endif
}
 800ca14:	bd80      	pop	{r7, pc}
 800ca16:	bf00      	nop
 800ca18:	20001338 	.word	0x20001338
 800ca1c:	2000136c 	.word	0x2000136c
 800ca20:	0800ea4c 	.word	0x0800ea4c
 800ca24:	20000500 	.word	0x20000500
 800ca28:	0800e930 	.word	0x0800e930

0800ca2c <_local_ctor_4>:
>>>>>>> 752c83b... update binaries
#include <modules/pubsub/pubsub.h>
#include <modules/worker_thread/worker_thread.h>

WORKER_THREAD_TAKEOVER_MAIN(lpwork_thread, LOWPRIO)
<<<<<<< HEAD
 800c9a4:	b580      	push	{r7, lr}
 800c9a6:	af00      	add	r7, sp, #0
 800c9a8:	4802      	ldr	r0, [pc, #8]	; (800c9b4 <_local_ctor_4+0x10>)
 800c9aa:	4903      	ldr	r1, [pc, #12]	; (800c9b8 <_local_ctor_4+0x14>)
 800c9ac:	2202      	movs	r2, #2
 800c9ae:	f7fb fefb 	bl	80087a8 <worker_thread_init>
 800c9b2:	bd80      	pop	{r7, pc}
 800c9b4:	20000a20 	.word	0x20000a20
 800c9b8:	0800e6d8 	.word	0x0800e6d8

0800c9bc <main>:
 800c9bc:	b580      	push	{r7, lr}
 800c9be:	af00      	add	r7, sp, #0
 800c9c0:	4802      	ldr	r0, [pc, #8]	; (800c9cc <main+0x10>)
 800c9c2:	f7f9 fff5 	bl	80069b0 <worker_thread_takeover>
 800c9c6:	2300      	movs	r3, #0
 800c9c8:	4618      	mov	r0, r3
 800c9ca:	bd80      	pop	{r7, pc}
 800c9cc:	20000a20 	.word	0x20000a20

0800c9d0 <_local_ctor_5>:
WORKER_THREAD_SPAWN(can_thread, LOWPRIO, 4096)
 800c9d0:	b580      	push	{r7, lr}
 800c9d2:	af00      	add	r7, sp, #0
 800c9d4:	4805      	ldr	r0, [pc, #20]	; (800c9ec <_local_ctor_5+0x1c>)
 800c9d6:	4906      	ldr	r1, [pc, #24]	; (800c9f0 <_local_ctor_5+0x20>)
 800c9d8:	2202      	movs	r2, #2
 800c9da:	f7fb fee5 	bl	80087a8 <worker_thread_init>
 800c9de:	4803      	ldr	r0, [pc, #12]	; (800c9ec <_local_ctor_5+0x1c>)
 800c9e0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800c9e4:	f7fb ff06 	bl	80087f4 <worker_thread_start>
 800c9e8:	bd80      	pop	{r7, pc}
 800c9ea:	bf00      	nop
 800c9ec:	20000a3c 	.word	0x20000a3c
 800c9f0:	0800e6e8 	.word	0x0800e6e8

0800c9f4 <_local_ctor_7>:

PUBSUB_TOPIC_GROUP_CREATE(default_topic_group, 2048)
 800c9f4:	b580      	push	{r7, lr}
 800c9f6:	af00      	add	r7, sp, #0
 800c9f8:	4803      	ldr	r0, [pc, #12]	; (800ca08 <_local_ctor_7+0x14>)
 800c9fa:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800c9fe:	4a03      	ldr	r2, [pc, #12]	; (800ca0c <_local_ctor_7+0x18>)
 800ca00:	f7fb fb9e 	bl	8008140 <pubsub_create_topic_group>
 800ca04:	bd80      	pop	{r7, pc}
 800ca06:	bf00      	nop
 800ca08:	20000a58 	.word	0x20000a58
 800ca0c:	20000a68 	.word	0x20000a68

0800ca10 <canardInit>:
=======
 800ca2c:	b580      	push	{r7, lr}
 800ca2e:	af00      	add	r7, sp, #0
 800ca30:	4802      	ldr	r0, [pc, #8]	; (800ca3c <_local_ctor_4+0x10>)
 800ca32:	4903      	ldr	r1, [pc, #12]	; (800ca40 <_local_ctor_4+0x14>)
 800ca34:	2202      	movs	r2, #2
 800ca36:	f7fb fec3 	bl	80087c0 <worker_thread_init>
 800ca3a:	bd80      	pop	{r7, pc}
 800ca3c:	20000a20 	.word	0x20000a20
 800ca40:	0800e7b4 	.word	0x0800e7b4

0800ca44 <main>:
 800ca44:	b580      	push	{r7, lr}
 800ca46:	af00      	add	r7, sp, #0
 800ca48:	4802      	ldr	r0, [pc, #8]	; (800ca54 <main+0x10>)
 800ca4a:	f7f9 ff87 	bl	800695c <worker_thread_takeover>
 800ca4e:	2300      	movs	r3, #0
 800ca50:	4618      	mov	r0, r3
 800ca52:	bd80      	pop	{r7, pc}
 800ca54:	20000a20 	.word	0x20000a20

0800ca58 <_local_ctor_5>:
WORKER_THREAD_SPAWN(can_thread, LOWPRIO, 4096)
 800ca58:	b580      	push	{r7, lr}
 800ca5a:	af00      	add	r7, sp, #0
 800ca5c:	4805      	ldr	r0, [pc, #20]	; (800ca74 <_local_ctor_5+0x1c>)
 800ca5e:	4906      	ldr	r1, [pc, #24]	; (800ca78 <_local_ctor_5+0x20>)
 800ca60:	2202      	movs	r2, #2
 800ca62:	f7fb fead 	bl	80087c0 <worker_thread_init>
 800ca66:	4803      	ldr	r0, [pc, #12]	; (800ca74 <_local_ctor_5+0x1c>)
 800ca68:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800ca6c:	f7fb fece 	bl	800880c <worker_thread_start>
 800ca70:	bd80      	pop	{r7, pc}
 800ca72:	bf00      	nop
 800ca74:	20000a3c 	.word	0x20000a3c
 800ca78:	0800e7c4 	.word	0x0800e7c4

0800ca7c <_local_ctor_7>:

PUBSUB_TOPIC_GROUP_CREATE(default_topic_group, 2048)
 800ca7c:	b580      	push	{r7, lr}
 800ca7e:	af00      	add	r7, sp, #0
 800ca80:	4803      	ldr	r0, [pc, #12]	; (800ca90 <_local_ctor_7+0x14>)
 800ca82:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800ca86:	4a03      	ldr	r2, [pc, #12]	; (800ca94 <_local_ctor_7+0x18>)
 800ca88:	f7fb fb82 	bl	8008190 <pubsub_create_topic_group>
 800ca8c:	bd80      	pop	{r7, pc}
 800ca8e:	bf00      	nop
 800ca90:	20000a58 	.word	0x20000a58
 800ca94:	20000a68 	.word	0x20000a68

0800ca98 <canardInit>:
>>>>>>> 752c83b... update binaries
                void* mem_arena,
                size_t mem_arena_size,
                CanardOnTransferReception on_reception,
                CanardShouldAcceptTransfer should_accept,
                void* user_reference)
{
<<<<<<< HEAD
 800ca10:	b580      	push	{r7, lr}
 800ca12:	b086      	sub	sp, #24
 800ca14:	af00      	add	r7, sp, #0
 800ca16:	60f8      	str	r0, [r7, #12]
 800ca18:	60b9      	str	r1, [r7, #8]
 800ca1a:	607a      	str	r2, [r7, #4]
 800ca1c:	603b      	str	r3, [r7, #0]
=======
 800ca98:	b580      	push	{r7, lr}
 800ca9a:	b086      	sub	sp, #24
 800ca9c:	af00      	add	r7, sp, #0
 800ca9e:	60f8      	str	r0, [r7, #12]
 800caa0:	60b9      	str	r1, [r7, #8]
 800caa2:	607a      	str	r2, [r7, #4]
 800caa4:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
     * If your application fails here, make sure it's not built in 64-bit mode.
     * Refer to the design documentation for more info.
     */
    CANARD_ASSERT(CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE >= 6);

    memset(out_ins, 0, sizeof(*out_ins));
<<<<<<< HEAD
 800ca1e:	68f8      	ldr	r0, [r7, #12]
 800ca20:	2100      	movs	r1, #0
 800ca22:	2224      	movs	r2, #36	; 0x24
 800ca24:	f001 fdd0 	bl	800e5c8 <memset>

    out_ins->node_id = CANARD_BROADCAST_NODE_ID;
 800ca28:	68fb      	ldr	r3, [r7, #12]
 800ca2a:	2200      	movs	r2, #0
 800ca2c:	701a      	strb	r2, [r3, #0]
    out_ins->on_reception = on_reception;
 800ca2e:	68fb      	ldr	r3, [r7, #12]
 800ca30:	683a      	ldr	r2, [r7, #0]
 800ca32:	609a      	str	r2, [r3, #8]
    out_ins->should_accept = should_accept;
 800ca34:	68fb      	ldr	r3, [r7, #12]
 800ca36:	6a3a      	ldr	r2, [r7, #32]
 800ca38:	605a      	str	r2, [r3, #4]
    out_ins->rx_states = NULL;
 800ca3a:	68fb      	ldr	r3, [r7, #12]
 800ca3c:	2200      	movs	r2, #0
 800ca3e:	619a      	str	r2, [r3, #24]
    out_ins->tx_queue = NULL;
 800ca40:	68fb      	ldr	r3, [r7, #12]
 800ca42:	2200      	movs	r2, #0
 800ca44:	61da      	str	r2, [r3, #28]
    out_ins->user_reference = user_reference;
 800ca46:	68fb      	ldr	r3, [r7, #12]
 800ca48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ca4a:	621a      	str	r2, [r3, #32]

    size_t pool_capacity = mem_arena_size / CANARD_MEM_BLOCK_SIZE;
 800ca4c:	687b      	ldr	r3, [r7, #4]
 800ca4e:	095b      	lsrs	r3, r3, #5
 800ca50:	617b      	str	r3, [r7, #20]
    if (pool_capacity > 0xFFFFU)
 800ca52:	697b      	ldr	r3, [r7, #20]
 800ca54:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800ca58:	d302      	bcc.n	800ca60 <canardInit+0x50>
    {
        pool_capacity = 0xFFFFU;
 800ca5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800ca5e:	617b      	str	r3, [r7, #20]
    }

    initPoolAllocator(&out_ins->allocator, mem_arena, (uint16_t)pool_capacity);
 800ca60:	68fb      	ldr	r3, [r7, #12]
 800ca62:	f103 020c 	add.w	r2, r3, #12
 800ca66:	697b      	ldr	r3, [r7, #20]
 800ca68:	b29b      	uxth	r3, r3
 800ca6a:	4610      	mov	r0, r2
 800ca6c:	68b9      	ldr	r1, [r7, #8]
 800ca6e:	461a      	mov	r2, r3
 800ca70:	f001 fa66 	bl	800df40 <initPoolAllocator>
}
 800ca74:	3718      	adds	r7, #24
 800ca76:	46bd      	mov	sp, r7
 800ca78:	bd80      	pop	{r7, pc}
 800ca7a:	bf00      	nop

0800ca7c <canardGetUserReference>:

void* canardGetUserReference(CanardInstance* ins)
{
 800ca7c:	b480      	push	{r7}
 800ca7e:	b083      	sub	sp, #12
 800ca80:	af00      	add	r7, sp, #0
 800ca82:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(ins != NULL);
    return ins->user_reference;
 800ca84:	687b      	ldr	r3, [r7, #4]
 800ca86:	6a1b      	ldr	r3, [r3, #32]
}
 800ca88:	4618      	mov	r0, r3
 800ca8a:	370c      	adds	r7, #12
 800ca8c:	46bd      	mov	sp, r7
 800ca8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca92:	4770      	bx	lr

0800ca94 <canardSetLocalNodeID>:

void canardSetLocalNodeID(CanardInstance* ins, uint8_t self_node_id)
{
 800ca94:	b480      	push	{r7}
 800ca96:	b083      	sub	sp, #12
 800ca98:	af00      	add	r7, sp, #0
 800ca9a:	6078      	str	r0, [r7, #4]
 800ca9c:	460b      	mov	r3, r1
 800ca9e:	70fb      	strb	r3, [r7, #3]
    CANARD_ASSERT(ins != NULL);

    if ((ins->node_id == CANARD_BROADCAST_NODE_ID) &&
 800caa0:	687b      	ldr	r3, [r7, #4]
 800caa2:	781b      	ldrb	r3, [r3, #0]
 800caa4:	2b00      	cmp	r3, #0
 800caa6:	d109      	bne.n	800cabc <canardSetLocalNodeID+0x28>
 800caa8:	78fb      	ldrb	r3, [r7, #3]
 800caaa:	2b00      	cmp	r3, #0
 800caac:	d006      	beq.n	800cabc <canardSetLocalNodeID+0x28>
        (self_node_id >= CANARD_MIN_NODE_ID) &&
        (self_node_id <= CANARD_MAX_NODE_ID))
 800caae:	78fb      	ldrb	r3, [r7, #3]
=======
 800caa6:	68f8      	ldr	r0, [r7, #12]
 800caa8:	2100      	movs	r1, #0
 800caaa:	2224      	movs	r2, #36	; 0x24
 800caac:	f001 fdd0 	bl	800e650 <memset>

    out_ins->node_id = CANARD_BROADCAST_NODE_ID;
 800cab0:	68fb      	ldr	r3, [r7, #12]
 800cab2:	2200      	movs	r2, #0
 800cab4:	701a      	strb	r2, [r3, #0]
    out_ins->on_reception = on_reception;
 800cab6:	68fb      	ldr	r3, [r7, #12]
 800cab8:	683a      	ldr	r2, [r7, #0]
 800caba:	609a      	str	r2, [r3, #8]
    out_ins->should_accept = should_accept;
 800cabc:	68fb      	ldr	r3, [r7, #12]
 800cabe:	6a3a      	ldr	r2, [r7, #32]
 800cac0:	605a      	str	r2, [r3, #4]
    out_ins->rx_states = NULL;
 800cac2:	68fb      	ldr	r3, [r7, #12]
 800cac4:	2200      	movs	r2, #0
 800cac6:	619a      	str	r2, [r3, #24]
    out_ins->tx_queue = NULL;
 800cac8:	68fb      	ldr	r3, [r7, #12]
 800caca:	2200      	movs	r2, #0
 800cacc:	61da      	str	r2, [r3, #28]
    out_ins->user_reference = user_reference;
 800cace:	68fb      	ldr	r3, [r7, #12]
 800cad0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cad2:	621a      	str	r2, [r3, #32]

    size_t pool_capacity = mem_arena_size / CANARD_MEM_BLOCK_SIZE;
 800cad4:	687b      	ldr	r3, [r7, #4]
 800cad6:	095b      	lsrs	r3, r3, #5
 800cad8:	617b      	str	r3, [r7, #20]
    if (pool_capacity > 0xFFFFU)
 800cada:	697b      	ldr	r3, [r7, #20]
 800cadc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800cae0:	d302      	bcc.n	800cae8 <canardInit+0x50>
    {
        pool_capacity = 0xFFFFU;
 800cae2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800cae6:	617b      	str	r3, [r7, #20]
    }

    initPoolAllocator(&out_ins->allocator, mem_arena, (uint16_t)pool_capacity);
 800cae8:	68fb      	ldr	r3, [r7, #12]
 800caea:	f103 020c 	add.w	r2, r3, #12
 800caee:	697b      	ldr	r3, [r7, #20]
 800caf0:	b29b      	uxth	r3, r3
 800caf2:	4610      	mov	r0, r2
 800caf4:	68b9      	ldr	r1, [r7, #8]
 800caf6:	461a      	mov	r2, r3
 800caf8:	f001 fa66 	bl	800dfc8 <initPoolAllocator>
}
 800cafc:	3718      	adds	r7, #24
 800cafe:	46bd      	mov	sp, r7
 800cb00:	bd80      	pop	{r7, pc}
 800cb02:	bf00      	nop

0800cb04 <canardGetUserReference>:

void* canardGetUserReference(CanardInstance* ins)
{
 800cb04:	b480      	push	{r7}
 800cb06:	b083      	sub	sp, #12
 800cb08:	af00      	add	r7, sp, #0
 800cb0a:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(ins != NULL);
    return ins->user_reference;
 800cb0c:	687b      	ldr	r3, [r7, #4]
 800cb0e:	6a1b      	ldr	r3, [r3, #32]
}
 800cb10:	4618      	mov	r0, r3
 800cb12:	370c      	adds	r7, #12
 800cb14:	46bd      	mov	sp, r7
 800cb16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb1a:	4770      	bx	lr

0800cb1c <canardSetLocalNodeID>:

void canardSetLocalNodeID(CanardInstance* ins, uint8_t self_node_id)
{
 800cb1c:	b480      	push	{r7}
 800cb1e:	b083      	sub	sp, #12
 800cb20:	af00      	add	r7, sp, #0
 800cb22:	6078      	str	r0, [r7, #4]
 800cb24:	460b      	mov	r3, r1
 800cb26:	70fb      	strb	r3, [r7, #3]
    CANARD_ASSERT(ins != NULL);

    if ((ins->node_id == CANARD_BROADCAST_NODE_ID) &&
 800cb28:	687b      	ldr	r3, [r7, #4]
 800cb2a:	781b      	ldrb	r3, [r3, #0]
 800cb2c:	2b00      	cmp	r3, #0
 800cb2e:	d109      	bne.n	800cb44 <canardSetLocalNodeID+0x28>
 800cb30:	78fb      	ldrb	r3, [r7, #3]
 800cb32:	2b00      	cmp	r3, #0
 800cb34:	d006      	beq.n	800cb44 <canardSetLocalNodeID+0x28>
        (self_node_id >= CANARD_MIN_NODE_ID) &&
        (self_node_id <= CANARD_MAX_NODE_ID))
 800cb36:	78fb      	ldrb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
void canardSetLocalNodeID(CanardInstance* ins, uint8_t self_node_id)
{
    CANARD_ASSERT(ins != NULL);

    if ((ins->node_id == CANARD_BROADCAST_NODE_ID) &&
        (self_node_id >= CANARD_MIN_NODE_ID) &&
<<<<<<< HEAD
 800cab0:	b25b      	sxtb	r3, r3
 800cab2:	2b00      	cmp	r3, #0
 800cab4:	db02      	blt.n	800cabc <canardSetLocalNodeID+0x28>
        (self_node_id <= CANARD_MAX_NODE_ID))
    {
        ins->node_id = self_node_id;
 800cab6:	687b      	ldr	r3, [r7, #4]
 800cab8:	78fa      	ldrb	r2, [r7, #3]
 800caba:	701a      	strb	r2, [r3, #0]
=======
 800cb38:	b25b      	sxtb	r3, r3
 800cb3a:	2b00      	cmp	r3, #0
 800cb3c:	db02      	blt.n	800cb44 <canardSetLocalNodeID+0x28>
        (self_node_id <= CANARD_MAX_NODE_ID))
    {
        ins->node_id = self_node_id;
 800cb3e:	687b      	ldr	r3, [r7, #4]
 800cb40:	78fa      	ldrb	r2, [r7, #3]
 800cb42:	701a      	strb	r2, [r3, #0]
>>>>>>> 752c83b... update binaries
    }
    else
    {
        CANARD_ASSERT(false);
    }
}
<<<<<<< HEAD
 800cabc:	370c      	adds	r7, #12
 800cabe:	46bd      	mov	sp, r7
 800cac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cac4:	4770      	bx	lr
 800cac6:	bf00      	nop

0800cac8 <canardGetLocalNodeID>:

uint8_t canardGetLocalNodeID(const CanardInstance* ins)
{
 800cac8:	b480      	push	{r7}
 800caca:	b083      	sub	sp, #12
 800cacc:	af00      	add	r7, sp, #0
 800cace:	6078      	str	r0, [r7, #4]
    return ins->node_id;
 800cad0:	687b      	ldr	r3, [r7, #4]
 800cad2:	781b      	ldrb	r3, [r3, #0]
}
 800cad4:	4618      	mov	r0, r3
 800cad6:	370c      	adds	r7, #12
 800cad8:	46bd      	mov	sp, r7
 800cada:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cade:	4770      	bx	lr

0800cae0 <canardHandleRxFrame>:
=======
 800cb44:	370c      	adds	r7, #12
 800cb46:	46bd      	mov	sp, r7
 800cb48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb4c:	4770      	bx	lr
 800cb4e:	bf00      	nop

0800cb50 <canardGetLocalNodeID>:

uint8_t canardGetLocalNodeID(const CanardInstance* ins)
{
 800cb50:	b480      	push	{r7}
 800cb52:	b083      	sub	sp, #12
 800cb54:	af00      	add	r7, sp, #0
 800cb56:	6078      	str	r0, [r7, #4]
    return ins->node_id;
 800cb58:	687b      	ldr	r3, [r7, #4]
 800cb5a:	781b      	ldrb	r3, [r3, #0]
}
 800cb5c:	4618      	mov	r0, r3
 800cb5e:	370c      	adds	r7, #12
 800cb60:	46bd      	mov	sp, r7
 800cb62:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb66:	4770      	bx	lr

0800cb68 <canardHandleRxFrame>:
>>>>>>> 752c83b... update binaries
    ins->tx_queue = item->next;
    freeBlock(&ins->allocator, item);
}

void canardHandleRxFrame(CanardInstance* ins, const CanardCANFrame* frame, uint64_t timestamp_usec)
{
<<<<<<< HEAD
 800cae0:	b5b0      	push	{r4, r5, r7, lr}
 800cae2:	b0a0      	sub	sp, #128	; 0x80
 800cae4:	af02      	add	r7, sp, #8
 800cae6:	60f8      	str	r0, [r7, #12]
 800cae8:	60b9      	str	r1, [r7, #8]
 800caea:	e9c7 2300 	strd	r2, r3, [r7]
    const CanardTransferType transfer_type = extractTransferType(frame->id);
 800caee:	68bb      	ldr	r3, [r7, #8]
 800caf0:	681b      	ldr	r3, [r3, #0]
 800caf2:	4618      	mov	r0, r3
 800caf4:	f000 fdfe 	bl	800d6f4 <extractTransferType>
 800caf8:	4603      	mov	r3, r0
 800cafa:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
    const uint8_t destination_node_id = (transfer_type == CanardTransferTypeBroadcast) ?
 800cafe:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cb02:	2b02      	cmp	r3, #2
 800cb04:	d007      	beq.n	800cb16 <canardHandleRxFrame+0x36>
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);
 800cb06:	68bb      	ldr	r3, [r7, #8]
 800cb08:	681b      	ldr	r3, [r3, #0]
 800cb0a:	0a1b      	lsrs	r3, r3, #8
=======
 800cb68:	b5b0      	push	{r4, r5, r7, lr}
 800cb6a:	b0a0      	sub	sp, #128	; 0x80
 800cb6c:	af02      	add	r7, sp, #8
 800cb6e:	60f8      	str	r0, [r7, #12]
 800cb70:	60b9      	str	r1, [r7, #8]
 800cb72:	e9c7 2300 	strd	r2, r3, [r7]
    const CanardTransferType transfer_type = extractTransferType(frame->id);
 800cb76:	68bb      	ldr	r3, [r7, #8]
 800cb78:	681b      	ldr	r3, [r3, #0]
 800cb7a:	4618      	mov	r0, r3
 800cb7c:	f000 fdfe 	bl	800d77c <extractTransferType>
 800cb80:	4603      	mov	r3, r0
 800cb82:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
    const uint8_t destination_node_id = (transfer_type == CanardTransferTypeBroadcast) ?
 800cb86:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cb8a:	2b02      	cmp	r3, #2
 800cb8c:	d007      	beq.n	800cb9e <canardHandleRxFrame+0x36>
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);
 800cb8e:	68bb      	ldr	r3, [r7, #8]
 800cb90:	681b      	ldr	r3, [r3, #0]
 800cb92:	0a1b      	lsrs	r3, r3, #8
>>>>>>> 752c83b... update binaries
}

void canardHandleRxFrame(CanardInstance* ins, const CanardCANFrame* frame, uint64_t timestamp_usec)
{
    const CanardTransferType transfer_type = extractTransferType(frame->id);
    const uint8_t destination_node_id = (transfer_type == CanardTransferTypeBroadcast) ?
<<<<<<< HEAD
 800cb0c:	b2db      	uxtb	r3, r3
 800cb0e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800cb12:	b2db      	uxtb	r3, r3
 800cb14:	e000      	b.n	800cb18 <canardHandleRxFrame+0x38>
 800cb16:	2300      	movs	r3, #0
 800cb18:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
=======
 800cb94:	b2db      	uxtb	r3, r3
 800cb96:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800cb9a:	b2db      	uxtb	r3, r3
 800cb9c:	e000      	b.n	800cba0 <canardHandleRxFrame+0x38>
 800cb9e:	2300      	movs	r3, #0
 800cba0:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
>>>>>>> 752c83b... update binaries
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
<<<<<<< HEAD
 800cb1c:	68bb      	ldr	r3, [r7, #8]
 800cb1e:	681b      	ldr	r3, [r3, #0]
 800cb20:	2b00      	cmp	r3, #0
 800cb22:	f280 8308 	bge.w	800d136 <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
 800cb26:	68bb      	ldr	r3, [r7, #8]
 800cb28:	681b      	ldr	r3, [r3, #0]
 800cb2a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
=======
 800cba4:	68bb      	ldr	r3, [r7, #8]
 800cba6:	681b      	ldr	r3, [r3, #0]
 800cba8:	2b00      	cmp	r3, #0
 800cbaa:	f280 8308 	bge.w	800d1be <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
 800cbae:	68bb      	ldr	r3, [r7, #8]
 800cbb0:	681b      	ldr	r3, [r3, #0]
 800cbb2:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
>>>>>>> 752c83b... update binaries
                                        (uint8_t)CANARD_BROADCAST_NODE_ID :
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
<<<<<<< HEAD
 800cb2e:	2b00      	cmp	r3, #0
 800cb30:	f040 8301 	bne.w	800d136 <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
 800cb34:	68bb      	ldr	r3, [r7, #8]
 800cb36:	681b      	ldr	r3, [r3, #0]
 800cb38:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
=======
 800cbb6:	2b00      	cmp	r3, #0
 800cbb8:	f040 8301 	bne.w	800d1be <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
 800cbbc:	68bb      	ldr	r3, [r7, #8]
 800cbbe:	681b      	ldr	r3, [r3, #0]
 800cbc0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
>>>>>>> 752c83b... update binaries
                                        DEST_ID_FROM_ID(frame->id);

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
<<<<<<< HEAD
 800cb3c:	2b00      	cmp	r3, #0
 800cb3e:	f040 82fa 	bne.w	800d136 <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
        (frame->data_len < 1))
 800cb42:	68bb      	ldr	r3, [r7, #8]
 800cb44:	7b1b      	ldrb	r3, [r3, #12]
=======
 800cbc4:	2b00      	cmp	r3, #0
 800cbc6:	f040 82fa 	bne.w	800d1be <canardHandleRxFrame+0x656>
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
        (frame->data_len < 1))
 800cbca:	68bb      	ldr	r3, [r7, #8]
 800cbcc:	7b1b      	ldrb	r3, [r3, #12]
>>>>>>> 752c83b... update binaries

    // TODO: This function should maintain statistics of transfer errors and such.

    if ((frame->id & CANARD_CAN_FRAME_EFF) == 0 ||
        (frame->id & CANARD_CAN_FRAME_RTR) != 0 ||
        (frame->id & CANARD_CAN_FRAME_ERR) != 0 ||
<<<<<<< HEAD
 800cb46:	2b00      	cmp	r3, #0
 800cb48:	f000 82f5 	beq.w	800d136 <canardHandleRxFrame+0x656>
=======
 800cbce:	2b00      	cmp	r3, #0
 800cbd0:	f000 82f5 	beq.w	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
        (frame->data_len < 1))
    {
        return;     // Unsupported frame, not UAVCAN - ignore
    }

    if (transfer_type != CanardTransferTypeBroadcast &&
<<<<<<< HEAD
 800cb4c:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cb50:	2b02      	cmp	r3, #2
 800cb52:	d009      	beq.n	800cb68 <canardHandleRxFrame+0x88>
        destination_node_id != canardGetLocalNodeID(ins))
 800cb54:	68f8      	ldr	r0, [r7, #12]
 800cb56:	f7ff ffb7 	bl	800cac8 <canardGetLocalNodeID>
 800cb5a:	4603      	mov	r3, r0
 800cb5c:	461a      	mov	r2, r3
=======
 800cbd4:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cbd8:	2b02      	cmp	r3, #2
 800cbda:	d009      	beq.n	800cbf0 <canardHandleRxFrame+0x88>
        destination_node_id != canardGetLocalNodeID(ins))
 800cbdc:	68f8      	ldr	r0, [r7, #12]
 800cbde:	f7ff ffb7 	bl	800cb50 <canardGetLocalNodeID>
 800cbe2:	4603      	mov	r3, r0
 800cbe4:	461a      	mov	r2, r3
>>>>>>> 752c83b... update binaries
        (frame->data_len < 1))
    {
        return;     // Unsupported frame, not UAVCAN - ignore
    }

    if (transfer_type != CanardTransferTypeBroadcast &&
<<<<<<< HEAD
 800cb5e:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800cb62:	4293      	cmp	r3, r2
 800cb64:	f040 82e7 	bne.w	800d136 <canardHandleRxFrame+0x656>
=======
 800cbe6:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800cbea:	4293      	cmp	r3, r2
 800cbec:	f040 82e7 	bne.w	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
        destination_node_id != canardGetLocalNodeID(ins))
    {
        return;     // Address mismatch
    }

    const uint8_t priority = PRIORITY_FROM_ID(frame->id);
<<<<<<< HEAD
 800cb68:	68bb      	ldr	r3, [r7, #8]
 800cb6a:	681b      	ldr	r3, [r3, #0]
 800cb6c:	0e1b      	lsrs	r3, r3, #24
 800cb6e:	b2db      	uxtb	r3, r3
 800cb70:	f003 031f 	and.w	r3, r3, #31
 800cb74:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    const uint8_t source_node_id = SOURCE_ID_FROM_ID(frame->id);
 800cb78:	68bb      	ldr	r3, [r7, #8]
 800cb7a:	681b      	ldr	r3, [r3, #0]
 800cb7c:	b2db      	uxtb	r3, r3
 800cb7e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800cb82:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
    const uint16_t data_type_id = extractDataType(frame->id);
 800cb86:	68bb      	ldr	r3, [r7, #8]
 800cb88:	681b      	ldr	r3, [r3, #0]
 800cb8a:	4618      	mov	r0, r3
 800cb8c:	f000 fd90 	bl	800d6b0 <extractDataType>
 800cb90:	4603      	mov	r3, r0
 800cb92:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
    const uint32_t transfer_descriptor =
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);
 800cb96:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800cb9a:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cb9e:	041b      	lsls	r3, r3, #16
 800cba0:	431a      	orrs	r2, r3
 800cba2:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cba6:	049b      	lsls	r3, r3, #18
 800cba8:	431a      	orrs	r2, r3
 800cbaa:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800cbae:	065b      	lsls	r3, r3, #25
=======
 800cbf0:	68bb      	ldr	r3, [r7, #8]
 800cbf2:	681b      	ldr	r3, [r3, #0]
 800cbf4:	0e1b      	lsrs	r3, r3, #24
 800cbf6:	b2db      	uxtb	r3, r3
 800cbf8:	f003 031f 	and.w	r3, r3, #31
 800cbfc:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    const uint8_t source_node_id = SOURCE_ID_FROM_ID(frame->id);
 800cc00:	68bb      	ldr	r3, [r7, #8]
 800cc02:	681b      	ldr	r3, [r3, #0]
 800cc04:	b2db      	uxtb	r3, r3
 800cc06:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800cc0a:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
    const uint16_t data_type_id = extractDataType(frame->id);
 800cc0e:	68bb      	ldr	r3, [r7, #8]
 800cc10:	681b      	ldr	r3, [r3, #0]
 800cc12:	4618      	mov	r0, r3
 800cc14:	f000 fd90 	bl	800d738 <extractDataType>
 800cc18:	4603      	mov	r3, r0
 800cc1a:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
    const uint32_t transfer_descriptor =
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);
 800cc1e:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800cc22:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cc26:	041b      	lsls	r3, r3, #16
 800cc28:	431a      	orrs	r2, r3
 800cc2a:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cc2e:	049b      	lsls	r3, r3, #18
 800cc30:	431a      	orrs	r2, r3
 800cc32:	f897 305e 	ldrb.w	r3, [r7, #94]	; 0x5e
 800cc36:	065b      	lsls	r3, r3, #25
>>>>>>> 752c83b... update binaries
    }

    const uint8_t priority = PRIORITY_FROM_ID(frame->id);
    const uint8_t source_node_id = SOURCE_ID_FROM_ID(frame->id);
    const uint16_t data_type_id = extractDataType(frame->id);
    const uint32_t transfer_descriptor =
<<<<<<< HEAD
 800cbb0:	4313      	orrs	r3, r2
 800cbb2:	657b      	str	r3, [r7, #84]	; 0x54
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);

    const uint8_t tail_byte = frame->data[frame->data_len - 1];
 800cbb4:	68bb      	ldr	r3, [r7, #8]
 800cbb6:	7b1b      	ldrb	r3, [r3, #12]
 800cbb8:	3b01      	subs	r3, #1
 800cbba:	68ba      	ldr	r2, [r7, #8]
 800cbbc:	4413      	add	r3, r2
 800cbbe:	791b      	ldrb	r3, [r3, #4]
 800cbc0:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53

    CanardRxState* rx_state = NULL;
 800cbc4:	2300      	movs	r3, #0
 800cbc6:	677b      	str	r3, [r7, #116]	; 0x74

    if (IS_START_OF_TRANSFER(tail_byte))
 800cbc8:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cbcc:	09db      	lsrs	r3, r3, #7
 800cbce:	b2db      	uxtb	r3, r3
 800cbd0:	f003 0301 	and.w	r3, r3, #1
 800cbd4:	2b00      	cmp	r3, #0
 800cbd6:	d02b      	beq.n	800cc30 <canardHandleRxFrame+0x150>
    {
        uint64_t data_type_signature = 0;
 800cbd8:	f04f 0200 	mov.w	r2, #0
 800cbdc:	f04f 0300 	mov.w	r3, #0
 800cbe0:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

        if (ins->should_accept(ins, &data_type_signature, data_type_id, transfer_type, source_node_id))
 800cbe4:	68fb      	ldr	r3, [r7, #12]
 800cbe6:	685c      	ldr	r4, [r3, #4]
 800cbe8:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800cbec:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800cbf0:	f897 505f 	ldrb.w	r5, [r7, #95]	; 0x5f
 800cbf4:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cbf8:	9300      	str	r3, [sp, #0]
 800cbfa:	68f8      	ldr	r0, [r7, #12]
 800cbfc:	462b      	mov	r3, r5
 800cbfe:	47a0      	blx	r4
 800cc00:	4603      	mov	r3, r0
 800cc02:	2b00      	cmp	r3, #0
 800cc04:	f000 8296 	beq.w	800d134 <canardHandleRxFrame+0x654>
        {
            rx_state = traverseRxStates(ins, transfer_descriptor);
 800cc08:	68f8      	ldr	r0, [r7, #12]
 800cc0a:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800cc0c:	f000 fd96 	bl	800d73c <traverseRxStates>
 800cc10:	6778      	str	r0, [r7, #116]	; 0x74

            if(rx_state == NULL)
 800cc12:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc14:	2b00      	cmp	r3, #0
 800cc16:	f000 828d 	beq.w	800d134 <canardHandleRxFrame+0x654>
=======
 800cc38:	4313      	orrs	r3, r2
 800cc3a:	657b      	str	r3, [r7, #84]	; 0x54
            MAKE_TRANSFER_DESCRIPTOR(data_type_id, transfer_type, source_node_id, destination_node_id);

    const uint8_t tail_byte = frame->data[frame->data_len - 1];
 800cc3c:	68bb      	ldr	r3, [r7, #8]
 800cc3e:	7b1b      	ldrb	r3, [r3, #12]
 800cc40:	3b01      	subs	r3, #1
 800cc42:	68ba      	ldr	r2, [r7, #8]
 800cc44:	4413      	add	r3, r2
 800cc46:	791b      	ldrb	r3, [r3, #4]
 800cc48:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53

    CanardRxState* rx_state = NULL;
 800cc4c:	2300      	movs	r3, #0
 800cc4e:	677b      	str	r3, [r7, #116]	; 0x74

    if (IS_START_OF_TRANSFER(tail_byte))
 800cc50:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cc54:	09db      	lsrs	r3, r3, #7
 800cc56:	b2db      	uxtb	r3, r3
 800cc58:	f003 0301 	and.w	r3, r3, #1
 800cc5c:	2b00      	cmp	r3, #0
 800cc5e:	d02b      	beq.n	800ccb8 <canardHandleRxFrame+0x150>
    {
        uint64_t data_type_signature = 0;
 800cc60:	f04f 0200 	mov.w	r2, #0
 800cc64:	f04f 0300 	mov.w	r3, #0
 800cc68:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

        if (ins->should_accept(ins, &data_type_signature, data_type_id, transfer_type, source_node_id))
 800cc6c:	68fb      	ldr	r3, [r7, #12]
 800cc6e:	685c      	ldr	r4, [r3, #4]
 800cc70:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800cc74:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 800cc78:	f897 505f 	ldrb.w	r5, [r7, #95]	; 0x5f
 800cc7c:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cc80:	9300      	str	r3, [sp, #0]
 800cc82:	68f8      	ldr	r0, [r7, #12]
 800cc84:	462b      	mov	r3, r5
 800cc86:	47a0      	blx	r4
 800cc88:	4603      	mov	r3, r0
 800cc8a:	2b00      	cmp	r3, #0
 800cc8c:	f000 8296 	beq.w	800d1bc <canardHandleRxFrame+0x654>
        {
            rx_state = traverseRxStates(ins, transfer_descriptor);
 800cc90:	68f8      	ldr	r0, [r7, #12]
 800cc92:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800cc94:	f000 fd96 	bl	800d7c4 <traverseRxStates>
 800cc98:	6778      	str	r0, [r7, #116]	; 0x74

            if(rx_state == NULL)
 800cc9a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc9c:	2b00      	cmp	r3, #0
 800cc9e:	f000 828d 	beq.w	800d1bc <canardHandleRxFrame+0x654>
>>>>>>> 752c83b... update binaries
            {
                return; // No allocator room for this frame
            }

            rx_state->calculated_crc = crcAddSignature(0xFFFFU, data_type_signature);
<<<<<<< HEAD
 800cc1a:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 800cc1e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800cc22:	f001 f93f 	bl	800dea4 <crcAddSignature>
 800cc26:	4603      	mov	r3, r0
 800cc28:	461a      	mov	r2, r3
 800cc2a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc2c:	82da      	strh	r2, [r3, #22]
 800cc2e:	e00a      	b.n	800cc46 <canardHandleRxFrame+0x166>
=======
 800cca2:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 800cca6:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ccaa:	f001 f93f 	bl	800df2c <crcAddSignature>
 800ccae:	4603      	mov	r3, r0
 800ccb0:	461a      	mov	r2, r3
 800ccb2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ccb4:	82da      	strh	r2, [r3, #22]
 800ccb6:	e00a      	b.n	800ccce <canardHandleRxFrame+0x166>
>>>>>>> 752c83b... update binaries
            return;     // The application doesn't want this transfer
        }
    }
    else
    {
        rx_state = findRxState(ins->rx_states, transfer_descriptor);
<<<<<<< HEAD
 800cc30:	68fb      	ldr	r3, [r7, #12]
 800cc32:	699b      	ldr	r3, [r3, #24]
 800cc34:	4618      	mov	r0, r3
 800cc36:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800cc38:	f000 fdb0 	bl	800d79c <findRxState>
 800cc3c:	6778      	str	r0, [r7, #116]	; 0x74

        if (rx_state == NULL)
 800cc3e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc40:	2b00      	cmp	r3, #0
 800cc42:	f000 8278 	beq.w	800d136 <canardHandleRxFrame+0x656>
=======
 800ccb8:	68fb      	ldr	r3, [r7, #12]
 800ccba:	699b      	ldr	r3, [r3, #24]
 800ccbc:	4618      	mov	r0, r3
 800ccbe:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800ccc0:	f000 fdb0 	bl	800d824 <findRxState>
 800ccc4:	6778      	str	r0, [r7, #116]	; 0x74

        if (rx_state == NULL)
 800ccc6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ccc8:	2b00      	cmp	r3, #0
 800ccca:	f000 8278 	beq.w	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
    }

    CANARD_ASSERT(rx_state != NULL);    // All paths that lead to NULL should be terminated with return above

    // Resolving the state flags:
    const bool not_initialized = rx_state->timestamp_usec == 0;
<<<<<<< HEAD
 800cc46:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc48:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800cc4c:	4313      	orrs	r3, r2
 800cc4e:	2b00      	cmp	r3, #0
 800cc50:	bf0c      	ite	eq
 800cc52:	2301      	moveq	r3, #1
 800cc54:	2300      	movne	r3, #0
 800cc56:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
 800cc5a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc5c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800cc60:	e9d7 0100 	ldrd	r0, r1, [r7]
 800cc64:	1a82      	subs	r2, r0, r2
 800cc66:	eb61 0303 	sbc.w	r3, r1, r3
 800cc6a:	48b7      	ldr	r0, [pc, #732]	; (800cf48 <canardHandleRxFrame+0x468>)
 800cc6c:	f04f 0100 	mov.w	r1, #0
 800cc70:	4299      	cmp	r1, r3
 800cc72:	bf08      	it	eq
 800cc74:	4290      	cmpeq	r0, r2
 800cc76:	bf34      	ite	cc
 800cc78:	2301      	movcc	r3, #1
 800cc7a:	2300      	movcs	r3, #0
 800cc7c:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
 800cc80:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cc84:	09db      	lsrs	r3, r3, #7
 800cc86:	b2db      	uxtb	r3, r3
 800cc88:	f003 0301 	and.w	r3, r3, #1
 800cc8c:	2b00      	cmp	r3, #0
 800cc8e:	bf14      	ite	ne
 800cc90:	2301      	movne	r3, #1
 800cc92:	2300      	moveq	r3, #0
 800cc94:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;
 800cc98:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cc9a:	7e5b      	ldrb	r3, [r3, #25]
 800cc9c:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800cca0:	b2db      	uxtb	r3, r3
 800cca2:	461a      	mov	r2, r3
 800cca4:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cca8:	f003 031f 	and.w	r3, r3, #31
 800ccac:	b2db      	uxtb	r3, r3
 800ccae:	4610      	mov	r0, r2
 800ccb0:	4619      	mov	r1, r3
 800ccb2:	f000 fcc1 	bl	800d638 <computeTransferIDForwardDistance>
 800ccb6:	4603      	mov	r3, r0
=======
 800ccce:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ccd0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ccd4:	4313      	orrs	r3, r2
 800ccd6:	2b00      	cmp	r3, #0
 800ccd8:	bf0c      	ite	eq
 800ccda:	2301      	moveq	r3, #1
 800ccdc:	2300      	movne	r3, #0
 800ccde:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
 800cce2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cce4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800cce8:	e9d7 0100 	ldrd	r0, r1, [r7]
 800ccec:	1a82      	subs	r2, r0, r2
 800ccee:	eb61 0303 	sbc.w	r3, r1, r3
 800ccf2:	48b7      	ldr	r0, [pc, #732]	; (800cfd0 <canardHandleRxFrame+0x468>)
 800ccf4:	f04f 0100 	mov.w	r1, #0
 800ccf8:	4299      	cmp	r1, r3
 800ccfa:	bf08      	it	eq
 800ccfc:	4290      	cmpeq	r0, r2
 800ccfe:	bf34      	ite	cc
 800cd00:	2301      	movcc	r3, #1
 800cd02:	2300      	movcs	r3, #0
 800cd04:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
 800cd08:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd0c:	09db      	lsrs	r3, r3, #7
 800cd0e:	b2db      	uxtb	r3, r3
 800cd10:	f003 0301 	and.w	r3, r3, #1
 800cd14:	2b00      	cmp	r3, #0
 800cd16:	bf14      	ite	ne
 800cd18:	2301      	movne	r3, #1
 800cd1a:	2300      	moveq	r3, #0
 800cd1c:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;
 800cd20:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cd22:	7e5b      	ldrb	r3, [r3, #25]
 800cd24:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800cd28:	b2db      	uxtb	r3, r3
 800cd2a:	461a      	mov	r2, r3
 800cd2c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd30:	f003 031f 	and.w	r3, r3, #31
 800cd34:	b2db      	uxtb	r3, r3
 800cd36:	4610      	mov	r0, r2
 800cd38:	4619      	mov	r1, r3
 800cd3a:	f000 fcc1 	bl	800d6c0 <computeTransferIDForwardDistance>
 800cd3e:	4603      	mov	r3, r0
>>>>>>> 752c83b... update binaries

    // Resolving the state flags:
    const bool not_initialized = rx_state->timestamp_usec == 0;
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
<<<<<<< HEAD
 800ccb8:	2b01      	cmp	r3, #1
 800ccba:	bfcc      	ite	gt
 800ccbc:	2301      	movgt	r3, #1
 800ccbe:	2300      	movle	r3, #0
 800ccc0:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
=======
 800cd40:	2b01      	cmp	r3, #1
 800cd42:	bfcc      	ite	gt
 800cd44:	2301      	movgt	r3, #1
 800cd46:	2300      	movle	r3, #0
 800cd48:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
>>>>>>> 752c83b... update binaries
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
            (tid_timed_out) ||
<<<<<<< HEAD
 800ccc4:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 800ccc8:	2b00      	cmp	r3, #0
 800ccca:	d10b      	bne.n	800cce4 <canardHandleRxFrame+0x204>
=======
 800cd4c:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 800cd50:	2b00      	cmp	r3, #0
 800cd52:	d10b      	bne.n	800cd6c <canardHandleRxFrame+0x204>
>>>>>>> 752c83b... update binaries
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
<<<<<<< HEAD
 800cccc:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
 800ccd0:	2b00      	cmp	r3, #0
 800ccd2:	d107      	bne.n	800cce4 <canardHandleRxFrame+0x204>
            (tid_timed_out) ||
 800ccd4:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800ccd8:	2b00      	cmp	r3, #0
 800ccda:	d005      	beq.n	800cce8 <canardHandleRxFrame+0x208>
            (first_frame && not_previous_tid);
 800ccdc:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 800cce0:	2b00      	cmp	r3, #0
 800cce2:	d001      	beq.n	800cce8 <canardHandleRxFrame+0x208>
=======
 800cd54:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
 800cd58:	2b00      	cmp	r3, #0
 800cd5a:	d107      	bne.n	800cd6c <canardHandleRxFrame+0x204>
            (tid_timed_out) ||
 800cd5c:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800cd60:	2b00      	cmp	r3, #0
 800cd62:	d005      	beq.n	800cd70 <canardHandleRxFrame+0x208>
            (first_frame && not_previous_tid);
 800cd64:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 800cd68:	2b00      	cmp	r3, #0
 800cd6a:	d001      	beq.n	800cd70 <canardHandleRxFrame+0x208>
>>>>>>> 752c83b... update binaries
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
            (not_initialized) ||
            (tid_timed_out) ||
<<<<<<< HEAD
 800cce4:	2301      	movs	r3, #1
 800cce6:	e000      	b.n	800ccea <canardHandleRxFrame+0x20a>
 800cce8:	2300      	movs	r3, #0
=======
 800cd6c:	2301      	movs	r3, #1
 800cd6e:	e000      	b.n	800cd72 <canardHandleRxFrame+0x20a>
 800cd70:	2300      	movs	r3, #0
>>>>>>> 752c83b... update binaries
    const bool tid_timed_out = (timestamp_usec - rx_state->timestamp_usec) > TRANSFER_TIMEOUT_USEC;
    const bool first_frame = IS_START_OF_TRANSFER(tail_byte);
    const bool not_previous_tid =
        computeTransferIDForwardDistance((uint8_t) rx_state->transfer_id, TRANSFER_ID_FROM_TAIL_BYTE(tail_byte)) > 1;

    const bool need_restart =
<<<<<<< HEAD
 800ccea:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
 800ccee:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800ccf2:	f003 0301 	and.w	r3, r3, #1
 800ccf6:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
=======
 800cd72:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
 800cd76:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800cd7a:	f003 0301 	and.w	r3, r3, #1
 800cd7e:	f887 304e 	strb.w	r3, [r7, #78]	; 0x4e
>>>>>>> 752c83b... update binaries
            (not_initialized) ||
            (tid_timed_out) ||
            (first_frame && not_previous_tid);

    if (need_restart)
<<<<<<< HEAD
 800ccfa:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800ccfe:	2b00      	cmp	r3, #0
 800cd00:	d02a      	beq.n	800cd58 <canardHandleRxFrame+0x278>
    {
        rx_state->transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte);
 800cd02:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd06:	f003 031f 	and.w	r3, r3, #31
 800cd0a:	b2d9      	uxtb	r1, r3
 800cd0c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cd0e:	7e53      	ldrb	r3, [r2, #25]
 800cd10:	f361 0386 	bfi	r3, r1, #2, #5
 800cd14:	7653      	strb	r3, [r2, #25]
        rx_state->next_toggle = 0;
 800cd16:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cd18:	7e53      	ldrb	r3, [r2, #25]
 800cd1a:	f36f 13c7 	bfc	r3, #7, #1
 800cd1e:	7653      	strb	r3, [r2, #25]
        releaseStatePayload(ins, rx_state);
 800cd20:	68f8      	ldr	r0, [r7, #12]
 800cd22:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cd24:	f000 fda8 	bl	800d878 <releaseStatePayload>
        if (!IS_START_OF_TRANSFER(tail_byte)) // missed the first frame
 800cd28:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd2c:	09db      	lsrs	r3, r3, #7
 800cd2e:	b2db      	uxtb	r3, r3
 800cd30:	f003 0301 	and.w	r3, r3, #1
 800cd34:	2b00      	cmp	r3, #0
 800cd36:	d10f      	bne.n	800cd58 <canardHandleRxFrame+0x278>
        {
            rx_state->transfer_id += 1;
 800cd38:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cd3a:	7e5b      	ldrb	r3, [r3, #25]
 800cd3c:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800cd40:	b2db      	uxtb	r3, r3
 800cd42:	3301      	adds	r3, #1
 800cd44:	b2db      	uxtb	r3, r3
 800cd46:	f003 031f 	and.w	r3, r3, #31
 800cd4a:	b2d9      	uxtb	r1, r3
 800cd4c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cd4e:	7e53      	ldrb	r3, [r2, #25]
 800cd50:	f361 0386 	bfi	r3, r1, #2, #5
 800cd54:	7653      	strb	r3, [r2, #25]
 800cd56:	e1ee      	b.n	800d136 <canardHandleRxFrame+0x656>
=======
 800cd82:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 800cd86:	2b00      	cmp	r3, #0
 800cd88:	d02a      	beq.n	800cde0 <canardHandleRxFrame+0x278>
    {
        rx_state->transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte);
 800cd8a:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd8e:	f003 031f 	and.w	r3, r3, #31
 800cd92:	b2d9      	uxtb	r1, r3
 800cd94:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cd96:	7e53      	ldrb	r3, [r2, #25]
 800cd98:	f361 0386 	bfi	r3, r1, #2, #5
 800cd9c:	7653      	strb	r3, [r2, #25]
        rx_state->next_toggle = 0;
 800cd9e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cda0:	7e53      	ldrb	r3, [r2, #25]
 800cda2:	f36f 13c7 	bfc	r3, #7, #1
 800cda6:	7653      	strb	r3, [r2, #25]
        releaseStatePayload(ins, rx_state);
 800cda8:	68f8      	ldr	r0, [r7, #12]
 800cdaa:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cdac:	f000 fda8 	bl	800d900 <releaseStatePayload>
        if (!IS_START_OF_TRANSFER(tail_byte)) // missed the first frame
 800cdb0:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cdb4:	09db      	lsrs	r3, r3, #7
 800cdb6:	b2db      	uxtb	r3, r3
 800cdb8:	f003 0301 	and.w	r3, r3, #1
 800cdbc:	2b00      	cmp	r3, #0
 800cdbe:	d10f      	bne.n	800cde0 <canardHandleRxFrame+0x278>
        {
            rx_state->transfer_id += 1;
 800cdc0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cdc2:	7e5b      	ldrb	r3, [r3, #25]
 800cdc4:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800cdc8:	b2db      	uxtb	r3, r3
 800cdca:	3301      	adds	r3, #1
 800cdcc:	b2db      	uxtb	r3, r3
 800cdce:	f003 031f 	and.w	r3, r3, #31
 800cdd2:	b2d9      	uxtb	r1, r3
 800cdd4:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cdd6:	7e53      	ldrb	r3, [r2, #25]
 800cdd8:	f361 0386 	bfi	r3, r1, #2, #5
 800cddc:	7653      	strb	r3, [r2, #25]
 800cdde:	e1ee      	b.n	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
            return;
        }
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
<<<<<<< HEAD
 800cd58:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd5c:	09db      	lsrs	r3, r3, #7
 800cd5e:	b2db      	uxtb	r3, r3
 800cd60:	f003 0301 	and.w	r3, r3, #1
 800cd64:	2b00      	cmp	r3, #0
 800cd66:	d054      	beq.n	800ce12 <canardHandleRxFrame+0x332>
 800cd68:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cd6c:	099b      	lsrs	r3, r3, #6
 800cd6e:	b2db      	uxtb	r3, r3
 800cd70:	f003 0301 	and.w	r3, r3, #1
 800cd74:	2b00      	cmp	r3, #0
 800cd76:	d04c      	beq.n	800ce12 <canardHandleRxFrame+0x332>
    {
        rx_state->timestamp_usec = timestamp_usec;
 800cd78:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cd7a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800cd7e:	e9c1 2302 	strd	r2, r3, [r1, #8]
        CanardRxTransfer rx_transfer = {
 800cd82:	f107 0310 	add.w	r3, r7, #16
 800cd86:	2200      	movs	r2, #0
 800cd88:	601a      	str	r2, [r3, #0]
 800cd8a:	3304      	adds	r3, #4
 800cd8c:	2200      	movs	r2, #0
 800cd8e:	601a      	str	r2, [r3, #0]
 800cd90:	3304      	adds	r3, #4
 800cd92:	2200      	movs	r2, #0
 800cd94:	601a      	str	r2, [r3, #0]
 800cd96:	3304      	adds	r3, #4
 800cd98:	2200      	movs	r2, #0
 800cd9a:	601a      	str	r2, [r3, #0]
 800cd9c:	3304      	adds	r3, #4
 800cd9e:	2200      	movs	r2, #0
 800cda0:	601a      	str	r2, [r3, #0]
 800cda2:	3304      	adds	r3, #4
 800cda4:	2200      	movs	r2, #0
 800cda6:	601a      	str	r2, [r3, #0]
 800cda8:	3304      	adds	r3, #4
 800cdaa:	2200      	movs	r2, #0
 800cdac:	601a      	str	r2, [r3, #0]
 800cdae:	3304      	adds	r3, #4
 800cdb0:	2200      	movs	r2, #0
 800cdb2:	601a      	str	r2, [r3, #0]
 800cdb4:	3304      	adds	r3, #4
 800cdb6:	e9d7 2300 	ldrd	r2, r3, [r7]
 800cdba:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
 800cdbe:	68bb      	ldr	r3, [r7, #8]
 800cdc0:	3304      	adds	r3, #4
=======
 800cde0:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cde4:	09db      	lsrs	r3, r3, #7
 800cde6:	b2db      	uxtb	r3, r3
 800cde8:	f003 0301 	and.w	r3, r3, #1
 800cdec:	2b00      	cmp	r3, #0
 800cdee:	d054      	beq.n	800ce9a <canardHandleRxFrame+0x332>
 800cdf0:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cdf4:	099b      	lsrs	r3, r3, #6
 800cdf6:	b2db      	uxtb	r3, r3
 800cdf8:	f003 0301 	and.w	r3, r3, #1
 800cdfc:	2b00      	cmp	r3, #0
 800cdfe:	d04c      	beq.n	800ce9a <canardHandleRxFrame+0x332>
    {
        rx_state->timestamp_usec = timestamp_usec;
 800ce00:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800ce02:	e9d7 2300 	ldrd	r2, r3, [r7]
 800ce06:	e9c1 2302 	strd	r2, r3, [r1, #8]
        CanardRxTransfer rx_transfer = {
 800ce0a:	f107 0310 	add.w	r3, r7, #16
 800ce0e:	2200      	movs	r2, #0
 800ce10:	601a      	str	r2, [r3, #0]
 800ce12:	3304      	adds	r3, #4
 800ce14:	2200      	movs	r2, #0
 800ce16:	601a      	str	r2, [r3, #0]
 800ce18:	3304      	adds	r3, #4
 800ce1a:	2200      	movs	r2, #0
 800ce1c:	601a      	str	r2, [r3, #0]
 800ce1e:	3304      	adds	r3, #4
 800ce20:	2200      	movs	r2, #0
 800ce22:	601a      	str	r2, [r3, #0]
 800ce24:	3304      	adds	r3, #4
 800ce26:	2200      	movs	r2, #0
 800ce28:	601a      	str	r2, [r3, #0]
 800ce2a:	3304      	adds	r3, #4
 800ce2c:	2200      	movs	r2, #0
 800ce2e:	601a      	str	r2, [r3, #0]
 800ce30:	3304      	adds	r3, #4
 800ce32:	2200      	movs	r2, #0
 800ce34:	601a      	str	r2, [r3, #0]
 800ce36:	3304      	adds	r3, #4
 800ce38:	2200      	movs	r2, #0
 800ce3a:	601a      	str	r2, [r3, #0]
 800ce3c:	3304      	adds	r3, #4
 800ce3e:	e9d7 2300 	ldrd	r2, r3, [r7]
 800ce42:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
 800ce46:	68bb      	ldr	r3, [r7, #8]
 800ce48:	3304      	adds	r3, #4
>>>>>>> 752c83b... update binaries
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800cdc2:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
            .payload_len = (uint8_t)(frame->data_len - 1U),
 800cdc4:	68bb      	ldr	r3, [r7, #8]
 800cdc6:	7b1b      	ldrb	r3, [r3, #12]
 800cdc8:	3b01      	subs	r3, #1
 800cdca:	b2db      	uxtb	r3, r3
=======
 800ce4a:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
            .payload_len = (uint8_t)(frame->data_len - 1U),
 800ce4c:	68bb      	ldr	r3, [r7, #8]
 800ce4e:	7b1b      	ldrb	r3, [r3, #12]
 800ce50:	3b01      	subs	r3, #1
 800ce52:	b2db      	uxtb	r3, r3
>>>>>>> 752c83b... update binaries
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800cdcc:	b29b      	uxth	r3, r3
 800cdce:	84bb      	strh	r3, [r7, #36]	; 0x24
 800cdd0:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800cdd4:	84fb      	strh	r3, [r7, #38]	; 0x26
 800cdd6:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800cdda:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
=======
 800ce54:	b29b      	uxth	r3, r3
 800ce56:	84bb      	strh	r3, [r7, #36]	; 0x24
 800ce58:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800ce5c:	84fb      	strh	r3, [r7, #38]	; 0x26
 800ce5e:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800ce62:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
>>>>>>> 752c83b... update binaries
            .timestamp_usec = timestamp_usec,
            .payload_head = frame->data,
            .payload_len = (uint8_t)(frame->data_len - 1U),
            .data_type_id = data_type_id,
            .transfer_type = transfer_type,
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
<<<<<<< HEAD
 800cdde:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cde2:	f003 031f 	and.w	r3, r3, #31
 800cde6:	b2db      	uxtb	r3, r3
=======
 800ce66:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce6a:	f003 031f 	and.w	r3, r3, #31
 800ce6e:	b2db      	uxtb	r3, r3
>>>>>>> 752c83b... update binaries
    }

    if (IS_START_OF_TRANSFER(tail_byte) && IS_END_OF_TRANSFER(tail_byte)) // single frame transfer
    {
        rx_state->timestamp_usec = timestamp_usec;
        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800cde8:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800cdec:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800cdf0:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800cdf4:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800cdf8:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
=======
 800ce70:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800ce74:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800ce78:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800ce7c:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800ce80:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
>>>>>>> 752c83b... update binaries
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
            .priority = priority,
            .source_node_id = source_node_id
        };

        ins->on_reception(ins, &rx_transfer);
<<<<<<< HEAD
 800cdfc:	68fb      	ldr	r3, [r7, #12]
 800cdfe:	689b      	ldr	r3, [r3, #8]
 800ce00:	f107 0210 	add.w	r2, r7, #16
 800ce04:	68f8      	ldr	r0, [r7, #12]
 800ce06:	4611      	mov	r1, r2
 800ce08:	4798      	blx	r3

        prepareForNextTransfer(rx_state);
 800ce0a:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800ce0c:	f000 fc2e 	bl	800d66c <prepareForNextTransfer>
 800ce10:	e191      	b.n	800d136 <canardHandleRxFrame+0x656>
=======
 800ce84:	68fb      	ldr	r3, [r7, #12]
 800ce86:	689b      	ldr	r3, [r3, #8]
 800ce88:	f107 0210 	add.w	r2, r7, #16
 800ce8c:	68f8      	ldr	r0, [r7, #12]
 800ce8e:	4611      	mov	r1, r2
 800ce90:	4798      	blx	r3

        prepareForNextTransfer(rx_state);
 800ce92:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800ce94:	f000 fc2e 	bl	800d6f4 <prepareForNextTransfer>
 800ce98:	e191      	b.n	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
        return;
    }

    if (TOGGLE_BIT(tail_byte) != rx_state->next_toggle)
<<<<<<< HEAD
 800ce12:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce16:	095b      	lsrs	r3, r3, #5
 800ce18:	b2db      	uxtb	r3, r3
 800ce1a:	f003 0301 	and.w	r3, r3, #1
 800ce1e:	2b00      	cmp	r3, #0
 800ce20:	bf14      	ite	ne
 800ce22:	2301      	movne	r3, #1
 800ce24:	2300      	moveq	r3, #0
 800ce26:	b2db      	uxtb	r3, r3
 800ce28:	461a      	mov	r2, r3
 800ce2a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ce2c:	7e5b      	ldrb	r3, [r3, #25]
 800ce2e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800ce32:	b2db      	uxtb	r3, r3
 800ce34:	429a      	cmp	r2, r3
 800ce36:	f040 817e 	bne.w	800d136 <canardHandleRxFrame+0x656>
=======
 800ce9a:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce9e:	095b      	lsrs	r3, r3, #5
 800cea0:	b2db      	uxtb	r3, r3
 800cea2:	f003 0301 	and.w	r3, r3, #1
 800cea6:	2b00      	cmp	r3, #0
 800cea8:	bf14      	ite	ne
 800ceaa:	2301      	movne	r3, #1
 800ceac:	2300      	moveq	r3, #0
 800ceae:	b2db      	uxtb	r3, r3
 800ceb0:	461a      	mov	r2, r3
 800ceb2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ceb4:	7e5b      	ldrb	r3, [r3, #25]
 800ceb6:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800ceba:	b2db      	uxtb	r3, r3
 800cebc:	429a      	cmp	r2, r3
 800cebe:	f040 817e 	bne.w	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
    {
        return; // wrong toggle
    }

    if (TRANSFER_ID_FROM_TAIL_BYTE(tail_byte) != rx_state->transfer_id)
<<<<<<< HEAD
 800ce3a:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce3e:	f003 031f 	and.w	r3, r3, #31
 800ce42:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800ce44:	7e52      	ldrb	r2, [r2, #25]
 800ce46:	f3c2 0284 	ubfx	r2, r2, #2, #5
 800ce4a:	b2d2      	uxtb	r2, r2
 800ce4c:	4293      	cmp	r3, r2
 800ce4e:	f040 8172 	bne.w	800d136 <canardHandleRxFrame+0x656>
=======
 800cec2:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cec6:	f003 031f 	and.w	r3, r3, #31
 800ceca:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cecc:	7e52      	ldrb	r2, [r2, #25]
 800cece:	f3c2 0284 	ubfx	r2, r2, #2, #5
 800ced2:	b2d2      	uxtb	r2, r2
 800ced4:	4293      	cmp	r3, r2
 800ced6:	f040 8172 	bne.w	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
    {
        return; // unexpected tid
    }

    if (IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))      // Beginning of multi frame transfer
<<<<<<< HEAD
 800ce52:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce56:	09db      	lsrs	r3, r3, #7
 800ce58:	b2db      	uxtb	r3, r3
 800ce5a:	f003 0301 	and.w	r3, r3, #1
 800ce5e:	2b00      	cmp	r3, #0
 800ce60:	d048      	beq.n	800cef4 <canardHandleRxFrame+0x414>
 800ce62:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ce66:	099b      	lsrs	r3, r3, #6
 800ce68:	b2db      	uxtb	r3, r3
 800ce6a:	f003 0301 	and.w	r3, r3, #1
 800ce6e:	2b00      	cmp	r3, #0
 800ce70:	d140      	bne.n	800cef4 <canardHandleRxFrame+0x414>
    {
        if (frame->data_len <= 3)
 800ce72:	68bb      	ldr	r3, [r7, #8]
 800ce74:	7b1b      	ldrb	r3, [r3, #12]
 800ce76:	2b03      	cmp	r3, #3
 800ce78:	f240 815d 	bls.w	800d136 <canardHandleRxFrame+0x656>
=======
 800ceda:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cede:	09db      	lsrs	r3, r3, #7
 800cee0:	b2db      	uxtb	r3, r3
 800cee2:	f003 0301 	and.w	r3, r3, #1
 800cee6:	2b00      	cmp	r3, #0
 800cee8:	d048      	beq.n	800cf7c <canardHandleRxFrame+0x414>
 800ceea:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800ceee:	099b      	lsrs	r3, r3, #6
 800cef0:	b2db      	uxtb	r3, r3
 800cef2:	f003 0301 	and.w	r3, r3, #1
 800cef6:	2b00      	cmp	r3, #0
 800cef8:	d140      	bne.n	800cf7c <canardHandleRxFrame+0x414>
    {
        if (frame->data_len <= 3)
 800cefa:	68bb      	ldr	r3, [r7, #8]
 800cefc:	7b1b      	ldrb	r3, [r3, #12]
 800cefe:	2b03      	cmp	r3, #3
 800cf00:	f240 815d 	bls.w	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
        {
            return;     // Not enough data
        }

        // take off the crc and store the payload
        rx_state->timestamp_usec = timestamp_usec;
<<<<<<< HEAD
 800ce7c:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800ce7e:	e9d7 2300 	ldrd	r2, r3, [r7]
 800ce82:	e9c1 2302 	strd	r2, r3, [r1, #8]
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data + 2,
 800ce86:	68fb      	ldr	r3, [r7, #12]
 800ce88:	f103 010c 	add.w	r1, r3, #12
 800ce8c:	68bb      	ldr	r3, [r7, #8]
 800ce8e:	1d9a      	adds	r2, r3, #6
                                             (uint8_t) (frame->data_len - 3));
 800ce90:	68bb      	ldr	r3, [r7, #8]
 800ce92:	7b1b      	ldrb	r3, [r3, #12]
=======
 800cf04:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cf06:	e9d7 2300 	ldrd	r2, r3, [r7]
 800cf0a:	e9c1 2302 	strd	r2, r3, [r1, #8]
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data + 2,
 800cf0e:	68fb      	ldr	r3, [r7, #12]
 800cf10:	f103 010c 	add.w	r1, r3, #12
 800cf14:	68bb      	ldr	r3, [r7, #8]
 800cf16:	1d9a      	adds	r2, r3, #6
                                             (uint8_t) (frame->data_len - 3));
 800cf18:	68bb      	ldr	r3, [r7, #8]
 800cf1a:	7b1b      	ldrb	r3, [r3, #12]
>>>>>>> 752c83b... update binaries
            return;     // Not enough data
        }

        // take off the crc and store the payload
        rx_state->timestamp_usec = timestamp_usec;
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data + 2,
<<<<<<< HEAD
 800ce94:	3b03      	subs	r3, #3
 800ce96:	b2db      	uxtb	r3, r3
 800ce98:	4608      	mov	r0, r1
 800ce9a:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800ce9c:	f000 fd14 	bl	800d8c8 <bufferBlockPushBytes>
 800cea0:	64b8      	str	r0, [r7, #72]	; 0x48
                                             (uint8_t) (frame->data_len - 3));
        if (ret < 0)
 800cea2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cea4:	2b00      	cmp	r3, #0
 800cea6:	da07      	bge.n	800ceb8 <canardHandleRxFrame+0x3d8>
        {
            releaseStatePayload(ins, rx_state);
 800cea8:	68f8      	ldr	r0, [r7, #12]
 800ceaa:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800ceac:	f000 fce4 	bl	800d878 <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800ceb0:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800ceb2:	f000 fbdb 	bl	800d66c <prepareForNextTransfer>
 800ceb6:	e13e      	b.n	800d136 <canardHandleRxFrame+0x656>
            return;
        }
        rx_state->payload_crc = ((uint16_t) frame->data[0]) | ((uint16_t) frame->data[1] << 8);
 800ceb8:	68bb      	ldr	r3, [r7, #8]
 800ceba:	791b      	ldrb	r3, [r3, #4]
 800cebc:	b29a      	uxth	r2, r3
 800cebe:	68bb      	ldr	r3, [r7, #8]
 800cec0:	795b      	ldrb	r3, [r3, #5]
 800cec2:	021b      	lsls	r3, r3, #8
 800cec4:	b29b      	uxth	r3, r3
 800cec6:	4313      	orrs	r3, r2
 800cec8:	b29b      	uxth	r3, r3
 800ceca:	b29a      	uxth	r2, r3
 800cecc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cece:	829a      	strh	r2, [r3, #20]
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800ced0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ced2:	8ad9      	ldrh	r1, [r3, #22]
 800ced4:	68bb      	ldr	r3, [r7, #8]
 800ced6:	1d9a      	adds	r2, r3, #6
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
 800ced8:	68bb      	ldr	r3, [r7, #8]
 800ceda:	7b1b      	ldrb	r3, [r3, #12]
 800cedc:	3b03      	subs	r3, #3
 800cede:	b2db      	uxtb	r3, r3
=======
 800cf1c:	3b03      	subs	r3, #3
 800cf1e:	b2db      	uxtb	r3, r3
 800cf20:	4608      	mov	r0, r1
 800cf22:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cf24:	f000 fd14 	bl	800d950 <bufferBlockPushBytes>
 800cf28:	64b8      	str	r0, [r7, #72]	; 0x48
                                             (uint8_t) (frame->data_len - 3));
        if (ret < 0)
 800cf2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cf2c:	2b00      	cmp	r3, #0
 800cf2e:	da07      	bge.n	800cf40 <canardHandleRxFrame+0x3d8>
        {
            releaseStatePayload(ins, rx_state);
 800cf30:	68f8      	ldr	r0, [r7, #12]
 800cf32:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cf34:	f000 fce4 	bl	800d900 <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800cf38:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800cf3a:	f000 fbdb 	bl	800d6f4 <prepareForNextTransfer>
 800cf3e:	e13e      	b.n	800d1be <canardHandleRxFrame+0x656>
            return;
        }
        rx_state->payload_crc = ((uint16_t) frame->data[0]) | ((uint16_t) frame->data[1] << 8);
 800cf40:	68bb      	ldr	r3, [r7, #8]
 800cf42:	791b      	ldrb	r3, [r3, #4]
 800cf44:	b29a      	uxth	r2, r3
 800cf46:	68bb      	ldr	r3, [r7, #8]
 800cf48:	795b      	ldrb	r3, [r3, #5]
 800cf4a:	021b      	lsls	r3, r3, #8
 800cf4c:	b29b      	uxth	r3, r3
 800cf4e:	4313      	orrs	r3, r2
 800cf50:	b29b      	uxth	r3, r3
 800cf52:	b29a      	uxth	r2, r3
 800cf54:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf56:	829a      	strh	r2, [r3, #20]
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800cf58:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf5a:	8ad9      	ldrh	r1, [r3, #22]
 800cf5c:	68bb      	ldr	r3, [r7, #8]
 800cf5e:	1d9a      	adds	r2, r3, #6
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
 800cf60:	68bb      	ldr	r3, [r7, #8]
 800cf62:	7b1b      	ldrb	r3, [r3, #12]
 800cf64:	3b03      	subs	r3, #3
 800cf66:	b2db      	uxtb	r3, r3
>>>>>>> 752c83b... update binaries
            releaseStatePayload(ins, rx_state);
            prepareForNextTransfer(rx_state);
            return;
        }
        rx_state->payload_crc = ((uint16_t) frame->data[0]) | ((uint16_t) frame->data[1] << 8);
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
<<<<<<< HEAD
 800cee0:	4608      	mov	r0, r1
 800cee2:	4611      	mov	r1, r2
 800cee4:	461a      	mov	r2, r3
 800cee6:	f001 f80d 	bl	800df04 <crcAdd>
 800ceea:	4603      	mov	r3, r0
 800ceec:	461a      	mov	r2, r3
 800ceee:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cef0:	82da      	strh	r2, [r3, #22]
 800cef2:	e10e      	b.n	800d112 <canardHandleRxFrame+0x632>
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
    }
    else if (!IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))    // Middle of a multi-frame transfer
 800cef4:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cef8:	09db      	lsrs	r3, r3, #7
 800cefa:	b2db      	uxtb	r3, r3
 800cefc:	f003 0301 	and.w	r3, r3, #1
 800cf00:	2b00      	cmp	r3, #0
 800cf02:	d135      	bne.n	800cf70 <canardHandleRxFrame+0x490>
 800cf04:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cf08:	099b      	lsrs	r3, r3, #6
 800cf0a:	b2db      	uxtb	r3, r3
 800cf0c:	f003 0301 	and.w	r3, r3, #1
 800cf10:	2b00      	cmp	r3, #0
 800cf12:	d12d      	bne.n	800cf70 <canardHandleRxFrame+0x490>
    {
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data,
 800cf14:	68fb      	ldr	r3, [r7, #12]
 800cf16:	f103 010c 	add.w	r1, r3, #12
 800cf1a:	68bb      	ldr	r3, [r7, #8]
 800cf1c:	1d1a      	adds	r2, r3, #4
                                             (uint8_t) (frame->data_len - 1));
 800cf1e:	68bb      	ldr	r3, [r7, #8]
 800cf20:	7b1b      	ldrb	r3, [r3, #12]
=======
 800cf68:	4608      	mov	r0, r1
 800cf6a:	4611      	mov	r1, r2
 800cf6c:	461a      	mov	r2, r3
 800cf6e:	f001 f80d 	bl	800df8c <crcAdd>
 800cf72:	4603      	mov	r3, r0
 800cf74:	461a      	mov	r2, r3
 800cf76:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf78:	82da      	strh	r2, [r3, #22]
 800cf7a:	e10e      	b.n	800d19a <canardHandleRxFrame+0x632>
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
    }
    else if (!IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))    // Middle of a multi-frame transfer
 800cf7c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cf80:	09db      	lsrs	r3, r3, #7
 800cf82:	b2db      	uxtb	r3, r3
 800cf84:	f003 0301 	and.w	r3, r3, #1
 800cf88:	2b00      	cmp	r3, #0
 800cf8a:	d135      	bne.n	800cff8 <canardHandleRxFrame+0x490>
 800cf8c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800cf90:	099b      	lsrs	r3, r3, #6
 800cf92:	b2db      	uxtb	r3, r3
 800cf94:	f003 0301 	and.w	r3, r3, #1
 800cf98:	2b00      	cmp	r3, #0
 800cf9a:	d12d      	bne.n	800cff8 <canardHandleRxFrame+0x490>
    {
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data,
 800cf9c:	68fb      	ldr	r3, [r7, #12]
 800cf9e:	f103 010c 	add.w	r1, r3, #12
 800cfa2:	68bb      	ldr	r3, [r7, #8]
 800cfa4:	1d1a      	adds	r2, r3, #4
                                             (uint8_t) (frame->data_len - 1));
 800cfa6:	68bb      	ldr	r3, [r7, #8]
 800cfa8:	7b1b      	ldrb	r3, [r3, #12]
>>>>>>> 752c83b... update binaries
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
                                          frame->data + 2, (uint8_t)(frame->data_len - 3));
    }
    else if (!IS_START_OF_TRANSFER(tail_byte) && !IS_END_OF_TRANSFER(tail_byte))    // Middle of a multi-frame transfer
    {
        const int ret = bufferBlockPushBytes(&ins->allocator, rx_state, frame->data,
<<<<<<< HEAD
 800cf22:	3b01      	subs	r3, #1
 800cf24:	b2db      	uxtb	r3, r3
 800cf26:	4608      	mov	r0, r1
 800cf28:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cf2a:	f000 fccd 	bl	800d8c8 <bufferBlockPushBytes>
 800cf2e:	6478      	str	r0, [r7, #68]	; 0x44
                                             (uint8_t) (frame->data_len - 1));
        if (ret < 0)
 800cf30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800cf32:	2b00      	cmp	r3, #0
 800cf34:	da0a      	bge.n	800cf4c <canardHandleRxFrame+0x46c>
        {
            releaseStatePayload(ins, rx_state);
 800cf36:	68f8      	ldr	r0, [r7, #12]
 800cf38:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cf3a:	f000 fc9d 	bl	800d878 <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800cf3e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800cf40:	f000 fb94 	bl	800d66c <prepareForNextTransfer>
 800cf44:	e0f7      	b.n	800d136 <canardHandleRxFrame+0x656>
 800cf46:	bf00      	nop
 800cf48:	001e8480 	.word	0x001e8480
            return;
        }
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800cf4c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf4e:	8ad9      	ldrh	r1, [r3, #22]
                                          frame->data, (uint8_t)(frame->data_len - 1));
 800cf50:	68bb      	ldr	r3, [r7, #8]
 800cf52:	1d1a      	adds	r2, r3, #4
 800cf54:	68bb      	ldr	r3, [r7, #8]
 800cf56:	7b1b      	ldrb	r3, [r3, #12]
 800cf58:	3b01      	subs	r3, #1
 800cf5a:	b2db      	uxtb	r3, r3
=======
 800cfaa:	3b01      	subs	r3, #1
 800cfac:	b2db      	uxtb	r3, r3
 800cfae:	4608      	mov	r0, r1
 800cfb0:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cfb2:	f000 fccd 	bl	800d950 <bufferBlockPushBytes>
 800cfb6:	6478      	str	r0, [r7, #68]	; 0x44
                                             (uint8_t) (frame->data_len - 1));
        if (ret < 0)
 800cfb8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800cfba:	2b00      	cmp	r3, #0
 800cfbc:	da0a      	bge.n	800cfd4 <canardHandleRxFrame+0x46c>
        {
            releaseStatePayload(ins, rx_state);
 800cfbe:	68f8      	ldr	r0, [r7, #12]
 800cfc0:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800cfc2:	f000 fc9d 	bl	800d900 <releaseStatePayload>
            prepareForNextTransfer(rx_state);
 800cfc6:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800cfc8:	f000 fb94 	bl	800d6f4 <prepareForNextTransfer>
 800cfcc:	e0f7      	b.n	800d1be <canardHandleRxFrame+0x656>
 800cfce:	bf00      	nop
 800cfd0:	001e8480 	.word	0x001e8480
            return;
        }
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
 800cfd4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cfd6:	8ad9      	ldrh	r1, [r3, #22]
                                          frame->data, (uint8_t)(frame->data_len - 1));
 800cfd8:	68bb      	ldr	r3, [r7, #8]
 800cfda:	1d1a      	adds	r2, r3, #4
 800cfdc:	68bb      	ldr	r3, [r7, #8]
 800cfde:	7b1b      	ldrb	r3, [r3, #12]
 800cfe0:	3b01      	subs	r3, #1
 800cfe2:	b2db      	uxtb	r3, r3
>>>>>>> 752c83b... update binaries
        {
            releaseStatePayload(ins, rx_state);
            prepareForNextTransfer(rx_state);
            return;
        }
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc,
<<<<<<< HEAD
 800cf5c:	4608      	mov	r0, r1
 800cf5e:	4611      	mov	r1, r2
 800cf60:	461a      	mov	r2, r3
 800cf62:	f000 ffcf 	bl	800df04 <crcAdd>
 800cf66:	4603      	mov	r3, r0
 800cf68:	461a      	mov	r2, r3
 800cf6a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf6c:	82da      	strh	r2, [r3, #22]
 800cf6e:	e0d0      	b.n	800d112 <canardHandleRxFrame+0x632>
=======
 800cfe4:	4608      	mov	r0, r1
 800cfe6:	4611      	mov	r1, r2
 800cfe8:	461a      	mov	r2, r3
 800cfea:	f000 ffcf 	bl	800df8c <crcAdd>
 800cfee:	4603      	mov	r3, r0
 800cff0:	461a      	mov	r2, r3
 800cff2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cff4:	82da      	strh	r2, [r3, #22]
 800cff6:	e0d0      	b.n	800d19a <canardHandleRxFrame+0x632>
>>>>>>> 752c83b... update binaries
                                          frame->data, (uint8_t)(frame->data_len - 1));
    }
    else                                                                            // End of a multi-frame transfer
    {
        const uint8_t frame_payload_size = (uint8_t)(frame->data_len - 1);
<<<<<<< HEAD
 800cf70:	68bb      	ldr	r3, [r7, #8]
 800cf72:	7b1b      	ldrb	r3, [r3, #12]
 800cf74:	3b01      	subs	r3, #1
 800cf76:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

        uint8_t tail_offset = 0;
 800cf7a:	2300      	movs	r3, #0
 800cf7c:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73

        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
 800cf80:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf82:	8b1b      	ldrh	r3, [r3, #24]
 800cf84:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800cf88:	b29b      	uxth	r3, r3
 800cf8a:	2b05      	cmp	r3, #5
 800cf8c:	d823      	bhi.n	800cfd6 <canardHandleRxFrame+0x4f6>
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
 800cf8e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cf90:	8b1b      	ldrh	r3, [r3, #24]
 800cf92:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800cf96:	b29b      	uxth	r3, r3
 800cf98:	66fb      	str	r3, [r7, #108]	; 0x6c
 800cf9a:	e012      	b.n	800cfc2 <canardHandleRxFrame+0x4e2>
=======
 800cff8:	68bb      	ldr	r3, [r7, #8]
 800cffa:	7b1b      	ldrb	r3, [r3, #12]
 800cffc:	3b01      	subs	r3, #1
 800cffe:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

        uint8_t tail_offset = 0;
 800d002:	2300      	movs	r3, #0
 800d004:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73

        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
 800d008:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d00a:	8b1b      	ldrh	r3, [r3, #24]
 800d00c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d010:	b29b      	uxth	r3, r3
 800d012:	2b05      	cmp	r3, #5
 800d014:	d823      	bhi.n	800d05e <canardHandleRxFrame+0x4f6>
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
 800d016:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d018:	8b1b      	ldrh	r3, [r3, #24]
 800d01a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d01e:	b29b      	uxth	r3, r3
 800d020:	66fb      	str	r3, [r7, #108]	; 0x6c
 800d022:	e012      	b.n	800d04a <canardHandleRxFrame+0x4e2>
>>>>>>> 752c83b... update binaries
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
                 i++, tail_offset++)
            {
                rx_state->buffer_head[i] = frame->data[tail_offset];
<<<<<<< HEAD
 800cf9c:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800cfa0:	68ba      	ldr	r2, [r7, #8]
 800cfa2:	4413      	add	r3, r2
 800cfa4:	7919      	ldrb	r1, [r3, #4]
 800cfa6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cfa8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cfaa:	4413      	add	r3, r2
 800cfac:	3318      	adds	r3, #24
 800cfae:	460a      	mov	r2, r1
 800cfb0:	709a      	strb	r2, [r3, #2]
=======
 800d024:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d028:	68ba      	ldr	r2, [r7, #8]
 800d02a:	4413      	add	r3, r2
 800d02c:	7919      	ldrb	r1, [r3, #4]
 800d02e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800d030:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800d032:	4413      	add	r3, r2
 800d034:	3318      	adds	r3, #24
 800d036:	460a      	mov	r2, r1
 800d038:	709a      	strb	r2, [r3, #2]
>>>>>>> 752c83b... update binaries
        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
                 i++, tail_offset++)
<<<<<<< HEAD
 800cfb2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cfb4:	3301      	adds	r3, #1
 800cfb6:	66fb      	str	r3, [r7, #108]	; 0x6c
 800cfb8:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800cfbc:	3301      	adds	r3, #1
 800cfbe:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
=======
 800d03a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800d03c:	3301      	adds	r3, #1
 800d03e:	66fb      	str	r3, [r7, #108]	; 0x6c
 800d040:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d044:	3301      	adds	r3, #1
 800d046:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
>>>>>>> 752c83b... update binaries
        uint8_t tail_offset = 0;

        if (rx_state->payload_len < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE)
        {
            // Copy the beginning of the frame into the head, point the tail pointer to the remainder
            for (size_t i = rx_state->payload_len;
<<<<<<< HEAD
 800cfc2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800cfc4:	2b05      	cmp	r3, #5
 800cfc6:	d840      	bhi.n	800d04a <canardHandleRxFrame+0x56a>
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
 800cfc8:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800cfcc:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800cfd0:	429a      	cmp	r2, r3
 800cfd2:	d3e3      	bcc.n	800cf9c <canardHandleRxFrame+0x4bc>
 800cfd4:	e039      	b.n	800d04a <canardHandleRxFrame+0x56a>
=======
 800d04a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800d04c:	2b05      	cmp	r3, #5
 800d04e:	d840      	bhi.n	800d0d2 <canardHandleRxFrame+0x56a>
                 (i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) && (tail_offset < frame_payload_size);
 800d050:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800d054:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d058:	429a      	cmp	r2, r3
 800d05a:	d3e3      	bcc.n	800d024 <canardHandleRxFrame+0x4bc>
 800d05c:	e039      	b.n	800d0d2 <canardHandleRxFrame+0x56a>
>>>>>>> 752c83b... update binaries
            }
        }
        else
        {
            // Like above, except that the beginning goes into the last block of the storage
            CanardBufferBlock* block = rx_state->buffer_blocks;
<<<<<<< HEAD
 800cfd6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cfd8:	685b      	ldr	r3, [r3, #4]
 800cfda:	66bb      	str	r3, [r7, #104]	; 0x68
            if (block != NULL)          // If there's no middle, that's fine, we'll use only head and tail
 800cfdc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800cfde:	2b00      	cmp	r3, #0
 800cfe0:	d033      	beq.n	800d04a <canardHandleRxFrame+0x56a>
            {
                size_t offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE;    // Payload offset of the first block
 800cfe2:	2306      	movs	r3, #6
 800cfe4:	667b      	str	r3, [r7, #100]	; 0x64
 800cfe6:	e005      	b.n	800cff4 <canardHandleRxFrame+0x514>
                while (block->next != NULL)
                {
                    block = block->next;
 800cfe8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800cfea:	681b      	ldr	r3, [r3, #0]
 800cfec:	66bb      	str	r3, [r7, #104]	; 0x68
                    offset += CANARD_BUFFER_BLOCK_DATA_SIZE;
 800cfee:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800cff0:	331c      	adds	r3, #28
 800cff2:	667b      	str	r3, [r7, #100]	; 0x64
=======
 800d05e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d060:	685b      	ldr	r3, [r3, #4]
 800d062:	66bb      	str	r3, [r7, #104]	; 0x68
            if (block != NULL)          // If there's no middle, that's fine, we'll use only head and tail
 800d064:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d066:	2b00      	cmp	r3, #0
 800d068:	d033      	beq.n	800d0d2 <canardHandleRxFrame+0x56a>
            {
                size_t offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE;    // Payload offset of the first block
 800d06a:	2306      	movs	r3, #6
 800d06c:	667b      	str	r3, [r7, #100]	; 0x64
 800d06e:	e005      	b.n	800d07c <canardHandleRxFrame+0x514>
                while (block->next != NULL)
                {
                    block = block->next;
 800d070:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d072:	681b      	ldr	r3, [r3, #0]
 800d074:	66bb      	str	r3, [r7, #104]	; 0x68
                    offset += CANARD_BUFFER_BLOCK_DATA_SIZE;
 800d076:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d078:	331c      	adds	r3, #28
 800d07a:	667b      	str	r3, [r7, #100]	; 0x64
>>>>>>> 752c83b... update binaries
            // Like above, except that the beginning goes into the last block of the storage
            CanardBufferBlock* block = rx_state->buffer_blocks;
            if (block != NULL)          // If there's no middle, that's fine, we'll use only head and tail
            {
                size_t offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE;    // Payload offset of the first block
                while (block->next != NULL)
<<<<<<< HEAD
 800cff4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800cff6:	681b      	ldr	r3, [r3, #0]
 800cff8:	2b00      	cmp	r3, #0
 800cffa:	d1f5      	bne.n	800cfe8 <canardHandleRxFrame+0x508>
=======
 800d07c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d07e:	681b      	ldr	r3, [r3, #0]
 800d080:	2b00      	cmp	r3, #0
 800d082:	d1f5      	bne.n	800d070 <canardHandleRxFrame+0x508>
>>>>>>> 752c83b... update binaries
                    block = block->next;
                    offset += CANARD_BUFFER_BLOCK_DATA_SIZE;
                }
                CANARD_ASSERT(block != NULL);

                const size_t offset_within_block = rx_state->payload_len - offset;
<<<<<<< HEAD
 800cffc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cffe:	8b1b      	ldrh	r3, [r3, #24]
 800d000:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d004:	b29b      	uxth	r3, r3
 800d006:	461a      	mov	r2, r3
 800d008:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d00a:	1ad3      	subs	r3, r2, r3
 800d00c:	63fb      	str	r3, [r7, #60]	; 0x3c
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
 800d00e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d010:	663b      	str	r3, [r7, #96]	; 0x60
 800d012:	e011      	b.n	800d038 <canardHandleRxFrame+0x558>
=======
 800d084:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d086:	8b1b      	ldrh	r3, [r3, #24]
 800d088:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d08c:	b29b      	uxth	r3, r3
 800d08e:	461a      	mov	r2, r3
 800d090:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d092:	1ad3      	subs	r3, r2, r3
 800d094:	63fb      	str	r3, [r7, #60]	; 0x3c
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
 800d096:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d098:	663b      	str	r3, [r7, #96]	; 0x60
 800d09a:	e011      	b.n	800d0c0 <canardHandleRxFrame+0x558>
>>>>>>> 752c83b... update binaries
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
                     i++, tail_offset++)
                {
                    block->data[i] = frame->data[tail_offset];
<<<<<<< HEAD
 800d014:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d018:	68ba      	ldr	r2, [r7, #8]
 800d01a:	4413      	add	r3, r2
 800d01c:	7919      	ldrb	r1, [r3, #4]
 800d01e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800d020:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d022:	4413      	add	r3, r2
 800d024:	460a      	mov	r2, r1
 800d026:	711a      	strb	r2, [r3, #4]
=======
 800d09c:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d0a0:	68ba      	ldr	r2, [r7, #8]
 800d0a2:	4413      	add	r3, r2
 800d0a4:	7919      	ldrb	r1, [r3, #4]
 800d0a6:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800d0a8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d0aa:	4413      	add	r3, r2
 800d0ac:	460a      	mov	r2, r1
 800d0ae:	711a      	strb	r2, [r3, #4]
>>>>>>> 752c83b... update binaries
                const size_t offset_within_block = rx_state->payload_len - offset;
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
                     i++, tail_offset++)
<<<<<<< HEAD
 800d028:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d02a:	3301      	adds	r3, #1
 800d02c:	663b      	str	r3, [r7, #96]	; 0x60
 800d02e:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d032:	3301      	adds	r3, #1
 800d034:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
=======
 800d0b0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d0b2:	3301      	adds	r3, #1
 800d0b4:	663b      	str	r3, [r7, #96]	; 0x60
 800d0b6:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d0ba:	3301      	adds	r3, #1
 800d0bc:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
>>>>>>> 752c83b... update binaries
                CANARD_ASSERT(block != NULL);

                const size_t offset_within_block = rx_state->payload_len - offset;
                CANARD_ASSERT(offset_within_block < CANARD_BUFFER_BLOCK_DATA_SIZE);

                for (size_t i = offset_within_block;
<<<<<<< HEAD
 800d038:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d03a:	2b1b      	cmp	r3, #27
 800d03c:	d805      	bhi.n	800d04a <canardHandleRxFrame+0x56a>
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
 800d03e:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800d042:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d046:	429a      	cmp	r2, r3
 800d048:	d3e4      	bcc.n	800d014 <canardHandleRxFrame+0x534>
=======
 800d0c0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d0c2:	2b1b      	cmp	r3, #27
 800d0c4:	d805      	bhi.n	800d0d2 <canardHandleRxFrame+0x56a>
                     (i < CANARD_BUFFER_BLOCK_DATA_SIZE) && (tail_offset < frame_payload_size);
 800d0c6:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800d0ca:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d0ce:	429a      	cmp	r2, r3
 800d0d0:	d3e4      	bcc.n	800d09c <canardHandleRxFrame+0x534>
>>>>>>> 752c83b... update binaries
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800d04a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800d04e:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
 800d052:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d054:	331a      	adds	r3, #26
=======
 800d0d2:	e9d7 2300 	ldrd	r2, r3, [r7]
 800d0d6:	e9c7 2304 	strd	r2, r3, [r7, #16]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
 800d0da:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0dc:	331a      	adds	r3, #26
>>>>>>> 752c83b... update binaries
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800d056:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
 800d058:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d05a:	685b      	ldr	r3, [r3, #4]
=======
 800d0de:	61bb      	str	r3, [r7, #24]
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
 800d0e0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0e2:	685b      	ldr	r3, [r3, #4]
>>>>>>> 752c83b... update binaries
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800d05c:	61fb      	str	r3, [r7, #28]
=======
 800d0e4:	61fb      	str	r3, [r7, #28]
>>>>>>> 752c83b... update binaries
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
<<<<<<< HEAD
 800d05e:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800d062:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d066:	429a      	cmp	r2, r3
 800d068:	d205      	bcs.n	800d076 <canardHandleRxFrame+0x596>
 800d06a:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d06e:	68ba      	ldr	r2, [r7, #8]
 800d070:	4413      	add	r3, r2
 800d072:	3304      	adds	r3, #4
 800d074:	e000      	b.n	800d078 <canardHandleRxFrame+0x598>
 800d076:	2300      	movs	r3, #0
=======
 800d0e6:	f897 2073 	ldrb.w	r2, [r7, #115]	; 0x73
 800d0ea:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d0ee:	429a      	cmp	r2, r3
 800d0f0:	d205      	bcs.n	800d0fe <canardHandleRxFrame+0x596>
 800d0f2:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800d0f6:	68ba      	ldr	r2, [r7, #8]
 800d0f8:	4413      	add	r3, r2
 800d0fa:	3304      	adds	r3, #4
 800d0fc:	e000      	b.n	800d100 <canardHandleRxFrame+0x598>
 800d0fe:	2300      	movs	r3, #0
>>>>>>> 752c83b... update binaries
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800d078:	623b      	str	r3, [r7, #32]
=======
 800d100:	623b      	str	r3, [r7, #32]
>>>>>>> 752c83b... update binaries
            .timestamp_usec = timestamp_usec,
            .payload_head = rx_state->buffer_head,
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
            .payload_len = (uint16_t)(rx_state->payload_len + frame_payload_size),
<<<<<<< HEAD
 800d07a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d07c:	8b1b      	ldrh	r3, [r3, #24]
 800d07e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d082:	b29b      	uxth	r3, r3
 800d084:	461a      	mov	r2, r3
 800d086:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d08a:	b29b      	uxth	r3, r3
 800d08c:	4413      	add	r3, r2
 800d08e:	b29b      	uxth	r3, r3
=======
 800d102:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d104:	8b1b      	ldrh	r3, [r3, #24]
 800d106:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d10a:	b29b      	uxth	r3, r3
 800d10c:	461a      	mov	r2, r3
 800d10e:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800d112:	b29b      	uxth	r3, r3
 800d114:	4413      	add	r3, r2
 800d116:	b29b      	uxth	r3, r3
>>>>>>> 752c83b... update binaries
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800d090:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d092:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800d096:	84fb      	strh	r3, [r7, #38]	; 0x26
 800d098:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800d09c:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
=======
 800d118:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d11a:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 800d11e:	84fb      	strh	r3, [r7, #38]	; 0x26
 800d120:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800d124:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
>>>>>>> 752c83b... update binaries
            .payload_middle = rx_state->buffer_blocks,
            .payload_tail = (tail_offset >= frame_payload_size) ? NULL : (&frame->data[tail_offset]),
            .payload_len = (uint16_t)(rx_state->payload_len + frame_payload_size),
            .data_type_id = data_type_id,
            .transfer_type = transfer_type,
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
<<<<<<< HEAD
 800d0a0:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800d0a4:	f003 031f 	and.w	r3, r3, #31
 800d0a8:	b2db      	uxtb	r3, r3
=======
 800d128:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 800d12c:	f003 031f 	and.w	r3, r3, #31
 800d130:	b2db      	uxtb	r3, r3
>>>>>>> 752c83b... update binaries
                    block->data[i] = frame->data[tail_offset];
                }
            }
        }

        CanardRxTransfer rx_transfer = {
<<<<<<< HEAD
 800d0aa:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800d0ae:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800d0b2:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800d0b6:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800d0ba:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
=======
 800d132:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 800d136:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 800d13a:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800d13e:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 800d142:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
>>>>>>> 752c83b... update binaries
            .transfer_id = TRANSFER_ID_FROM_TAIL_BYTE(tail_byte),
            .priority = priority,
            .source_node_id = source_node_id
        };

        rx_state->buffer_blocks = NULL;     // Block list ownership has been transferred to rx_transfer!
<<<<<<< HEAD
 800d0be:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0c0:	2200      	movs	r2, #0
 800d0c2:	605a      	str	r2, [r3, #4]

        // CRC validation
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc, frame->data, frame->data_len - 1U);
 800d0c4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0c6:	8ad9      	ldrh	r1, [r3, #22]
 800d0c8:	68bb      	ldr	r3, [r7, #8]
 800d0ca:	1d1a      	adds	r2, r3, #4
 800d0cc:	68bb      	ldr	r3, [r7, #8]
 800d0ce:	7b1b      	ldrb	r3, [r3, #12]
 800d0d0:	3b01      	subs	r3, #1
 800d0d2:	4608      	mov	r0, r1
 800d0d4:	4611      	mov	r1, r2
 800d0d6:	461a      	mov	r2, r3
 800d0d8:	f000 ff14 	bl	800df04 <crcAdd>
 800d0dc:	4603      	mov	r3, r0
 800d0de:	461a      	mov	r2, r3
 800d0e0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0e2:	82da      	strh	r2, [r3, #22]
        if (rx_state->calculated_crc == rx_state->payload_crc)
 800d0e4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0e6:	8ada      	ldrh	r2, [r3, #22]
 800d0e8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d0ea:	8a9b      	ldrh	r3, [r3, #20]
 800d0ec:	429a      	cmp	r2, r3
 800d0ee:	d106      	bne.n	800d0fe <canardHandleRxFrame+0x61e>
        {
            ins->on_reception(ins, &rx_transfer);
 800d0f0:	68fb      	ldr	r3, [r7, #12]
 800d0f2:	689b      	ldr	r3, [r3, #8]
 800d0f4:	f107 0210 	add.w	r2, r7, #16
 800d0f8:	68f8      	ldr	r0, [r7, #12]
 800d0fa:	4611      	mov	r1, r2
 800d0fc:	4798      	blx	r3
=======
 800d146:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d148:	2200      	movs	r2, #0
 800d14a:	605a      	str	r2, [r3, #4]

        // CRC validation
        rx_state->calculated_crc = crcAdd((uint16_t)rx_state->calculated_crc, frame->data, frame->data_len - 1U);
 800d14c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d14e:	8ad9      	ldrh	r1, [r3, #22]
 800d150:	68bb      	ldr	r3, [r7, #8]
 800d152:	1d1a      	adds	r2, r3, #4
 800d154:	68bb      	ldr	r3, [r7, #8]
 800d156:	7b1b      	ldrb	r3, [r3, #12]
 800d158:	3b01      	subs	r3, #1
 800d15a:	4608      	mov	r0, r1
 800d15c:	4611      	mov	r1, r2
 800d15e:	461a      	mov	r2, r3
 800d160:	f000 ff14 	bl	800df8c <crcAdd>
 800d164:	4603      	mov	r3, r0
 800d166:	461a      	mov	r2, r3
 800d168:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d16a:	82da      	strh	r2, [r3, #22]
        if (rx_state->calculated_crc == rx_state->payload_crc)
 800d16c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d16e:	8ada      	ldrh	r2, [r3, #22]
 800d170:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d172:	8a9b      	ldrh	r3, [r3, #20]
 800d174:	429a      	cmp	r2, r3
 800d176:	d106      	bne.n	800d186 <canardHandleRxFrame+0x61e>
        {
            ins->on_reception(ins, &rx_transfer);
 800d178:	68fb      	ldr	r3, [r7, #12]
 800d17a:	689b      	ldr	r3, [r3, #8]
 800d17c:	f107 0210 	add.w	r2, r7, #16
 800d180:	68f8      	ldr	r0, [r7, #12]
 800d182:	4611      	mov	r1, r2
 800d184:	4798      	blx	r3
>>>>>>> 752c83b... update binaries
        }

        // Making sure the payload is released even if the application didn't bother with it
        canardReleaseRxTransferPayload(ins, &rx_transfer);
<<<<<<< HEAD
 800d0fe:	f107 0310 	add.w	r3, r7, #16
 800d102:	68f8      	ldr	r0, [r7, #12]
 800d104:	4619      	mov	r1, r3
 800d106:	f000 fa6d 	bl	800d5e4 <canardReleaseRxTransferPayload>
        prepareForNextTransfer(rx_state);
 800d10a:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800d10c:	f000 faae 	bl	800d66c <prepareForNextTransfer>
 800d110:	e011      	b.n	800d136 <canardHandleRxFrame+0x656>
=======
 800d186:	f107 0310 	add.w	r3, r7, #16
 800d18a:	68f8      	ldr	r0, [r7, #12]
 800d18c:	4619      	mov	r1, r3
 800d18e:	f000 fa6d 	bl	800d66c <canardReleaseRxTransferPayload>
        prepareForNextTransfer(rx_state);
 800d192:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800d194:	f000 faae 	bl	800d6f4 <prepareForNextTransfer>
 800d198:	e011      	b.n	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
        return;
    }

    rx_state->next_toggle ^= 1;
<<<<<<< HEAD
 800d112:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d114:	7e5b      	ldrb	r3, [r3, #25]
 800d116:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d11a:	b2db      	uxtb	r3, r3
 800d11c:	f083 0301 	eor.w	r3, r3, #1
 800d120:	b2db      	uxtb	r3, r3
 800d122:	f003 0301 	and.w	r3, r3, #1
 800d126:	b2d9      	uxtb	r1, r3
 800d128:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800d12a:	7e53      	ldrb	r3, [r2, #25]
 800d12c:	f361 13c7 	bfi	r3, r1, #7, #1
 800d130:	7653      	strb	r3, [r2, #25]
 800d132:	e000      	b.n	800d136 <canardHandleRxFrame+0x656>
=======
 800d19a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d19c:	7e5b      	ldrb	r3, [r3, #25]
 800d19e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800d1a2:	b2db      	uxtb	r3, r3
 800d1a4:	f083 0301 	eor.w	r3, r3, #1
 800d1a8:	b2db      	uxtb	r3, r3
 800d1aa:	f003 0301 	and.w	r3, r3, #1
 800d1ae:	b2d9      	uxtb	r1, r3
 800d1b0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800d1b2:	7e53      	ldrb	r3, [r2, #25]
 800d1b4:	f361 13c7 	bfi	r3, r1, #7, #1
 800d1b8:	7653      	strb	r3, [r2, #25]
 800d1ba:	e000      	b.n	800d1be <canardHandleRxFrame+0x656>
>>>>>>> 752c83b... update binaries
        {
            rx_state = traverseRxStates(ins, transfer_descriptor);

            if(rx_state == NULL)
            {
                return; // No allocator room for this frame
<<<<<<< HEAD
 800d134:	bf00      	nop
=======
 800d1bc:	bf00      	nop
>>>>>>> 752c83b... update binaries
        prepareForNextTransfer(rx_state);
        return;
    }

    rx_state->next_toggle ^= 1;
}
<<<<<<< HEAD
 800d136:	3778      	adds	r7, #120	; 0x78
 800d138:	46bd      	mov	sp, r7
 800d13a:	bdb0      	pop	{r4, r5, r7, pc}

0800d13c <canardCleanupStaleTransfers>:

void canardCleanupStaleTransfers(CanardInstance* ins, uint64_t current_time_usec)
{
 800d13c:	b580      	push	{r7, lr}
 800d13e:	b086      	sub	sp, #24
 800d140:	af00      	add	r7, sp, #0
 800d142:	60f8      	str	r0, [r7, #12]
 800d144:	e9c7 2300 	strd	r2, r3, [r7]
    CanardRxState* prev = ins->rx_states, * state = ins->rx_states;
 800d148:	68fb      	ldr	r3, [r7, #12]
 800d14a:	699b      	ldr	r3, [r3, #24]
 800d14c:	617b      	str	r3, [r7, #20]
 800d14e:	68fb      	ldr	r3, [r7, #12]
 800d150:	699b      	ldr	r3, [r3, #24]
 800d152:	613b      	str	r3, [r7, #16]
 800d154:	e03f      	b.n	800d1d6 <canardCleanupStaleTransfers+0x9a>
=======
 800d1be:	3778      	adds	r7, #120	; 0x78
 800d1c0:	46bd      	mov	sp, r7
 800d1c2:	bdb0      	pop	{r4, r5, r7, pc}

0800d1c4 <canardCleanupStaleTransfers>:

void canardCleanupStaleTransfers(CanardInstance* ins, uint64_t current_time_usec)
{
 800d1c4:	b580      	push	{r7, lr}
 800d1c6:	b086      	sub	sp, #24
 800d1c8:	af00      	add	r7, sp, #0
 800d1ca:	60f8      	str	r0, [r7, #12]
 800d1cc:	e9c7 2300 	strd	r2, r3, [r7]
    CanardRxState* prev = ins->rx_states, * state = ins->rx_states;
 800d1d0:	68fb      	ldr	r3, [r7, #12]
 800d1d2:	699b      	ldr	r3, [r3, #24]
 800d1d4:	617b      	str	r3, [r7, #20]
 800d1d6:	68fb      	ldr	r3, [r7, #12]
 800d1d8:	699b      	ldr	r3, [r3, #24]
 800d1da:	613b      	str	r3, [r7, #16]
 800d1dc:	e03f      	b.n	800d25e <canardCleanupStaleTransfers+0x9a>
>>>>>>> 752c83b... update binaries

    while (state != NULL)
    {
        if ((current_time_usec - state->timestamp_usec) > TRANSFER_TIMEOUT_USEC)
<<<<<<< HEAD
 800d156:	693b      	ldr	r3, [r7, #16]
 800d158:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800d15c:	e9d7 0100 	ldrd	r0, r1, [r7]
 800d160:	1a82      	subs	r2, r0, r2
 800d162:	eb61 0303 	sbc.w	r3, r1, r3
 800d166:	481f      	ldr	r0, [pc, #124]	; (800d1e4 <canardCleanupStaleTransfers+0xa8>)
 800d168:	f04f 0100 	mov.w	r1, #0
 800d16c:	4299      	cmp	r1, r3
 800d16e:	bf08      	it	eq
 800d170:	4290      	cmpeq	r0, r2
 800d172:	d22b      	bcs.n	800d1cc <canardCleanupStaleTransfers+0x90>
        {
            if (state == ins->rx_states)
 800d174:	68fb      	ldr	r3, [r7, #12]
 800d176:	699a      	ldr	r2, [r3, #24]
 800d178:	693b      	ldr	r3, [r7, #16]
 800d17a:	429a      	cmp	r2, r3
 800d17c:	d114      	bne.n	800d1a8 <canardCleanupStaleTransfers+0x6c>
            {
                releaseStatePayload(ins, state);
 800d17e:	68f8      	ldr	r0, [r7, #12]
 800d180:	6939      	ldr	r1, [r7, #16]
 800d182:	f000 fb79 	bl	800d878 <releaseStatePayload>
                ins->rx_states = ins->rx_states->next;
 800d186:	68fb      	ldr	r3, [r7, #12]
 800d188:	699b      	ldr	r3, [r3, #24]
 800d18a:	681a      	ldr	r2, [r3, #0]
 800d18c:	68fb      	ldr	r3, [r7, #12]
 800d18e:	619a      	str	r2, [r3, #24]
                freeBlock(&ins->allocator, state);
 800d190:	68fb      	ldr	r3, [r7, #12]
 800d192:	330c      	adds	r3, #12
 800d194:	4618      	mov	r0, r3
 800d196:	6939      	ldr	r1, [r7, #16]
 800d198:	f000 ff2a 	bl	800dff0 <freeBlock>
                state = ins->rx_states;
 800d19c:	68fb      	ldr	r3, [r7, #12]
 800d19e:	699b      	ldr	r3, [r3, #24]
 800d1a0:	613b      	str	r3, [r7, #16]
                prev = state;
 800d1a2:	693b      	ldr	r3, [r7, #16]
 800d1a4:	617b      	str	r3, [r7, #20]
=======
 800d1de:	693b      	ldr	r3, [r7, #16]
 800d1e0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800d1e4:	e9d7 0100 	ldrd	r0, r1, [r7]
 800d1e8:	1a82      	subs	r2, r0, r2
 800d1ea:	eb61 0303 	sbc.w	r3, r1, r3
 800d1ee:	481f      	ldr	r0, [pc, #124]	; (800d26c <canardCleanupStaleTransfers+0xa8>)
 800d1f0:	f04f 0100 	mov.w	r1, #0
 800d1f4:	4299      	cmp	r1, r3
 800d1f6:	bf08      	it	eq
 800d1f8:	4290      	cmpeq	r0, r2
 800d1fa:	d22b      	bcs.n	800d254 <canardCleanupStaleTransfers+0x90>
        {
            if (state == ins->rx_states)
 800d1fc:	68fb      	ldr	r3, [r7, #12]
 800d1fe:	699a      	ldr	r2, [r3, #24]
 800d200:	693b      	ldr	r3, [r7, #16]
 800d202:	429a      	cmp	r2, r3
 800d204:	d114      	bne.n	800d230 <canardCleanupStaleTransfers+0x6c>
            {
                releaseStatePayload(ins, state);
 800d206:	68f8      	ldr	r0, [r7, #12]
 800d208:	6939      	ldr	r1, [r7, #16]
 800d20a:	f000 fb79 	bl	800d900 <releaseStatePayload>
                ins->rx_states = ins->rx_states->next;
 800d20e:	68fb      	ldr	r3, [r7, #12]
 800d210:	699b      	ldr	r3, [r3, #24]
 800d212:	681a      	ldr	r2, [r3, #0]
 800d214:	68fb      	ldr	r3, [r7, #12]
 800d216:	619a      	str	r2, [r3, #24]
                freeBlock(&ins->allocator, state);
 800d218:	68fb      	ldr	r3, [r7, #12]
 800d21a:	330c      	adds	r3, #12
 800d21c:	4618      	mov	r0, r3
 800d21e:	6939      	ldr	r1, [r7, #16]
 800d220:	f000 ff2a 	bl	800e078 <freeBlock>
                state = ins->rx_states;
 800d224:	68fb      	ldr	r3, [r7, #12]
 800d226:	699b      	ldr	r3, [r3, #24]
 800d228:	613b      	str	r3, [r7, #16]
                prev = state;
 800d22a:	693b      	ldr	r3, [r7, #16]
 800d22c:	617b      	str	r3, [r7, #20]
>>>>>>> 752c83b... update binaries
            else
            {
                releaseStatePayload(ins, state);
                prev->next = state->next;
                freeBlock(&ins->allocator, state);
                state = prev->next;
<<<<<<< HEAD
 800d1a6:	e016      	b.n	800d1d6 <canardCleanupStaleTransfers+0x9a>
=======
 800d22e:	e016      	b.n	800d25e <canardCleanupStaleTransfers+0x9a>
>>>>>>> 752c83b... update binaries
                state = ins->rx_states;
                prev = state;
            }
            else
            {
                releaseStatePayload(ins, state);
<<<<<<< HEAD
 800d1a8:	68f8      	ldr	r0, [r7, #12]
 800d1aa:	6939      	ldr	r1, [r7, #16]
 800d1ac:	f000 fb64 	bl	800d878 <releaseStatePayload>
                prev->next = state->next;
 800d1b0:	693b      	ldr	r3, [r7, #16]
 800d1b2:	681a      	ldr	r2, [r3, #0]
 800d1b4:	697b      	ldr	r3, [r7, #20]
 800d1b6:	601a      	str	r2, [r3, #0]
                freeBlock(&ins->allocator, state);
 800d1b8:	68fb      	ldr	r3, [r7, #12]
 800d1ba:	330c      	adds	r3, #12
 800d1bc:	4618      	mov	r0, r3
 800d1be:	6939      	ldr	r1, [r7, #16]
 800d1c0:	f000 ff16 	bl	800dff0 <freeBlock>
                state = prev->next;
 800d1c4:	697b      	ldr	r3, [r7, #20]
 800d1c6:	681b      	ldr	r3, [r3, #0]
 800d1c8:	613b      	str	r3, [r7, #16]
 800d1ca:	e004      	b.n	800d1d6 <canardCleanupStaleTransfers+0x9a>
=======
 800d230:	68f8      	ldr	r0, [r7, #12]
 800d232:	6939      	ldr	r1, [r7, #16]
 800d234:	f000 fb64 	bl	800d900 <releaseStatePayload>
                prev->next = state->next;
 800d238:	693b      	ldr	r3, [r7, #16]
 800d23a:	681a      	ldr	r2, [r3, #0]
 800d23c:	697b      	ldr	r3, [r7, #20]
 800d23e:	601a      	str	r2, [r3, #0]
                freeBlock(&ins->allocator, state);
 800d240:	68fb      	ldr	r3, [r7, #12]
 800d242:	330c      	adds	r3, #12
 800d244:	4618      	mov	r0, r3
 800d246:	6939      	ldr	r1, [r7, #16]
 800d248:	f000 ff16 	bl	800e078 <freeBlock>
                state = prev->next;
 800d24c:	697b      	ldr	r3, [r7, #20]
 800d24e:	681b      	ldr	r3, [r3, #0]
 800d250:	613b      	str	r3, [r7, #16]
 800d252:	e004      	b.n	800d25e <canardCleanupStaleTransfers+0x9a>
>>>>>>> 752c83b... update binaries
            }
        }
        else
        {
            prev = state;
<<<<<<< HEAD
 800d1cc:	693b      	ldr	r3, [r7, #16]
 800d1ce:	617b      	str	r3, [r7, #20]
            state = state->next;
 800d1d0:	693b      	ldr	r3, [r7, #16]
 800d1d2:	681b      	ldr	r3, [r3, #0]
 800d1d4:	613b      	str	r3, [r7, #16]
=======
 800d254:	693b      	ldr	r3, [r7, #16]
 800d256:	617b      	str	r3, [r7, #20]
            state = state->next;
 800d258:	693b      	ldr	r3, [r7, #16]
 800d25a:	681b      	ldr	r3, [r3, #0]
 800d25c:	613b      	str	r3, [r7, #16]
>>>>>>> 752c83b... update binaries

void canardCleanupStaleTransfers(CanardInstance* ins, uint64_t current_time_usec)
{
    CanardRxState* prev = ins->rx_states, * state = ins->rx_states;

    while (state != NULL)
<<<<<<< HEAD
 800d1d6:	693b      	ldr	r3, [r7, #16]
 800d1d8:	2b00      	cmp	r3, #0
 800d1da:	d1bc      	bne.n	800d156 <canardCleanupStaleTransfers+0x1a>
=======
 800d25e:	693b      	ldr	r3, [r7, #16]
 800d260:	2b00      	cmp	r3, #0
 800d262:	d1bc      	bne.n	800d1de <canardCleanupStaleTransfers+0x1a>
>>>>>>> 752c83b... update binaries
        {
            prev = state;
            state = state->next;
        }
    }
}
<<<<<<< HEAD
 800d1dc:	3718      	adds	r7, #24
 800d1de:	46bd      	mov	sp, r7
 800d1e0:	bd80      	pop	{r7, pc}
 800d1e2:	bf00      	nop
 800d1e4:	001e8480 	.word	0x001e8480

0800d1e8 <canardDecodeScalar>:
=======
 800d264:	3718      	adds	r7, #24
 800d266:	46bd      	mov	sp, r7
 800d268:	bd80      	pop	{r7, pc}
 800d26a:	bf00      	nop
 800d26c:	001e8480 	.word	0x001e8480

0800d270 <canardDecodeScalar>:
>>>>>>> 752c83b... update binaries
int canardDecodeScalar(const CanardRxTransfer* transfer,
                       uint32_t bit_offset,
                       uint8_t bit_length,
                       bool value_is_signed,
                       void* out_value)
{
<<<<<<< HEAD
 800d1e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d1ec:	b089      	sub	sp, #36	; 0x24
 800d1ee:	af00      	add	r7, sp, #0
 800d1f0:	60f8      	str	r0, [r7, #12]
 800d1f2:	60b9      	str	r1, [r7, #8]
 800d1f4:	4611      	mov	r1, r2
 800d1f6:	461a      	mov	r2, r3
 800d1f8:	460b      	mov	r3, r1
 800d1fa:	71fb      	strb	r3, [r7, #7]
 800d1fc:	4613      	mov	r3, r2
 800d1fe:	71bb      	strb	r3, [r7, #6]
    if (transfer == NULL || out_value == NULL)
 800d200:	68fb      	ldr	r3, [r7, #12]
 800d202:	2b00      	cmp	r3, #0
 800d204:	d002      	beq.n	800d20c <canardDecodeScalar+0x24>
 800d206:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d208:	2b00      	cmp	r3, #0
 800d20a:	d102      	bne.n	800d212 <canardDecodeScalar+0x2a>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d20c:	f06f 0301 	mvn.w	r3, #1
 800d210:	e15d      	b.n	800d4ce <canardDecodeScalar+0x2e6>
    }

    if (bit_length < 1 || bit_length > 64)
 800d212:	79fb      	ldrb	r3, [r7, #7]
 800d214:	2b00      	cmp	r3, #0
 800d216:	d002      	beq.n	800d21e <canardDecodeScalar+0x36>
 800d218:	79fb      	ldrb	r3, [r7, #7]
 800d21a:	2b40      	cmp	r3, #64	; 0x40
 800d21c:	d902      	bls.n	800d224 <canardDecodeScalar+0x3c>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d21e:	f06f 0301 	mvn.w	r3, #1
 800d222:	e154      	b.n	800d4ce <canardDecodeScalar+0x2e6>
    }

    if (bit_length == 1 && value_is_signed)
 800d224:	79fb      	ldrb	r3, [r7, #7]
 800d226:	2b01      	cmp	r3, #1
 800d228:	d105      	bne.n	800d236 <canardDecodeScalar+0x4e>
 800d22a:	79bb      	ldrb	r3, [r7, #6]
 800d22c:	2b00      	cmp	r3, #0
 800d22e:	d002      	beq.n	800d236 <canardDecodeScalar+0x4e>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d230:	f06f 0301 	mvn.w	r3, #1
 800d234:	e14b      	b.n	800d4ce <canardDecodeScalar+0x2e6>
=======
 800d270:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d274:	b089      	sub	sp, #36	; 0x24
 800d276:	af00      	add	r7, sp, #0
 800d278:	60f8      	str	r0, [r7, #12]
 800d27a:	60b9      	str	r1, [r7, #8]
 800d27c:	4611      	mov	r1, r2
 800d27e:	461a      	mov	r2, r3
 800d280:	460b      	mov	r3, r1
 800d282:	71fb      	strb	r3, [r7, #7]
 800d284:	4613      	mov	r3, r2
 800d286:	71bb      	strb	r3, [r7, #6]
    if (transfer == NULL || out_value == NULL)
 800d288:	68fb      	ldr	r3, [r7, #12]
 800d28a:	2b00      	cmp	r3, #0
 800d28c:	d002      	beq.n	800d294 <canardDecodeScalar+0x24>
 800d28e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d290:	2b00      	cmp	r3, #0
 800d292:	d102      	bne.n	800d29a <canardDecodeScalar+0x2a>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d294:	f06f 0301 	mvn.w	r3, #1
 800d298:	e15d      	b.n	800d556 <canardDecodeScalar+0x2e6>
    }

    if (bit_length < 1 || bit_length > 64)
 800d29a:	79fb      	ldrb	r3, [r7, #7]
 800d29c:	2b00      	cmp	r3, #0
 800d29e:	d002      	beq.n	800d2a6 <canardDecodeScalar+0x36>
 800d2a0:	79fb      	ldrb	r3, [r7, #7]
 800d2a2:	2b40      	cmp	r3, #64	; 0x40
 800d2a4:	d902      	bls.n	800d2ac <canardDecodeScalar+0x3c>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d2a6:	f06f 0301 	mvn.w	r3, #1
 800d2aa:	e154      	b.n	800d556 <canardDecodeScalar+0x2e6>
    }

    if (bit_length == 1 && value_is_signed)
 800d2ac:	79fb      	ldrb	r3, [r7, #7]
 800d2ae:	2b01      	cmp	r3, #1
 800d2b0:	d105      	bne.n	800d2be <canardDecodeScalar+0x4e>
 800d2b2:	79bb      	ldrb	r3, [r7, #6]
 800d2b4:	2b00      	cmp	r3, #0
 800d2b6:	d002      	beq.n	800d2be <canardDecodeScalar+0x4e>
    {
        return -CANARD_ERROR_INVALID_ARGUMENT;
 800d2b8:	f06f 0301 	mvn.w	r3, #1
 800d2bc:	e14b      	b.n	800d556 <canardDecodeScalar+0x2e6>
>>>>>>> 752c83b... update binaries
        uint64_t u64;
        int64_t  s64;           ///< Also double, possibly float, possibly long double (depends on implementation)
        uint8_t bytes[8];
    } storage;

    memset(&storage, 0, sizeof(storage));   // This is important
<<<<<<< HEAD
 800d236:	f107 0310 	add.w	r3, r7, #16
 800d23a:	4618      	mov	r0, r3
 800d23c:	2100      	movs	r1, #0
 800d23e:	2208      	movs	r2, #8
 800d240:	f001 f9c2 	bl	800e5c8 <memset>

    const int result = descatterTransferPayload(transfer, bit_offset, bit_length, &storage.bytes[0]);
 800d244:	79fa      	ldrb	r2, [r7, #7]
 800d246:	f107 0310 	add.w	r3, r7, #16
 800d24a:	68f8      	ldr	r0, [r7, #12]
 800d24c:	68b9      	ldr	r1, [r7, #8]
 800d24e:	f000 fcc9 	bl	800dbe4 <descatterTransferPayload>
 800d252:	61b8      	str	r0, [r7, #24]
    if (result <= 0)
 800d254:	69bb      	ldr	r3, [r7, #24]
 800d256:	2b00      	cmp	r3, #0
 800d258:	dc01      	bgt.n	800d25e <canardDecodeScalar+0x76>
    {
        return result;
 800d25a:	69bb      	ldr	r3, [r7, #24]
 800d25c:	e137      	b.n	800d4ce <canardDecodeScalar+0x2e6>
=======
 800d2be:	f107 0310 	add.w	r3, r7, #16
 800d2c2:	4618      	mov	r0, r3
 800d2c4:	2100      	movs	r1, #0
 800d2c6:	2208      	movs	r2, #8
 800d2c8:	f001 f9c2 	bl	800e650 <memset>

    const int result = descatterTransferPayload(transfer, bit_offset, bit_length, &storage.bytes[0]);
 800d2cc:	79fa      	ldrb	r2, [r7, #7]
 800d2ce:	f107 0310 	add.w	r3, r7, #16
 800d2d2:	68f8      	ldr	r0, [r7, #12]
 800d2d4:	68b9      	ldr	r1, [r7, #8]
 800d2d6:	f000 fcc9 	bl	800dc6c <descatterTransferPayload>
 800d2da:	61b8      	str	r0, [r7, #24]
    if (result <= 0)
 800d2dc:	69bb      	ldr	r3, [r7, #24]
 800d2de:	2b00      	cmp	r3, #0
 800d2e0:	dc01      	bgt.n	800d2e6 <canardDecodeScalar+0x76>
    {
        return result;
 800d2e2:	69bb      	ldr	r3, [r7, #24]
 800d2e4:	e137      	b.n	800d556 <canardDecodeScalar+0x2e6>
>>>>>>> 752c83b... update binaries
     * The bit copy algorithm assumes that more significant bits have lower index, so we need to shift some.
     * Extra most significant bits will be filled with zeroes, which is fine.
     * Coverity Scan mistakenly believes that the array may be overrun if bit_length == 64; however, this branch will
     * not be taken if bit_length == 64, because 64 % 8 == 0.
     */
    if ((bit_length % 8) != 0)
<<<<<<< HEAD
 800d25e:	79fb      	ldrb	r3, [r7, #7]
 800d260:	f003 0307 	and.w	r3, r3, #7
 800d264:	b2db      	uxtb	r3, r3
 800d266:	2b00      	cmp	r3, #0
 800d268:	d018      	beq.n	800d29c <canardDecodeScalar+0xb4>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] >> ((8 - (bit_length % 8)) & 7));
 800d26a:	79fb      	ldrb	r3, [r7, #7]
 800d26c:	08db      	lsrs	r3, r3, #3
 800d26e:	b2db      	uxtb	r3, r3
 800d270:	4619      	mov	r1, r3
 800d272:	79fb      	ldrb	r3, [r7, #7]
 800d274:	08db      	lsrs	r3, r3, #3
 800d276:	b2db      	uxtb	r3, r3
 800d278:	f107 0220 	add.w	r2, r7, #32
 800d27c:	4413      	add	r3, r2
 800d27e:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800d282:	461a      	mov	r2, r3
 800d284:	79fb      	ldrb	r3, [r7, #7]
 800d286:	425b      	negs	r3, r3
 800d288:	f003 0307 	and.w	r3, r3, #7
 800d28c:	fa42 f303 	asr.w	r3, r2, r3
 800d290:	b2da      	uxtb	r2, r3
 800d292:	f107 0320 	add.w	r3, r7, #32
 800d296:	440b      	add	r3, r1
 800d298:	f803 2c10 	strb.w	r2, [r3, #-16]
=======
 800d2e6:	79fb      	ldrb	r3, [r7, #7]
 800d2e8:	f003 0307 	and.w	r3, r3, #7
 800d2ec:	b2db      	uxtb	r3, r3
 800d2ee:	2b00      	cmp	r3, #0
 800d2f0:	d018      	beq.n	800d324 <canardDecodeScalar+0xb4>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] >> ((8 - (bit_length % 8)) & 7));
 800d2f2:	79fb      	ldrb	r3, [r7, #7]
 800d2f4:	08db      	lsrs	r3, r3, #3
 800d2f6:	b2db      	uxtb	r3, r3
 800d2f8:	4619      	mov	r1, r3
 800d2fa:	79fb      	ldrb	r3, [r7, #7]
 800d2fc:	08db      	lsrs	r3, r3, #3
 800d2fe:	b2db      	uxtb	r3, r3
 800d300:	f107 0220 	add.w	r2, r7, #32
 800d304:	4413      	add	r3, r2
 800d306:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800d30a:	461a      	mov	r2, r3
 800d30c:	79fb      	ldrb	r3, [r7, #7]
 800d30e:	425b      	negs	r3, r3
 800d310:	f003 0307 	and.w	r3, r3, #7
 800d314:	fa42 f303 	asr.w	r3, r2, r3
 800d318:	b2da      	uxtb	r2, r3
 800d31a:	f107 0320 	add.w	r3, r7, #32
 800d31e:	440b      	add	r3, r1
 800d320:	f803 2c10 	strb.w	r2, [r3, #-16]
>>>>>>> 752c83b... update binaries
    }

    /*
     * Determining the closest standard byte length - this will be needed for byte reordering and sign bit extension.
     */
    uint8_t std_byte_length = 0;
<<<<<<< HEAD
 800d29c:	2300      	movs	r3, #0
 800d29e:	77fb      	strb	r3, [r7, #31]
    if      (bit_length == 1)   { std_byte_length = sizeof(bool); }
 800d2a0:	79fb      	ldrb	r3, [r7, #7]
 800d2a2:	2b01      	cmp	r3, #1
 800d2a4:	d102      	bne.n	800d2ac <canardDecodeScalar+0xc4>
 800d2a6:	2301      	movs	r3, #1
 800d2a8:	77fb      	strb	r3, [r7, #31]
 800d2aa:	e01a      	b.n	800d2e2 <canardDecodeScalar+0xfa>
    else if (bit_length <= 8)   { std_byte_length = 1; }
 800d2ac:	79fb      	ldrb	r3, [r7, #7]
 800d2ae:	2b08      	cmp	r3, #8
 800d2b0:	d802      	bhi.n	800d2b8 <canardDecodeScalar+0xd0>
 800d2b2:	2301      	movs	r3, #1
 800d2b4:	77fb      	strb	r3, [r7, #31]
 800d2b6:	e014      	b.n	800d2e2 <canardDecodeScalar+0xfa>
    else if (bit_length <= 16)  { std_byte_length = 2; }
 800d2b8:	79fb      	ldrb	r3, [r7, #7]
 800d2ba:	2b10      	cmp	r3, #16
 800d2bc:	d802      	bhi.n	800d2c4 <canardDecodeScalar+0xdc>
 800d2be:	2302      	movs	r3, #2
 800d2c0:	77fb      	strb	r3, [r7, #31]
 800d2c2:	e00e      	b.n	800d2e2 <canardDecodeScalar+0xfa>
    else if (bit_length <= 32)  { std_byte_length = 4; }
 800d2c4:	79fb      	ldrb	r3, [r7, #7]
 800d2c6:	2b20      	cmp	r3, #32
 800d2c8:	d802      	bhi.n	800d2d0 <canardDecodeScalar+0xe8>
 800d2ca:	2304      	movs	r3, #4
 800d2cc:	77fb      	strb	r3, [r7, #31]
 800d2ce:	e008      	b.n	800d2e2 <canardDecodeScalar+0xfa>
    else if (bit_length <= 64)  { std_byte_length = 8; }
 800d2d0:	79fb      	ldrb	r3, [r7, #7]
 800d2d2:	2b40      	cmp	r3, #64	; 0x40
 800d2d4:	d802      	bhi.n	800d2dc <canardDecodeScalar+0xf4>
 800d2d6:	2308      	movs	r3, #8
 800d2d8:	77fb      	strb	r3, [r7, #31]
 800d2da:	e002      	b.n	800d2e2 <canardDecodeScalar+0xfa>
=======
 800d324:	2300      	movs	r3, #0
 800d326:	77fb      	strb	r3, [r7, #31]
    if      (bit_length == 1)   { std_byte_length = sizeof(bool); }
 800d328:	79fb      	ldrb	r3, [r7, #7]
 800d32a:	2b01      	cmp	r3, #1
 800d32c:	d102      	bne.n	800d334 <canardDecodeScalar+0xc4>
 800d32e:	2301      	movs	r3, #1
 800d330:	77fb      	strb	r3, [r7, #31]
 800d332:	e01a      	b.n	800d36a <canardDecodeScalar+0xfa>
    else if (bit_length <= 8)   { std_byte_length = 1; }
 800d334:	79fb      	ldrb	r3, [r7, #7]
 800d336:	2b08      	cmp	r3, #8
 800d338:	d802      	bhi.n	800d340 <canardDecodeScalar+0xd0>
 800d33a:	2301      	movs	r3, #1
 800d33c:	77fb      	strb	r3, [r7, #31]
 800d33e:	e014      	b.n	800d36a <canardDecodeScalar+0xfa>
    else if (bit_length <= 16)  { std_byte_length = 2; }
 800d340:	79fb      	ldrb	r3, [r7, #7]
 800d342:	2b10      	cmp	r3, #16
 800d344:	d802      	bhi.n	800d34c <canardDecodeScalar+0xdc>
 800d346:	2302      	movs	r3, #2
 800d348:	77fb      	strb	r3, [r7, #31]
 800d34a:	e00e      	b.n	800d36a <canardDecodeScalar+0xfa>
    else if (bit_length <= 32)  { std_byte_length = 4; }
 800d34c:	79fb      	ldrb	r3, [r7, #7]
 800d34e:	2b20      	cmp	r3, #32
 800d350:	d802      	bhi.n	800d358 <canardDecodeScalar+0xe8>
 800d352:	2304      	movs	r3, #4
 800d354:	77fb      	strb	r3, [r7, #31]
 800d356:	e008      	b.n	800d36a <canardDecodeScalar+0xfa>
    else if (bit_length <= 64)  { std_byte_length = 8; }
 800d358:	79fb      	ldrb	r3, [r7, #7]
 800d35a:	2b40      	cmp	r3, #64	; 0x40
 800d35c:	d802      	bhi.n	800d364 <canardDecodeScalar+0xf4>
 800d35e:	2308      	movs	r3, #8
 800d360:	77fb      	strb	r3, [r7, #31]
 800d362:	e002      	b.n	800d36a <canardDecodeScalar+0xfa>
>>>>>>> 752c83b... update binaries
    else
    {
        CANARD_ASSERT(false);
        return -CANARD_ERROR_INTERNAL;
<<<<<<< HEAD
 800d2dc:	f06f 0308 	mvn.w	r3, #8
 800d2e0:	e0f5      	b.n	800d4ce <canardDecodeScalar+0x2e6>
=======
 800d364:	f06f 0308 	mvn.w	r3, #8
 800d368:	e0f5      	b.n	800d556 <canardDecodeScalar+0x2e6>
>>>>>>> 752c83b... update binaries
    CANARD_ASSERT((std_byte_length > 0) && (std_byte_length <= 8));

    /*
     * Flipping the byte order if needed.
     */
    if (isBigEndian())
<<<<<<< HEAD
 800d2e2:	f000 fd6f 	bl	800ddc4 <isBigEndian>
 800d2e6:	4603      	mov	r3, r0
 800d2e8:	2b00      	cmp	r3, #0
 800d2ea:	d006      	beq.n	800d2fa <canardDecodeScalar+0x112>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800d2ec:	7ffb      	ldrb	r3, [r7, #31]
 800d2ee:	f107 0210 	add.w	r2, r7, #16
 800d2f2:	4610      	mov	r0, r2
 800d2f4:	4619      	mov	r1, r3
 800d2f6:	f000 fd77 	bl	800dde8 <swapByteOrder>
=======
 800d36a:	f000 fd6f 	bl	800de4c <isBigEndian>
 800d36e:	4603      	mov	r3, r0
 800d370:	2b00      	cmp	r3, #0
 800d372:	d006      	beq.n	800d382 <canardDecodeScalar+0x112>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800d374:	7ffb      	ldrb	r3, [r7, #31]
 800d376:	f107 0210 	add.w	r2, r7, #16
 800d37a:	4610      	mov	r0, r2
 800d37c:	4619      	mov	r1, r3
 800d37e:	f000 fd77 	bl	800de70 <swapByteOrder>
>>>>>>> 752c83b... update binaries
    }

    /*
     * Extending the sign bit if needed. I miss templates.
     */
    if (value_is_signed && (std_byte_length * 8 != bit_length))
<<<<<<< HEAD
 800d2fa:	79bb      	ldrb	r3, [r7, #6]
 800d2fc:	2b00      	cmp	r3, #0
 800d2fe:	f000 8099 	beq.w	800d434 <canardDecodeScalar+0x24c>
 800d302:	7ffb      	ldrb	r3, [r7, #31]
 800d304:	00da      	lsls	r2, r3, #3
 800d306:	79fb      	ldrb	r3, [r7, #7]
 800d308:	429a      	cmp	r2, r3
 800d30a:	f000 8093 	beq.w	800d434 <canardDecodeScalar+0x24c>
    {
        if (bit_length <= 8)
 800d30e:	79fb      	ldrb	r3, [r7, #7]
 800d310:	2b08      	cmp	r3, #8
 800d312:	d818      	bhi.n	800d346 <canardDecodeScalar+0x15e>
        {
            if ((storage.s8 & (1U << (bit_length - 1))) != 0)                           // If the sign bit is set...
 800d314:	7c3b      	ldrb	r3, [r7, #16]
 800d316:	b25a      	sxtb	r2, r3
 800d318:	79fb      	ldrb	r3, [r7, #7]
 800d31a:	3b01      	subs	r3, #1
 800d31c:	fa22 f303 	lsr.w	r3, r2, r3
 800d320:	f003 0301 	and.w	r3, r3, #1
 800d324:	2b00      	cmp	r3, #0
 800d326:	f000 8085 	beq.w	800d434 <canardDecodeScalar+0x24c>
            {
                storage.s8 |= (uint8_t) 0xFFU & (uint8_t) ~((1U << bit_length) - 1U);   // ...set all bits above it.
 800d32a:	7c39      	ldrb	r1, [r7, #16]
 800d32c:	79fb      	ldrb	r3, [r7, #7]
 800d32e:	2201      	movs	r2, #1
 800d330:	fa02 f303 	lsl.w	r3, r2, r3
 800d334:	b2db      	uxtb	r3, r3
 800d336:	425b      	negs	r3, r3
 800d338:	b2db      	uxtb	r3, r3
 800d33a:	b2db      	uxtb	r3, r3
 800d33c:	460a      	mov	r2, r1
 800d33e:	4313      	orrs	r3, r2
 800d340:	b2db      	uxtb	r3, r3
 800d342:	743b      	strb	r3, [r7, #16]
 800d344:	e076      	b.n	800d434 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 16)
 800d346:	79fb      	ldrb	r3, [r7, #7]
 800d348:	2b10      	cmp	r3, #16
 800d34a:	d817      	bhi.n	800d37c <canardDecodeScalar+0x194>
        {
            if ((storage.s16 & (1U << (bit_length - 1))) != 0)
 800d34c:	8a3b      	ldrh	r3, [r7, #16]
 800d34e:	b21a      	sxth	r2, r3
 800d350:	79fb      	ldrb	r3, [r7, #7]
 800d352:	3b01      	subs	r3, #1
 800d354:	fa22 f303 	lsr.w	r3, r2, r3
 800d358:	f003 0301 	and.w	r3, r3, #1
 800d35c:	2b00      	cmp	r3, #0
 800d35e:	d069      	beq.n	800d434 <canardDecodeScalar+0x24c>
            {
                storage.s16 |= (uint16_t) 0xFFFFU & (uint16_t) ~((1U << bit_length) - 1U);
 800d360:	8a39      	ldrh	r1, [r7, #16]
 800d362:	79fb      	ldrb	r3, [r7, #7]
 800d364:	2201      	movs	r2, #1
 800d366:	fa02 f303 	lsl.w	r3, r2, r3
 800d36a:	b29b      	uxth	r3, r3
 800d36c:	425b      	negs	r3, r3
 800d36e:	b29b      	uxth	r3, r3
 800d370:	b29b      	uxth	r3, r3
 800d372:	460a      	mov	r2, r1
 800d374:	4313      	orrs	r3, r2
 800d376:	b29b      	uxth	r3, r3
 800d378:	823b      	strh	r3, [r7, #16]
 800d37a:	e05b      	b.n	800d434 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 32)
 800d37c:	79fb      	ldrb	r3, [r7, #7]
 800d37e:	2b20      	cmp	r3, #32
 800d380:	d813      	bhi.n	800d3aa <canardDecodeScalar+0x1c2>
        {
            if ((storage.s32 & (((uint32_t) 1) << (bit_length - 1))) != 0)
 800d382:	693b      	ldr	r3, [r7, #16]
 800d384:	461a      	mov	r2, r3
 800d386:	79fb      	ldrb	r3, [r7, #7]
 800d388:	3b01      	subs	r3, #1
 800d38a:	fa22 f303 	lsr.w	r3, r2, r3
 800d38e:	f003 0301 	and.w	r3, r3, #1
 800d392:	2b00      	cmp	r3, #0
 800d394:	d04e      	beq.n	800d434 <canardDecodeScalar+0x24c>
            {
                storage.s32 |= (uint32_t) 0xFFFFFFFFUL & (uint32_t) ~((((uint32_t) 1) << bit_length) - 1U);
 800d396:	693b      	ldr	r3, [r7, #16]
 800d398:	4619      	mov	r1, r3
 800d39a:	79fb      	ldrb	r3, [r7, #7]
 800d39c:	2201      	movs	r2, #1
 800d39e:	fa02 f303 	lsl.w	r3, r2, r3
 800d3a2:	425b      	negs	r3, r3
 800d3a4:	430b      	orrs	r3, r1
 800d3a6:	613b      	str	r3, [r7, #16]
 800d3a8:	e044      	b.n	800d434 <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length < 64)   // Strictly less, this is not a typo
 800d3aa:	79fb      	ldrb	r3, [r7, #7]
 800d3ac:	2b3f      	cmp	r3, #63	; 0x3f
 800d3ae:	d83e      	bhi.n	800d42e <canardDecodeScalar+0x246>
        {
            if ((storage.s64 & (((uint64_t) 1) << (bit_length - 1))) != 0)
 800d3b0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d3b4:	79f9      	ldrb	r1, [r7, #7]
 800d3b6:	3901      	subs	r1, #1
 800d3b8:	f1c1 0620 	rsb	r6, r1, #32
 800d3bc:	f1a1 0020 	sub.w	r0, r1, #32
 800d3c0:	fa22 f801 	lsr.w	r8, r2, r1
 800d3c4:	fa03 f606 	lsl.w	r6, r3, r6
 800d3c8:	ea48 0806 	orr.w	r8, r8, r6
 800d3cc:	fa23 f000 	lsr.w	r0, r3, r0
 800d3d0:	ea48 0800 	orr.w	r8, r8, r0
 800d3d4:	fa23 f901 	lsr.w	r9, r3, r1
 800d3d8:	f04f 0201 	mov.w	r2, #1
 800d3dc:	f04f 0300 	mov.w	r3, #0
 800d3e0:	ea02 0208 	and.w	r2, r2, r8
 800d3e4:	ea03 0309 	and.w	r3, r3, r9
 800d3e8:	4313      	orrs	r3, r2
 800d3ea:	d023      	beq.n	800d434 <canardDecodeScalar+0x24c>
            {
                storage.s64 |= (uint64_t) 0xFFFFFFFFFFFFFFFFULL & (uint64_t) ~((((uint64_t) 1) << bit_length) - 1U);
 800d3ec:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d3f0:	4690      	mov	r8, r2
 800d3f2:	4699      	mov	r9, r3
 800d3f4:	79f9      	ldrb	r1, [r7, #7]
 800d3f6:	f04f 0201 	mov.w	r2, #1
 800d3fa:	f04f 0300 	mov.w	r3, #0
 800d3fe:	f1a1 0620 	sub.w	r6, r1, #32
 800d402:	f1c1 0020 	rsb	r0, r1, #32
 800d406:	fa03 f501 	lsl.w	r5, r3, r1
 800d40a:	fa02 f606 	lsl.w	r6, r2, r6
 800d40e:	4335      	orrs	r5, r6
 800d410:	fa22 f000 	lsr.w	r0, r2, r0
 800d414:	4305      	orrs	r5, r0
 800d416:	fa02 f401 	lsl.w	r4, r2, r1
 800d41a:	4262      	negs	r2, r4
 800d41c:	eb65 0345 	sbc.w	r3, r5, r5, lsl #1
 800d420:	ea42 0208 	orr.w	r2, r2, r8
 800d424:	ea43 0309 	orr.w	r3, r3, r9
 800d428:	e9c7 2304 	strd	r2, r3, [r7, #16]
 800d42c:	e002      	b.n	800d434 <canardDecodeScalar+0x24c>
=======
 800d382:	79bb      	ldrb	r3, [r7, #6]
 800d384:	2b00      	cmp	r3, #0
 800d386:	f000 8099 	beq.w	800d4bc <canardDecodeScalar+0x24c>
 800d38a:	7ffb      	ldrb	r3, [r7, #31]
 800d38c:	00da      	lsls	r2, r3, #3
 800d38e:	79fb      	ldrb	r3, [r7, #7]
 800d390:	429a      	cmp	r2, r3
 800d392:	f000 8093 	beq.w	800d4bc <canardDecodeScalar+0x24c>
    {
        if (bit_length <= 8)
 800d396:	79fb      	ldrb	r3, [r7, #7]
 800d398:	2b08      	cmp	r3, #8
 800d39a:	d818      	bhi.n	800d3ce <canardDecodeScalar+0x15e>
        {
            if ((storage.s8 & (1U << (bit_length - 1))) != 0)                           // If the sign bit is set...
 800d39c:	7c3b      	ldrb	r3, [r7, #16]
 800d39e:	b25a      	sxtb	r2, r3
 800d3a0:	79fb      	ldrb	r3, [r7, #7]
 800d3a2:	3b01      	subs	r3, #1
 800d3a4:	fa22 f303 	lsr.w	r3, r2, r3
 800d3a8:	f003 0301 	and.w	r3, r3, #1
 800d3ac:	2b00      	cmp	r3, #0
 800d3ae:	f000 8085 	beq.w	800d4bc <canardDecodeScalar+0x24c>
            {
                storage.s8 |= (uint8_t) 0xFFU & (uint8_t) ~((1U << bit_length) - 1U);   // ...set all bits above it.
 800d3b2:	7c39      	ldrb	r1, [r7, #16]
 800d3b4:	79fb      	ldrb	r3, [r7, #7]
 800d3b6:	2201      	movs	r2, #1
 800d3b8:	fa02 f303 	lsl.w	r3, r2, r3
 800d3bc:	b2db      	uxtb	r3, r3
 800d3be:	425b      	negs	r3, r3
 800d3c0:	b2db      	uxtb	r3, r3
 800d3c2:	b2db      	uxtb	r3, r3
 800d3c4:	460a      	mov	r2, r1
 800d3c6:	4313      	orrs	r3, r2
 800d3c8:	b2db      	uxtb	r3, r3
 800d3ca:	743b      	strb	r3, [r7, #16]
 800d3cc:	e076      	b.n	800d4bc <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 16)
 800d3ce:	79fb      	ldrb	r3, [r7, #7]
 800d3d0:	2b10      	cmp	r3, #16
 800d3d2:	d817      	bhi.n	800d404 <canardDecodeScalar+0x194>
        {
            if ((storage.s16 & (1U << (bit_length - 1))) != 0)
 800d3d4:	8a3b      	ldrh	r3, [r7, #16]
 800d3d6:	b21a      	sxth	r2, r3
 800d3d8:	79fb      	ldrb	r3, [r7, #7]
 800d3da:	3b01      	subs	r3, #1
 800d3dc:	fa22 f303 	lsr.w	r3, r2, r3
 800d3e0:	f003 0301 	and.w	r3, r3, #1
 800d3e4:	2b00      	cmp	r3, #0
 800d3e6:	d069      	beq.n	800d4bc <canardDecodeScalar+0x24c>
            {
                storage.s16 |= (uint16_t) 0xFFFFU & (uint16_t) ~((1U << bit_length) - 1U);
 800d3e8:	8a39      	ldrh	r1, [r7, #16]
 800d3ea:	79fb      	ldrb	r3, [r7, #7]
 800d3ec:	2201      	movs	r2, #1
 800d3ee:	fa02 f303 	lsl.w	r3, r2, r3
 800d3f2:	b29b      	uxth	r3, r3
 800d3f4:	425b      	negs	r3, r3
 800d3f6:	b29b      	uxth	r3, r3
 800d3f8:	b29b      	uxth	r3, r3
 800d3fa:	460a      	mov	r2, r1
 800d3fc:	4313      	orrs	r3, r2
 800d3fe:	b29b      	uxth	r3, r3
 800d400:	823b      	strh	r3, [r7, #16]
 800d402:	e05b      	b.n	800d4bc <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length <= 32)
 800d404:	79fb      	ldrb	r3, [r7, #7]
 800d406:	2b20      	cmp	r3, #32
 800d408:	d813      	bhi.n	800d432 <canardDecodeScalar+0x1c2>
        {
            if ((storage.s32 & (((uint32_t) 1) << (bit_length - 1))) != 0)
 800d40a:	693b      	ldr	r3, [r7, #16]
 800d40c:	461a      	mov	r2, r3
 800d40e:	79fb      	ldrb	r3, [r7, #7]
 800d410:	3b01      	subs	r3, #1
 800d412:	fa22 f303 	lsr.w	r3, r2, r3
 800d416:	f003 0301 	and.w	r3, r3, #1
 800d41a:	2b00      	cmp	r3, #0
 800d41c:	d04e      	beq.n	800d4bc <canardDecodeScalar+0x24c>
            {
                storage.s32 |= (uint32_t) 0xFFFFFFFFUL & (uint32_t) ~((((uint32_t) 1) << bit_length) - 1U);
 800d41e:	693b      	ldr	r3, [r7, #16]
 800d420:	4619      	mov	r1, r3
 800d422:	79fb      	ldrb	r3, [r7, #7]
 800d424:	2201      	movs	r2, #1
 800d426:	fa02 f303 	lsl.w	r3, r2, r3
 800d42a:	425b      	negs	r3, r3
 800d42c:	430b      	orrs	r3, r1
 800d42e:	613b      	str	r3, [r7, #16]
 800d430:	e044      	b.n	800d4bc <canardDecodeScalar+0x24c>
            }
        }
        else if (bit_length < 64)   // Strictly less, this is not a typo
 800d432:	79fb      	ldrb	r3, [r7, #7]
 800d434:	2b3f      	cmp	r3, #63	; 0x3f
 800d436:	d83e      	bhi.n	800d4b6 <canardDecodeScalar+0x246>
        {
            if ((storage.s64 & (((uint64_t) 1) << (bit_length - 1))) != 0)
 800d438:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d43c:	79f9      	ldrb	r1, [r7, #7]
 800d43e:	3901      	subs	r1, #1
 800d440:	f1c1 0620 	rsb	r6, r1, #32
 800d444:	f1a1 0020 	sub.w	r0, r1, #32
 800d448:	fa22 f801 	lsr.w	r8, r2, r1
 800d44c:	fa03 f606 	lsl.w	r6, r3, r6
 800d450:	ea48 0806 	orr.w	r8, r8, r6
 800d454:	fa23 f000 	lsr.w	r0, r3, r0
 800d458:	ea48 0800 	orr.w	r8, r8, r0
 800d45c:	fa23 f901 	lsr.w	r9, r3, r1
 800d460:	f04f 0201 	mov.w	r2, #1
 800d464:	f04f 0300 	mov.w	r3, #0
 800d468:	ea02 0208 	and.w	r2, r2, r8
 800d46c:	ea03 0309 	and.w	r3, r3, r9
 800d470:	4313      	orrs	r3, r2
 800d472:	d023      	beq.n	800d4bc <canardDecodeScalar+0x24c>
            {
                storage.s64 |= (uint64_t) 0xFFFFFFFFFFFFFFFFULL & (uint64_t) ~((((uint64_t) 1) << bit_length) - 1U);
 800d474:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d478:	4690      	mov	r8, r2
 800d47a:	4699      	mov	r9, r3
 800d47c:	79f9      	ldrb	r1, [r7, #7]
 800d47e:	f04f 0201 	mov.w	r2, #1
 800d482:	f04f 0300 	mov.w	r3, #0
 800d486:	f1a1 0620 	sub.w	r6, r1, #32
 800d48a:	f1c1 0020 	rsb	r0, r1, #32
 800d48e:	fa03 f501 	lsl.w	r5, r3, r1
 800d492:	fa02 f606 	lsl.w	r6, r2, r6
 800d496:	4335      	orrs	r5, r6
 800d498:	fa22 f000 	lsr.w	r0, r2, r0
 800d49c:	4305      	orrs	r5, r0
 800d49e:	fa02 f401 	lsl.w	r4, r2, r1
 800d4a2:	4262      	negs	r2, r4
 800d4a4:	eb65 0345 	sbc.w	r3, r5, r5, lsl #1
 800d4a8:	ea42 0208 	orr.w	r2, r2, r8
 800d4ac:	ea43 0309 	orr.w	r3, r3, r9
 800d4b0:	e9c7 2304 	strd	r2, r3, [r7, #16]
 800d4b4:	e002      	b.n	800d4bc <canardDecodeScalar+0x24c>
>>>>>>> 752c83b... update binaries
            }
        }
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
<<<<<<< HEAD
 800d42e:	f06f 0308 	mvn.w	r3, #8
 800d432:	e04c      	b.n	800d4ce <canardDecodeScalar+0x2e6>
=======
 800d4b6:	f06f 0308 	mvn.w	r3, #8
 800d4ba:	e04c      	b.n	800d556 <canardDecodeScalar+0x2e6>
>>>>>>> 752c83b... update binaries
    }

    /*
     * Copying the result out.
     */
    if (value_is_signed)
<<<<<<< HEAD
 800d434:	79bb      	ldrb	r3, [r7, #6]
 800d436:	2b00      	cmp	r3, #0
 800d438:	d020      	beq.n	800d47c <canardDecodeScalar+0x294>
    {
        if      (bit_length <= 8)   { *( (int8_t*) out_value) = storage.s8;  }
 800d43a:	79fb      	ldrb	r3, [r7, #7]
 800d43c:	2b08      	cmp	r3, #8
 800d43e:	d803      	bhi.n	800d448 <canardDecodeScalar+0x260>
 800d440:	7c3a      	ldrb	r2, [r7, #16]
 800d442:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d444:	701a      	strb	r2, [r3, #0]
 800d446:	e041      	b.n	800d4cc <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((int16_t*) out_value) = storage.s16; }
 800d448:	79fb      	ldrb	r3, [r7, #7]
 800d44a:	2b10      	cmp	r3, #16
 800d44c:	d803      	bhi.n	800d456 <canardDecodeScalar+0x26e>
 800d44e:	8a3a      	ldrh	r2, [r7, #16]
 800d450:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d452:	801a      	strh	r2, [r3, #0]
 800d454:	e03a      	b.n	800d4cc <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((int32_t*) out_value) = storage.s32; }
 800d456:	79fb      	ldrb	r3, [r7, #7]
 800d458:	2b20      	cmp	r3, #32
 800d45a:	d803      	bhi.n	800d464 <canardDecodeScalar+0x27c>
 800d45c:	693a      	ldr	r2, [r7, #16]
 800d45e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d460:	601a      	str	r2, [r3, #0]
 800d462:	e033      	b.n	800d4cc <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((int64_t*) out_value) = storage.s64; }
 800d464:	79fb      	ldrb	r3, [r7, #7]
 800d466:	2b40      	cmp	r3, #64	; 0x40
 800d468:	d805      	bhi.n	800d476 <canardDecodeScalar+0x28e>
 800d46a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d46e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800d470:	e9c1 2300 	strd	r2, r3, [r1]
 800d474:	e02a      	b.n	800d4cc <canardDecodeScalar+0x2e4>
=======
 800d4bc:	79bb      	ldrb	r3, [r7, #6]
 800d4be:	2b00      	cmp	r3, #0
 800d4c0:	d020      	beq.n	800d504 <canardDecodeScalar+0x294>
    {
        if      (bit_length <= 8)   { *( (int8_t*) out_value) = storage.s8;  }
 800d4c2:	79fb      	ldrb	r3, [r7, #7]
 800d4c4:	2b08      	cmp	r3, #8
 800d4c6:	d803      	bhi.n	800d4d0 <canardDecodeScalar+0x260>
 800d4c8:	7c3a      	ldrb	r2, [r7, #16]
 800d4ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d4cc:	701a      	strb	r2, [r3, #0]
 800d4ce:	e041      	b.n	800d554 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((int16_t*) out_value) = storage.s16; }
 800d4d0:	79fb      	ldrb	r3, [r7, #7]
 800d4d2:	2b10      	cmp	r3, #16
 800d4d4:	d803      	bhi.n	800d4de <canardDecodeScalar+0x26e>
 800d4d6:	8a3a      	ldrh	r2, [r7, #16]
 800d4d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d4da:	801a      	strh	r2, [r3, #0]
 800d4dc:	e03a      	b.n	800d554 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((int32_t*) out_value) = storage.s32; }
 800d4de:	79fb      	ldrb	r3, [r7, #7]
 800d4e0:	2b20      	cmp	r3, #32
 800d4e2:	d803      	bhi.n	800d4ec <canardDecodeScalar+0x27c>
 800d4e4:	693a      	ldr	r2, [r7, #16]
 800d4e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d4e8:	601a      	str	r2, [r3, #0]
 800d4ea:	e033      	b.n	800d554 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((int64_t*) out_value) = storage.s64; }
 800d4ec:	79fb      	ldrb	r3, [r7, #7]
 800d4ee:	2b40      	cmp	r3, #64	; 0x40
 800d4f0:	d805      	bhi.n	800d4fe <canardDecodeScalar+0x28e>
 800d4f2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d4f6:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800d4f8:	e9c1 2300 	strd	r2, r3, [r1]
 800d4fc:	e02a      	b.n	800d554 <canardDecodeScalar+0x2e4>
>>>>>>> 752c83b... update binaries
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
<<<<<<< HEAD
 800d476:	f06f 0308 	mvn.w	r3, #8
 800d47a:	e028      	b.n	800d4ce <canardDecodeScalar+0x2e6>
=======
 800d4fe:	f06f 0308 	mvn.w	r3, #8
 800d502:	e028      	b.n	800d556 <canardDecodeScalar+0x2e6>
>>>>>>> 752c83b... update binaries
        }
    }
    else
    {
        if      (bit_length == 1)   { *(    (bool*) out_value) = storage.boolean; }
<<<<<<< HEAD
 800d47c:	79fb      	ldrb	r3, [r7, #7]
 800d47e:	2b01      	cmp	r3, #1
 800d480:	d103      	bne.n	800d48a <canardDecodeScalar+0x2a2>
 800d482:	7c3a      	ldrb	r2, [r7, #16]
 800d484:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d486:	701a      	strb	r2, [r3, #0]
 800d488:	e020      	b.n	800d4cc <canardDecodeScalar+0x2e4>
        else if (bit_length <= 8)   { *( (uint8_t*) out_value) = storage.u8;  }
 800d48a:	79fb      	ldrb	r3, [r7, #7]
 800d48c:	2b08      	cmp	r3, #8
 800d48e:	d803      	bhi.n	800d498 <canardDecodeScalar+0x2b0>
 800d490:	7c3a      	ldrb	r2, [r7, #16]
 800d492:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d494:	701a      	strb	r2, [r3, #0]
 800d496:	e019      	b.n	800d4cc <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((uint16_t*) out_value) = storage.u16; }
 800d498:	79fb      	ldrb	r3, [r7, #7]
 800d49a:	2b10      	cmp	r3, #16
 800d49c:	d803      	bhi.n	800d4a6 <canardDecodeScalar+0x2be>
 800d49e:	8a3a      	ldrh	r2, [r7, #16]
 800d4a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d4a2:	801a      	strh	r2, [r3, #0]
 800d4a4:	e012      	b.n	800d4cc <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((uint32_t*) out_value) = storage.u32; }
 800d4a6:	79fb      	ldrb	r3, [r7, #7]
 800d4a8:	2b20      	cmp	r3, #32
 800d4aa:	d803      	bhi.n	800d4b4 <canardDecodeScalar+0x2cc>
 800d4ac:	693a      	ldr	r2, [r7, #16]
 800d4ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d4b0:	601a      	str	r2, [r3, #0]
 800d4b2:	e00b      	b.n	800d4cc <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((uint64_t*) out_value) = storage.u64; }
 800d4b4:	79fb      	ldrb	r3, [r7, #7]
 800d4b6:	2b40      	cmp	r3, #64	; 0x40
 800d4b8:	d805      	bhi.n	800d4c6 <canardDecodeScalar+0x2de>
 800d4ba:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d4be:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800d4c0:	e9c1 2300 	strd	r2, r3, [r1]
 800d4c4:	e002      	b.n	800d4cc <canardDecodeScalar+0x2e4>
=======
 800d504:	79fb      	ldrb	r3, [r7, #7]
 800d506:	2b01      	cmp	r3, #1
 800d508:	d103      	bne.n	800d512 <canardDecodeScalar+0x2a2>
 800d50a:	7c3a      	ldrb	r2, [r7, #16]
 800d50c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d50e:	701a      	strb	r2, [r3, #0]
 800d510:	e020      	b.n	800d554 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 8)   { *( (uint8_t*) out_value) = storage.u8;  }
 800d512:	79fb      	ldrb	r3, [r7, #7]
 800d514:	2b08      	cmp	r3, #8
 800d516:	d803      	bhi.n	800d520 <canardDecodeScalar+0x2b0>
 800d518:	7c3a      	ldrb	r2, [r7, #16]
 800d51a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d51c:	701a      	strb	r2, [r3, #0]
 800d51e:	e019      	b.n	800d554 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 16)  { *((uint16_t*) out_value) = storage.u16; }
 800d520:	79fb      	ldrb	r3, [r7, #7]
 800d522:	2b10      	cmp	r3, #16
 800d524:	d803      	bhi.n	800d52e <canardDecodeScalar+0x2be>
 800d526:	8a3a      	ldrh	r2, [r7, #16]
 800d528:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d52a:	801a      	strh	r2, [r3, #0]
 800d52c:	e012      	b.n	800d554 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 32)  { *((uint32_t*) out_value) = storage.u32; }
 800d52e:	79fb      	ldrb	r3, [r7, #7]
 800d530:	2b20      	cmp	r3, #32
 800d532:	d803      	bhi.n	800d53c <canardDecodeScalar+0x2cc>
 800d534:	693a      	ldr	r2, [r7, #16]
 800d536:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d538:	601a      	str	r2, [r3, #0]
 800d53a:	e00b      	b.n	800d554 <canardDecodeScalar+0x2e4>
        else if (bit_length <= 64)  { *((uint64_t*) out_value) = storage.u64; }
 800d53c:	79fb      	ldrb	r3, [r7, #7]
 800d53e:	2b40      	cmp	r3, #64	; 0x40
 800d540:	d805      	bhi.n	800d54e <canardDecodeScalar+0x2de>
 800d542:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800d546:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800d548:	e9c1 2300 	strd	r2, r3, [r1]
 800d54c:	e002      	b.n	800d554 <canardDecodeScalar+0x2e4>
>>>>>>> 752c83b... update binaries
        else
        {
            CANARD_ASSERT(false);
            return -CANARD_ERROR_INTERNAL;
<<<<<<< HEAD
 800d4c6:	f06f 0308 	mvn.w	r3, #8
 800d4ca:	e000      	b.n	800d4ce <canardDecodeScalar+0x2e6>
=======
 800d54e:	f06f 0308 	mvn.w	r3, #8
 800d552:	e000      	b.n	800d556 <canardDecodeScalar+0x2e6>
>>>>>>> 752c83b... update binaries
        }
    }

    CANARD_ASSERT(result <= bit_length);
    CANARD_ASSERT(result > 0);
    return result;
<<<<<<< HEAD
 800d4cc:	69bb      	ldr	r3, [r7, #24]
}
 800d4ce:	4618      	mov	r0, r3
 800d4d0:	3724      	adds	r7, #36	; 0x24
 800d4d2:	46bd      	mov	sp, r7
 800d4d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800d4d8 <canardEncodeScalar>:
=======
 800d554:	69bb      	ldr	r3, [r7, #24]
}
 800d556:	4618      	mov	r0, r3
 800d558:	3724      	adds	r7, #36	; 0x24
 800d55a:	46bd      	mov	sp, r7
 800d55c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800d560 <canardEncodeScalar>:
>>>>>>> 752c83b... update binaries

void canardEncodeScalar(void* destination,
                        uint32_t bit_offset,
                        uint8_t bit_length,
                        const void* value)
{
<<<<<<< HEAD
 800d4d8:	b580      	push	{r7, lr}
 800d4da:	b08a      	sub	sp, #40	; 0x28
 800d4dc:	af02      	add	r7, sp, #8
 800d4de:	60f8      	str	r0, [r7, #12]
 800d4e0:	60b9      	str	r1, [r7, #8]
 800d4e2:	603b      	str	r3, [r7, #0]
 800d4e4:	4613      	mov	r3, r2
 800d4e6:	71fb      	strb	r3, [r7, #7]
=======
 800d560:	b580      	push	{r7, lr}
 800d562:	b08a      	sub	sp, #40	; 0x28
 800d564:	af02      	add	r7, sp, #8
 800d566:	60f8      	str	r0, [r7, #12]
 800d568:	60b9      	str	r1, [r7, #8]
 800d56a:	603b      	str	r3, [r7, #0]
 800d56c:	4613      	mov	r3, r2
 800d56e:	71fb      	strb	r3, [r7, #7]
>>>>>>> 752c83b... update binaries
     * Maybe not the best solution, but it simplifies the API.
     */
    CANARD_ASSERT(destination != NULL);
    CANARD_ASSERT(value != NULL);

    if (bit_length > 64)
<<<<<<< HEAD
 800d4e8:	79fb      	ldrb	r3, [r7, #7]
 800d4ea:	2b40      	cmp	r3, #64	; 0x40
 800d4ec:	d901      	bls.n	800d4f2 <canardEncodeScalar+0x1a>
    {
        CANARD_ASSERT(false);
        bit_length = 64;
 800d4ee:	2340      	movs	r3, #64	; 0x40
 800d4f0:	71fb      	strb	r3, [r7, #7]
    }

    if (bit_length < 1)
 800d4f2:	79fb      	ldrb	r3, [r7, #7]
 800d4f4:	2b00      	cmp	r3, #0
 800d4f6:	d101      	bne.n	800d4fc <canardEncodeScalar+0x24>
    {
        CANARD_ASSERT(false);
        bit_length = 1;
 800d4f8:	2301      	movs	r3, #1
 800d4fa:	71fb      	strb	r3, [r7, #7]
=======
 800d570:	79fb      	ldrb	r3, [r7, #7]
 800d572:	2b40      	cmp	r3, #64	; 0x40
 800d574:	d901      	bls.n	800d57a <canardEncodeScalar+0x1a>
    {
        CANARD_ASSERT(false);
        bit_length = 64;
 800d576:	2340      	movs	r3, #64	; 0x40
 800d578:	71fb      	strb	r3, [r7, #7]
    }

    if (bit_length < 1)
 800d57a:	79fb      	ldrb	r3, [r7, #7]
 800d57c:	2b00      	cmp	r3, #0
 800d57e:	d101      	bne.n	800d584 <canardEncodeScalar+0x24>
    {
        CANARD_ASSERT(false);
        bit_length = 1;
 800d580:	2301      	movs	r3, #1
 800d582:	71fb      	strb	r3, [r7, #7]
>>>>>>> 752c83b... update binaries
        uint32_t u32;
        uint64_t u64;
        uint8_t bytes[8];
    } storage;

    memset(&storage, 0, sizeof(storage));
<<<<<<< HEAD
 800d4fc:	f107 0310 	add.w	r3, r7, #16
 800d500:	4618      	mov	r0, r3
 800d502:	2100      	movs	r1, #0
 800d504:	2208      	movs	r2, #8
 800d506:	f001 f85f 	bl	800e5c8 <memset>

    uint8_t std_byte_length = 0;
 800d50a:	2300      	movs	r3, #0
 800d50c:	77fb      	strb	r3, [r7, #31]

    // Extra most significant bits can be safely ignored here.
    if      (bit_length == 1)   { std_byte_length = sizeof(bool);   storage.boolean = (*((bool*) value) != 0); }
 800d50e:	79fb      	ldrb	r3, [r7, #7]
 800d510:	2b01      	cmp	r3, #1
 800d512:	d10a      	bne.n	800d52a <canardEncodeScalar+0x52>
 800d514:	2301      	movs	r3, #1
 800d516:	77fb      	strb	r3, [r7, #31]
 800d518:	683b      	ldr	r3, [r7, #0]
 800d51a:	781b      	ldrb	r3, [r3, #0]
 800d51c:	2b00      	cmp	r3, #0
 800d51e:	bf14      	ite	ne
 800d520:	2301      	movne	r3, #1
 800d522:	2300      	moveq	r3, #0
 800d524:	b2db      	uxtb	r3, r3
 800d526:	743b      	strb	r3, [r7, #16]
 800d528:	e024      	b.n	800d574 <canardEncodeScalar+0x9c>
    else if (bit_length <= 8)   { std_byte_length = 1;              storage.u8  = *((uint8_t*) value);  }
 800d52a:	79fb      	ldrb	r3, [r7, #7]
 800d52c:	2b08      	cmp	r3, #8
 800d52e:	d805      	bhi.n	800d53c <canardEncodeScalar+0x64>
 800d530:	2301      	movs	r3, #1
 800d532:	77fb      	strb	r3, [r7, #31]
 800d534:	683b      	ldr	r3, [r7, #0]
 800d536:	781b      	ldrb	r3, [r3, #0]
 800d538:	743b      	strb	r3, [r7, #16]
 800d53a:	e01b      	b.n	800d574 <canardEncodeScalar+0x9c>
    else if (bit_length <= 16)  { std_byte_length = 2;              storage.u16 = *((uint16_t*) value); }
 800d53c:	79fb      	ldrb	r3, [r7, #7]
 800d53e:	2b10      	cmp	r3, #16
 800d540:	d805      	bhi.n	800d54e <canardEncodeScalar+0x76>
 800d542:	2302      	movs	r3, #2
 800d544:	77fb      	strb	r3, [r7, #31]
 800d546:	683b      	ldr	r3, [r7, #0]
 800d548:	881b      	ldrh	r3, [r3, #0]
 800d54a:	823b      	strh	r3, [r7, #16]
 800d54c:	e012      	b.n	800d574 <canardEncodeScalar+0x9c>
    else if (bit_length <= 32)  { std_byte_length = 4;              storage.u32 = *((uint32_t*) value); }
 800d54e:	79fb      	ldrb	r3, [r7, #7]
 800d550:	2b20      	cmp	r3, #32
 800d552:	d805      	bhi.n	800d560 <canardEncodeScalar+0x88>
 800d554:	2304      	movs	r3, #4
 800d556:	77fb      	strb	r3, [r7, #31]
 800d558:	683b      	ldr	r3, [r7, #0]
 800d55a:	681b      	ldr	r3, [r3, #0]
 800d55c:	613b      	str	r3, [r7, #16]
 800d55e:	e009      	b.n	800d574 <canardEncodeScalar+0x9c>
    else if (bit_length <= 64)  { std_byte_length = 8;              storage.u64 = *((uint64_t*) value); }
 800d560:	79fb      	ldrb	r3, [r7, #7]
 800d562:	2b40      	cmp	r3, #64	; 0x40
 800d564:	d806      	bhi.n	800d574 <canardEncodeScalar+0x9c>
 800d566:	2308      	movs	r3, #8
 800d568:	77fb      	strb	r3, [r7, #31]
 800d56a:	683b      	ldr	r3, [r7, #0]
 800d56c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d570:	e9c7 2304 	strd	r2, r3, [r7, #16]
=======
 800d584:	f107 0310 	add.w	r3, r7, #16
 800d588:	4618      	mov	r0, r3
 800d58a:	2100      	movs	r1, #0
 800d58c:	2208      	movs	r2, #8
 800d58e:	f001 f85f 	bl	800e650 <memset>

    uint8_t std_byte_length = 0;
 800d592:	2300      	movs	r3, #0
 800d594:	77fb      	strb	r3, [r7, #31]

    // Extra most significant bits can be safely ignored here.
    if      (bit_length == 1)   { std_byte_length = sizeof(bool);   storage.boolean = (*((bool*) value) != 0); }
 800d596:	79fb      	ldrb	r3, [r7, #7]
 800d598:	2b01      	cmp	r3, #1
 800d59a:	d10a      	bne.n	800d5b2 <canardEncodeScalar+0x52>
 800d59c:	2301      	movs	r3, #1
 800d59e:	77fb      	strb	r3, [r7, #31]
 800d5a0:	683b      	ldr	r3, [r7, #0]
 800d5a2:	781b      	ldrb	r3, [r3, #0]
 800d5a4:	2b00      	cmp	r3, #0
 800d5a6:	bf14      	ite	ne
 800d5a8:	2301      	movne	r3, #1
 800d5aa:	2300      	moveq	r3, #0
 800d5ac:	b2db      	uxtb	r3, r3
 800d5ae:	743b      	strb	r3, [r7, #16]
 800d5b0:	e024      	b.n	800d5fc <canardEncodeScalar+0x9c>
    else if (bit_length <= 8)   { std_byte_length = 1;              storage.u8  = *((uint8_t*) value);  }
 800d5b2:	79fb      	ldrb	r3, [r7, #7]
 800d5b4:	2b08      	cmp	r3, #8
 800d5b6:	d805      	bhi.n	800d5c4 <canardEncodeScalar+0x64>
 800d5b8:	2301      	movs	r3, #1
 800d5ba:	77fb      	strb	r3, [r7, #31]
 800d5bc:	683b      	ldr	r3, [r7, #0]
 800d5be:	781b      	ldrb	r3, [r3, #0]
 800d5c0:	743b      	strb	r3, [r7, #16]
 800d5c2:	e01b      	b.n	800d5fc <canardEncodeScalar+0x9c>
    else if (bit_length <= 16)  { std_byte_length = 2;              storage.u16 = *((uint16_t*) value); }
 800d5c4:	79fb      	ldrb	r3, [r7, #7]
 800d5c6:	2b10      	cmp	r3, #16
 800d5c8:	d805      	bhi.n	800d5d6 <canardEncodeScalar+0x76>
 800d5ca:	2302      	movs	r3, #2
 800d5cc:	77fb      	strb	r3, [r7, #31]
 800d5ce:	683b      	ldr	r3, [r7, #0]
 800d5d0:	881b      	ldrh	r3, [r3, #0]
 800d5d2:	823b      	strh	r3, [r7, #16]
 800d5d4:	e012      	b.n	800d5fc <canardEncodeScalar+0x9c>
    else if (bit_length <= 32)  { std_byte_length = 4;              storage.u32 = *((uint32_t*) value); }
 800d5d6:	79fb      	ldrb	r3, [r7, #7]
 800d5d8:	2b20      	cmp	r3, #32
 800d5da:	d805      	bhi.n	800d5e8 <canardEncodeScalar+0x88>
 800d5dc:	2304      	movs	r3, #4
 800d5de:	77fb      	strb	r3, [r7, #31]
 800d5e0:	683b      	ldr	r3, [r7, #0]
 800d5e2:	681b      	ldr	r3, [r3, #0]
 800d5e4:	613b      	str	r3, [r7, #16]
 800d5e6:	e009      	b.n	800d5fc <canardEncodeScalar+0x9c>
    else if (bit_length <= 64)  { std_byte_length = 8;              storage.u64 = *((uint64_t*) value); }
 800d5e8:	79fb      	ldrb	r3, [r7, #7]
 800d5ea:	2b40      	cmp	r3, #64	; 0x40
 800d5ec:	d806      	bhi.n	800d5fc <canardEncodeScalar+0x9c>
 800d5ee:	2308      	movs	r3, #8
 800d5f0:	77fb      	strb	r3, [r7, #31]
 800d5f2:	683b      	ldr	r3, [r7, #0]
 800d5f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d5f8:	e9c7 2304 	strd	r2, r3, [r7, #16]
>>>>>>> 752c83b... update binaries
        CANARD_ASSERT(false);
    }

    CANARD_ASSERT(std_byte_length > 0);

    if (isBigEndian())
<<<<<<< HEAD
 800d574:	f000 fc26 	bl	800ddc4 <isBigEndian>
 800d578:	4603      	mov	r3, r0
 800d57a:	2b00      	cmp	r3, #0
 800d57c:	d006      	beq.n	800d58c <canardEncodeScalar+0xb4>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800d57e:	7ffb      	ldrb	r3, [r7, #31]
 800d580:	f107 0210 	add.w	r2, r7, #16
 800d584:	4610      	mov	r0, r2
 800d586:	4619      	mov	r1, r3
 800d588:	f000 fc2e 	bl	800dde8 <swapByteOrder>
=======
 800d5fc:	f000 fc26 	bl	800de4c <isBigEndian>
 800d600:	4603      	mov	r3, r0
 800d602:	2b00      	cmp	r3, #0
 800d604:	d006      	beq.n	800d614 <canardEncodeScalar+0xb4>
    {
        swapByteOrder(&storage.bytes[0], std_byte_length);
 800d606:	7ffb      	ldrb	r3, [r7, #31]
 800d608:	f107 0210 	add.w	r2, r7, #16
 800d60c:	4610      	mov	r0, r2
 800d60e:	4619      	mov	r1, r3
 800d610:	f000 fc2e 	bl	800de70 <swapByteOrder>
>>>>>>> 752c83b... update binaries
     * Extra least significant bits will be filled with zeroes, which is fine.
     * Extra most significant bits will be discarded here.
     * Coverity Scan mistakenly believes that the array may be overrun if bit_length == 64; however, this branch will
     * not be taken if bit_length == 64, because 64 % 8 == 0.
     */
    if ((bit_length % 8) != 0)
<<<<<<< HEAD
 800d58c:	79fb      	ldrb	r3, [r7, #7]
 800d58e:	f003 0307 	and.w	r3, r3, #7
 800d592:	b2db      	uxtb	r3, r3
 800d594:	2b00      	cmp	r3, #0
 800d596:	d018      	beq.n	800d5ca <canardEncodeScalar+0xf2>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] << ((8 - (bit_length % 8)) & 7));
 800d598:	79fb      	ldrb	r3, [r7, #7]
 800d59a:	08db      	lsrs	r3, r3, #3
 800d59c:	b2db      	uxtb	r3, r3
 800d59e:	4619      	mov	r1, r3
 800d5a0:	79fb      	ldrb	r3, [r7, #7]
 800d5a2:	08db      	lsrs	r3, r3, #3
 800d5a4:	b2db      	uxtb	r3, r3
 800d5a6:	f107 0220 	add.w	r2, r7, #32
 800d5aa:	4413      	add	r3, r2
 800d5ac:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800d5b0:	461a      	mov	r2, r3
 800d5b2:	79fb      	ldrb	r3, [r7, #7]
 800d5b4:	425b      	negs	r3, r3
 800d5b6:	f003 0307 	and.w	r3, r3, #7
 800d5ba:	fa02 f303 	lsl.w	r3, r2, r3
 800d5be:	b2da      	uxtb	r2, r3
 800d5c0:	f107 0320 	add.w	r3, r7, #32
 800d5c4:	440b      	add	r3, r1
 800d5c6:	f803 2c10 	strb.w	r2, [r3, #-16]
=======
 800d614:	79fb      	ldrb	r3, [r7, #7]
 800d616:	f003 0307 	and.w	r3, r3, #7
 800d61a:	b2db      	uxtb	r3, r3
 800d61c:	2b00      	cmp	r3, #0
 800d61e:	d018      	beq.n	800d652 <canardEncodeScalar+0xf2>
    {
        // coverity[overrun-local]
        storage.bytes[bit_length / 8] = (uint8_t)(storage.bytes[bit_length / 8] << ((8 - (bit_length % 8)) & 7));
 800d620:	79fb      	ldrb	r3, [r7, #7]
 800d622:	08db      	lsrs	r3, r3, #3
 800d624:	b2db      	uxtb	r3, r3
 800d626:	4619      	mov	r1, r3
 800d628:	79fb      	ldrb	r3, [r7, #7]
 800d62a:	08db      	lsrs	r3, r3, #3
 800d62c:	b2db      	uxtb	r3, r3
 800d62e:	f107 0220 	add.w	r2, r7, #32
 800d632:	4413      	add	r3, r2
 800d634:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 800d638:	461a      	mov	r2, r3
 800d63a:	79fb      	ldrb	r3, [r7, #7]
 800d63c:	425b      	negs	r3, r3
 800d63e:	f003 0307 	and.w	r3, r3, #7
 800d642:	fa02 f303 	lsl.w	r3, r2, r3
 800d646:	b2da      	uxtb	r2, r3
 800d648:	f107 0320 	add.w	r3, r7, #32
 800d64c:	440b      	add	r3, r1
 800d64e:	f803 2c10 	strb.w	r2, [r3, #-16]
>>>>>>> 752c83b... update binaries
    }

    /*
     * Now, the storage contains properly serialized scalar. Copying it out.
     */
    copyBitArray(&storage.bytes[0], 0, bit_length, (uint8_t*) destination, bit_offset);
<<<<<<< HEAD
 800d5ca:	79fa      	ldrb	r2, [r7, #7]
 800d5cc:	f107 0110 	add.w	r1, r7, #16
 800d5d0:	68bb      	ldr	r3, [r7, #8]
 800d5d2:	9300      	str	r3, [sp, #0]
 800d5d4:	4608      	mov	r0, r1
 800d5d6:	2100      	movs	r1, #0
 800d5d8:	68fb      	ldr	r3, [r7, #12]
 800d5da:	f000 fa89 	bl	800daf0 <copyBitArray>
}
 800d5de:	3720      	adds	r7, #32
 800d5e0:	46bd      	mov	sp, r7
 800d5e2:	bd80      	pop	{r7, pc}

0800d5e4 <canardReleaseRxTransferPayload>:

void canardReleaseRxTransferPayload(CanardInstance* ins, CanardRxTransfer* transfer)
{
 800d5e4:	b580      	push	{r7, lr}
 800d5e6:	b084      	sub	sp, #16
 800d5e8:	af00      	add	r7, sp, #0
 800d5ea:	6078      	str	r0, [r7, #4]
 800d5ec:	6039      	str	r1, [r7, #0]
 800d5ee:	e00f      	b.n	800d610 <canardReleaseRxTransferPayload+0x2c>
    while (transfer->payload_middle != NULL)
    {
        CanardBufferBlock* const temp = transfer->payload_middle->next;
 800d5f0:	683b      	ldr	r3, [r7, #0]
 800d5f2:	68db      	ldr	r3, [r3, #12]
 800d5f4:	681b      	ldr	r3, [r3, #0]
 800d5f6:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, transfer->payload_middle);
 800d5f8:	687b      	ldr	r3, [r7, #4]
 800d5fa:	f103 020c 	add.w	r2, r3, #12
 800d5fe:	683b      	ldr	r3, [r7, #0]
 800d600:	68db      	ldr	r3, [r3, #12]
 800d602:	4610      	mov	r0, r2
 800d604:	4619      	mov	r1, r3
 800d606:	f000 fcf3 	bl	800dff0 <freeBlock>
        transfer->payload_middle = temp;
 800d60a:	683b      	ldr	r3, [r7, #0]
 800d60c:	68fa      	ldr	r2, [r7, #12]
 800d60e:	60da      	str	r2, [r3, #12]
=======
 800d652:	79fa      	ldrb	r2, [r7, #7]
 800d654:	f107 0110 	add.w	r1, r7, #16
 800d658:	68bb      	ldr	r3, [r7, #8]
 800d65a:	9300      	str	r3, [sp, #0]
 800d65c:	4608      	mov	r0, r1
 800d65e:	2100      	movs	r1, #0
 800d660:	68fb      	ldr	r3, [r7, #12]
 800d662:	f000 fa89 	bl	800db78 <copyBitArray>
}
 800d666:	3720      	adds	r7, #32
 800d668:	46bd      	mov	sp, r7
 800d66a:	bd80      	pop	{r7, pc}

0800d66c <canardReleaseRxTransferPayload>:

void canardReleaseRxTransferPayload(CanardInstance* ins, CanardRxTransfer* transfer)
{
 800d66c:	b580      	push	{r7, lr}
 800d66e:	b084      	sub	sp, #16
 800d670:	af00      	add	r7, sp, #0
 800d672:	6078      	str	r0, [r7, #4]
 800d674:	6039      	str	r1, [r7, #0]
 800d676:	e00f      	b.n	800d698 <canardReleaseRxTransferPayload+0x2c>
    while (transfer->payload_middle != NULL)
    {
        CanardBufferBlock* const temp = transfer->payload_middle->next;
 800d678:	683b      	ldr	r3, [r7, #0]
 800d67a:	68db      	ldr	r3, [r3, #12]
 800d67c:	681b      	ldr	r3, [r3, #0]
 800d67e:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, transfer->payload_middle);
 800d680:	687b      	ldr	r3, [r7, #4]
 800d682:	f103 020c 	add.w	r2, r3, #12
 800d686:	683b      	ldr	r3, [r7, #0]
 800d688:	68db      	ldr	r3, [r3, #12]
 800d68a:	4610      	mov	r0, r2
 800d68c:	4619      	mov	r1, r3
 800d68e:	f000 fcf3 	bl	800e078 <freeBlock>
        transfer->payload_middle = temp;
 800d692:	683b      	ldr	r3, [r7, #0]
 800d694:	68fa      	ldr	r2, [r7, #12]
 800d696:	60da      	str	r2, [r3, #12]
>>>>>>> 752c83b... update binaries
    copyBitArray(&storage.bytes[0], 0, bit_length, (uint8_t*) destination, bit_offset);
}

void canardReleaseRxTransferPayload(CanardInstance* ins, CanardRxTransfer* transfer)
{
    while (transfer->payload_middle != NULL)
<<<<<<< HEAD
 800d610:	683b      	ldr	r3, [r7, #0]
 800d612:	68db      	ldr	r3, [r3, #12]
 800d614:	2b00      	cmp	r3, #0
 800d616:	d1eb      	bne.n	800d5f0 <canardReleaseRxTransferPayload+0xc>
=======
 800d698:	683b      	ldr	r3, [r7, #0]
 800d69a:	68db      	ldr	r3, [r3, #12]
 800d69c:	2b00      	cmp	r3, #0
 800d69e:	d1eb      	bne.n	800d678 <canardReleaseRxTransferPayload+0xc>
>>>>>>> 752c83b... update binaries
        CanardBufferBlock* const temp = transfer->payload_middle->next;
        freeBlock(&ins->allocator, transfer->payload_middle);
        transfer->payload_middle = temp;
    }

    transfer->payload_middle = NULL;
<<<<<<< HEAD
 800d618:	683b      	ldr	r3, [r7, #0]
 800d61a:	2200      	movs	r2, #0
 800d61c:	60da      	str	r2, [r3, #12]
    transfer->payload_head = NULL;
 800d61e:	683b      	ldr	r3, [r7, #0]
 800d620:	2200      	movs	r2, #0
 800d622:	609a      	str	r2, [r3, #8]
    transfer->payload_tail = NULL;
 800d624:	683b      	ldr	r3, [r7, #0]
 800d626:	2200      	movs	r2, #0
 800d628:	611a      	str	r2, [r3, #16]
    transfer->payload_len = 0;
 800d62a:	683b      	ldr	r3, [r7, #0]
 800d62c:	2200      	movs	r2, #0
 800d62e:	829a      	strh	r2, [r3, #20]
}
 800d630:	3710      	adds	r7, #16
 800d632:	46bd      	mov	sp, r7
 800d634:	bd80      	pop	{r7, pc}
 800d636:	bf00      	nop

0800d638 <computeTransferIDForwardDistance>:
=======
 800d6a0:	683b      	ldr	r3, [r7, #0]
 800d6a2:	2200      	movs	r2, #0
 800d6a4:	60da      	str	r2, [r3, #12]
    transfer->payload_head = NULL;
 800d6a6:	683b      	ldr	r3, [r7, #0]
 800d6a8:	2200      	movs	r2, #0
 800d6aa:	609a      	str	r2, [r3, #8]
    transfer->payload_tail = NULL;
 800d6ac:	683b      	ldr	r3, [r7, #0]
 800d6ae:	2200      	movs	r2, #0
 800d6b0:	611a      	str	r2, [r3, #16]
    transfer->payload_len = 0;
 800d6b2:	683b      	ldr	r3, [r7, #0]
 800d6b4:	2200      	movs	r2, #0
 800d6b6:	829a      	strh	r2, [r3, #20]
}
 800d6b8:	3710      	adds	r7, #16
 800d6ba:	46bd      	mov	sp, r7
 800d6bc:	bd80      	pop	{r7, pc}
 800d6be:	bf00      	nop

0800d6c0 <computeTransferIDForwardDistance>:
>>>>>>> 752c83b... update binaries

/*
 * Internal (static functions)
 */
CANARD_INTERNAL int computeTransferIDForwardDistance(uint8_t a, uint8_t b)
{
<<<<<<< HEAD
 800d638:	b480      	push	{r7}
 800d63a:	b085      	sub	sp, #20
 800d63c:	af00      	add	r7, sp, #0
 800d63e:	4603      	mov	r3, r0
 800d640:	460a      	mov	r2, r1
 800d642:	71fb      	strb	r3, [r7, #7]
 800d644:	4613      	mov	r3, r2
 800d646:	71bb      	strb	r3, [r7, #6]
    int d = b - a;
 800d648:	79ba      	ldrb	r2, [r7, #6]
 800d64a:	79fb      	ldrb	r3, [r7, #7]
 800d64c:	1ad3      	subs	r3, r2, r3
 800d64e:	60fb      	str	r3, [r7, #12]
    if (d < 0)
 800d650:	68fb      	ldr	r3, [r7, #12]
 800d652:	2b00      	cmp	r3, #0
 800d654:	da02      	bge.n	800d65c <computeTransferIDForwardDistance+0x24>
    {
        d += 1 << TRANSFER_ID_BIT_LEN;
 800d656:	68fb      	ldr	r3, [r7, #12]
 800d658:	3320      	adds	r3, #32
 800d65a:	60fb      	str	r3, [r7, #12]
    }
    return d;
 800d65c:	68fb      	ldr	r3, [r7, #12]
}
 800d65e:	4618      	mov	r0, r3
 800d660:	3714      	adds	r7, #20
 800d662:	46bd      	mov	sp, r7
 800d664:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d668:	4770      	bx	lr
 800d66a:	bf00      	nop

0800d66c <prepareForNextTransfer>:
=======
 800d6c0:	b480      	push	{r7}
 800d6c2:	b085      	sub	sp, #20
 800d6c4:	af00      	add	r7, sp, #0
 800d6c6:	4603      	mov	r3, r0
 800d6c8:	460a      	mov	r2, r1
 800d6ca:	71fb      	strb	r3, [r7, #7]
 800d6cc:	4613      	mov	r3, r2
 800d6ce:	71bb      	strb	r3, [r7, #6]
    int d = b - a;
 800d6d0:	79ba      	ldrb	r2, [r7, #6]
 800d6d2:	79fb      	ldrb	r3, [r7, #7]
 800d6d4:	1ad3      	subs	r3, r2, r3
 800d6d6:	60fb      	str	r3, [r7, #12]
    if (d < 0)
 800d6d8:	68fb      	ldr	r3, [r7, #12]
 800d6da:	2b00      	cmp	r3, #0
 800d6dc:	da02      	bge.n	800d6e4 <computeTransferIDForwardDistance+0x24>
    {
        d += 1 << TRANSFER_ID_BIT_LEN;
 800d6de:	68fb      	ldr	r3, [r7, #12]
 800d6e0:	3320      	adds	r3, #32
 800d6e2:	60fb      	str	r3, [r7, #12]
    }
    return d;
 800d6e4:	68fb      	ldr	r3, [r7, #12]
}
 800d6e6:	4618      	mov	r0, r3
 800d6e8:	3714      	adds	r7, #20
 800d6ea:	46bd      	mov	sp, r7
 800d6ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6f0:	4770      	bx	lr
 800d6f2:	bf00      	nop

0800d6f4 <prepareForNextTransfer>:
>>>>>>> 752c83b... update binaries

/**
 * preps the rx state for the next transfer. does not delete the state
 */
CANARD_INTERNAL void prepareForNextTransfer(CanardRxState* state)
{
<<<<<<< HEAD
 800d66c:	b480      	push	{r7}
 800d66e:	b083      	sub	sp, #12
 800d670:	af00      	add	r7, sp, #0
 800d672:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(state->buffer_blocks == NULL);
    state->transfer_id += 1;
 800d674:	687b      	ldr	r3, [r7, #4]
 800d676:	7e5b      	ldrb	r3, [r3, #25]
 800d678:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800d67c:	b2db      	uxtb	r3, r3
 800d67e:	3301      	adds	r3, #1
 800d680:	b2db      	uxtb	r3, r3
 800d682:	f003 031f 	and.w	r3, r3, #31
 800d686:	b2d9      	uxtb	r1, r3
 800d688:	687a      	ldr	r2, [r7, #4]
 800d68a:	7e53      	ldrb	r3, [r2, #25]
 800d68c:	f361 0386 	bfi	r3, r1, #2, #5
 800d690:	7653      	strb	r3, [r2, #25]
    state->payload_len = 0;
 800d692:	687a      	ldr	r2, [r7, #4]
 800d694:	8b13      	ldrh	r3, [r2, #24]
 800d696:	f36f 0309 	bfc	r3, #0, #10
 800d69a:	8313      	strh	r3, [r2, #24]
    state->next_toggle = 0;
 800d69c:	687a      	ldr	r2, [r7, #4]
 800d69e:	7e53      	ldrb	r3, [r2, #25]
 800d6a0:	f36f 13c7 	bfc	r3, #7, #1
 800d6a4:	7653      	strb	r3, [r2, #25]
}
 800d6a6:	370c      	adds	r7, #12
 800d6a8:	46bd      	mov	sp, r7
 800d6aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6ae:	4770      	bx	lr

0800d6b0 <extractDataType>:
=======
 800d6f4:	b480      	push	{r7}
 800d6f6:	b083      	sub	sp, #12
 800d6f8:	af00      	add	r7, sp, #0
 800d6fa:	6078      	str	r0, [r7, #4]
    CANARD_ASSERT(state->buffer_blocks == NULL);
    state->transfer_id += 1;
 800d6fc:	687b      	ldr	r3, [r7, #4]
 800d6fe:	7e5b      	ldrb	r3, [r3, #25]
 800d700:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800d704:	b2db      	uxtb	r3, r3
 800d706:	3301      	adds	r3, #1
 800d708:	b2db      	uxtb	r3, r3
 800d70a:	f003 031f 	and.w	r3, r3, #31
 800d70e:	b2d9      	uxtb	r1, r3
 800d710:	687a      	ldr	r2, [r7, #4]
 800d712:	7e53      	ldrb	r3, [r2, #25]
 800d714:	f361 0386 	bfi	r3, r1, #2, #5
 800d718:	7653      	strb	r3, [r2, #25]
    state->payload_len = 0;
 800d71a:	687a      	ldr	r2, [r7, #4]
 800d71c:	8b13      	ldrh	r3, [r2, #24]
 800d71e:	f36f 0309 	bfc	r3, #0, #10
 800d722:	8313      	strh	r3, [r2, #24]
    state->next_toggle = 0;
 800d724:	687a      	ldr	r2, [r7, #4]
 800d726:	7e53      	ldrb	r3, [r2, #25]
 800d728:	f36f 13c7 	bfc	r3, #7, #1
 800d72c:	7653      	strb	r3, [r2, #25]
}
 800d72e:	370c      	adds	r7, #12
 800d730:	46bd      	mov	sp, r7
 800d732:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d736:	4770      	bx	lr

0800d738 <extractDataType>:
>>>>>>> 752c83b... update binaries

/**
 * returns data type from id
 */
CANARD_INTERNAL uint16_t extractDataType(uint32_t id)
{
<<<<<<< HEAD
 800d6b0:	b580      	push	{r7, lr}
 800d6b2:	b084      	sub	sp, #16
 800d6b4:	af00      	add	r7, sp, #0
 800d6b6:	6078      	str	r0, [r7, #4]
    if (extractTransferType(id) == CanardTransferTypeBroadcast)
 800d6b8:	6878      	ldr	r0, [r7, #4]
 800d6ba:	f000 f81b 	bl	800d6f4 <extractTransferType>
 800d6be:	4603      	mov	r3, r0
 800d6c0:	2b02      	cmp	r3, #2
 800d6c2:	d10e      	bne.n	800d6e2 <extractDataType+0x32>
    {
        uint16_t dtid = MSG_TYPE_FROM_ID(id);
 800d6c4:	687b      	ldr	r3, [r7, #4]
 800d6c6:	0a1b      	lsrs	r3, r3, #8
 800d6c8:	81fb      	strh	r3, [r7, #14]
        if (SOURCE_ID_FROM_ID(id) == CANARD_BROADCAST_NODE_ID)
 800d6ca:	687b      	ldr	r3, [r7, #4]
 800d6cc:	b2db      	uxtb	r3, r3
 800d6ce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800d6d2:	2b00      	cmp	r3, #0
 800d6d4:	d103      	bne.n	800d6de <extractDataType+0x2e>
        {
            dtid &= (1U << ANON_MSG_DATA_TYPE_ID_BIT_LEN) - 1U;
 800d6d6:	89fb      	ldrh	r3, [r7, #14]
 800d6d8:	f003 0303 	and.w	r3, r3, #3
 800d6dc:	81fb      	strh	r3, [r7, #14]
        }
        return dtid;
 800d6de:	89fb      	ldrh	r3, [r7, #14]
 800d6e0:	e003      	b.n	800d6ea <extractDataType+0x3a>
=======
 800d738:	b580      	push	{r7, lr}
 800d73a:	b084      	sub	sp, #16
 800d73c:	af00      	add	r7, sp, #0
 800d73e:	6078      	str	r0, [r7, #4]
    if (extractTransferType(id) == CanardTransferTypeBroadcast)
 800d740:	6878      	ldr	r0, [r7, #4]
 800d742:	f000 f81b 	bl	800d77c <extractTransferType>
 800d746:	4603      	mov	r3, r0
 800d748:	2b02      	cmp	r3, #2
 800d74a:	d10e      	bne.n	800d76a <extractDataType+0x32>
    {
        uint16_t dtid = MSG_TYPE_FROM_ID(id);
 800d74c:	687b      	ldr	r3, [r7, #4]
 800d74e:	0a1b      	lsrs	r3, r3, #8
 800d750:	81fb      	strh	r3, [r7, #14]
        if (SOURCE_ID_FROM_ID(id) == CANARD_BROADCAST_NODE_ID)
 800d752:	687b      	ldr	r3, [r7, #4]
 800d754:	b2db      	uxtb	r3, r3
 800d756:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800d75a:	2b00      	cmp	r3, #0
 800d75c:	d103      	bne.n	800d766 <extractDataType+0x2e>
        {
            dtid &= (1U << ANON_MSG_DATA_TYPE_ID_BIT_LEN) - 1U;
 800d75e:	89fb      	ldrh	r3, [r7, #14]
 800d760:	f003 0303 	and.w	r3, r3, #3
 800d764:	81fb      	strh	r3, [r7, #14]
        }
        return dtid;
 800d766:	89fb      	ldrh	r3, [r7, #14]
 800d768:	e003      	b.n	800d772 <extractDataType+0x3a>
>>>>>>> 752c83b... update binaries
    }
    else
    {
        return (uint16_t) SRV_TYPE_FROM_ID(id);
<<<<<<< HEAD
 800d6e2:	687b      	ldr	r3, [r7, #4]
 800d6e4:	0c1b      	lsrs	r3, r3, #16
 800d6e6:	b2db      	uxtb	r3, r3
 800d6e8:	b29b      	uxth	r3, r3
    }
}
 800d6ea:	4618      	mov	r0, r3
 800d6ec:	3710      	adds	r7, #16
 800d6ee:	46bd      	mov	sp, r7
 800d6f0:	bd80      	pop	{r7, pc}
 800d6f2:	bf00      	nop

0800d6f4 <extractTransferType>:
=======
 800d76a:	687b      	ldr	r3, [r7, #4]
 800d76c:	0c1b      	lsrs	r3, r3, #16
 800d76e:	b2db      	uxtb	r3, r3
 800d770:	b29b      	uxth	r3, r3
    }
}
 800d772:	4618      	mov	r0, r3
 800d774:	3710      	adds	r7, #16
 800d776:	46bd      	mov	sp, r7
 800d778:	bd80      	pop	{r7, pc}
 800d77a:	bf00      	nop

0800d77c <extractTransferType>:
>>>>>>> 752c83b... update binaries

/**
 * returns transfer type from id
 */
CANARD_INTERNAL CanardTransferType extractTransferType(uint32_t id)
{
<<<<<<< HEAD
 800d6f4:	b480      	push	{r7}
 800d6f6:	b085      	sub	sp, #20
 800d6f8:	af00      	add	r7, sp, #0
 800d6fa:	6078      	str	r0, [r7, #4]
    const bool is_service = SERVICE_NOT_MSG_FROM_ID(id);
 800d6fc:	687b      	ldr	r3, [r7, #4]
 800d6fe:	09db      	lsrs	r3, r3, #7
 800d700:	f003 0301 	and.w	r3, r3, #1
 800d704:	2b00      	cmp	r3, #0
 800d706:	bf14      	ite	ne
 800d708:	2301      	movne	r3, #1
 800d70a:	2300      	moveq	r3, #0
 800d70c:	73fb      	strb	r3, [r7, #15]
    if (!is_service)
 800d70e:	7bfb      	ldrb	r3, [r7, #15]
 800d710:	f083 0301 	eor.w	r3, r3, #1
 800d714:	b2db      	uxtb	r3, r3
 800d716:	2b00      	cmp	r3, #0
 800d718:	d001      	beq.n	800d71e <extractTransferType+0x2a>
    {
        return CanardTransferTypeBroadcast;
 800d71a:	2302      	movs	r3, #2
 800d71c:	e008      	b.n	800d730 <extractTransferType+0x3c>
    }
    else if (REQUEST_NOT_RESPONSE_FROM_ID(id) == 1)
 800d71e:	687b      	ldr	r3, [r7, #4]
 800d720:	0bdb      	lsrs	r3, r3, #15
 800d722:	f003 0301 	and.w	r3, r3, #1
 800d726:	2b00      	cmp	r3, #0
 800d728:	d001      	beq.n	800d72e <extractTransferType+0x3a>
    {
        return CanardTransferTypeRequest;
 800d72a:	2301      	movs	r3, #1
 800d72c:	e000      	b.n	800d730 <extractTransferType+0x3c>
=======
 800d77c:	b480      	push	{r7}
 800d77e:	b085      	sub	sp, #20
 800d780:	af00      	add	r7, sp, #0
 800d782:	6078      	str	r0, [r7, #4]
    const bool is_service = SERVICE_NOT_MSG_FROM_ID(id);
 800d784:	687b      	ldr	r3, [r7, #4]
 800d786:	09db      	lsrs	r3, r3, #7
 800d788:	f003 0301 	and.w	r3, r3, #1
 800d78c:	2b00      	cmp	r3, #0
 800d78e:	bf14      	ite	ne
 800d790:	2301      	movne	r3, #1
 800d792:	2300      	moveq	r3, #0
 800d794:	73fb      	strb	r3, [r7, #15]
    if (!is_service)
 800d796:	7bfb      	ldrb	r3, [r7, #15]
 800d798:	f083 0301 	eor.w	r3, r3, #1
 800d79c:	b2db      	uxtb	r3, r3
 800d79e:	2b00      	cmp	r3, #0
 800d7a0:	d001      	beq.n	800d7a6 <extractTransferType+0x2a>
    {
        return CanardTransferTypeBroadcast;
 800d7a2:	2302      	movs	r3, #2
 800d7a4:	e008      	b.n	800d7b8 <extractTransferType+0x3c>
    }
    else if (REQUEST_NOT_RESPONSE_FROM_ID(id) == 1)
 800d7a6:	687b      	ldr	r3, [r7, #4]
 800d7a8:	0bdb      	lsrs	r3, r3, #15
 800d7aa:	f003 0301 	and.w	r3, r3, #1
 800d7ae:	2b00      	cmp	r3, #0
 800d7b0:	d001      	beq.n	800d7b6 <extractTransferType+0x3a>
    {
        return CanardTransferTypeRequest;
 800d7b2:	2301      	movs	r3, #1
 800d7b4:	e000      	b.n	800d7b8 <extractTransferType+0x3c>
>>>>>>> 752c83b... update binaries
    }
    else
    {
        return CanardTransferTypeResponse;
<<<<<<< HEAD
 800d72e:	2300      	movs	r3, #0
    }
}
 800d730:	4618      	mov	r0, r3
 800d732:	3714      	adds	r7, #20
 800d734:	46bd      	mov	sp, r7
 800d736:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d73a:	4770      	bx	lr

0800d73c <traverseRxStates>:
=======
 800d7b6:	2300      	movs	r3, #0
    }
}
 800d7b8:	4618      	mov	r0, r3
 800d7ba:	3714      	adds	r7, #20
 800d7bc:	46bd      	mov	sp, r7
 800d7be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7c2:	4770      	bx	lr

0800d7c4 <traverseRxStates>:
>>>>>>> 752c83b... update binaries
/**
 * Traverses the list of CanardRxState's and returns a pointer to the CanardRxState
 * with either the Id or a new one at the end
 */
CANARD_INTERNAL CanardRxState* traverseRxStates(CanardInstance* ins, uint32_t transfer_descriptor)
{
<<<<<<< HEAD
 800d73c:	b580      	push	{r7, lr}
 800d73e:	b084      	sub	sp, #16
 800d740:	af00      	add	r7, sp, #0
 800d742:	6078      	str	r0, [r7, #4]
 800d744:	6039      	str	r1, [r7, #0]
    CanardRxState* states = ins->rx_states;
 800d746:	687b      	ldr	r3, [r7, #4]
 800d748:	699b      	ldr	r3, [r3, #24]
 800d74a:	60fb      	str	r3, [r7, #12]

    if (states == NULL) // initialize CanardRxStates
 800d74c:	68fb      	ldr	r3, [r7, #12]
 800d74e:	2b00      	cmp	r3, #0
 800d750:	d110      	bne.n	800d774 <traverseRxStates+0x38>
    {
        states = createRxState(&ins->allocator, transfer_descriptor);
 800d752:	687b      	ldr	r3, [r7, #4]
 800d754:	330c      	adds	r3, #12
 800d756:	4618      	mov	r0, r3
 800d758:	6839      	ldr	r1, [r7, #0]
 800d75a:	f000 f857 	bl	800d80c <createRxState>
 800d75e:	60f8      	str	r0, [r7, #12]
        
        if(states == NULL)
 800d760:	68fb      	ldr	r3, [r7, #12]
 800d762:	2b00      	cmp	r3, #0
 800d764:	d101      	bne.n	800d76a <traverseRxStates+0x2e>
        {
            return NULL;
 800d766:	2300      	movs	r3, #0
 800d768:	e013      	b.n	800d792 <traverseRxStates+0x56>
        }

        ins->rx_states = states;
 800d76a:	687b      	ldr	r3, [r7, #4]
 800d76c:	68fa      	ldr	r2, [r7, #12]
 800d76e:	619a      	str	r2, [r3, #24]
        return states;
 800d770:	68fb      	ldr	r3, [r7, #12]
 800d772:	e00e      	b.n	800d792 <traverseRxStates+0x56>
    }

    states = findRxState(states, transfer_descriptor);
 800d774:	68f8      	ldr	r0, [r7, #12]
 800d776:	6839      	ldr	r1, [r7, #0]
 800d778:	f000 f810 	bl	800d79c <findRxState>
 800d77c:	60f8      	str	r0, [r7, #12]
    if (states != NULL)
 800d77e:	68fb      	ldr	r3, [r7, #12]
 800d780:	2b00      	cmp	r3, #0
 800d782:	d001      	beq.n	800d788 <traverseRxStates+0x4c>
    {
        return states;
 800d784:	68fb      	ldr	r3, [r7, #12]
 800d786:	e004      	b.n	800d792 <traverseRxStates+0x56>
=======
 800d7c4:	b580      	push	{r7, lr}
 800d7c6:	b084      	sub	sp, #16
 800d7c8:	af00      	add	r7, sp, #0
 800d7ca:	6078      	str	r0, [r7, #4]
 800d7cc:	6039      	str	r1, [r7, #0]
    CanardRxState* states = ins->rx_states;
 800d7ce:	687b      	ldr	r3, [r7, #4]
 800d7d0:	699b      	ldr	r3, [r3, #24]
 800d7d2:	60fb      	str	r3, [r7, #12]

    if (states == NULL) // initialize CanardRxStates
 800d7d4:	68fb      	ldr	r3, [r7, #12]
 800d7d6:	2b00      	cmp	r3, #0
 800d7d8:	d110      	bne.n	800d7fc <traverseRxStates+0x38>
    {
        states = createRxState(&ins->allocator, transfer_descriptor);
 800d7da:	687b      	ldr	r3, [r7, #4]
 800d7dc:	330c      	adds	r3, #12
 800d7de:	4618      	mov	r0, r3
 800d7e0:	6839      	ldr	r1, [r7, #0]
 800d7e2:	f000 f857 	bl	800d894 <createRxState>
 800d7e6:	60f8      	str	r0, [r7, #12]
        
        if(states == NULL)
 800d7e8:	68fb      	ldr	r3, [r7, #12]
 800d7ea:	2b00      	cmp	r3, #0
 800d7ec:	d101      	bne.n	800d7f2 <traverseRxStates+0x2e>
        {
            return NULL;
 800d7ee:	2300      	movs	r3, #0
 800d7f0:	e013      	b.n	800d81a <traverseRxStates+0x56>
        }

        ins->rx_states = states;
 800d7f2:	687b      	ldr	r3, [r7, #4]
 800d7f4:	68fa      	ldr	r2, [r7, #12]
 800d7f6:	619a      	str	r2, [r3, #24]
        return states;
 800d7f8:	68fb      	ldr	r3, [r7, #12]
 800d7fa:	e00e      	b.n	800d81a <traverseRxStates+0x56>
    }

    states = findRxState(states, transfer_descriptor);
 800d7fc:	68f8      	ldr	r0, [r7, #12]
 800d7fe:	6839      	ldr	r1, [r7, #0]
 800d800:	f000 f810 	bl	800d824 <findRxState>
 800d804:	60f8      	str	r0, [r7, #12]
    if (states != NULL)
 800d806:	68fb      	ldr	r3, [r7, #12]
 800d808:	2b00      	cmp	r3, #0
 800d80a:	d001      	beq.n	800d810 <traverseRxStates+0x4c>
    {
        return states;
 800d80c:	68fb      	ldr	r3, [r7, #12]
 800d80e:	e004      	b.n	800d81a <traverseRxStates+0x56>
>>>>>>> 752c83b... update binaries
    }
    else
    {
        return prependRxState(ins, transfer_descriptor);
<<<<<<< HEAD
 800d788:	6878      	ldr	r0, [r7, #4]
 800d78a:	6839      	ldr	r1, [r7, #0]
 800d78c:	f000 f820 	bl	800d7d0 <prependRxState>
 800d790:	4603      	mov	r3, r0
    }
}
 800d792:	4618      	mov	r0, r3
 800d794:	3710      	adds	r7, #16
 800d796:	46bd      	mov	sp, r7
 800d798:	bd80      	pop	{r7, pc}
 800d79a:	bf00      	nop

0800d79c <findRxState>:
=======
 800d810:	6878      	ldr	r0, [r7, #4]
 800d812:	6839      	ldr	r1, [r7, #0]
 800d814:	f000 f820 	bl	800d858 <prependRxState>
 800d818:	4603      	mov	r3, r0
    }
}
 800d81a:	4618      	mov	r0, r3
 800d81c:	3710      	adds	r7, #16
 800d81e:	46bd      	mov	sp, r7
 800d820:	bd80      	pop	{r7, pc}
 800d822:	bf00      	nop

0800d824 <findRxState>:
>>>>>>> 752c83b... update binaries

/**
 * returns pointer to the rx state of transfer descriptor or null if not found
 */
CANARD_INTERNAL CanardRxState* findRxState(CanardRxState* state, uint32_t transfer_descriptor)
{
<<<<<<< HEAD
 800d79c:	b480      	push	{r7}
 800d79e:	b083      	sub	sp, #12
 800d7a0:	af00      	add	r7, sp, #0
 800d7a2:	6078      	str	r0, [r7, #4]
 800d7a4:	6039      	str	r1, [r7, #0]
 800d7a6:	e009      	b.n	800d7bc <findRxState+0x20>
    while (state != NULL)
    {
        if (state->dtid_tt_snid_dnid == transfer_descriptor)
 800d7a8:	687b      	ldr	r3, [r7, #4]
 800d7aa:	691a      	ldr	r2, [r3, #16]
 800d7ac:	683b      	ldr	r3, [r7, #0]
 800d7ae:	429a      	cmp	r2, r3
 800d7b0:	d101      	bne.n	800d7b6 <findRxState+0x1a>
        {
            return state;
 800d7b2:	687b      	ldr	r3, [r7, #4]
 800d7b4:	e006      	b.n	800d7c4 <findRxState+0x28>
        }
        state = state->next;
 800d7b6:	687b      	ldr	r3, [r7, #4]
 800d7b8:	681b      	ldr	r3, [r3, #0]
 800d7ba:	607b      	str	r3, [r7, #4]
=======
 800d824:	b480      	push	{r7}
 800d826:	b083      	sub	sp, #12
 800d828:	af00      	add	r7, sp, #0
 800d82a:	6078      	str	r0, [r7, #4]
 800d82c:	6039      	str	r1, [r7, #0]
 800d82e:	e009      	b.n	800d844 <findRxState+0x20>
    while (state != NULL)
    {
        if (state->dtid_tt_snid_dnid == transfer_descriptor)
 800d830:	687b      	ldr	r3, [r7, #4]
 800d832:	691a      	ldr	r2, [r3, #16]
 800d834:	683b      	ldr	r3, [r7, #0]
 800d836:	429a      	cmp	r2, r3
 800d838:	d101      	bne.n	800d83e <findRxState+0x1a>
        {
            return state;
 800d83a:	687b      	ldr	r3, [r7, #4]
 800d83c:	e006      	b.n	800d84c <findRxState+0x28>
        }
        state = state->next;
 800d83e:	687b      	ldr	r3, [r7, #4]
 800d840:	681b      	ldr	r3, [r3, #0]
 800d842:	607b      	str	r3, [r7, #4]
>>>>>>> 752c83b... update binaries
/**
 * returns pointer to the rx state of transfer descriptor or null if not found
 */
CANARD_INTERNAL CanardRxState* findRxState(CanardRxState* state, uint32_t transfer_descriptor)
{
    while (state != NULL)
<<<<<<< HEAD
 800d7bc:	687b      	ldr	r3, [r7, #4]
 800d7be:	2b00      	cmp	r3, #0
 800d7c0:	d1f2      	bne.n	800d7a8 <findRxState+0xc>
=======
 800d844:	687b      	ldr	r3, [r7, #4]
 800d846:	2b00      	cmp	r3, #0
 800d848:	d1f2      	bne.n	800d830 <findRxState+0xc>
>>>>>>> 752c83b... update binaries
        {
            return state;
        }
        state = state->next;
    }
    return NULL;
<<<<<<< HEAD
 800d7c2:	2300      	movs	r3, #0
}
 800d7c4:	4618      	mov	r0, r3
 800d7c6:	370c      	adds	r7, #12
 800d7c8:	46bd      	mov	sp, r7
 800d7ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7ce:	4770      	bx	lr

0800d7d0 <prependRxState>:
=======
 800d84a:	2300      	movs	r3, #0
}
 800d84c:	4618      	mov	r0, r3
 800d84e:	370c      	adds	r7, #12
 800d850:	46bd      	mov	sp, r7
 800d852:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d856:	4770      	bx	lr

0800d858 <prependRxState>:
>>>>>>> 752c83b... update binaries

/**
 * prepends rx state to the canard instance rx_states
 */
CANARD_INTERNAL CanardRxState* prependRxState(CanardInstance* ins, uint32_t transfer_descriptor)
{
<<<<<<< HEAD
 800d7d0:	b580      	push	{r7, lr}
 800d7d2:	b084      	sub	sp, #16
 800d7d4:	af00      	add	r7, sp, #0
 800d7d6:	6078      	str	r0, [r7, #4]
 800d7d8:	6039      	str	r1, [r7, #0]
    CanardRxState* state = createRxState(&ins->allocator, transfer_descriptor);
 800d7da:	687b      	ldr	r3, [r7, #4]
 800d7dc:	330c      	adds	r3, #12
 800d7de:	4618      	mov	r0, r3
 800d7e0:	6839      	ldr	r1, [r7, #0]
 800d7e2:	f000 f813 	bl	800d80c <createRxState>
 800d7e6:	60f8      	str	r0, [r7, #12]

    if(state == NULL)
 800d7e8:	68fb      	ldr	r3, [r7, #12]
 800d7ea:	2b00      	cmp	r3, #0
 800d7ec:	d101      	bne.n	800d7f2 <prependRxState+0x22>
    {
        return NULL;
 800d7ee:	2300      	movs	r3, #0
 800d7f0:	e007      	b.n	800d802 <prependRxState+0x32>
    }

    state->next = ins->rx_states;
 800d7f2:	687b      	ldr	r3, [r7, #4]
 800d7f4:	699a      	ldr	r2, [r3, #24]
 800d7f6:	68fb      	ldr	r3, [r7, #12]
 800d7f8:	601a      	str	r2, [r3, #0]
    ins->rx_states = state;
 800d7fa:	687b      	ldr	r3, [r7, #4]
 800d7fc:	68fa      	ldr	r2, [r7, #12]
 800d7fe:	619a      	str	r2, [r3, #24]
    return state;
 800d800:	68fb      	ldr	r3, [r7, #12]
}
 800d802:	4618      	mov	r0, r3
 800d804:	3710      	adds	r7, #16
 800d806:	46bd      	mov	sp, r7
 800d808:	bd80      	pop	{r7, pc}
 800d80a:	bf00      	nop

0800d80c <createRxState>:

CANARD_INTERNAL CanardRxState* createRxState(CanardPoolAllocator* allocator, uint32_t transfer_descriptor)
{
 800d80c:	b580      	push	{r7, lr}
 800d80e:	b08c      	sub	sp, #48	; 0x30
 800d810:	af00      	add	r7, sp, #0
 800d812:	6078      	str	r0, [r7, #4]
 800d814:	6039      	str	r1, [r7, #0]
    CanardRxState init = {
 800d816:	f107 0308 	add.w	r3, r7, #8
 800d81a:	2200      	movs	r2, #0
 800d81c:	601a      	str	r2, [r3, #0]
 800d81e:	3304      	adds	r3, #4
 800d820:	2200      	movs	r2, #0
 800d822:	601a      	str	r2, [r3, #0]
 800d824:	3304      	adds	r3, #4
 800d826:	2200      	movs	r2, #0
 800d828:	601a      	str	r2, [r3, #0]
 800d82a:	3304      	adds	r3, #4
 800d82c:	2200      	movs	r2, #0
 800d82e:	601a      	str	r2, [r3, #0]
 800d830:	3304      	adds	r3, #4
 800d832:	2200      	movs	r2, #0
 800d834:	601a      	str	r2, [r3, #0]
 800d836:	3304      	adds	r3, #4
 800d838:	2200      	movs	r2, #0
 800d83a:	601a      	str	r2, [r3, #0]
 800d83c:	3304      	adds	r3, #4
 800d83e:	2200      	movs	r2, #0
 800d840:	601a      	str	r2, [r3, #0]
 800d842:	3304      	adds	r3, #4
 800d844:	2200      	movs	r2, #0
 800d846:	601a      	str	r2, [r3, #0]
 800d848:	3304      	adds	r3, #4
 800d84a:	683b      	ldr	r3, [r7, #0]
 800d84c:	61bb      	str	r3, [r7, #24]
=======
 800d858:	b580      	push	{r7, lr}
 800d85a:	b084      	sub	sp, #16
 800d85c:	af00      	add	r7, sp, #0
 800d85e:	6078      	str	r0, [r7, #4]
 800d860:	6039      	str	r1, [r7, #0]
    CanardRxState* state = createRxState(&ins->allocator, transfer_descriptor);
 800d862:	687b      	ldr	r3, [r7, #4]
 800d864:	330c      	adds	r3, #12
 800d866:	4618      	mov	r0, r3
 800d868:	6839      	ldr	r1, [r7, #0]
 800d86a:	f000 f813 	bl	800d894 <createRxState>
 800d86e:	60f8      	str	r0, [r7, #12]

    if(state == NULL)
 800d870:	68fb      	ldr	r3, [r7, #12]
 800d872:	2b00      	cmp	r3, #0
 800d874:	d101      	bne.n	800d87a <prependRxState+0x22>
    {
        return NULL;
 800d876:	2300      	movs	r3, #0
 800d878:	e007      	b.n	800d88a <prependRxState+0x32>
    }

    state->next = ins->rx_states;
 800d87a:	687b      	ldr	r3, [r7, #4]
 800d87c:	699a      	ldr	r2, [r3, #24]
 800d87e:	68fb      	ldr	r3, [r7, #12]
 800d880:	601a      	str	r2, [r3, #0]
    ins->rx_states = state;
 800d882:	687b      	ldr	r3, [r7, #4]
 800d884:	68fa      	ldr	r2, [r7, #12]
 800d886:	619a      	str	r2, [r3, #24]
    return state;
 800d888:	68fb      	ldr	r3, [r7, #12]
}
 800d88a:	4618      	mov	r0, r3
 800d88c:	3710      	adds	r7, #16
 800d88e:	46bd      	mov	sp, r7
 800d890:	bd80      	pop	{r7, pc}
 800d892:	bf00      	nop

0800d894 <createRxState>:

CANARD_INTERNAL CanardRxState* createRxState(CanardPoolAllocator* allocator, uint32_t transfer_descriptor)
{
 800d894:	b580      	push	{r7, lr}
 800d896:	b08c      	sub	sp, #48	; 0x30
 800d898:	af00      	add	r7, sp, #0
 800d89a:	6078      	str	r0, [r7, #4]
 800d89c:	6039      	str	r1, [r7, #0]
    CanardRxState init = {
 800d89e:	f107 0308 	add.w	r3, r7, #8
 800d8a2:	2200      	movs	r2, #0
 800d8a4:	601a      	str	r2, [r3, #0]
 800d8a6:	3304      	adds	r3, #4
 800d8a8:	2200      	movs	r2, #0
 800d8aa:	601a      	str	r2, [r3, #0]
 800d8ac:	3304      	adds	r3, #4
 800d8ae:	2200      	movs	r2, #0
 800d8b0:	601a      	str	r2, [r3, #0]
 800d8b2:	3304      	adds	r3, #4
 800d8b4:	2200      	movs	r2, #0
 800d8b6:	601a      	str	r2, [r3, #0]
 800d8b8:	3304      	adds	r3, #4
 800d8ba:	2200      	movs	r2, #0
 800d8bc:	601a      	str	r2, [r3, #0]
 800d8be:	3304      	adds	r3, #4
 800d8c0:	2200      	movs	r2, #0
 800d8c2:	601a      	str	r2, [r3, #0]
 800d8c4:	3304      	adds	r3, #4
 800d8c6:	2200      	movs	r2, #0
 800d8c8:	601a      	str	r2, [r3, #0]
 800d8ca:	3304      	adds	r3, #4
 800d8cc:	2200      	movs	r2, #0
 800d8ce:	601a      	str	r2, [r3, #0]
 800d8d0:	3304      	adds	r3, #4
 800d8d2:	683b      	ldr	r3, [r7, #0]
 800d8d4:	61bb      	str	r3, [r7, #24]
>>>>>>> 752c83b... update binaries
        .next = NULL,
        .buffer_blocks = NULL,
        .dtid_tt_snid_dnid = transfer_descriptor
    };

    CanardRxState* state = (CanardRxState*) allocateBlock(allocator);
<<<<<<< HEAD
 800d84e:	6878      	ldr	r0, [r7, #4]
 800d850:	f000 fba4 	bl	800df9c <allocateBlock>
 800d854:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (state == NULL)
 800d856:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d858:	2b00      	cmp	r3, #0
 800d85a:	d101      	bne.n	800d860 <createRxState+0x54>
    {
        return NULL;
 800d85c:	2300      	movs	r3, #0
 800d85e:	e007      	b.n	800d870 <createRxState+0x64>
    }
    memcpy(state, &init, sizeof(*state));
 800d860:	f107 0308 	add.w	r3, r7, #8
 800d864:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800d866:	4619      	mov	r1, r3
 800d868:	2220      	movs	r2, #32
 800d86a:	f000 fe87 	bl	800e57c <memcpy>

    return state;
 800d86e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800d870:	4618      	mov	r0, r3
 800d872:	3730      	adds	r7, #48	; 0x30
 800d874:	46bd      	mov	sp, r7
 800d876:	bd80      	pop	{r7, pc}

0800d878 <releaseStatePayload>:

CANARD_INTERNAL uint64_t releaseStatePayload(CanardInstance* ins, CanardRxState* rxstate)
{
 800d878:	b580      	push	{r7, lr}
 800d87a:	b084      	sub	sp, #16
 800d87c:	af00      	add	r7, sp, #0
 800d87e:	6078      	str	r0, [r7, #4]
 800d880:	6039      	str	r1, [r7, #0]
 800d882:	e00f      	b.n	800d8a4 <releaseStatePayload+0x2c>
    while (rxstate->buffer_blocks != NULL)
    {
        CanardBufferBlock* const temp = rxstate->buffer_blocks->next;
 800d884:	683b      	ldr	r3, [r7, #0]
 800d886:	685b      	ldr	r3, [r3, #4]
 800d888:	681b      	ldr	r3, [r3, #0]
 800d88a:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, rxstate->buffer_blocks);
 800d88c:	687b      	ldr	r3, [r7, #4]
 800d88e:	f103 020c 	add.w	r2, r3, #12
 800d892:	683b      	ldr	r3, [r7, #0]
 800d894:	685b      	ldr	r3, [r3, #4]
 800d896:	4610      	mov	r0, r2
 800d898:	4619      	mov	r1, r3
 800d89a:	f000 fba9 	bl	800dff0 <freeBlock>
        rxstate->buffer_blocks = temp;
 800d89e:	683b      	ldr	r3, [r7, #0]
 800d8a0:	68fa      	ldr	r2, [r7, #12]
 800d8a2:	605a      	str	r2, [r3, #4]
=======
 800d8d6:	6878      	ldr	r0, [r7, #4]
 800d8d8:	f000 fba4 	bl	800e024 <allocateBlock>
 800d8dc:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (state == NULL)
 800d8de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d8e0:	2b00      	cmp	r3, #0
 800d8e2:	d101      	bne.n	800d8e8 <createRxState+0x54>
    {
        return NULL;
 800d8e4:	2300      	movs	r3, #0
 800d8e6:	e007      	b.n	800d8f8 <createRxState+0x64>
    }
    memcpy(state, &init, sizeof(*state));
 800d8e8:	f107 0308 	add.w	r3, r7, #8
 800d8ec:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800d8ee:	4619      	mov	r1, r3
 800d8f0:	2220      	movs	r2, #32
 800d8f2:	f000 fe87 	bl	800e604 <memcpy>

    return state;
 800d8f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800d8f8:	4618      	mov	r0, r3
 800d8fa:	3730      	adds	r7, #48	; 0x30
 800d8fc:	46bd      	mov	sp, r7
 800d8fe:	bd80      	pop	{r7, pc}

0800d900 <releaseStatePayload>:

CANARD_INTERNAL uint64_t releaseStatePayload(CanardInstance* ins, CanardRxState* rxstate)
{
 800d900:	b580      	push	{r7, lr}
 800d902:	b084      	sub	sp, #16
 800d904:	af00      	add	r7, sp, #0
 800d906:	6078      	str	r0, [r7, #4]
 800d908:	6039      	str	r1, [r7, #0]
 800d90a:	e00f      	b.n	800d92c <releaseStatePayload+0x2c>
    while (rxstate->buffer_blocks != NULL)
    {
        CanardBufferBlock* const temp = rxstate->buffer_blocks->next;
 800d90c:	683b      	ldr	r3, [r7, #0]
 800d90e:	685b      	ldr	r3, [r3, #4]
 800d910:	681b      	ldr	r3, [r3, #0]
 800d912:	60fb      	str	r3, [r7, #12]
        freeBlock(&ins->allocator, rxstate->buffer_blocks);
 800d914:	687b      	ldr	r3, [r7, #4]
 800d916:	f103 020c 	add.w	r2, r3, #12
 800d91a:	683b      	ldr	r3, [r7, #0]
 800d91c:	685b      	ldr	r3, [r3, #4]
 800d91e:	4610      	mov	r0, r2
 800d920:	4619      	mov	r1, r3
 800d922:	f000 fba9 	bl	800e078 <freeBlock>
        rxstate->buffer_blocks = temp;
 800d926:	683b      	ldr	r3, [r7, #0]
 800d928:	68fa      	ldr	r2, [r7, #12]
 800d92a:	605a      	str	r2, [r3, #4]
>>>>>>> 752c83b... update binaries
    return state;
}

CANARD_INTERNAL uint64_t releaseStatePayload(CanardInstance* ins, CanardRxState* rxstate)
{
    while (rxstate->buffer_blocks != NULL)
<<<<<<< HEAD
 800d8a4:	683b      	ldr	r3, [r7, #0]
 800d8a6:	685b      	ldr	r3, [r3, #4]
 800d8a8:	2b00      	cmp	r3, #0
 800d8aa:	d1eb      	bne.n	800d884 <releaseStatePayload+0xc>
=======
 800d92c:	683b      	ldr	r3, [r7, #0]
 800d92e:	685b      	ldr	r3, [r3, #4]
 800d930:	2b00      	cmp	r3, #0
 800d932:	d1eb      	bne.n	800d90c <releaseStatePayload+0xc>
>>>>>>> 752c83b... update binaries
    {
        CanardBufferBlock* const temp = rxstate->buffer_blocks->next;
        freeBlock(&ins->allocator, rxstate->buffer_blocks);
        rxstate->buffer_blocks = temp;
    }
    rxstate->payload_len = 0;
<<<<<<< HEAD
 800d8ac:	683a      	ldr	r2, [r7, #0]
 800d8ae:	8b13      	ldrh	r3, [r2, #24]
 800d8b0:	f36f 0309 	bfc	r3, #0, #10
 800d8b4:	8313      	strh	r3, [r2, #24]
    return CANARD_OK;
 800d8b6:	f04f 0200 	mov.w	r2, #0
 800d8ba:	f04f 0300 	mov.w	r3, #0
}
 800d8be:	4610      	mov	r0, r2
 800d8c0:	4619      	mov	r1, r3
 800d8c2:	3710      	adds	r7, #16
 800d8c4:	46bd      	mov	sp, r7
 800d8c6:	bd80      	pop	{r7, pc}

0800d8c8 <bufferBlockPushBytes>:
=======
 800d934:	683a      	ldr	r2, [r7, #0]
 800d936:	8b13      	ldrh	r3, [r2, #24]
 800d938:	f36f 0309 	bfc	r3, #0, #10
 800d93c:	8313      	strh	r3, [r2, #24]
    return CANARD_OK;
 800d93e:	f04f 0200 	mov.w	r2, #0
 800d942:	f04f 0300 	mov.w	r3, #0
}
 800d946:	4610      	mov	r0, r2
 800d948:	4619      	mov	r1, r3
 800d94a:	3710      	adds	r7, #16
 800d94c:	46bd      	mov	sp, r7
 800d94e:	bd80      	pop	{r7, pc}

0800d950 <bufferBlockPushBytes>:
>>>>>>> 752c83b... update binaries
 */
CANARD_INTERNAL int bufferBlockPushBytes(CanardPoolAllocator* allocator,
                                         CanardRxState* state,
                                         const uint8_t* data,
                                         uint8_t data_len)
{
<<<<<<< HEAD
 800d8c8:	b580      	push	{r7, lr}
 800d8ca:	b08a      	sub	sp, #40	; 0x28
 800d8cc:	af00      	add	r7, sp, #0
 800d8ce:	60f8      	str	r0, [r7, #12]
 800d8d0:	60b9      	str	r1, [r7, #8]
 800d8d2:	607a      	str	r2, [r7, #4]
 800d8d4:	70fb      	strb	r3, [r7, #3]
    uint16_t data_index = 0;
 800d8d6:	2300      	movs	r3, #0
 800d8d8:	84fb      	strh	r3, [r7, #38]	; 0x26

    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
 800d8da:	68bb      	ldr	r3, [r7, #8]
 800d8dc:	8b1b      	ldrh	r3, [r3, #24]
 800d8de:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d8e2:	b29b      	uxth	r3, r3
 800d8e4:	f1c3 0306 	rsb	r3, r3, #6
 800d8e8:	2b00      	cmp	r3, #0
 800d8ea:	dd36      	ble.n	800d95a <bufferBlockPushBytes+0x92>
    {
        for (uint16_t i = (uint16_t)state->payload_len;
 800d8ec:	68bb      	ldr	r3, [r7, #8]
 800d8ee:	8b1b      	ldrh	r3, [r3, #24]
 800d8f0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d8f4:	b29b      	uxth	r3, r3
 800d8f6:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d8f8:	e00e      	b.n	800d918 <bufferBlockPushBytes+0x50>
=======
 800d950:	b580      	push	{r7, lr}
 800d952:	b08a      	sub	sp, #40	; 0x28
 800d954:	af00      	add	r7, sp, #0
 800d956:	60f8      	str	r0, [r7, #12]
 800d958:	60b9      	str	r1, [r7, #8]
 800d95a:	607a      	str	r2, [r7, #4]
 800d95c:	70fb      	strb	r3, [r7, #3]
    uint16_t data_index = 0;
 800d95e:	2300      	movs	r3, #0
 800d960:	84fb      	strh	r3, [r7, #38]	; 0x26

    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
 800d962:	68bb      	ldr	r3, [r7, #8]
 800d964:	8b1b      	ldrh	r3, [r3, #24]
 800d966:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d96a:	b29b      	uxth	r3, r3
 800d96c:	f1c3 0306 	rsb	r3, r3, #6
 800d970:	2b00      	cmp	r3, #0
 800d972:	dd36      	ble.n	800d9e2 <bufferBlockPushBytes+0x92>
    {
        for (uint16_t i = (uint16_t)state->payload_len;
 800d974:	68bb      	ldr	r3, [r7, #8]
 800d976:	8b1b      	ldrh	r3, [r3, #24]
 800d978:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d97c:	b29b      	uxth	r3, r3
 800d97e:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d980:	e00e      	b.n	800d9a0 <bufferBlockPushBytes+0x50>
>>>>>>> 752c83b... update binaries
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
             i++, data_index++)
        {
            state->buffer_head[i] = data[data_index];
<<<<<<< HEAD
 800d8fa:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d8fc:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d8fe:	6879      	ldr	r1, [r7, #4]
 800d900:	440a      	add	r2, r1
 800d902:	7811      	ldrb	r1, [r2, #0]
 800d904:	68ba      	ldr	r2, [r7, #8]
 800d906:	4413      	add	r3, r2
 800d908:	460a      	mov	r2, r1
 800d90a:	769a      	strb	r2, [r3, #26]
=======
 800d982:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d984:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d986:	6879      	ldr	r1, [r7, #4]
 800d988:	440a      	add	r2, r1
 800d98a:	7811      	ldrb	r1, [r2, #0]
 800d98c:	68ba      	ldr	r2, [r7, #8]
 800d98e:	4413      	add	r3, r2
 800d990:	460a      	mov	r2, r1
 800d992:	769a      	strb	r2, [r3, #26]
>>>>>>> 752c83b... update binaries
    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
    {
        for (uint16_t i = (uint16_t)state->payload_len;
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
             i++, data_index++)
<<<<<<< HEAD
 800d90c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d90e:	3301      	adds	r3, #1
 800d910:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d912:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800d914:	3301      	adds	r3, #1
 800d916:	84fb      	strh	r3, [r7, #38]	; 0x26
=======
 800d994:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d996:	3301      	adds	r3, #1
 800d998:	84bb      	strh	r3, [r7, #36]	; 0x24
 800d99a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800d99c:	3301      	adds	r3, #1
 800d99e:	84fb      	strh	r3, [r7, #38]	; 0x26
>>>>>>> 752c83b... update binaries
    uint16_t data_index = 0;

    // if head is not full, add data to head
    if ((int) CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE - (int) state->payload_len > 0)
    {
        for (uint16_t i = (uint16_t)state->payload_len;
<<<<<<< HEAD
 800d918:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d91a:	2b05      	cmp	r3, #5
 800d91c:	d804      	bhi.n	800d928 <bufferBlockPushBytes+0x60>
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
 800d91e:	78fb      	ldrb	r3, [r7, #3]
 800d920:	b29b      	uxth	r3, r3
 800d922:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d924:	429a      	cmp	r2, r3
 800d926:	d3e8      	bcc.n	800d8fa <bufferBlockPushBytes+0x32>
=======
 800d9a0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d9a2:	2b05      	cmp	r3, #5
 800d9a4:	d804      	bhi.n	800d9b0 <bufferBlockPushBytes+0x60>
             i < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE && data_index < data_len;
 800d9a6:	78fb      	ldrb	r3, [r7, #3]
 800d9a8:	b29b      	uxth	r3, r3
 800d9aa:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d9ac:	429a      	cmp	r2, r3
 800d9ae:	d3e8      	bcc.n	800d982 <bufferBlockPushBytes+0x32>
>>>>>>> 752c83b... update binaries
             i++, data_index++)
        {
            state->buffer_head[i] = data[data_index];
        }
        if (data_index >= data_len)
<<<<<<< HEAD
 800d928:	78fb      	ldrb	r3, [r7, #3]
 800d92a:	b29b      	uxth	r3, r3
 800d92c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d92e:	429a      	cmp	r2, r3
 800d930:	d313      	bcc.n	800d95a <bufferBlockPushBytes+0x92>
        {
            state->payload_len += data_len;
 800d932:	68bb      	ldr	r3, [r7, #8]
 800d934:	8b1b      	ldrh	r3, [r3, #24]
 800d936:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d93a:	b29b      	uxth	r3, r3
 800d93c:	461a      	mov	r2, r3
 800d93e:	78fb      	ldrb	r3, [r7, #3]
 800d940:	b29b      	uxth	r3, r3
 800d942:	4413      	add	r3, r2
 800d944:	b29b      	uxth	r3, r3
 800d946:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d94a:	b299      	uxth	r1, r3
 800d94c:	68ba      	ldr	r2, [r7, #8]
 800d94e:	8b13      	ldrh	r3, [r2, #24]
 800d950:	f361 0309 	bfi	r3, r1, #0, #10
 800d954:	8313      	strh	r3, [r2, #24]
            return 1;
 800d956:	2301      	movs	r3, #1
 800d958:	e0ae      	b.n	800dab8 <bufferBlockPushBytes+0x1f0>
=======
 800d9b0:	78fb      	ldrb	r3, [r7, #3]
 800d9b2:	b29b      	uxth	r3, r3
 800d9b4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d9b6:	429a      	cmp	r2, r3
 800d9b8:	d313      	bcc.n	800d9e2 <bufferBlockPushBytes+0x92>
        {
            state->payload_len += data_len;
 800d9ba:	68bb      	ldr	r3, [r7, #8]
 800d9bc:	8b1b      	ldrh	r3, [r3, #24]
 800d9be:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d9c2:	b29b      	uxth	r3, r3
 800d9c4:	461a      	mov	r2, r3
 800d9c6:	78fb      	ldrb	r3, [r7, #3]
 800d9c8:	b29b      	uxth	r3, r3
 800d9ca:	4413      	add	r3, r2
 800d9cc:	b29b      	uxth	r3, r3
 800d9ce:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d9d2:	b299      	uxth	r1, r3
 800d9d4:	68ba      	ldr	r2, [r7, #8]
 800d9d6:	8b13      	ldrh	r3, [r2, #24]
 800d9d8:	f361 0309 	bfi	r3, r1, #0, #10
 800d9dc:	8313      	strh	r3, [r2, #24]
            return 1;
 800d9de:	2301      	movs	r3, #1
 800d9e0:	e0ae      	b.n	800db40 <bufferBlockPushBytes+0x1f0>
>>>>>>> 752c83b... update binaries
        }
    } // head is full.

    uint8_t index_at_nth_block =
        (((state->payload_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) % CANARD_BUFFER_BLOCK_DATA_SIZE);
<<<<<<< HEAD
 800d95a:	68bb      	ldr	r3, [r7, #8]
 800d95c:	8b1b      	ldrh	r3, [r3, #24]
 800d95e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d962:	b29b      	uxth	r3, r3
 800d964:	1f9a      	subs	r2, r3, #6
 800d966:	0893      	lsrs	r3, r2, #2
 800d968:	4955      	ldr	r1, [pc, #340]	; (800dac0 <bufferBlockPushBytes+0x1f8>)
 800d96a:	fba1 3103 	umull	r3, r1, r1, r3
 800d96e:	460b      	mov	r3, r1
 800d970:	00db      	lsls	r3, r3, #3
 800d972:	1a5b      	subs	r3, r3, r1
 800d974:	009b      	lsls	r3, r3, #2
 800d976:	1ad3      	subs	r3, r2, r3
=======
 800d9e2:	68bb      	ldr	r3, [r7, #8]
 800d9e4:	8b1b      	ldrh	r3, [r3, #24]
 800d9e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d9ea:	b29b      	uxth	r3, r3
 800d9ec:	1f9a      	subs	r2, r3, #6
 800d9ee:	0893      	lsrs	r3, r2, #2
 800d9f0:	4955      	ldr	r1, [pc, #340]	; (800db48 <bufferBlockPushBytes+0x1f8>)
 800d9f2:	fba1 3103 	umull	r3, r1, r1, r3
 800d9f6:	460b      	mov	r3, r1
 800d9f8:	00db      	lsls	r3, r3, #3
 800d9fa:	1a5b      	subs	r3, r3, r1
 800d9fc:	009b      	lsls	r3, r3, #2
 800d9fe:	1ad3      	subs	r3, r2, r3
>>>>>>> 752c83b... update binaries
            state->payload_len += data_len;
            return 1;
        }
    } // head is full.

    uint8_t index_at_nth_block =
<<<<<<< HEAD
 800d978:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
=======
 800da00:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
>>>>>>> 752c83b... update binaries
        (((state->payload_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) % CANARD_BUFFER_BLOCK_DATA_SIZE);

    // get to current block
    CanardBufferBlock* block = NULL;
<<<<<<< HEAD
 800d97c:	2300      	movs	r3, #0
 800d97e:	61fb      	str	r3, [r7, #28]

    // buffer blocks uninitialized
    if (state->buffer_blocks == NULL)
 800d980:	68bb      	ldr	r3, [r7, #8]
 800d982:	685b      	ldr	r3, [r3, #4]
 800d984:	2b00      	cmp	r3, #0
 800d986:	d113      	bne.n	800d9b0 <bufferBlockPushBytes+0xe8>
    {
        state->buffer_blocks = createBufferBlock(allocator);
 800d988:	68f8      	ldr	r0, [r7, #12]
 800d98a:	f000 f89b 	bl	800dac4 <createBufferBlock>
 800d98e:	4602      	mov	r2, r0
 800d990:	68bb      	ldr	r3, [r7, #8]
 800d992:	605a      	str	r2, [r3, #4]

        if (state->buffer_blocks == NULL)
 800d994:	68bb      	ldr	r3, [r7, #8]
 800d996:	685b      	ldr	r3, [r3, #4]
 800d998:	2b00      	cmp	r3, #0
 800d99a:	d102      	bne.n	800d9a2 <bufferBlockPushBytes+0xda>
        {
            return -CANARD_ERROR_OUT_OF_MEMORY;
 800d99c:	f06f 0302 	mvn.w	r3, #2
 800d9a0:	e08a      	b.n	800dab8 <bufferBlockPushBytes+0x1f0>
        }

        block = state->buffer_blocks;
 800d9a2:	68bb      	ldr	r3, [r7, #8]
 800d9a4:	685b      	ldr	r3, [r3, #4]
 800d9a6:	61fb      	str	r3, [r7, #28]
        index_at_nth_block = 0;
 800d9a8:	2300      	movs	r3, #0
 800d9aa:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800d9ae:	e06b      	b.n	800da88 <bufferBlockPushBytes+0x1c0>
=======
 800da04:	2300      	movs	r3, #0
 800da06:	61fb      	str	r3, [r7, #28]

    // buffer blocks uninitialized
    if (state->buffer_blocks == NULL)
 800da08:	68bb      	ldr	r3, [r7, #8]
 800da0a:	685b      	ldr	r3, [r3, #4]
 800da0c:	2b00      	cmp	r3, #0
 800da0e:	d113      	bne.n	800da38 <bufferBlockPushBytes+0xe8>
    {
        state->buffer_blocks = createBufferBlock(allocator);
 800da10:	68f8      	ldr	r0, [r7, #12]
 800da12:	f000 f89b 	bl	800db4c <createBufferBlock>
 800da16:	4602      	mov	r2, r0
 800da18:	68bb      	ldr	r3, [r7, #8]
 800da1a:	605a      	str	r2, [r3, #4]

        if (state->buffer_blocks == NULL)
 800da1c:	68bb      	ldr	r3, [r7, #8]
 800da1e:	685b      	ldr	r3, [r3, #4]
 800da20:	2b00      	cmp	r3, #0
 800da22:	d102      	bne.n	800da2a <bufferBlockPushBytes+0xda>
        {
            return -CANARD_ERROR_OUT_OF_MEMORY;
 800da24:	f06f 0302 	mvn.w	r3, #2
 800da28:	e08a      	b.n	800db40 <bufferBlockPushBytes+0x1f0>
        }

        block = state->buffer_blocks;
 800da2a:	68bb      	ldr	r3, [r7, #8]
 800da2c:	685b      	ldr	r3, [r3, #4]
 800da2e:	61fb      	str	r3, [r7, #28]
        index_at_nth_block = 0;
 800da30:	2300      	movs	r3, #0
 800da32:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800da36:	e06b      	b.n	800db10 <bufferBlockPushBytes+0x1c0>
>>>>>>> 752c83b... update binaries
    }
    else
    {
        uint8_t nth_block = 1;
<<<<<<< HEAD
 800d9b0:	2301      	movs	r3, #1
 800d9b2:	76fb      	strb	r3, [r7, #27]

        // get to block
        block = state->buffer_blocks;
 800d9b4:	68bb      	ldr	r3, [r7, #8]
 800d9b6:	685b      	ldr	r3, [r3, #4]
 800d9b8:	61fb      	str	r3, [r7, #28]
 800d9ba:	e005      	b.n	800d9c8 <bufferBlockPushBytes+0x100>
        while (block->next != NULL)
        {
            nth_block++;
 800d9bc:	7efb      	ldrb	r3, [r7, #27]
 800d9be:	3301      	adds	r3, #1
 800d9c0:	76fb      	strb	r3, [r7, #27]
            block = block->next;
 800d9c2:	69fb      	ldr	r3, [r7, #28]
 800d9c4:	681b      	ldr	r3, [r3, #0]
 800d9c6:	61fb      	str	r3, [r7, #28]
=======
 800da38:	2301      	movs	r3, #1
 800da3a:	76fb      	strb	r3, [r7, #27]

        // get to block
        block = state->buffer_blocks;
 800da3c:	68bb      	ldr	r3, [r7, #8]
 800da3e:	685b      	ldr	r3, [r3, #4]
 800da40:	61fb      	str	r3, [r7, #28]
 800da42:	e005      	b.n	800da50 <bufferBlockPushBytes+0x100>
        while (block->next != NULL)
        {
            nth_block++;
 800da44:	7efb      	ldrb	r3, [r7, #27]
 800da46:	3301      	adds	r3, #1
 800da48:	76fb      	strb	r3, [r7, #27]
            block = block->next;
 800da4a:	69fb      	ldr	r3, [r7, #28]
 800da4c:	681b      	ldr	r3, [r3, #0]
 800da4e:	61fb      	str	r3, [r7, #28]
>>>>>>> 752c83b... update binaries
    {
        uint8_t nth_block = 1;

        // get to block
        block = state->buffer_blocks;
        while (block->next != NULL)
<<<<<<< HEAD
 800d9c8:	69fb      	ldr	r3, [r7, #28]
 800d9ca:	681b      	ldr	r3, [r3, #0]
 800d9cc:	2b00      	cmp	r3, #0
 800d9ce:	d1f5      	bne.n	800d9bc <bufferBlockPushBytes+0xf4>
=======
 800da50:	69fb      	ldr	r3, [r7, #28]
 800da52:	681b      	ldr	r3, [r3, #0]
 800da54:	2b00      	cmp	r3, #0
 800da56:	d1f5      	bne.n	800da44 <bufferBlockPushBytes+0xf4>
>>>>>>> 752c83b... update binaries
        {
            nth_block++;
            block = block->next;
        }

        const uint8_t num_buffer_blocks = (((state->payload_len + data_len) - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE) /
<<<<<<< HEAD
 800d9d0:	68bb      	ldr	r3, [r7, #8]
 800d9d2:	8b1b      	ldrh	r3, [r3, #24]
 800d9d4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800d9d8:	b29b      	uxth	r3, r3
 800d9da:	461a      	mov	r2, r3
 800d9dc:	78fb      	ldrb	r3, [r7, #3]
 800d9de:	4413      	add	r3, r2
 800d9e0:	3b06      	subs	r3, #6
 800d9e2:	089b      	lsrs	r3, r3, #2
 800d9e4:	4a36      	ldr	r2, [pc, #216]	; (800dac0 <bufferBlockPushBytes+0x1f8>)
 800d9e6:	fba2 2303 	umull	r2, r3, r2, r3
 800d9ea:	b2db      	uxtb	r3, r3
 800d9ec:	3301      	adds	r3, #1
 800d9ee:	75fb      	strb	r3, [r7, #23]
                                           CANARD_BUFFER_BLOCK_DATA_SIZE) + 1;

        if (num_buffer_blocks > nth_block && index_at_nth_block == 0)
 800d9f0:	7dfa      	ldrb	r2, [r7, #23]
 800d9f2:	7efb      	ldrb	r3, [r7, #27]
 800d9f4:	429a      	cmp	r2, r3
 800d9f6:	d947      	bls.n	800da88 <bufferBlockPushBytes+0x1c0>
 800d9f8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800d9fc:	2b00      	cmp	r3, #0
 800d9fe:	d143      	bne.n	800da88 <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800da00:	68f8      	ldr	r0, [r7, #12]
 800da02:	f000 f85f 	bl	800dac4 <createBufferBlock>
 800da06:	4602      	mov	r2, r0
 800da08:	69fb      	ldr	r3, [r7, #28]
 800da0a:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800da0c:	69fb      	ldr	r3, [r7, #28]
 800da0e:	681b      	ldr	r3, [r3, #0]
 800da10:	2b00      	cmp	r3, #0
 800da12:	d102      	bne.n	800da1a <bufferBlockPushBytes+0x152>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800da14:	f06f 0302 	mvn.w	r3, #2
 800da18:	e04e      	b.n	800dab8 <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800da1a:	69fb      	ldr	r3, [r7, #28]
 800da1c:	681b      	ldr	r3, [r3, #0]
 800da1e:	61fb      	str	r3, [r7, #28]
 800da20:	e032      	b.n	800da88 <bufferBlockPushBytes+0x1c0>
=======
 800da58:	68bb      	ldr	r3, [r7, #8]
 800da5a:	8b1b      	ldrh	r3, [r3, #24]
 800da5c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800da60:	b29b      	uxth	r3, r3
 800da62:	461a      	mov	r2, r3
 800da64:	78fb      	ldrb	r3, [r7, #3]
 800da66:	4413      	add	r3, r2
 800da68:	3b06      	subs	r3, #6
 800da6a:	089b      	lsrs	r3, r3, #2
 800da6c:	4a36      	ldr	r2, [pc, #216]	; (800db48 <bufferBlockPushBytes+0x1f8>)
 800da6e:	fba2 2303 	umull	r2, r3, r2, r3
 800da72:	b2db      	uxtb	r3, r3
 800da74:	3301      	adds	r3, #1
 800da76:	75fb      	strb	r3, [r7, #23]
                                           CANARD_BUFFER_BLOCK_DATA_SIZE) + 1;

        if (num_buffer_blocks > nth_block && index_at_nth_block == 0)
 800da78:	7dfa      	ldrb	r2, [r7, #23]
 800da7a:	7efb      	ldrb	r3, [r7, #27]
 800da7c:	429a      	cmp	r2, r3
 800da7e:	d947      	bls.n	800db10 <bufferBlockPushBytes+0x1c0>
 800da80:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800da84:	2b00      	cmp	r3, #0
 800da86:	d143      	bne.n	800db10 <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800da88:	68f8      	ldr	r0, [r7, #12]
 800da8a:	f000 f85f 	bl	800db4c <createBufferBlock>
 800da8e:	4602      	mov	r2, r0
 800da90:	69fb      	ldr	r3, [r7, #28]
 800da92:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800da94:	69fb      	ldr	r3, [r7, #28]
 800da96:	681b      	ldr	r3, [r3, #0]
 800da98:	2b00      	cmp	r3, #0
 800da9a:	d102      	bne.n	800daa2 <bufferBlockPushBytes+0x152>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800da9c:	f06f 0302 	mvn.w	r3, #2
 800daa0:	e04e      	b.n	800db40 <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800daa2:	69fb      	ldr	r3, [r7, #28]
 800daa4:	681b      	ldr	r3, [r3, #0]
 800daa6:	61fb      	str	r3, [r7, #28]
 800daa8:	e032      	b.n	800db10 <bufferBlockPushBytes+0x1c0>
>>>>>>> 752c83b... update binaries
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
<<<<<<< HEAD
 800da22:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800da26:	833b      	strh	r3, [r7, #24]
 800da28:	e00e      	b.n	800da48 <bufferBlockPushBytes+0x180>
=======
 800daaa:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800daae:	833b      	strh	r3, [r7, #24]
 800dab0:	e00e      	b.n	800dad0 <bufferBlockPushBytes+0x180>
>>>>>>> 752c83b... update binaries
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
             i++, data_index++)
        {
            block->data[i] = data[data_index];
<<<<<<< HEAD
 800da2a:	8b3b      	ldrh	r3, [r7, #24]
 800da2c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da2e:	6879      	ldr	r1, [r7, #4]
 800da30:	440a      	add	r2, r1
 800da32:	7811      	ldrb	r1, [r2, #0]
 800da34:	69fa      	ldr	r2, [r7, #28]
 800da36:	4413      	add	r3, r2
 800da38:	460a      	mov	r2, r1
 800da3a:	711a      	strb	r2, [r3, #4]
=======
 800dab2:	8b3b      	ldrh	r3, [r7, #24]
 800dab4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800dab6:	6879      	ldr	r1, [r7, #4]
 800dab8:	440a      	add	r2, r1
 800daba:	7811      	ldrb	r1, [r2, #0]
 800dabc:	69fa      	ldr	r2, [r7, #28]
 800dabe:	4413      	add	r3, r2
 800dac0:	460a      	mov	r2, r1
 800dac2:	711a      	strb	r2, [r3, #4]
>>>>>>> 752c83b... update binaries
    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
             i++, data_index++)
<<<<<<< HEAD
 800da3c:	8b3b      	ldrh	r3, [r7, #24]
 800da3e:	3301      	adds	r3, #1
 800da40:	833b      	strh	r3, [r7, #24]
 800da42:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800da44:	3301      	adds	r3, #1
 800da46:	84fb      	strh	r3, [r7, #38]	; 0x26
=======
 800dac4:	8b3b      	ldrh	r3, [r7, #24]
 800dac6:	3301      	adds	r3, #1
 800dac8:	833b      	strh	r3, [r7, #24]
 800daca:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800dacc:	3301      	adds	r3, #1
 800dace:	84fb      	strh	r3, [r7, #38]	; 0x26
>>>>>>> 752c83b... update binaries
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
    {
        for (uint16_t i = index_at_nth_block;
<<<<<<< HEAD
 800da48:	8b3b      	ldrh	r3, [r7, #24]
 800da4a:	2b1b      	cmp	r3, #27
 800da4c:	d804      	bhi.n	800da58 <bufferBlockPushBytes+0x190>
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
 800da4e:	78fb      	ldrb	r3, [r7, #3]
 800da50:	b29b      	uxth	r3, r3
 800da52:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da54:	429a      	cmp	r2, r3
 800da56:	d3e8      	bcc.n	800da2a <bufferBlockPushBytes+0x162>
=======
 800dad0:	8b3b      	ldrh	r3, [r7, #24]
 800dad2:	2b1b      	cmp	r3, #27
 800dad4:	d804      	bhi.n	800dae0 <bufferBlockPushBytes+0x190>
             i < CANARD_BUFFER_BLOCK_DATA_SIZE && data_index < data_len;
 800dad6:	78fb      	ldrb	r3, [r7, #3]
 800dad8:	b29b      	uxth	r3, r3
 800dada:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800dadc:	429a      	cmp	r2, r3
 800dade:	d3e8      	bcc.n	800dab2 <bufferBlockPushBytes+0x162>
>>>>>>> 752c83b... update binaries
             i++, data_index++)
        {
            block->data[i] = data[data_index];
        }

        if (data_index < data_len)
<<<<<<< HEAD
 800da58:	78fb      	ldrb	r3, [r7, #3]
 800da5a:	b29b      	uxth	r3, r3
 800da5c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da5e:	429a      	cmp	r2, r3
 800da60:	d212      	bcs.n	800da88 <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800da62:	68f8      	ldr	r0, [r7, #12]
 800da64:	f000 f82e 	bl	800dac4 <createBufferBlock>
 800da68:	4602      	mov	r2, r0
 800da6a:	69fb      	ldr	r3, [r7, #28]
 800da6c:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800da6e:	69fb      	ldr	r3, [r7, #28]
 800da70:	681b      	ldr	r3, [r3, #0]
 800da72:	2b00      	cmp	r3, #0
 800da74:	d102      	bne.n	800da7c <bufferBlockPushBytes+0x1b4>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800da76:	f06f 0302 	mvn.w	r3, #2
 800da7a:	e01d      	b.n	800dab8 <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800da7c:	69fb      	ldr	r3, [r7, #28]
 800da7e:	681b      	ldr	r3, [r3, #0]
 800da80:	61fb      	str	r3, [r7, #28]
            index_at_nth_block = 0;
 800da82:	2300      	movs	r3, #0
 800da84:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
=======
 800dae0:	78fb      	ldrb	r3, [r7, #3]
 800dae2:	b29b      	uxth	r3, r3
 800dae4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800dae6:	429a      	cmp	r2, r3
 800dae8:	d212      	bcs.n	800db10 <bufferBlockPushBytes+0x1c0>
        {
            block->next = createBufferBlock(allocator);
 800daea:	68f8      	ldr	r0, [r7, #12]
 800daec:	f000 f82e 	bl	800db4c <createBufferBlock>
 800daf0:	4602      	mov	r2, r0
 800daf2:	69fb      	ldr	r3, [r7, #28]
 800daf4:	601a      	str	r2, [r3, #0]
            if (block->next == NULL)
 800daf6:	69fb      	ldr	r3, [r7, #28]
 800daf8:	681b      	ldr	r3, [r3, #0]
 800dafa:	2b00      	cmp	r3, #0
 800dafc:	d102      	bne.n	800db04 <bufferBlockPushBytes+0x1b4>
            {
                return -CANARD_ERROR_OUT_OF_MEMORY;
 800dafe:	f06f 0302 	mvn.w	r3, #2
 800db02:	e01d      	b.n	800db40 <bufferBlockPushBytes+0x1f0>
            }
            block = block->next;
 800db04:	69fb      	ldr	r3, [r7, #28]
 800db06:	681b      	ldr	r3, [r3, #0]
 800db08:	61fb      	str	r3, [r7, #28]
            index_at_nth_block = 0;
 800db0a:	2300      	movs	r3, #0
 800db0c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
>>>>>>> 752c83b... update binaries
            block = block->next;
        }
    }

    // add data to current block until it becomes full, add new block if necessary
    while (data_index < data_len)
<<<<<<< HEAD
 800da88:	78fb      	ldrb	r3, [r7, #3]
 800da8a:	b29b      	uxth	r3, r3
 800da8c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800da8e:	429a      	cmp	r2, r3
 800da90:	d3c7      	bcc.n	800da22 <bufferBlockPushBytes+0x15a>
=======
 800db10:	78fb      	ldrb	r3, [r7, #3]
 800db12:	b29b      	uxth	r3, r3
 800db14:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800db16:	429a      	cmp	r2, r3
 800db18:	d3c7      	bcc.n	800daaa <bufferBlockPushBytes+0x15a>
>>>>>>> 752c83b... update binaries
            block = block->next;
            index_at_nth_block = 0;
        }
    }

    state->payload_len += data_len;
<<<<<<< HEAD
 800da92:	68bb      	ldr	r3, [r7, #8]
 800da94:	8b1b      	ldrh	r3, [r3, #24]
 800da96:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800da9a:	b29b      	uxth	r3, r3
 800da9c:	461a      	mov	r2, r3
 800da9e:	78fb      	ldrb	r3, [r7, #3]
 800daa0:	b29b      	uxth	r3, r3
 800daa2:	4413      	add	r3, r2
 800daa4:	b29b      	uxth	r3, r3
 800daa6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800daaa:	b299      	uxth	r1, r3
 800daac:	68ba      	ldr	r2, [r7, #8]
 800daae:	8b13      	ldrh	r3, [r2, #24]
 800dab0:	f361 0309 	bfi	r3, r1, #0, #10
 800dab4:	8313      	strh	r3, [r2, #24]

    return 1;
 800dab6:	2301      	movs	r3, #1
}
 800dab8:	4618      	mov	r0, r3
 800daba:	3728      	adds	r7, #40	; 0x28
 800dabc:	46bd      	mov	sp, r7
 800dabe:	bd80      	pop	{r7, pc}
 800dac0:	24924925 	.word	0x24924925

0800dac4 <createBufferBlock>:

CANARD_INTERNAL CanardBufferBlock* createBufferBlock(CanardPoolAllocator* allocator)
{
 800dac4:	b580      	push	{r7, lr}
 800dac6:	b084      	sub	sp, #16
 800dac8:	af00      	add	r7, sp, #0
 800daca:	6078      	str	r0, [r7, #4]
    CanardBufferBlock* block = (CanardBufferBlock*) allocateBlock(allocator);
 800dacc:	6878      	ldr	r0, [r7, #4]
 800dace:	f000 fa65 	bl	800df9c <allocateBlock>
 800dad2:	60f8      	str	r0, [r7, #12]
    if (block == NULL)
 800dad4:	68fb      	ldr	r3, [r7, #12]
 800dad6:	2b00      	cmp	r3, #0
 800dad8:	d101      	bne.n	800dade <createBufferBlock+0x1a>
    {
        return NULL;
 800dada:	2300      	movs	r3, #0
 800dadc:	e003      	b.n	800dae6 <createBufferBlock+0x22>
    }
    block->next = NULL;
 800dade:	68fb      	ldr	r3, [r7, #12]
 800dae0:	2200      	movs	r2, #0
 800dae2:	601a      	str	r2, [r3, #0]
    return block;
 800dae4:	68fb      	ldr	r3, [r7, #12]
}
 800dae6:	4618      	mov	r0, r3
 800dae8:	3710      	adds	r7, #16
 800daea:	46bd      	mov	sp, r7
 800daec:	bd80      	pop	{r7, pc}
 800daee:	bf00      	nop

0800daf0 <copyBitArray>:
=======
 800db1a:	68bb      	ldr	r3, [r7, #8]
 800db1c:	8b1b      	ldrh	r3, [r3, #24]
 800db1e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800db22:	b29b      	uxth	r3, r3
 800db24:	461a      	mov	r2, r3
 800db26:	78fb      	ldrb	r3, [r7, #3]
 800db28:	b29b      	uxth	r3, r3
 800db2a:	4413      	add	r3, r2
 800db2c:	b29b      	uxth	r3, r3
 800db2e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800db32:	b299      	uxth	r1, r3
 800db34:	68ba      	ldr	r2, [r7, #8]
 800db36:	8b13      	ldrh	r3, [r2, #24]
 800db38:	f361 0309 	bfi	r3, r1, #0, #10
 800db3c:	8313      	strh	r3, [r2, #24]

    return 1;
 800db3e:	2301      	movs	r3, #1
}
 800db40:	4618      	mov	r0, r3
 800db42:	3728      	adds	r7, #40	; 0x28
 800db44:	46bd      	mov	sp, r7
 800db46:	bd80      	pop	{r7, pc}
 800db48:	24924925 	.word	0x24924925

0800db4c <createBufferBlock>:

CANARD_INTERNAL CanardBufferBlock* createBufferBlock(CanardPoolAllocator* allocator)
{
 800db4c:	b580      	push	{r7, lr}
 800db4e:	b084      	sub	sp, #16
 800db50:	af00      	add	r7, sp, #0
 800db52:	6078      	str	r0, [r7, #4]
    CanardBufferBlock* block = (CanardBufferBlock*) allocateBlock(allocator);
 800db54:	6878      	ldr	r0, [r7, #4]
 800db56:	f000 fa65 	bl	800e024 <allocateBlock>
 800db5a:	60f8      	str	r0, [r7, #12]
    if (block == NULL)
 800db5c:	68fb      	ldr	r3, [r7, #12]
 800db5e:	2b00      	cmp	r3, #0
 800db60:	d101      	bne.n	800db66 <createBufferBlock+0x1a>
    {
        return NULL;
 800db62:	2300      	movs	r3, #0
 800db64:	e003      	b.n	800db6e <createBufferBlock+0x22>
    }
    block->next = NULL;
 800db66:	68fb      	ldr	r3, [r7, #12]
 800db68:	2200      	movs	r2, #0
 800db6a:	601a      	str	r2, [r3, #0]
    return block;
 800db6c:	68fb      	ldr	r3, [r7, #12]
}
 800db6e:	4618      	mov	r0, r3
 800db70:	3710      	adds	r7, #16
 800db72:	46bd      	mov	sp, r7
 800db74:	bd80      	pop	{r7, pc}
 800db76:	bf00      	nop

0800db78 <copyBitArray>:
>>>>>>> 752c83b... update binaries
/**
 * Bit array copy routine, originally developed by Ben Dyer for Libuavcan. Thanks Ben.
 */
void copyBitArray(const uint8_t* src, uint32_t src_offset, uint32_t src_len,
                        uint8_t* dst, uint32_t dst_offset)
{
<<<<<<< HEAD
 800daf0:	b480      	push	{r7}
 800daf2:	b089      	sub	sp, #36	; 0x24
 800daf4:	af00      	add	r7, sp, #0
 800daf6:	60f8      	str	r0, [r7, #12]
 800daf8:	60b9      	str	r1, [r7, #8]
 800dafa:	607a      	str	r2, [r7, #4]
 800dafc:	603b      	str	r3, [r7, #0]
=======
 800db78:	b480      	push	{r7}
 800db7a:	b089      	sub	sp, #36	; 0x24
 800db7c:	af00      	add	r7, sp, #0
 800db7e:	60f8      	str	r0, [r7, #12]
 800db80:	60b9      	str	r1, [r7, #8]
 800db82:	607a      	str	r2, [r7, #4]
 800db84:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    CANARD_ASSERT(src_len > 0U);

    // Normalizing inputs
    src += src_offset / 8;
<<<<<<< HEAD
 800dafe:	68bb      	ldr	r3, [r7, #8]
 800db00:	08db      	lsrs	r3, r3, #3
 800db02:	68fa      	ldr	r2, [r7, #12]
 800db04:	4413      	add	r3, r2
 800db06:	60fb      	str	r3, [r7, #12]
    dst += dst_offset / 8;
 800db08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db0a:	08db      	lsrs	r3, r3, #3
 800db0c:	683a      	ldr	r2, [r7, #0]
 800db0e:	4413      	add	r3, r2
 800db10:	603b      	str	r3, [r7, #0]

    src_offset %= 8;
 800db12:	68bb      	ldr	r3, [r7, #8]
 800db14:	f003 0307 	and.w	r3, r3, #7
 800db18:	60bb      	str	r3, [r7, #8]
    dst_offset %= 8;
 800db1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db1c:	f003 0307 	and.w	r3, r3, #7
 800db20:	62bb      	str	r3, [r7, #40]	; 0x28

    const size_t last_bit = src_offset + src_len;
 800db22:	68ba      	ldr	r2, [r7, #8]
 800db24:	687b      	ldr	r3, [r7, #4]
 800db26:	4413      	add	r3, r2
 800db28:	61fb      	str	r3, [r7, #28]
 800db2a:	e051      	b.n	800dbd0 <copyBitArray+0xe0>
    while (last_bit - src_offset)
    {
        const uint8_t src_bit_offset = (uint8_t)(src_offset % 8U);
 800db2c:	68bb      	ldr	r3, [r7, #8]
 800db2e:	b2db      	uxtb	r3, r3
 800db30:	f003 0307 	and.w	r3, r3, #7
 800db34:	76fb      	strb	r3, [r7, #27]
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);
 800db36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db38:	b2db      	uxtb	r3, r3
 800db3a:	f003 0307 	and.w	r3, r3, #7
 800db3e:	76bb      	strb	r3, [r7, #26]

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
 800db40:	7eba      	ldrb	r2, [r7, #26]
 800db42:	7efb      	ldrb	r3, [r7, #27]
 800db44:	4293      	cmp	r3, r2
 800db46:	bf38      	it	cc
 800db48:	4613      	movcc	r3, r2
 800db4a:	767b      	strb	r3, [r7, #25]
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);
 800db4c:	7e7b      	ldrb	r3, [r7, #25]
 800db4e:	f1c3 0208 	rsb	r2, r3, #8
 800db52:	69f9      	ldr	r1, [r7, #28]
 800db54:	68bb      	ldr	r3, [r7, #8]
 800db56:	1acb      	subs	r3, r1, r3
 800db58:	4293      	cmp	r3, r2
 800db5a:	bf28      	it	cs
 800db5c:	4613      	movcs	r3, r2
 800db5e:	617b      	str	r3, [r7, #20]

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 800db60:	697b      	ldr	r3, [r7, #20]
 800db62:	f44f 427f 	mov.w	r2, #65280	; 0xff00
 800db66:	fa22 f303 	lsr.w	r3, r2, r3
 800db6a:	b2db      	uxtb	r3, r3
 800db6c:	461a      	mov	r2, r3
 800db6e:	7ebb      	ldrb	r3, [r7, #26]
 800db70:	fa42 f303 	asr.w	r3, r2, r3
 800db74:	74fb      	strb	r3, [r7, #19]
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 800db76:	68bb      	ldr	r3, [r7, #8]
 800db78:	08db      	lsrs	r3, r3, #3
 800db7a:	68fa      	ldr	r2, [r7, #12]
 800db7c:	4413      	add	r3, r2
 800db7e:	781b      	ldrb	r3, [r3, #0]
 800db80:	461a      	mov	r2, r3
 800db82:	7efb      	ldrb	r3, [r7, #27]
 800db84:	409a      	lsls	r2, r3
 800db86:	7ebb      	ldrb	r3, [r7, #26]
 800db88:	fa42 f303 	asr.w	r3, r2, r3
 800db8c:	74bb      	strb	r3, [r7, #18]

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 800db8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db90:	08db      	lsrs	r3, r3, #3
 800db92:	683a      	ldr	r2, [r7, #0]
 800db94:	4413      	add	r3, r2
 800db96:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800db98:	08d2      	lsrs	r2, r2, #3
 800db9a:	6839      	ldr	r1, [r7, #0]
 800db9c:	440a      	add	r2, r1
 800db9e:	7812      	ldrb	r2, [r2, #0]
 800dba0:	b2d1      	uxtb	r1, r2
 800dba2:	7cfa      	ldrb	r2, [r7, #19]
 800dba4:	43d2      	mvns	r2, r2
 800dba6:	b2d2      	uxtb	r2, r2
 800dba8:	400a      	ands	r2, r1
 800dbaa:	b2d0      	uxtb	r0, r2
 800dbac:	7cb9      	ldrb	r1, [r7, #18]
 800dbae:	7cfa      	ldrb	r2, [r7, #19]
 800dbb0:	400a      	ands	r2, r1
 800dbb2:	b2d2      	uxtb	r2, r2
 800dbb4:	b2d2      	uxtb	r2, r2
 800dbb6:	4601      	mov	r1, r0
 800dbb8:	430a      	orrs	r2, r1
 800dbba:	b2d2      	uxtb	r2, r2
 800dbbc:	b2d2      	uxtb	r2, r2
 800dbbe:	701a      	strb	r2, [r3, #0]

        src_offset += copy_bits;
 800dbc0:	68ba      	ldr	r2, [r7, #8]
 800dbc2:	697b      	ldr	r3, [r7, #20]
 800dbc4:	4413      	add	r3, r2
 800dbc6:	60bb      	str	r3, [r7, #8]
        dst_offset += copy_bits;
 800dbc8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dbca:	697b      	ldr	r3, [r7, #20]
 800dbcc:	4413      	add	r3, r2
 800dbce:	62bb      	str	r3, [r7, #40]	; 0x28
=======
 800db86:	68bb      	ldr	r3, [r7, #8]
 800db88:	08db      	lsrs	r3, r3, #3
 800db8a:	68fa      	ldr	r2, [r7, #12]
 800db8c:	4413      	add	r3, r2
 800db8e:	60fb      	str	r3, [r7, #12]
    dst += dst_offset / 8;
 800db90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800db92:	08db      	lsrs	r3, r3, #3
 800db94:	683a      	ldr	r2, [r7, #0]
 800db96:	4413      	add	r3, r2
 800db98:	603b      	str	r3, [r7, #0]

    src_offset %= 8;
 800db9a:	68bb      	ldr	r3, [r7, #8]
 800db9c:	f003 0307 	and.w	r3, r3, #7
 800dba0:	60bb      	str	r3, [r7, #8]
    dst_offset %= 8;
 800dba2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dba4:	f003 0307 	and.w	r3, r3, #7
 800dba8:	62bb      	str	r3, [r7, #40]	; 0x28

    const size_t last_bit = src_offset + src_len;
 800dbaa:	68ba      	ldr	r2, [r7, #8]
 800dbac:	687b      	ldr	r3, [r7, #4]
 800dbae:	4413      	add	r3, r2
 800dbb0:	61fb      	str	r3, [r7, #28]
 800dbb2:	e051      	b.n	800dc58 <copyBitArray+0xe0>
    while (last_bit - src_offset)
    {
        const uint8_t src_bit_offset = (uint8_t)(src_offset % 8U);
 800dbb4:	68bb      	ldr	r3, [r7, #8]
 800dbb6:	b2db      	uxtb	r3, r3
 800dbb8:	f003 0307 	and.w	r3, r3, #7
 800dbbc:	76fb      	strb	r3, [r7, #27]
        const uint8_t dst_bit_offset = (uint8_t)(dst_offset % 8U);
 800dbbe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dbc0:	b2db      	uxtb	r3, r3
 800dbc2:	f003 0307 	and.w	r3, r3, #7
 800dbc6:	76bb      	strb	r3, [r7, #26]

        const uint8_t max_offset = MAX(src_bit_offset, dst_bit_offset);
 800dbc8:	7eba      	ldrb	r2, [r7, #26]
 800dbca:	7efb      	ldrb	r3, [r7, #27]
 800dbcc:	4293      	cmp	r3, r2
 800dbce:	bf38      	it	cc
 800dbd0:	4613      	movcc	r3, r2
 800dbd2:	767b      	strb	r3, [r7, #25]
        const uint32_t copy_bits = MIN(last_bit - src_offset, 8U - max_offset);
 800dbd4:	7e7b      	ldrb	r3, [r7, #25]
 800dbd6:	f1c3 0208 	rsb	r2, r3, #8
 800dbda:	69f9      	ldr	r1, [r7, #28]
 800dbdc:	68bb      	ldr	r3, [r7, #8]
 800dbde:	1acb      	subs	r3, r1, r3
 800dbe0:	4293      	cmp	r3, r2
 800dbe2:	bf28      	it	cs
 800dbe4:	4613      	movcs	r3, r2
 800dbe6:	617b      	str	r3, [r7, #20]

        const uint8_t write_mask = (uint8_t)((uint8_t)(0xFF00U >> copy_bits) >> dst_bit_offset);
 800dbe8:	697b      	ldr	r3, [r7, #20]
 800dbea:	f44f 427f 	mov.w	r2, #65280	; 0xff00
 800dbee:	fa22 f303 	lsr.w	r3, r2, r3
 800dbf2:	b2db      	uxtb	r3, r3
 800dbf4:	461a      	mov	r2, r3
 800dbf6:	7ebb      	ldrb	r3, [r7, #26]
 800dbf8:	fa42 f303 	asr.w	r3, r2, r3
 800dbfc:	74fb      	strb	r3, [r7, #19]
        const uint8_t src_data = (uint8_t)((src[src_offset / 8U] << src_bit_offset) >> dst_bit_offset);
 800dbfe:	68bb      	ldr	r3, [r7, #8]
 800dc00:	08db      	lsrs	r3, r3, #3
 800dc02:	68fa      	ldr	r2, [r7, #12]
 800dc04:	4413      	add	r3, r2
 800dc06:	781b      	ldrb	r3, [r3, #0]
 800dc08:	461a      	mov	r2, r3
 800dc0a:	7efb      	ldrb	r3, [r7, #27]
 800dc0c:	409a      	lsls	r2, r3
 800dc0e:	7ebb      	ldrb	r3, [r7, #26]
 800dc10:	fa42 f303 	asr.w	r3, r2, r3
 800dc14:	74bb      	strb	r3, [r7, #18]

        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));
 800dc16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dc18:	08db      	lsrs	r3, r3, #3
 800dc1a:	683a      	ldr	r2, [r7, #0]
 800dc1c:	4413      	add	r3, r2
 800dc1e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dc20:	08d2      	lsrs	r2, r2, #3
 800dc22:	6839      	ldr	r1, [r7, #0]
 800dc24:	440a      	add	r2, r1
 800dc26:	7812      	ldrb	r2, [r2, #0]
 800dc28:	b2d1      	uxtb	r1, r2
 800dc2a:	7cfa      	ldrb	r2, [r7, #19]
 800dc2c:	43d2      	mvns	r2, r2
 800dc2e:	b2d2      	uxtb	r2, r2
 800dc30:	400a      	ands	r2, r1
 800dc32:	b2d0      	uxtb	r0, r2
 800dc34:	7cb9      	ldrb	r1, [r7, #18]
 800dc36:	7cfa      	ldrb	r2, [r7, #19]
 800dc38:	400a      	ands	r2, r1
 800dc3a:	b2d2      	uxtb	r2, r2
 800dc3c:	b2d2      	uxtb	r2, r2
 800dc3e:	4601      	mov	r1, r0
 800dc40:	430a      	orrs	r2, r1
 800dc42:	b2d2      	uxtb	r2, r2
 800dc44:	b2d2      	uxtb	r2, r2
 800dc46:	701a      	strb	r2, [r3, #0]

        src_offset += copy_bits;
 800dc48:	68ba      	ldr	r2, [r7, #8]
 800dc4a:	697b      	ldr	r3, [r7, #20]
 800dc4c:	4413      	add	r3, r2
 800dc4e:	60bb      	str	r3, [r7, #8]
        dst_offset += copy_bits;
 800dc50:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dc52:	697b      	ldr	r3, [r7, #20]
 800dc54:	4413      	add	r3, r2
 800dc56:	62bb      	str	r3, [r7, #40]	; 0x28
>>>>>>> 752c83b... update binaries

    src_offset %= 8;
    dst_offset %= 8;

    const size_t last_bit = src_offset + src_len;
    while (last_bit - src_offset)
<<<<<<< HEAD
 800dbd0:	69fa      	ldr	r2, [r7, #28]
 800dbd2:	68bb      	ldr	r3, [r7, #8]
 800dbd4:	429a      	cmp	r2, r3
 800dbd6:	d1a9      	bne.n	800db2c <copyBitArray+0x3c>
=======
 800dc58:	69fa      	ldr	r2, [r7, #28]
 800dc5a:	68bb      	ldr	r3, [r7, #8]
 800dc5c:	429a      	cmp	r2, r3
 800dc5e:	d1a9      	bne.n	800dbb4 <copyBitArray+0x3c>
>>>>>>> 752c83b... update binaries
        dst[dst_offset / 8U] = (uint8_t)((dst[dst_offset / 8U] & ~write_mask) | (src_data & write_mask));

        src_offset += copy_bits;
        dst_offset += copy_bits;
    }
}
<<<<<<< HEAD
 800dbd8:	3724      	adds	r7, #36	; 0x24
 800dbda:	46bd      	mov	sp, r7
 800dbdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dbe0:	4770      	bx	lr
 800dbe2:	bf00      	nop

0800dbe4 <descatterTransferPayload>:
=======
 800dc60:	3724      	adds	r7, #36	; 0x24
 800dc62:	46bd      	mov	sp, r7
 800dc64:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dc68:	4770      	bx	lr
 800dc6a:	bf00      	nop

0800dc6c <descatterTransferPayload>:
>>>>>>> 752c83b... update binaries

CANARD_INTERNAL int descatterTransferPayload(const CanardRxTransfer* transfer,
                                             uint32_t bit_offset,
                                             uint8_t bit_length,
                                             void* output)
{
<<<<<<< HEAD
 800dbe4:	b580      	push	{r7, lr}
 800dbe6:	b090      	sub	sp, #64	; 0x40
 800dbe8:	af02      	add	r7, sp, #8
 800dbea:	60f8      	str	r0, [r7, #12]
 800dbec:	60b9      	str	r1, [r7, #8]
 800dbee:	603b      	str	r3, [r7, #0]
 800dbf0:	4613      	mov	r3, r2
 800dbf2:	71fb      	strb	r3, [r7, #7]
    CANARD_ASSERT(transfer != 0);

    if (bit_offset >= transfer->payload_len * 8)
 800dbf4:	68fb      	ldr	r3, [r7, #12]
 800dbf6:	8a9b      	ldrh	r3, [r3, #20]
 800dbf8:	00db      	lsls	r3, r3, #3
 800dbfa:	461a      	mov	r2, r3
 800dbfc:	68bb      	ldr	r3, [r7, #8]
 800dbfe:	429a      	cmp	r2, r3
 800dc00:	d801      	bhi.n	800dc06 <descatterTransferPayload+0x22>
    {
        return 0;       // Out of range, reading zero bits
 800dc02:	2300      	movs	r3, #0
 800dc04:	e0da      	b.n	800ddbc <descatterTransferPayload+0x1d8>
    }

    if (bit_offset + bit_length > transfer->payload_len * 8)
 800dc06:	79fa      	ldrb	r2, [r7, #7]
 800dc08:	68bb      	ldr	r3, [r7, #8]
 800dc0a:	4413      	add	r3, r2
 800dc0c:	68fa      	ldr	r2, [r7, #12]
 800dc0e:	8a92      	ldrh	r2, [r2, #20]
 800dc10:	00d2      	lsls	r2, r2, #3
 800dc12:	4293      	cmp	r3, r2
 800dc14:	d908      	bls.n	800dc28 <descatterTransferPayload+0x44>
    {
        bit_length = (uint8_t)(transfer->payload_len * 8 - bit_offset);
 800dc16:	68fb      	ldr	r3, [r7, #12]
 800dc18:	8a9b      	ldrh	r3, [r3, #20]
 800dc1a:	b2db      	uxtb	r3, r3
 800dc1c:	00db      	lsls	r3, r3, #3
 800dc1e:	b2da      	uxtb	r2, r3
 800dc20:	68bb      	ldr	r3, [r7, #8]
 800dc22:	b2db      	uxtb	r3, r3
 800dc24:	1ad3      	subs	r3, r2, r3
 800dc26:	71fb      	strb	r3, [r7, #7]
=======
 800dc6c:	b580      	push	{r7, lr}
 800dc6e:	b090      	sub	sp, #64	; 0x40
 800dc70:	af02      	add	r7, sp, #8
 800dc72:	60f8      	str	r0, [r7, #12]
 800dc74:	60b9      	str	r1, [r7, #8]
 800dc76:	603b      	str	r3, [r7, #0]
 800dc78:	4613      	mov	r3, r2
 800dc7a:	71fb      	strb	r3, [r7, #7]
    CANARD_ASSERT(transfer != 0);

    if (bit_offset >= transfer->payload_len * 8)
 800dc7c:	68fb      	ldr	r3, [r7, #12]
 800dc7e:	8a9b      	ldrh	r3, [r3, #20]
 800dc80:	00db      	lsls	r3, r3, #3
 800dc82:	461a      	mov	r2, r3
 800dc84:	68bb      	ldr	r3, [r7, #8]
 800dc86:	429a      	cmp	r2, r3
 800dc88:	d801      	bhi.n	800dc8e <descatterTransferPayload+0x22>
    {
        return 0;       // Out of range, reading zero bits
 800dc8a:	2300      	movs	r3, #0
 800dc8c:	e0da      	b.n	800de44 <descatterTransferPayload+0x1d8>
    }

    if (bit_offset + bit_length > transfer->payload_len * 8)
 800dc8e:	79fa      	ldrb	r2, [r7, #7]
 800dc90:	68bb      	ldr	r3, [r7, #8]
 800dc92:	4413      	add	r3, r2
 800dc94:	68fa      	ldr	r2, [r7, #12]
 800dc96:	8a92      	ldrh	r2, [r2, #20]
 800dc98:	00d2      	lsls	r2, r2, #3
 800dc9a:	4293      	cmp	r3, r2
 800dc9c:	d908      	bls.n	800dcb0 <descatterTransferPayload+0x44>
    {
        bit_length = (uint8_t)(transfer->payload_len * 8 - bit_offset);
 800dc9e:	68fb      	ldr	r3, [r7, #12]
 800dca0:	8a9b      	ldrh	r3, [r3, #20]
 800dca2:	b2db      	uxtb	r3, r3
 800dca4:	00db      	lsls	r3, r3, #3
 800dca6:	b2da      	uxtb	r2, r3
 800dca8:	68bb      	ldr	r3, [r7, #8]
 800dcaa:	b2db      	uxtb	r3, r3
 800dcac:	1ad3      	subs	r3, r2, r3
 800dcae:	71fb      	strb	r3, [r7, #7]
>>>>>>> 752c83b... update binaries
    }

    CANARD_ASSERT(bit_length > 0);

    if ((transfer->payload_middle != NULL) || (transfer->payload_tail != NULL)) // Multi frame
<<<<<<< HEAD
 800dc28:	68fb      	ldr	r3, [r7, #12]
 800dc2a:	68db      	ldr	r3, [r3, #12]
 800dc2c:	2b00      	cmp	r3, #0
 800dc2e:	d104      	bne.n	800dc3a <descatterTransferPayload+0x56>
 800dc30:	68fb      	ldr	r3, [r7, #12]
 800dc32:	691b      	ldr	r3, [r3, #16]
 800dc34:	2b00      	cmp	r3, #0
 800dc36:	f000 80b6 	beq.w	800dda6 <descatterTransferPayload+0x1c2>
=======
 800dcb0:	68fb      	ldr	r3, [r7, #12]
 800dcb2:	68db      	ldr	r3, [r3, #12]
 800dcb4:	2b00      	cmp	r3, #0
 800dcb6:	d104      	bne.n	800dcc2 <descatterTransferPayload+0x56>
 800dcb8:	68fb      	ldr	r3, [r7, #12]
 800dcba:	691b      	ldr	r3, [r3, #16]
 800dcbc:	2b00      	cmp	r3, #0
 800dcbe:	f000 80b6 	beq.w	800de2e <descatterTransferPayload+0x1c2>
>>>>>>> 752c83b... update binaries
        /*
         * This part is hideously complicated and probably should be redesigned.
         * The objective here is to copy the requested number of bits from scattered storage into the temporary
         * local storage. We go through great pains to ensure that all corner cases are handled correctly.
         */
        uint32_t input_bit_offset = bit_offset;
<<<<<<< HEAD
 800dc3a:	68bb      	ldr	r3, [r7, #8]
 800dc3c:	637b      	str	r3, [r7, #52]	; 0x34
        uint8_t output_bit_offset = 0;
 800dc3e:	2300      	movs	r3, #0
 800dc40:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        uint8_t remaining_bit_length = bit_length;
 800dc44:	79fb      	ldrb	r3, [r7, #7]
 800dc46:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32

        // Reading head
        if (input_bit_offset < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8)
 800dc4a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dc4c:	2b2f      	cmp	r3, #47	; 0x2f
 800dc4e:	d827      	bhi.n	800dca0 <descatterTransferPayload+0xbc>
        {
            const uint8_t amount = MIN(remaining_bit_length,
 800dc50:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dc52:	f1c3 0230 	rsb	r2, r3, #48	; 0x30
 800dc56:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dc5a:	4293      	cmp	r3, r2
 800dc5c:	bf28      	it	cs
 800dc5e:	4613      	movcs	r3, r2
 800dc60:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
                                       CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U - input_bit_offset);

            copyBitArray(&transfer->payload_head[0], input_bit_offset, amount, (uint8_t*) output, 0);
 800dc64:	68fb      	ldr	r3, [r7, #12]
 800dc66:	6899      	ldr	r1, [r3, #8]
 800dc68:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800dc6c:	2300      	movs	r3, #0
 800dc6e:	9300      	str	r3, [sp, #0]
 800dc70:	4608      	mov	r0, r1
 800dc72:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800dc74:	683b      	ldr	r3, [r7, #0]
 800dc76:	f7ff ff3b 	bl	800daf0 <copyBitArray>

            input_bit_offset += amount;
 800dc7a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dc7e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dc80:	4413      	add	r3, r2
 800dc82:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += amount;
 800dc84:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dc88:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dc8c:	4413      	add	r3, r2
 800dc8e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length -= amount;
 800dc92:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dc96:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dc9a:	1ad3      	subs	r3, r2, r3
 800dc9c:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
=======
 800dcc2:	68bb      	ldr	r3, [r7, #8]
 800dcc4:	637b      	str	r3, [r7, #52]	; 0x34
        uint8_t output_bit_offset = 0;
 800dcc6:	2300      	movs	r3, #0
 800dcc8:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        uint8_t remaining_bit_length = bit_length;
 800dccc:	79fb      	ldrb	r3, [r7, #7]
 800dcce:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32

        // Reading head
        if (input_bit_offset < CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8)
 800dcd2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcd4:	2b2f      	cmp	r3, #47	; 0x2f
 800dcd6:	d827      	bhi.n	800dd28 <descatterTransferPayload+0xbc>
        {
            const uint8_t amount = MIN(remaining_bit_length,
 800dcd8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcda:	f1c3 0230 	rsb	r2, r3, #48	; 0x30
 800dcde:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dce2:	4293      	cmp	r3, r2
 800dce4:	bf28      	it	cs
 800dce6:	4613      	movcs	r3, r2
 800dce8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
                                       CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U - input_bit_offset);

            copyBitArray(&transfer->payload_head[0], input_bit_offset, amount, (uint8_t*) output, 0);
 800dcec:	68fb      	ldr	r3, [r7, #12]
 800dcee:	6899      	ldr	r1, [r3, #8]
 800dcf0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800dcf4:	2300      	movs	r3, #0
 800dcf6:	9300      	str	r3, [sp, #0]
 800dcf8:	4608      	mov	r0, r1
 800dcfa:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800dcfc:	683b      	ldr	r3, [r7, #0]
 800dcfe:	f7ff ff3b 	bl	800db78 <copyBitArray>

            input_bit_offset += amount;
 800dd02:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dd06:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd08:	4413      	add	r3, r2
 800dd0a:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += amount;
 800dd0c:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dd10:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dd14:	4413      	add	r3, r2
 800dd16:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length -= amount;
 800dd1a:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dd1e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800dd22:	1ad3      	subs	r3, r2, r3
 800dd24:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
>>>>>>> 752c83b... update binaries
        }

        // Reading middle
        uint32_t remaining_bits = transfer->payload_len * 8U - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
<<<<<<< HEAD
 800dca0:	68fb      	ldr	r3, [r7, #12]
 800dca2:	8a9b      	ldrh	r3, [r3, #20]
 800dca4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800dca8:	3b06      	subs	r3, #6
 800dcaa:	00db      	lsls	r3, r3, #3
 800dcac:	62fb      	str	r3, [r7, #44]	; 0x2c
        uint32_t block_bit_offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
 800dcae:	2330      	movs	r3, #48	; 0x30
 800dcb0:	62bb      	str	r3, [r7, #40]	; 0x28
        const CanardBufferBlock* block = transfer->payload_middle;
 800dcb2:	68fb      	ldr	r3, [r7, #12]
 800dcb4:	68db      	ldr	r3, [r3, #12]
 800dcb6:	627b      	str	r3, [r7, #36]	; 0x24
 800dcb8:	e046      	b.n	800dd48 <descatterTransferPayload+0x164>
=======
 800dd28:	68fb      	ldr	r3, [r7, #12]
 800dd2a:	8a9b      	ldrh	r3, [r3, #20]
 800dd2c:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800dd30:	3b06      	subs	r3, #6
 800dd32:	00db      	lsls	r3, r3, #3
 800dd34:	62fb      	str	r3, [r7, #44]	; 0x2c
        uint32_t block_bit_offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
 800dd36:	2330      	movs	r3, #48	; 0x30
 800dd38:	62bb      	str	r3, [r7, #40]	; 0x28
        const CanardBufferBlock* block = transfer->payload_middle;
 800dd3a:	68fb      	ldr	r3, [r7, #12]
 800dd3c:	68db      	ldr	r3, [r3, #12]
 800dd3e:	627b      	str	r3, [r7, #36]	; 0x24
 800dd40:	e046      	b.n	800ddd0 <descatterTransferPayload+0x164>
>>>>>>> 752c83b... update binaries

        while ((block != NULL) && (remaining_bit_length > 0))
        {
            CANARD_ASSERT(remaining_bits > 0);
            const uint32_t block_end_bit_offset = block_bit_offset + MIN(CANARD_BUFFER_BLOCK_DATA_SIZE * 8,
<<<<<<< HEAD
 800dcba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dcbc:	2be0      	cmp	r3, #224	; 0xe0
 800dcbe:	bf28      	it	cs
 800dcc0:	23e0      	movcs	r3, #224	; 0xe0
 800dcc2:	461a      	mov	r2, r3
 800dcc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dcc6:	4413      	add	r3, r2
 800dcc8:	61fb      	str	r3, [r7, #28]
=======
 800dd42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dd44:	2be0      	cmp	r3, #224	; 0xe0
 800dd46:	bf28      	it	cs
 800dd48:	23e0      	movcs	r3, #224	; 0xe0
 800dd4a:	461a      	mov	r2, r3
 800dd4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dd4e:	4413      	add	r3, r2
 800dd50:	61fb      	str	r3, [r7, #28]
>>>>>>> 752c83b... update binaries
                                                                         remaining_bits);

            // Perform copy if we've reached the requested offset, otherwise jump over this block and try next
            if (block_end_bit_offset > input_bit_offset)
<<<<<<< HEAD
 800dcca:	69fa      	ldr	r2, [r7, #28]
 800dccc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcce:	429a      	cmp	r2, r3
 800dcd0:	d92f      	bls.n	800dd32 <descatterTransferPayload+0x14e>
            {
                const uint8_t amount = (uint8_t) MIN(remaining_bit_length, block_end_bit_offset - input_bit_offset);
 800dcd2:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dcd6:	69f9      	ldr	r1, [r7, #28]
 800dcd8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dcda:	1acb      	subs	r3, r1, r3
 800dcdc:	429a      	cmp	r2, r3
 800dcde:	d306      	bcc.n	800dcee <descatterTransferPayload+0x10a>
 800dce0:	69fb      	ldr	r3, [r7, #28]
 800dce2:	b2da      	uxtb	r2, r3
 800dce4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dce6:	b2db      	uxtb	r3, r3
 800dce8:	1ad3      	subs	r3, r2, r3
 800dcea:	b2db      	uxtb	r3, r3
 800dcec:	e001      	b.n	800dcf2 <descatterTransferPayload+0x10e>
 800dcee:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dcf2:	76fb      	strb	r3, [r7, #27]

                CANARD_ASSERT(input_bit_offset >= block_bit_offset);
                const uint32_t bit_offset_within_block = input_bit_offset - block_bit_offset;
 800dcf4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dcf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dcf8:	1ad3      	subs	r3, r2, r3
 800dcfa:	617b      	str	r3, [r7, #20]

                copyBitArray(&block->data[0], bit_offset_within_block, amount, (uint8_t*) output, output_bit_offset);
 800dcfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dcfe:	1d19      	adds	r1, r3, #4
 800dd00:	7efa      	ldrb	r2, [r7, #27]
 800dd02:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800dd06:	9300      	str	r3, [sp, #0]
 800dd08:	4608      	mov	r0, r1
 800dd0a:	6979      	ldr	r1, [r7, #20]
 800dd0c:	683b      	ldr	r3, [r7, #0]
 800dd0e:	f7ff feef 	bl	800daf0 <copyBitArray>

                input_bit_offset += amount;
 800dd12:	7efb      	ldrb	r3, [r7, #27]
 800dd14:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd16:	4413      	add	r3, r2
 800dd18:	637b      	str	r3, [r7, #52]	; 0x34
                output_bit_offset += amount;
 800dd1a:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dd1e:	7efb      	ldrb	r3, [r7, #27]
 800dd20:	4413      	add	r3, r2
 800dd22:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
                remaining_bit_length -= amount;
 800dd26:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dd2a:	7efb      	ldrb	r3, [r7, #27]
 800dd2c:	1ad3      	subs	r3, r2, r3
 800dd2e:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
=======
 800dd52:	69fa      	ldr	r2, [r7, #28]
 800dd54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dd56:	429a      	cmp	r2, r3
 800dd58:	d92f      	bls.n	800ddba <descatterTransferPayload+0x14e>
            {
                const uint8_t amount = (uint8_t) MIN(remaining_bit_length, block_end_bit_offset - input_bit_offset);
 800dd5a:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dd5e:	69f9      	ldr	r1, [r7, #28]
 800dd60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dd62:	1acb      	subs	r3, r1, r3
 800dd64:	429a      	cmp	r2, r3
 800dd66:	d306      	bcc.n	800dd76 <descatterTransferPayload+0x10a>
 800dd68:	69fb      	ldr	r3, [r7, #28]
 800dd6a:	b2da      	uxtb	r2, r3
 800dd6c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dd6e:	b2db      	uxtb	r3, r3
 800dd70:	1ad3      	subs	r3, r2, r3
 800dd72:	b2db      	uxtb	r3, r3
 800dd74:	e001      	b.n	800dd7a <descatterTransferPayload+0x10e>
 800dd76:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd7a:	76fb      	strb	r3, [r7, #27]

                CANARD_ASSERT(input_bit_offset >= block_bit_offset);
                const uint32_t bit_offset_within_block = input_bit_offset - block_bit_offset;
 800dd7c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dd80:	1ad3      	subs	r3, r2, r3
 800dd82:	617b      	str	r3, [r7, #20]

                copyBitArray(&block->data[0], bit_offset_within_block, amount, (uint8_t*) output, output_bit_offset);
 800dd84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd86:	1d19      	adds	r1, r3, #4
 800dd88:	7efa      	ldrb	r2, [r7, #27]
 800dd8a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800dd8e:	9300      	str	r3, [sp, #0]
 800dd90:	4608      	mov	r0, r1
 800dd92:	6979      	ldr	r1, [r7, #20]
 800dd94:	683b      	ldr	r3, [r7, #0]
 800dd96:	f7ff feef 	bl	800db78 <copyBitArray>

                input_bit_offset += amount;
 800dd9a:	7efb      	ldrb	r3, [r7, #27]
 800dd9c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd9e:	4413      	add	r3, r2
 800dda0:	637b      	str	r3, [r7, #52]	; 0x34
                output_bit_offset += amount;
 800dda2:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dda6:	7efb      	ldrb	r3, [r7, #27]
 800dda8:	4413      	add	r3, r2
 800ddaa:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
                remaining_bit_length -= amount;
 800ddae:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800ddb2:	7efb      	ldrb	r3, [r7, #27]
 800ddb4:	1ad3      	subs	r3, r2, r3
 800ddb6:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
>>>>>>> 752c83b... update binaries
            }

            CANARD_ASSERT(block_end_bit_offset > block_bit_offset);
            remaining_bits -= block_end_bit_offset - block_bit_offset;
<<<<<<< HEAD
 800dd32:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800dd34:	69fb      	ldr	r3, [r7, #28]
 800dd36:	1ad3      	subs	r3, r2, r3
 800dd38:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800dd3a:	4413      	add	r3, r2
 800dd3c:	62fb      	str	r3, [r7, #44]	; 0x2c
            block_bit_offset = block_end_bit_offset;
 800dd3e:	69fb      	ldr	r3, [r7, #28]
 800dd40:	62bb      	str	r3, [r7, #40]	; 0x28
            block = block->next;
 800dd42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd44:	681b      	ldr	r3, [r3, #0]
 800dd46:	627b      	str	r3, [r7, #36]	; 0x24
=======
 800ddba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800ddbc:	69fb      	ldr	r3, [r7, #28]
 800ddbe:	1ad3      	subs	r3, r2, r3
 800ddc0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ddc2:	4413      	add	r3, r2
 800ddc4:	62fb      	str	r3, [r7, #44]	; 0x2c
            block_bit_offset = block_end_bit_offset;
 800ddc6:	69fb      	ldr	r3, [r7, #28]
 800ddc8:	62bb      	str	r3, [r7, #40]	; 0x28
            block = block->next;
 800ddca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ddcc:	681b      	ldr	r3, [r3, #0]
 800ddce:	627b      	str	r3, [r7, #36]	; 0x24
>>>>>>> 752c83b... update binaries
        // Reading middle
        uint32_t remaining_bits = transfer->payload_len * 8U - CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
        uint32_t block_bit_offset = CANARD_MULTIFRAME_RX_PAYLOAD_HEAD_SIZE * 8U;
        const CanardBufferBlock* block = transfer->payload_middle;

        while ((block != NULL) && (remaining_bit_length > 0))
<<<<<<< HEAD
 800dd48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800dd4a:	2b00      	cmp	r3, #0
 800dd4c:	d003      	beq.n	800dd56 <descatterTransferPayload+0x172>
 800dd4e:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd52:	2b00      	cmp	r3, #0
 800dd54:	d1b1      	bne.n	800dcba <descatterTransferPayload+0xd6>
=======
 800ddd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ddd2:	2b00      	cmp	r3, #0
 800ddd4:	d003      	beq.n	800ddde <descatterTransferPayload+0x172>
 800ddd6:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800ddda:	2b00      	cmp	r3, #0
 800dddc:	d1b1      	bne.n	800dd42 <descatterTransferPayload+0xd6>
>>>>>>> 752c83b... update binaries
        }

        CANARD_ASSERT(remaining_bit_length <= remaining_bits);

        // Reading tail
        if ((transfer->payload_tail != NULL) && (remaining_bit_length > 0))
<<<<<<< HEAD
 800dd56:	68fb      	ldr	r3, [r7, #12]
 800dd58:	691b      	ldr	r3, [r3, #16]
 800dd5a:	2b00      	cmp	r3, #0
 800dd5c:	d02d      	beq.n	800ddba <descatterTransferPayload+0x1d6>
 800dd5e:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd62:	2b00      	cmp	r3, #0
 800dd64:	d029      	beq.n	800ddba <descatterTransferPayload+0x1d6>
        {
            CANARD_ASSERT(input_bit_offset >= block_bit_offset);
            const uint32_t offset = input_bit_offset - block_bit_offset;
 800dd66:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd68:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dd6a:	1ad3      	subs	r3, r2, r3
 800dd6c:	613b      	str	r3, [r7, #16]

            copyBitArray(&transfer->payload_tail[0], offset, remaining_bit_length, (uint8_t*) output,
 800dd6e:	68fb      	ldr	r3, [r7, #12]
 800dd70:	6919      	ldr	r1, [r3, #16]
 800dd72:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800dd76:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800dd7a:	9300      	str	r3, [sp, #0]
 800dd7c:	4608      	mov	r0, r1
 800dd7e:	6939      	ldr	r1, [r7, #16]
 800dd80:	683b      	ldr	r3, [r7, #0]
 800dd82:	f7ff feb5 	bl	800daf0 <copyBitArray>
                         output_bit_offset);

            input_bit_offset += remaining_bit_length;
 800dd86:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd8a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800dd8c:	4413      	add	r3, r2
 800dd8e:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += remaining_bit_length;
 800dd90:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800dd94:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800dd98:	4413      	add	r3, r2
 800dd9a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length = 0;
 800dd9e:	2300      	movs	r3, #0
 800dda0:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 800dda4:	e009      	b.n	800ddba <descatterTransferPayload+0x1d6>
=======
 800ddde:	68fb      	ldr	r3, [r7, #12]
 800dde0:	691b      	ldr	r3, [r3, #16]
 800dde2:	2b00      	cmp	r3, #0
 800dde4:	d02d      	beq.n	800de42 <descatterTransferPayload+0x1d6>
 800dde6:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800ddea:	2b00      	cmp	r3, #0
 800ddec:	d029      	beq.n	800de42 <descatterTransferPayload+0x1d6>
        {
            CANARD_ASSERT(input_bit_offset >= block_bit_offset);
            const uint32_t offset = input_bit_offset - block_bit_offset;
 800ddee:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ddf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ddf2:	1ad3      	subs	r3, r2, r3
 800ddf4:	613b      	str	r3, [r7, #16]

            copyBitArray(&transfer->payload_tail[0], offset, remaining_bit_length, (uint8_t*) output,
 800ddf6:	68fb      	ldr	r3, [r7, #12]
 800ddf8:	6919      	ldr	r1, [r3, #16]
 800ddfa:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800ddfe:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800de02:	9300      	str	r3, [sp, #0]
 800de04:	4608      	mov	r0, r1
 800de06:	6939      	ldr	r1, [r7, #16]
 800de08:	683b      	ldr	r3, [r7, #0]
 800de0a:	f7ff feb5 	bl	800db78 <copyBitArray>
                         output_bit_offset);

            input_bit_offset += remaining_bit_length;
 800de0e:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800de12:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800de14:	4413      	add	r3, r2
 800de16:	637b      	str	r3, [r7, #52]	; 0x34
            output_bit_offset += remaining_bit_length;
 800de18:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 800de1c:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800de20:	4413      	add	r3, r2
 800de22:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
            remaining_bit_length = 0;
 800de26:	2300      	movs	r3, #0
 800de28:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 800de2c:	e009      	b.n	800de42 <descatterTransferPayload+0x1d6>
>>>>>>> 752c83b... update binaries
        CANARD_ASSERT(output_bit_offset <= 64);
        CANARD_ASSERT(remaining_bit_length == 0);
    }
    else                                                                    // Single frame
    {
        copyBitArray(&transfer->payload_head[0], bit_offset, bit_length, (uint8_t*) output, 0);
<<<<<<< HEAD
 800dda6:	68fb      	ldr	r3, [r7, #12]
 800dda8:	6899      	ldr	r1, [r3, #8]
 800ddaa:	79fa      	ldrb	r2, [r7, #7]
 800ddac:	2300      	movs	r3, #0
 800ddae:	9300      	str	r3, [sp, #0]
 800ddb0:	4608      	mov	r0, r1
 800ddb2:	68b9      	ldr	r1, [r7, #8]
 800ddb4:	683b      	ldr	r3, [r7, #0]
 800ddb6:	f7ff fe9b 	bl	800daf0 <copyBitArray>
    }

    return bit_length;
 800ddba:	79fb      	ldrb	r3, [r7, #7]
}
 800ddbc:	4618      	mov	r0, r3
 800ddbe:	3738      	adds	r7, #56	; 0x38
 800ddc0:	46bd      	mov	sp, r7
 800ddc2:	bd80      	pop	{r7, pc}

0800ddc4 <isBigEndian>:

CANARD_INTERNAL bool isBigEndian(void)
{
 800ddc4:	b480      	push	{r7}
 800ddc6:	b083      	sub	sp, #12
 800ddc8:	af00      	add	r7, sp, #0
=======
 800de2e:	68fb      	ldr	r3, [r7, #12]
 800de30:	6899      	ldr	r1, [r3, #8]
 800de32:	79fa      	ldrb	r2, [r7, #7]
 800de34:	2300      	movs	r3, #0
 800de36:	9300      	str	r3, [sp, #0]
 800de38:	4608      	mov	r0, r1
 800de3a:	68b9      	ldr	r1, [r7, #8]
 800de3c:	683b      	ldr	r3, [r7, #0]
 800de3e:	f7ff fe9b 	bl	800db78 <copyBitArray>
    }

    return bit_length;
 800de42:	79fb      	ldrb	r3, [r7, #7]
}
 800de44:	4618      	mov	r0, r3
 800de46:	3738      	adds	r7, #56	; 0x38
 800de48:	46bd      	mov	sp, r7
 800de4a:	bd80      	pop	{r7, pc}

0800de4c <isBigEndian>:

CANARD_INTERNAL bool isBigEndian(void)
{
 800de4c:	b480      	push	{r7}
 800de4e:	b083      	sub	sp, #12
 800de50:	af00      	add	r7, sp, #0
>>>>>>> 752c83b... update binaries
    union
    {
        uint16_t a;
        uint8_t b[2];
    } u;
    u.a = 1;
<<<<<<< HEAD
 800ddca:	2301      	movs	r3, #1
 800ddcc:	80bb      	strh	r3, [r7, #4]
    return u.b[1] == 1;                             // Some don't...
 800ddce:	797b      	ldrb	r3, [r7, #5]
 800ddd0:	2b01      	cmp	r3, #1
 800ddd2:	bf0c      	ite	eq
 800ddd4:	2301      	moveq	r3, #1
 800ddd6:	2300      	movne	r3, #0
 800ddd8:	b2db      	uxtb	r3, r3
#endif
}
 800ddda:	4618      	mov	r0, r3
 800dddc:	370c      	adds	r7, #12
 800ddde:	46bd      	mov	sp, r7
 800dde0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dde4:	4770      	bx	lr
 800dde6:	bf00      	nop

0800dde8 <swapByteOrder>:

CANARD_INTERNAL void swapByteOrder(void* data, unsigned size)
{
 800dde8:	b480      	push	{r7}
 800ddea:	b087      	sub	sp, #28
 800ddec:	af00      	add	r7, sp, #0
 800ddee:	6078      	str	r0, [r7, #4]
 800ddf0:	6039      	str	r1, [r7, #0]
    CANARD_ASSERT(data != NULL);

    uint8_t* const bytes = (uint8_t*) data;
 800ddf2:	687b      	ldr	r3, [r7, #4]
 800ddf4:	60fb      	str	r3, [r7, #12]

    unsigned fwd = 0;
 800ddf6:	2300      	movs	r3, #0
 800ddf8:	617b      	str	r3, [r7, #20]
    unsigned rev = size - 1;
 800ddfa:	683b      	ldr	r3, [r7, #0]
 800ddfc:	3b01      	subs	r3, #1
 800ddfe:	613b      	str	r3, [r7, #16]
 800de00:	e017      	b.n	800de32 <swapByteOrder+0x4a>
=======
 800de52:	2301      	movs	r3, #1
 800de54:	80bb      	strh	r3, [r7, #4]
    return u.b[1] == 1;                             // Some don't...
 800de56:	797b      	ldrb	r3, [r7, #5]
 800de58:	2b01      	cmp	r3, #1
 800de5a:	bf0c      	ite	eq
 800de5c:	2301      	moveq	r3, #1
 800de5e:	2300      	movne	r3, #0
 800de60:	b2db      	uxtb	r3, r3
#endif
}
 800de62:	4618      	mov	r0, r3
 800de64:	370c      	adds	r7, #12
 800de66:	46bd      	mov	sp, r7
 800de68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de6c:	4770      	bx	lr
 800de6e:	bf00      	nop

0800de70 <swapByteOrder>:

CANARD_INTERNAL void swapByteOrder(void* data, unsigned size)
{
 800de70:	b480      	push	{r7}
 800de72:	b087      	sub	sp, #28
 800de74:	af00      	add	r7, sp, #0
 800de76:	6078      	str	r0, [r7, #4]
 800de78:	6039      	str	r1, [r7, #0]
    CANARD_ASSERT(data != NULL);

    uint8_t* const bytes = (uint8_t*) data;
 800de7a:	687b      	ldr	r3, [r7, #4]
 800de7c:	60fb      	str	r3, [r7, #12]

    unsigned fwd = 0;
 800de7e:	2300      	movs	r3, #0
 800de80:	617b      	str	r3, [r7, #20]
    unsigned rev = size - 1;
 800de82:	683b      	ldr	r3, [r7, #0]
 800de84:	3b01      	subs	r3, #1
 800de86:	613b      	str	r3, [r7, #16]
 800de88:	e017      	b.n	800deba <swapByteOrder+0x4a>
>>>>>>> 752c83b... update binaries

    while (fwd < rev)
    {
        const uint8_t x = bytes[fwd];
<<<<<<< HEAD
 800de02:	68fa      	ldr	r2, [r7, #12]
 800de04:	697b      	ldr	r3, [r7, #20]
 800de06:	4413      	add	r3, r2
 800de08:	781b      	ldrb	r3, [r3, #0]
 800de0a:	72fb      	strb	r3, [r7, #11]
        bytes[fwd] = bytes[rev];
 800de0c:	68fa      	ldr	r2, [r7, #12]
 800de0e:	697b      	ldr	r3, [r7, #20]
 800de10:	4413      	add	r3, r2
 800de12:	68f9      	ldr	r1, [r7, #12]
 800de14:	693a      	ldr	r2, [r7, #16]
 800de16:	440a      	add	r2, r1
 800de18:	7812      	ldrb	r2, [r2, #0]
 800de1a:	701a      	strb	r2, [r3, #0]
        bytes[rev] = x;
 800de1c:	68fa      	ldr	r2, [r7, #12]
 800de1e:	693b      	ldr	r3, [r7, #16]
 800de20:	4413      	add	r3, r2
 800de22:	7afa      	ldrb	r2, [r7, #11]
 800de24:	701a      	strb	r2, [r3, #0]
        fwd++;
 800de26:	697b      	ldr	r3, [r7, #20]
 800de28:	3301      	adds	r3, #1
 800de2a:	617b      	str	r3, [r7, #20]
        rev--;
 800de2c:	693b      	ldr	r3, [r7, #16]
 800de2e:	3b01      	subs	r3, #1
 800de30:	613b      	str	r3, [r7, #16]
=======
 800de8a:	68fa      	ldr	r2, [r7, #12]
 800de8c:	697b      	ldr	r3, [r7, #20]
 800de8e:	4413      	add	r3, r2
 800de90:	781b      	ldrb	r3, [r3, #0]
 800de92:	72fb      	strb	r3, [r7, #11]
        bytes[fwd] = bytes[rev];
 800de94:	68fa      	ldr	r2, [r7, #12]
 800de96:	697b      	ldr	r3, [r7, #20]
 800de98:	4413      	add	r3, r2
 800de9a:	68f9      	ldr	r1, [r7, #12]
 800de9c:	693a      	ldr	r2, [r7, #16]
 800de9e:	440a      	add	r2, r1
 800dea0:	7812      	ldrb	r2, [r2, #0]
 800dea2:	701a      	strb	r2, [r3, #0]
        bytes[rev] = x;
 800dea4:	68fa      	ldr	r2, [r7, #12]
 800dea6:	693b      	ldr	r3, [r7, #16]
 800dea8:	4413      	add	r3, r2
 800deaa:	7afa      	ldrb	r2, [r7, #11]
 800deac:	701a      	strb	r2, [r3, #0]
        fwd++;
 800deae:	697b      	ldr	r3, [r7, #20]
 800deb0:	3301      	adds	r3, #1
 800deb2:	617b      	str	r3, [r7, #20]
        rev--;
 800deb4:	693b      	ldr	r3, [r7, #16]
 800deb6:	3b01      	subs	r3, #1
 800deb8:	613b      	str	r3, [r7, #16]
>>>>>>> 752c83b... update binaries
    uint8_t* const bytes = (uint8_t*) data;

    unsigned fwd = 0;
    unsigned rev = size - 1;

    while (fwd < rev)
<<<<<<< HEAD
 800de32:	697a      	ldr	r2, [r7, #20]
 800de34:	693b      	ldr	r3, [r7, #16]
 800de36:	429a      	cmp	r2, r3
 800de38:	d3e3      	bcc.n	800de02 <swapByteOrder+0x1a>
=======
 800deba:	697a      	ldr	r2, [r7, #20]
 800debc:	693b      	ldr	r3, [r7, #16]
 800debe:	429a      	cmp	r2, r3
 800dec0:	d3e3      	bcc.n	800de8a <swapByteOrder+0x1a>
>>>>>>> 752c83b... update binaries
        bytes[fwd] = bytes[rev];
        bytes[rev] = x;
        fwd++;
        rev--;
    }
}
<<<<<<< HEAD
 800de3a:	371c      	adds	r7, #28
 800de3c:	46bd      	mov	sp, r7
 800de3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de42:	4770      	bx	lr

0800de44 <crcAddByte>:
=======
 800dec2:	371c      	adds	r7, #28
 800dec4:	46bd      	mov	sp, r7
 800dec6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800deca:	4770      	bx	lr

0800decc <crcAddByte>:
>>>>>>> 752c83b... update binaries

/*
 * CRC functions
 */
CANARD_INTERNAL uint16_t crcAddByte(uint16_t crc_val, uint8_t byte)
{
<<<<<<< HEAD
 800de44:	b480      	push	{r7}
 800de46:	b085      	sub	sp, #20
 800de48:	af00      	add	r7, sp, #0
 800de4a:	4603      	mov	r3, r0
 800de4c:	460a      	mov	r2, r1
 800de4e:	80fb      	strh	r3, [r7, #6]
 800de50:	4613      	mov	r3, r2
 800de52:	717b      	strb	r3, [r7, #5]
    crc_val ^= (uint16_t) ((uint16_t) (byte) << 8);
 800de54:	797b      	ldrb	r3, [r7, #5]
 800de56:	b29b      	uxth	r3, r3
 800de58:	021b      	lsls	r3, r3, #8
 800de5a:	b29a      	uxth	r2, r3
 800de5c:	88fb      	ldrh	r3, [r7, #6]
 800de5e:	4053      	eors	r3, r2
 800de60:	80fb      	strh	r3, [r7, #6]
    for (int j = 0; j < 8; j++)
 800de62:	2300      	movs	r3, #0
 800de64:	60fb      	str	r3, [r7, #12]
 800de66:	e012      	b.n	800de8e <crcAddByte+0x4a>
    {
        if (crc_val & 0x8000U)
 800de68:	88fb      	ldrh	r3, [r7, #6]
 800de6a:	b21b      	sxth	r3, r3
 800de6c:	2b00      	cmp	r3, #0
 800de6e:	da08      	bge.n	800de82 <crcAddByte+0x3e>
        {
            crc_val = (uint16_t) ((uint16_t) (crc_val << 1) ^ 0x1021U);
 800de70:	88fb      	ldrh	r3, [r7, #6]
 800de72:	005b      	lsls	r3, r3, #1
 800de74:	b29b      	uxth	r3, r3
 800de76:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 800de7a:	f083 0301 	eor.w	r3, r3, #1
 800de7e:	80fb      	strh	r3, [r7, #6]
 800de80:	e002      	b.n	800de88 <crcAddByte+0x44>
=======
 800decc:	b480      	push	{r7}
 800dece:	b085      	sub	sp, #20
 800ded0:	af00      	add	r7, sp, #0
 800ded2:	4603      	mov	r3, r0
 800ded4:	460a      	mov	r2, r1
 800ded6:	80fb      	strh	r3, [r7, #6]
 800ded8:	4613      	mov	r3, r2
 800deda:	717b      	strb	r3, [r7, #5]
    crc_val ^= (uint16_t) ((uint16_t) (byte) << 8);
 800dedc:	797b      	ldrb	r3, [r7, #5]
 800dede:	b29b      	uxth	r3, r3
 800dee0:	021b      	lsls	r3, r3, #8
 800dee2:	b29a      	uxth	r2, r3
 800dee4:	88fb      	ldrh	r3, [r7, #6]
 800dee6:	4053      	eors	r3, r2
 800dee8:	80fb      	strh	r3, [r7, #6]
    for (int j = 0; j < 8; j++)
 800deea:	2300      	movs	r3, #0
 800deec:	60fb      	str	r3, [r7, #12]
 800deee:	e012      	b.n	800df16 <crcAddByte+0x4a>
    {
        if (crc_val & 0x8000U)
 800def0:	88fb      	ldrh	r3, [r7, #6]
 800def2:	b21b      	sxth	r3, r3
 800def4:	2b00      	cmp	r3, #0
 800def6:	da08      	bge.n	800df0a <crcAddByte+0x3e>
        {
            crc_val = (uint16_t) ((uint16_t) (crc_val << 1) ^ 0x1021U);
 800def8:	88fb      	ldrh	r3, [r7, #6]
 800defa:	005b      	lsls	r3, r3, #1
 800defc:	b29b      	uxth	r3, r3
 800defe:	f483 5381 	eor.w	r3, r3, #4128	; 0x1020
 800df02:	f083 0301 	eor.w	r3, r3, #1
 800df06:	80fb      	strh	r3, [r7, #6]
 800df08:	e002      	b.n	800df10 <crcAddByte+0x44>
>>>>>>> 752c83b... update binaries
        }
        else
        {
            crc_val = (uint16_t) (crc_val << 1);
<<<<<<< HEAD
 800de82:	88fb      	ldrh	r3, [r7, #6]
 800de84:	005b      	lsls	r3, r3, #1
 800de86:	80fb      	strh	r3, [r7, #6]
=======
 800df0a:	88fb      	ldrh	r3, [r7, #6]
 800df0c:	005b      	lsls	r3, r3, #1
 800df0e:	80fb      	strh	r3, [r7, #6]
>>>>>>> 752c83b... update binaries
 * CRC functions
 */
CANARD_INTERNAL uint16_t crcAddByte(uint16_t crc_val, uint8_t byte)
{
    crc_val ^= (uint16_t) ((uint16_t) (byte) << 8);
    for (int j = 0; j < 8; j++)
<<<<<<< HEAD
 800de88:	68fb      	ldr	r3, [r7, #12]
 800de8a:	3301      	adds	r3, #1
 800de8c:	60fb      	str	r3, [r7, #12]
 800de8e:	68fb      	ldr	r3, [r7, #12]
 800de90:	2b07      	cmp	r3, #7
 800de92:	dde9      	ble.n	800de68 <crcAddByte+0x24>
=======
 800df10:	68fb      	ldr	r3, [r7, #12]
 800df12:	3301      	adds	r3, #1
 800df14:	60fb      	str	r3, [r7, #12]
 800df16:	68fb      	ldr	r3, [r7, #12]
 800df18:	2b07      	cmp	r3, #7
 800df1a:	dde9      	ble.n	800def0 <crcAddByte+0x24>
>>>>>>> 752c83b... update binaries
        else
        {
            crc_val = (uint16_t) (crc_val << 1);
        }
    }
    return crc_val;
<<<<<<< HEAD
 800de94:	88fb      	ldrh	r3, [r7, #6]
}
 800de96:	4618      	mov	r0, r3
 800de98:	3714      	adds	r7, #20
 800de9a:	46bd      	mov	sp, r7
 800de9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dea0:	4770      	bx	lr
 800dea2:	bf00      	nop

0800dea4 <crcAddSignature>:

CANARD_INTERNAL uint16_t crcAddSignature(uint16_t crc_val, uint64_t data_type_signature)
{
 800dea4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dea6:	b087      	sub	sp, #28
 800dea8:	af00      	add	r7, sp, #0
 800deaa:	4601      	mov	r1, r0
 800deac:	e9c7 2300 	strd	r2, r3, [r7]
 800deb0:	460b      	mov	r3, r1
 800deb2:	81fb      	strh	r3, [r7, #14]
    for (int shift_val = 0; shift_val < 64; shift_val += 8)
 800deb4:	2300      	movs	r3, #0
 800deb6:	617b      	str	r3, [r7, #20]
 800deb8:	e01b      	b.n	800def2 <crcAddSignature+0x4e>
    {
        crc_val = crcAddByte(crc_val, (uint8_t) (data_type_signature >> shift_val));
 800deba:	e9d7 2300 	ldrd	r2, r3, [r7]
 800debe:	6979      	ldr	r1, [r7, #20]
 800dec0:	f1c1 0620 	rsb	r6, r1, #32
 800dec4:	f1a1 0020 	sub.w	r0, r1, #32
 800dec8:	fa22 f401 	lsr.w	r4, r2, r1
 800decc:	fa03 f606 	lsl.w	r6, r3, r6
 800ded0:	4334      	orrs	r4, r6
 800ded2:	fa23 f000 	lsr.w	r0, r3, r0
 800ded6:	4304      	orrs	r4, r0
 800ded8:	fa23 f501 	lsr.w	r5, r3, r1
 800dedc:	b2e3      	uxtb	r3, r4
 800dede:	89fa      	ldrh	r2, [r7, #14]
 800dee0:	4610      	mov	r0, r2
 800dee2:	4619      	mov	r1, r3
 800dee4:	f7ff ffae 	bl	800de44 <crcAddByte>
 800dee8:	4603      	mov	r3, r0
 800deea:	81fb      	strh	r3, [r7, #14]
=======
 800df1c:	88fb      	ldrh	r3, [r7, #6]
}
 800df1e:	4618      	mov	r0, r3
 800df20:	3714      	adds	r7, #20
 800df22:	46bd      	mov	sp, r7
 800df24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df28:	4770      	bx	lr
 800df2a:	bf00      	nop

0800df2c <crcAddSignature>:

CANARD_INTERNAL uint16_t crcAddSignature(uint16_t crc_val, uint64_t data_type_signature)
{
 800df2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800df2e:	b087      	sub	sp, #28
 800df30:	af00      	add	r7, sp, #0
 800df32:	4601      	mov	r1, r0
 800df34:	e9c7 2300 	strd	r2, r3, [r7]
 800df38:	460b      	mov	r3, r1
 800df3a:	81fb      	strh	r3, [r7, #14]
    for (int shift_val = 0; shift_val < 64; shift_val += 8)
 800df3c:	2300      	movs	r3, #0
 800df3e:	617b      	str	r3, [r7, #20]
 800df40:	e01b      	b.n	800df7a <crcAddSignature+0x4e>
    {
        crc_val = crcAddByte(crc_val, (uint8_t) (data_type_signature >> shift_val));
 800df42:	e9d7 2300 	ldrd	r2, r3, [r7]
 800df46:	6979      	ldr	r1, [r7, #20]
 800df48:	f1c1 0620 	rsb	r6, r1, #32
 800df4c:	f1a1 0020 	sub.w	r0, r1, #32
 800df50:	fa22 f401 	lsr.w	r4, r2, r1
 800df54:	fa03 f606 	lsl.w	r6, r3, r6
 800df58:	4334      	orrs	r4, r6
 800df5a:	fa23 f000 	lsr.w	r0, r3, r0
 800df5e:	4304      	orrs	r4, r0
 800df60:	fa23 f501 	lsr.w	r5, r3, r1
 800df64:	b2e3      	uxtb	r3, r4
 800df66:	89fa      	ldrh	r2, [r7, #14]
 800df68:	4610      	mov	r0, r2
 800df6a:	4619      	mov	r1, r3
 800df6c:	f7ff ffae 	bl	800decc <crcAddByte>
 800df70:	4603      	mov	r3, r0
 800df72:	81fb      	strh	r3, [r7, #14]
>>>>>>> 752c83b... update binaries
    return crc_val;
}

CANARD_INTERNAL uint16_t crcAddSignature(uint16_t crc_val, uint64_t data_type_signature)
{
    for (int shift_val = 0; shift_val < 64; shift_val += 8)
<<<<<<< HEAD
 800deec:	697b      	ldr	r3, [r7, #20]
 800deee:	3308      	adds	r3, #8
 800def0:	617b      	str	r3, [r7, #20]
 800def2:	697b      	ldr	r3, [r7, #20]
 800def4:	2b3f      	cmp	r3, #63	; 0x3f
 800def6:	dde0      	ble.n	800deba <crcAddSignature+0x16>
=======
 800df74:	697b      	ldr	r3, [r7, #20]
 800df76:	3308      	adds	r3, #8
 800df78:	617b      	str	r3, [r7, #20]
 800df7a:	697b      	ldr	r3, [r7, #20]
 800df7c:	2b3f      	cmp	r3, #63	; 0x3f
 800df7e:	dde0      	ble.n	800df42 <crcAddSignature+0x16>
>>>>>>> 752c83b... update binaries
    {
        crc_val = crcAddByte(crc_val, (uint8_t) (data_type_signature >> shift_val));
    }
    return crc_val;
<<<<<<< HEAD
 800def8:	89fb      	ldrh	r3, [r7, #14]
}
 800defa:	4618      	mov	r0, r3
 800defc:	371c      	adds	r7, #28
 800defe:	46bd      	mov	sp, r7
 800df00:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800df02:	bf00      	nop

0800df04 <crcAdd>:

CANARD_INTERNAL uint16_t crcAdd(uint16_t crc_val, const uint8_t* bytes, size_t len)
{
 800df04:	b580      	push	{r7, lr}
 800df06:	b084      	sub	sp, #16
 800df08:	af00      	add	r7, sp, #0
 800df0a:	4603      	mov	r3, r0
 800df0c:	60b9      	str	r1, [r7, #8]
 800df0e:	607a      	str	r2, [r7, #4]
 800df10:	81fb      	strh	r3, [r7, #14]
 800df12:	e00a      	b.n	800df2a <crcAdd+0x26>
    while (len--)
    {
        crc_val = crcAddByte(crc_val, *bytes++);
 800df14:	68bb      	ldr	r3, [r7, #8]
 800df16:	1c5a      	adds	r2, r3, #1
 800df18:	60ba      	str	r2, [r7, #8]
 800df1a:	781b      	ldrb	r3, [r3, #0]
 800df1c:	89fa      	ldrh	r2, [r7, #14]
 800df1e:	4610      	mov	r0, r2
 800df20:	4619      	mov	r1, r3
 800df22:	f7ff ff8f 	bl	800de44 <crcAddByte>
 800df26:	4603      	mov	r3, r0
 800df28:	81fb      	strh	r3, [r7, #14]
=======
 800df80:	89fb      	ldrh	r3, [r7, #14]
}
 800df82:	4618      	mov	r0, r3
 800df84:	371c      	adds	r7, #28
 800df86:	46bd      	mov	sp, r7
 800df88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800df8a:	bf00      	nop

0800df8c <crcAdd>:

CANARD_INTERNAL uint16_t crcAdd(uint16_t crc_val, const uint8_t* bytes, size_t len)
{
 800df8c:	b580      	push	{r7, lr}
 800df8e:	b084      	sub	sp, #16
 800df90:	af00      	add	r7, sp, #0
 800df92:	4603      	mov	r3, r0
 800df94:	60b9      	str	r1, [r7, #8]
 800df96:	607a      	str	r2, [r7, #4]
 800df98:	81fb      	strh	r3, [r7, #14]
 800df9a:	e00a      	b.n	800dfb2 <crcAdd+0x26>
    while (len--)
    {
        crc_val = crcAddByte(crc_val, *bytes++);
 800df9c:	68bb      	ldr	r3, [r7, #8]
 800df9e:	1c5a      	adds	r2, r3, #1
 800dfa0:	60ba      	str	r2, [r7, #8]
 800dfa2:	781b      	ldrb	r3, [r3, #0]
 800dfa4:	89fa      	ldrh	r2, [r7, #14]
 800dfa6:	4610      	mov	r0, r2
 800dfa8:	4619      	mov	r1, r3
 800dfaa:	f7ff ff8f 	bl	800decc <crcAddByte>
 800dfae:	4603      	mov	r3, r0
 800dfb0:	81fb      	strh	r3, [r7, #14]
>>>>>>> 752c83b... update binaries
    return crc_val;
}

CANARD_INTERNAL uint16_t crcAdd(uint16_t crc_val, const uint8_t* bytes, size_t len)
{
    while (len--)
<<<<<<< HEAD
 800df2a:	687b      	ldr	r3, [r7, #4]
 800df2c:	1e5a      	subs	r2, r3, #1
 800df2e:	607a      	str	r2, [r7, #4]
 800df30:	2b00      	cmp	r3, #0
 800df32:	d1ef      	bne.n	800df14 <crcAdd+0x10>
=======
 800dfb2:	687b      	ldr	r3, [r7, #4]
 800dfb4:	1e5a      	subs	r2, r3, #1
 800dfb6:	607a      	str	r2, [r7, #4]
 800dfb8:	2b00      	cmp	r3, #0
 800dfba:	d1ef      	bne.n	800df9c <crcAdd+0x10>
>>>>>>> 752c83b... update binaries
    {
        crc_val = crcAddByte(crc_val, *bytes++);
    }
    return crc_val;
<<<<<<< HEAD
 800df34:	89fb      	ldrh	r3, [r7, #14]
}
 800df36:	4618      	mov	r0, r3
 800df38:	3710      	adds	r7, #16
 800df3a:	46bd      	mov	sp, r7
 800df3c:	bd80      	pop	{r7, pc}
 800df3e:	bf00      	nop

0800df40 <initPoolAllocator>:
=======
 800dfbc:	89fb      	ldrh	r3, [r7, #14]
}
 800dfbe:	4618      	mov	r0, r3
 800dfc0:	3710      	adds	r7, #16
 800dfc2:	46bd      	mov	sp, r7
 800dfc4:	bd80      	pop	{r7, pc}
 800dfc6:	bf00      	nop

0800dfc8 <initPoolAllocator>:
>>>>>>> 752c83b... update binaries
 *  Pool Allocator functions
 */
CANARD_INTERNAL void initPoolAllocator(CanardPoolAllocator* allocator,
                                       CanardPoolAllocatorBlock* buf,
                                       uint16_t buf_len)
{
<<<<<<< HEAD
 800df40:	b480      	push	{r7}
 800df42:	b087      	sub	sp, #28
 800df44:	af00      	add	r7, sp, #0
 800df46:	60f8      	str	r0, [r7, #12]
 800df48:	60b9      	str	r1, [r7, #8]
 800df4a:	4613      	mov	r3, r2
 800df4c:	80fb      	strh	r3, [r7, #6]
    size_t current_index = 0;
 800df4e:	2300      	movs	r3, #0
 800df50:	617b      	str	r3, [r7, #20]
    CanardPoolAllocatorBlock** current_block = &(allocator->free_list);
 800df52:	68fb      	ldr	r3, [r7, #12]
 800df54:	613b      	str	r3, [r7, #16]
 800df56:	e00b      	b.n	800df70 <initPoolAllocator+0x30>
    while (current_index < buf_len)
    {
        *current_block = &buf[current_index];
 800df58:	697b      	ldr	r3, [r7, #20]
 800df5a:	015b      	lsls	r3, r3, #5
 800df5c:	68ba      	ldr	r2, [r7, #8]
 800df5e:	441a      	add	r2, r3
 800df60:	693b      	ldr	r3, [r7, #16]
 800df62:	601a      	str	r2, [r3, #0]
        current_block = &((*current_block)->next);
 800df64:	693b      	ldr	r3, [r7, #16]
 800df66:	681b      	ldr	r3, [r3, #0]
 800df68:	613b      	str	r3, [r7, #16]
        current_index++;
 800df6a:	697b      	ldr	r3, [r7, #20]
 800df6c:	3301      	adds	r3, #1
 800df6e:	617b      	str	r3, [r7, #20]
=======
 800dfc8:	b480      	push	{r7}
 800dfca:	b087      	sub	sp, #28
 800dfcc:	af00      	add	r7, sp, #0
 800dfce:	60f8      	str	r0, [r7, #12]
 800dfd0:	60b9      	str	r1, [r7, #8]
 800dfd2:	4613      	mov	r3, r2
 800dfd4:	80fb      	strh	r3, [r7, #6]
    size_t current_index = 0;
 800dfd6:	2300      	movs	r3, #0
 800dfd8:	617b      	str	r3, [r7, #20]
    CanardPoolAllocatorBlock** current_block = &(allocator->free_list);
 800dfda:	68fb      	ldr	r3, [r7, #12]
 800dfdc:	613b      	str	r3, [r7, #16]
 800dfde:	e00b      	b.n	800dff8 <initPoolAllocator+0x30>
    while (current_index < buf_len)
    {
        *current_block = &buf[current_index];
 800dfe0:	697b      	ldr	r3, [r7, #20]
 800dfe2:	015b      	lsls	r3, r3, #5
 800dfe4:	68ba      	ldr	r2, [r7, #8]
 800dfe6:	441a      	add	r2, r3
 800dfe8:	693b      	ldr	r3, [r7, #16]
 800dfea:	601a      	str	r2, [r3, #0]
        current_block = &((*current_block)->next);
 800dfec:	693b      	ldr	r3, [r7, #16]
 800dfee:	681b      	ldr	r3, [r3, #0]
 800dff0:	613b      	str	r3, [r7, #16]
        current_index++;
 800dff2:	697b      	ldr	r3, [r7, #20]
 800dff4:	3301      	adds	r3, #1
 800dff6:	617b      	str	r3, [r7, #20]
>>>>>>> 752c83b... update binaries
                                       CanardPoolAllocatorBlock* buf,
                                       uint16_t buf_len)
{
    size_t current_index = 0;
    CanardPoolAllocatorBlock** current_block = &(allocator->free_list);
    while (current_index < buf_len)
<<<<<<< HEAD
 800df70:	88fa      	ldrh	r2, [r7, #6]
 800df72:	697b      	ldr	r3, [r7, #20]
 800df74:	429a      	cmp	r2, r3
 800df76:	d8ef      	bhi.n	800df58 <initPoolAllocator+0x18>
=======
 800dff8:	88fa      	ldrh	r2, [r7, #6]
 800dffa:	697b      	ldr	r3, [r7, #20]
 800dffc:	429a      	cmp	r2, r3
 800dffe:	d8ef      	bhi.n	800dfe0 <initPoolAllocator+0x18>
>>>>>>> 752c83b... update binaries
    {
        *current_block = &buf[current_index];
        current_block = &((*current_block)->next);
        current_index++;
    }
    *current_block = NULL;
<<<<<<< HEAD
 800df78:	693b      	ldr	r3, [r7, #16]
 800df7a:	2200      	movs	r2, #0
 800df7c:	601a      	str	r2, [r3, #0]

    allocator->statistics.capacity_blocks = buf_len;
 800df7e:	68fb      	ldr	r3, [r7, #12]
 800df80:	88fa      	ldrh	r2, [r7, #6]
 800df82:	809a      	strh	r2, [r3, #4]
    allocator->statistics.current_usage_blocks = 0;
 800df84:	68fb      	ldr	r3, [r7, #12]
 800df86:	2200      	movs	r2, #0
 800df88:	80da      	strh	r2, [r3, #6]
    allocator->statistics.peak_usage_blocks = 0;
 800df8a:	68fb      	ldr	r3, [r7, #12]
 800df8c:	2200      	movs	r2, #0
 800df8e:	811a      	strh	r2, [r3, #8]
}
 800df90:	371c      	adds	r7, #28
 800df92:	46bd      	mov	sp, r7
 800df94:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df98:	4770      	bx	lr
 800df9a:	bf00      	nop

0800df9c <allocateBlock>:

CANARD_INTERNAL void* allocateBlock(CanardPoolAllocator* allocator)
{
 800df9c:	b480      	push	{r7}
 800df9e:	b085      	sub	sp, #20
 800dfa0:	af00      	add	r7, sp, #0
 800dfa2:	6078      	str	r0, [r7, #4]
    // Check if there are any blocks available in the free list.
    if (allocator->free_list == NULL)
 800dfa4:	687b      	ldr	r3, [r7, #4]
 800dfa6:	681b      	ldr	r3, [r3, #0]
 800dfa8:	2b00      	cmp	r3, #0
 800dfaa:	d101      	bne.n	800dfb0 <allocateBlock+0x14>
    {
        return NULL;
 800dfac:	2300      	movs	r3, #0
 800dfae:	e018      	b.n	800dfe2 <allocateBlock+0x46>
=======
 800e000:	693b      	ldr	r3, [r7, #16]
 800e002:	2200      	movs	r2, #0
 800e004:	601a      	str	r2, [r3, #0]

    allocator->statistics.capacity_blocks = buf_len;
 800e006:	68fb      	ldr	r3, [r7, #12]
 800e008:	88fa      	ldrh	r2, [r7, #6]
 800e00a:	809a      	strh	r2, [r3, #4]
    allocator->statistics.current_usage_blocks = 0;
 800e00c:	68fb      	ldr	r3, [r7, #12]
 800e00e:	2200      	movs	r2, #0
 800e010:	80da      	strh	r2, [r3, #6]
    allocator->statistics.peak_usage_blocks = 0;
 800e012:	68fb      	ldr	r3, [r7, #12]
 800e014:	2200      	movs	r2, #0
 800e016:	811a      	strh	r2, [r3, #8]
}
 800e018:	371c      	adds	r7, #28
 800e01a:	46bd      	mov	sp, r7
 800e01c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e020:	4770      	bx	lr
 800e022:	bf00      	nop

0800e024 <allocateBlock>:

CANARD_INTERNAL void* allocateBlock(CanardPoolAllocator* allocator)
{
 800e024:	b480      	push	{r7}
 800e026:	b085      	sub	sp, #20
 800e028:	af00      	add	r7, sp, #0
 800e02a:	6078      	str	r0, [r7, #4]
    // Check if there are any blocks available in the free list.
    if (allocator->free_list == NULL)
 800e02c:	687b      	ldr	r3, [r7, #4]
 800e02e:	681b      	ldr	r3, [r3, #0]
 800e030:	2b00      	cmp	r3, #0
 800e032:	d101      	bne.n	800e038 <allocateBlock+0x14>
    {
        return NULL;
 800e034:	2300      	movs	r3, #0
 800e036:	e018      	b.n	800e06a <allocateBlock+0x46>
>>>>>>> 752c83b... update binaries
    }

    // Take first available block and prepares next block for use.
    void* result = allocator->free_list;
<<<<<<< HEAD
 800dfb0:	687b      	ldr	r3, [r7, #4]
 800dfb2:	681b      	ldr	r3, [r3, #0]
 800dfb4:	60fb      	str	r3, [r7, #12]
    allocator->free_list = allocator->free_list->next;
 800dfb6:	687b      	ldr	r3, [r7, #4]
 800dfb8:	681b      	ldr	r3, [r3, #0]
 800dfba:	681a      	ldr	r2, [r3, #0]
 800dfbc:	687b      	ldr	r3, [r7, #4]
 800dfbe:	601a      	str	r2, [r3, #0]

    // Update statistics
    allocator->statistics.current_usage_blocks++;
 800dfc0:	687b      	ldr	r3, [r7, #4]
 800dfc2:	88db      	ldrh	r3, [r3, #6]
 800dfc4:	3301      	adds	r3, #1
 800dfc6:	b29a      	uxth	r2, r3
 800dfc8:	687b      	ldr	r3, [r7, #4]
 800dfca:	80da      	strh	r2, [r3, #6]
    if (allocator->statistics.peak_usage_blocks < allocator->statistics.current_usage_blocks)
 800dfcc:	687b      	ldr	r3, [r7, #4]
 800dfce:	891a      	ldrh	r2, [r3, #8]
 800dfd0:	687b      	ldr	r3, [r7, #4]
 800dfd2:	88db      	ldrh	r3, [r3, #6]
 800dfd4:	429a      	cmp	r2, r3
 800dfd6:	d203      	bcs.n	800dfe0 <allocateBlock+0x44>
    {
        allocator->statistics.peak_usage_blocks = allocator->statistics.current_usage_blocks;
 800dfd8:	687b      	ldr	r3, [r7, #4]
 800dfda:	88da      	ldrh	r2, [r3, #6]
 800dfdc:	687b      	ldr	r3, [r7, #4]
 800dfde:	811a      	strh	r2, [r3, #8]
    }

    return result;
 800dfe0:	68fb      	ldr	r3, [r7, #12]
}
 800dfe2:	4618      	mov	r0, r3
 800dfe4:	3714      	adds	r7, #20
 800dfe6:	46bd      	mov	sp, r7
 800dfe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dfec:	4770      	bx	lr
 800dfee:	bf00      	nop

0800dff0 <freeBlock>:

CANARD_INTERNAL void freeBlock(CanardPoolAllocator* allocator, void* p)
{
 800dff0:	b480      	push	{r7}
 800dff2:	b085      	sub	sp, #20
 800dff4:	af00      	add	r7, sp, #0
 800dff6:	6078      	str	r0, [r7, #4]
 800dff8:	6039      	str	r1, [r7, #0]
    CanardPoolAllocatorBlock* block = (CanardPoolAllocatorBlock*) p;
 800dffa:	683b      	ldr	r3, [r7, #0]
 800dffc:	60fb      	str	r3, [r7, #12]

    block->next = allocator->free_list;
 800dffe:	687b      	ldr	r3, [r7, #4]
 800e000:	681a      	ldr	r2, [r3, #0]
 800e002:	68fb      	ldr	r3, [r7, #12]
 800e004:	601a      	str	r2, [r3, #0]
    allocator->free_list = block;
 800e006:	687b      	ldr	r3, [r7, #4]
 800e008:	68fa      	ldr	r2, [r7, #12]
 800e00a:	601a      	str	r2, [r3, #0]

    CANARD_ASSERT(allocator->statistics.current_usage_blocks > 0);
    allocator->statistics.current_usage_blocks--;
 800e00c:	687b      	ldr	r3, [r7, #4]
 800e00e:	88db      	ldrh	r3, [r3, #6]
 800e010:	3b01      	subs	r3, #1
 800e012:	b29a      	uxth	r2, r3
 800e014:	687b      	ldr	r3, [r7, #4]
 800e016:	80da      	strh	r2, [r3, #6]
}
 800e018:	3714      	adds	r7, #20
 800e01a:	46bd      	mov	sp, r7
 800e01c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e020:	4770      	bx	lr
 800e022:	bf00      	nop

0800e024 <encode_func.lto_priv.48>:
=======
 800e038:	687b      	ldr	r3, [r7, #4]
 800e03a:	681b      	ldr	r3, [r3, #0]
 800e03c:	60fb      	str	r3, [r7, #12]
    allocator->free_list = allocator->free_list->next;
 800e03e:	687b      	ldr	r3, [r7, #4]
 800e040:	681b      	ldr	r3, [r3, #0]
 800e042:	681a      	ldr	r2, [r3, #0]
 800e044:	687b      	ldr	r3, [r7, #4]
 800e046:	601a      	str	r2, [r3, #0]

    // Update statistics
    allocator->statistics.current_usage_blocks++;
 800e048:	687b      	ldr	r3, [r7, #4]
 800e04a:	88db      	ldrh	r3, [r3, #6]
 800e04c:	3301      	adds	r3, #1
 800e04e:	b29a      	uxth	r2, r3
 800e050:	687b      	ldr	r3, [r7, #4]
 800e052:	80da      	strh	r2, [r3, #6]
    if (allocator->statistics.peak_usage_blocks < allocator->statistics.current_usage_blocks)
 800e054:	687b      	ldr	r3, [r7, #4]
 800e056:	891a      	ldrh	r2, [r3, #8]
 800e058:	687b      	ldr	r3, [r7, #4]
 800e05a:	88db      	ldrh	r3, [r3, #6]
 800e05c:	429a      	cmp	r2, r3
 800e05e:	d203      	bcs.n	800e068 <allocateBlock+0x44>
    {
        allocator->statistics.peak_usage_blocks = allocator->statistics.current_usage_blocks;
 800e060:	687b      	ldr	r3, [r7, #4]
 800e062:	88da      	ldrh	r2, [r3, #6]
 800e064:	687b      	ldr	r3, [r7, #4]
 800e066:	811a      	strh	r2, [r3, #8]
    }

    return result;
 800e068:	68fb      	ldr	r3, [r7, #12]
}
 800e06a:	4618      	mov	r0, r3
 800e06c:	3714      	adds	r7, #20
 800e06e:	46bd      	mov	sp, r7
 800e070:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e074:	4770      	bx	lr
 800e076:	bf00      	nop

0800e078 <freeBlock>:

CANARD_INTERNAL void freeBlock(CanardPoolAllocator* allocator, void* p)
{
 800e078:	b480      	push	{r7}
 800e07a:	b085      	sub	sp, #20
 800e07c:	af00      	add	r7, sp, #0
 800e07e:	6078      	str	r0, [r7, #4]
 800e080:	6039      	str	r1, [r7, #0]
    CanardPoolAllocatorBlock* block = (CanardPoolAllocatorBlock*) p;
 800e082:	683b      	ldr	r3, [r7, #0]
 800e084:	60fb      	str	r3, [r7, #12]

    block->next = allocator->free_list;
 800e086:	687b      	ldr	r3, [r7, #4]
 800e088:	681a      	ldr	r2, [r3, #0]
 800e08a:	68fb      	ldr	r3, [r7, #12]
 800e08c:	601a      	str	r2, [r3, #0]
    allocator->free_list = block;
 800e08e:	687b      	ldr	r3, [r7, #4]
 800e090:	68fa      	ldr	r2, [r7, #12]
 800e092:	601a      	str	r2, [r3, #0]

    CANARD_ASSERT(allocator->statistics.current_usage_blocks > 0);
    allocator->statistics.current_usage_blocks--;
 800e094:	687b      	ldr	r3, [r7, #4]
 800e096:	88db      	ldrh	r3, [r3, #6]
 800e098:	3b01      	subs	r3, #1
 800e09a:	b29a      	uxth	r2, r3
 800e09c:	687b      	ldr	r3, [r7, #4]
 800e09e:	80da      	strh	r2, [r3, #6]
}
 800e0a0:	3714      	adds	r7, #20
 800e0a2:	46bd      	mov	sp, r7
 800e0a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e0a8:	4770      	bx	lr
 800e0aa:	bf00      	nop

0800e0ac <encode_func.lto_priv.48>:
>>>>>>> 752c83b... update binaries
#include <uavcan.protocol.NodeStatus.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e024:	b580      	push	{r7, lr}
 800e026:	b084      	sub	sp, #16
 800e028:	af00      	add	r7, sp, #0
 800e02a:	60f8      	str	r0, [r7, #12]
 800e02c:	60b9      	str	r1, [r7, #8]
 800e02e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_NodeStatus(msg, chunk_cb, ctx);
 800e030:	68f8      	ldr	r0, [r7, #12]
 800e032:	68b9      	ldr	r1, [r7, #8]
 800e034:	687a      	ldr	r2, [r7, #4]
 800e036:	f000 f811 	bl	800e05c <encode_uavcan_protocol_NodeStatus>
}
 800e03a:	3710      	adds	r7, #16
 800e03c:	46bd      	mov	sp, r7
 800e03e:	bd80      	pop	{r7, pc}

0800e040 <decode_func.lto_priv.56>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e040:	b580      	push	{r7, lr}
 800e042:	b082      	sub	sp, #8
 800e044:	af00      	add	r7, sp, #0
 800e046:	6078      	str	r0, [r7, #4]
 800e048:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_NodeStatus(transfer, msg);
 800e04a:	6878      	ldr	r0, [r7, #4]
 800e04c:	6839      	ldr	r1, [r7, #0]
 800e04e:	f000 f819 	bl	800e084 <decode_uavcan_protocol_NodeStatus>
 800e052:	4603      	mov	r3, r0
}
 800e054:	4618      	mov	r0, r3
 800e056:	3708      	adds	r7, #8
 800e058:	46bd      	mov	sp, r7
 800e05a:	bd80      	pop	{r7, pc}

0800e05c <encode_uavcan_protocol_NodeStatus>:
=======
 800e0ac:	b580      	push	{r7, lr}
 800e0ae:	b084      	sub	sp, #16
 800e0b0:	af00      	add	r7, sp, #0
 800e0b2:	60f8      	str	r0, [r7, #12]
 800e0b4:	60b9      	str	r1, [r7, #8]
 800e0b6:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_NodeStatus(msg, chunk_cb, ctx);
 800e0b8:	68f8      	ldr	r0, [r7, #12]
 800e0ba:	68b9      	ldr	r1, [r7, #8]
 800e0bc:	687a      	ldr	r2, [r7, #4]
 800e0be:	f000 f811 	bl	800e0e4 <encode_uavcan_protocol_NodeStatus>
}
 800e0c2:	3710      	adds	r7, #16
 800e0c4:	46bd      	mov	sp, r7
 800e0c6:	bd80      	pop	{r7, pc}

0800e0c8 <decode_func.lto_priv.56>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e0c8:	b580      	push	{r7, lr}
 800e0ca:	b082      	sub	sp, #8
 800e0cc:	af00      	add	r7, sp, #0
 800e0ce:	6078      	str	r0, [r7, #4]
 800e0d0:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_NodeStatus(transfer, msg);
 800e0d2:	6878      	ldr	r0, [r7, #4]
 800e0d4:	6839      	ldr	r1, [r7, #0]
 800e0d6:	f000 f819 	bl	800e10c <decode_uavcan_protocol_NodeStatus>
 800e0da:	4603      	mov	r3, r0
}
 800e0dc:	4618      	mov	r0, r3
 800e0de:	3708      	adds	r7, #8
 800e0e0:	46bd      	mov	sp, r7
 800e0e2:	bd80      	pop	{r7, pc}

0800e0e4 <encode_uavcan_protocol_NodeStatus>:
>>>>>>> 752c83b... update binaries
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_NodeStatus(struct uavcan_protocol_NodeStatus_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e05c:	b580      	push	{r7, lr}
 800e05e:	b088      	sub	sp, #32
 800e060:	af02      	add	r7, sp, #8
 800e062:	60f8      	str	r0, [r7, #12]
 800e064:	60b9      	str	r1, [r7, #8]
 800e066:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_NodeStatus(buffer, msg, chunk_cb, ctx, true);
 800e068:	f107 0210 	add.w	r2, r7, #16
 800e06c:	2301      	movs	r3, #1
 800e06e:	9300      	str	r3, [sp, #0]
 800e070:	4610      	mov	r0, r2
 800e072:	68f9      	ldr	r1, [r7, #12]
 800e074:	68ba      	ldr	r2, [r7, #8]
 800e076:	687b      	ldr	r3, [r7, #4]
 800e078:	f000 f81a 	bl	800e0b0 <_encode_uavcan_protocol_NodeStatus>
}
 800e07c:	3718      	adds	r7, #24
 800e07e:	46bd      	mov	sp, r7
 800e080:	bd80      	pop	{r7, pc}
 800e082:	bf00      	nop

0800e084 <decode_uavcan_protocol_NodeStatus>:

uint32_t decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, struct uavcan_protocol_NodeStatus_s* msg) {
 800e084:	b580      	push	{r7, lr}
 800e086:	b084      	sub	sp, #16
 800e088:	af00      	add	r7, sp, #0
 800e08a:	6078      	str	r0, [r7, #4]
 800e08c:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e08e:	2300      	movs	r3, #0
 800e090:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_NodeStatus(transfer, &bit_ofs, msg, true);
 800e092:	f107 030c 	add.w	r3, r7, #12
 800e096:	6878      	ldr	r0, [r7, #4]
 800e098:	4619      	mov	r1, r3
 800e09a:	683a      	ldr	r2, [r7, #0]
 800e09c:	2301      	movs	r3, #1
 800e09e:	f000 f865 	bl	800e16c <_decode_uavcan_protocol_NodeStatus>
    return (bit_ofs+7)/8;
 800e0a2:	68fb      	ldr	r3, [r7, #12]
 800e0a4:	3307      	adds	r3, #7
 800e0a6:	08db      	lsrs	r3, r3, #3
}
 800e0a8:	4618      	mov	r0, r3
 800e0aa:	3710      	adds	r7, #16
 800e0ac:	46bd      	mov	sp, r7
 800e0ae:	bd80      	pop	{r7, pc}

0800e0b0 <_encode_uavcan_protocol_NodeStatus>:

void _encode_uavcan_protocol_NodeStatus(uint8_t* buffer, struct uavcan_protocol_NodeStatus_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e0b0:	b580      	push	{r7, lr}
 800e0b2:	b084      	sub	sp, #16
 800e0b4:	af00      	add	r7, sp, #0
 800e0b6:	60f8      	str	r0, [r7, #12]
 800e0b8:	60b9      	str	r1, [r7, #8]
 800e0ba:	607a      	str	r2, [r7, #4]
 800e0bc:	603b      	str	r3, [r7, #0]
=======
 800e0e4:	b580      	push	{r7, lr}
 800e0e6:	b088      	sub	sp, #32
 800e0e8:	af02      	add	r7, sp, #8
 800e0ea:	60f8      	str	r0, [r7, #12]
 800e0ec:	60b9      	str	r1, [r7, #8]
 800e0ee:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_NodeStatus(buffer, msg, chunk_cb, ctx, true);
 800e0f0:	f107 0210 	add.w	r2, r7, #16
 800e0f4:	2301      	movs	r3, #1
 800e0f6:	9300      	str	r3, [sp, #0]
 800e0f8:	4610      	mov	r0, r2
 800e0fa:	68f9      	ldr	r1, [r7, #12]
 800e0fc:	68ba      	ldr	r2, [r7, #8]
 800e0fe:	687b      	ldr	r3, [r7, #4]
 800e100:	f000 f81a 	bl	800e138 <_encode_uavcan_protocol_NodeStatus>
}
 800e104:	3718      	adds	r7, #24
 800e106:	46bd      	mov	sp, r7
 800e108:	bd80      	pop	{r7, pc}
 800e10a:	bf00      	nop

0800e10c <decode_uavcan_protocol_NodeStatus>:

uint32_t decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, struct uavcan_protocol_NodeStatus_s* msg) {
 800e10c:	b580      	push	{r7, lr}
 800e10e:	b084      	sub	sp, #16
 800e110:	af00      	add	r7, sp, #0
 800e112:	6078      	str	r0, [r7, #4]
 800e114:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e116:	2300      	movs	r3, #0
 800e118:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_NodeStatus(transfer, &bit_ofs, msg, true);
 800e11a:	f107 030c 	add.w	r3, r7, #12
 800e11e:	6878      	ldr	r0, [r7, #4]
 800e120:	4619      	mov	r1, r3
 800e122:	683a      	ldr	r2, [r7, #0]
 800e124:	2301      	movs	r3, #1
 800e126:	f000 f865 	bl	800e1f4 <_decode_uavcan_protocol_NodeStatus>
    return (bit_ofs+7)/8;
 800e12a:	68fb      	ldr	r3, [r7, #12]
 800e12c:	3307      	adds	r3, #7
 800e12e:	08db      	lsrs	r3, r3, #3
}
 800e130:	4618      	mov	r0, r3
 800e132:	3710      	adds	r7, #16
 800e134:	46bd      	mov	sp, r7
 800e136:	bd80      	pop	{r7, pc}

0800e138 <_encode_uavcan_protocol_NodeStatus>:

void _encode_uavcan_protocol_NodeStatus(uint8_t* buffer, struct uavcan_protocol_NodeStatus_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e138:	b580      	push	{r7, lr}
 800e13a:	b084      	sub	sp, #16
 800e13c:	af00      	add	r7, sp, #0
 800e13e:	60f8      	str	r0, [r7, #12]
 800e140:	60b9      	str	r1, [r7, #8]
 800e142:	607a      	str	r2, [r7, #4]
 800e144:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
<<<<<<< HEAD
 800e0be:	68f8      	ldr	r0, [r7, #12]
 800e0c0:	2100      	movs	r1, #0
 800e0c2:	2208      	movs	r2, #8
 800e0c4:	f000 fa80 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->uptime_sec);
 800e0c8:	68bb      	ldr	r3, [r7, #8]
 800e0ca:	68f8      	ldr	r0, [r7, #12]
 800e0cc:	2100      	movs	r1, #0
 800e0ce:	2220      	movs	r2, #32
 800e0d0:	f7ff fa02 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800e0d4:	687b      	ldr	r3, [r7, #4]
 800e0d6:	68f8      	ldr	r0, [r7, #12]
 800e0d8:	2120      	movs	r1, #32
 800e0da:	683a      	ldr	r2, [r7, #0]
 800e0dc:	4798      	blx	r3
    memset(buffer,0,8);
 800e0de:	68f8      	ldr	r0, [r7, #12]
 800e0e0:	2100      	movs	r1, #0
 800e0e2:	2208      	movs	r2, #8
 800e0e4:	f000 fa70 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 2, &msg->health);
 800e0e8:	68bb      	ldr	r3, [r7, #8]
 800e0ea:	3304      	adds	r3, #4
 800e0ec:	68f8      	ldr	r0, [r7, #12]
 800e0ee:	2100      	movs	r1, #0
 800e0f0:	2202      	movs	r2, #2
 800e0f2:	f7ff f9f1 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 2, ctx);
 800e0f6:	687b      	ldr	r3, [r7, #4]
 800e0f8:	68f8      	ldr	r0, [r7, #12]
 800e0fa:	2102      	movs	r1, #2
 800e0fc:	683a      	ldr	r2, [r7, #0]
 800e0fe:	4798      	blx	r3
    memset(buffer,0,8);
 800e100:	68f8      	ldr	r0, [r7, #12]
 800e102:	2100      	movs	r1, #0
 800e104:	2208      	movs	r2, #8
 800e106:	f000 fa5f 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->mode);
 800e10a:	68bb      	ldr	r3, [r7, #8]
 800e10c:	3305      	adds	r3, #5
 800e10e:	68f8      	ldr	r0, [r7, #12]
 800e110:	2100      	movs	r1, #0
 800e112:	2203      	movs	r2, #3
 800e114:	f7ff f9e0 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800e118:	687b      	ldr	r3, [r7, #4]
 800e11a:	68f8      	ldr	r0, [r7, #12]
 800e11c:	2103      	movs	r1, #3
 800e11e:	683a      	ldr	r2, [r7, #0]
 800e120:	4798      	blx	r3
    memset(buffer,0,8);
 800e122:	68f8      	ldr	r0, [r7, #12]
 800e124:	2100      	movs	r1, #0
 800e126:	2208      	movs	r2, #8
 800e128:	f000 fa4e 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->sub_mode);
 800e12c:	68bb      	ldr	r3, [r7, #8]
 800e12e:	3306      	adds	r3, #6
 800e130:	68f8      	ldr	r0, [r7, #12]
 800e132:	2100      	movs	r1, #0
 800e134:	2203      	movs	r2, #3
 800e136:	f7ff f9cf 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800e13a:	687b      	ldr	r3, [r7, #4]
 800e13c:	68f8      	ldr	r0, [r7, #12]
 800e13e:	2103      	movs	r1, #3
 800e140:	683a      	ldr	r2, [r7, #0]
 800e142:	4798      	blx	r3
    memset(buffer,0,8);
 800e144:	68f8      	ldr	r0, [r7, #12]
 800e146:	2100      	movs	r1, #0
 800e148:	2208      	movs	r2, #8
 800e14a:	f000 fa3d 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 16, &msg->vendor_specific_status_code);
 800e14e:	68bb      	ldr	r3, [r7, #8]
 800e150:	3308      	adds	r3, #8
 800e152:	68f8      	ldr	r0, [r7, #12]
 800e154:	2100      	movs	r1, #0
 800e156:	2210      	movs	r2, #16
 800e158:	f7ff f9be 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 16, ctx);
 800e15c:	687b      	ldr	r3, [r7, #4]
 800e15e:	68f8      	ldr	r0, [r7, #12]
 800e160:	2110      	movs	r1, #16
 800e162:	683a      	ldr	r2, [r7, #0]
 800e164:	4798      	blx	r3
}
 800e166:	3710      	adds	r7, #16
 800e168:	46bd      	mov	sp, r7
 800e16a:	bd80      	pop	{r7, pc}

0800e16c <_decode_uavcan_protocol_NodeStatus>:

void _decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_NodeStatus_s* msg, bool tao) {
 800e16c:	b580      	push	{r7, lr}
 800e16e:	b086      	sub	sp, #24
 800e170:	af02      	add	r7, sp, #8
 800e172:	60f8      	str	r0, [r7, #12]
 800e174:	60b9      	str	r1, [r7, #8]
 800e176:	607a      	str	r2, [r7, #4]
 800e178:	70fb      	strb	r3, [r7, #3]
=======
 800e146:	68f8      	ldr	r0, [r7, #12]
 800e148:	2100      	movs	r1, #0
 800e14a:	2208      	movs	r2, #8
 800e14c:	f000 fa80 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 32, &msg->uptime_sec);
 800e150:	68bb      	ldr	r3, [r7, #8]
 800e152:	68f8      	ldr	r0, [r7, #12]
 800e154:	2100      	movs	r1, #0
 800e156:	2220      	movs	r2, #32
 800e158:	f7ff fa02 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 32, ctx);
 800e15c:	687b      	ldr	r3, [r7, #4]
 800e15e:	68f8      	ldr	r0, [r7, #12]
 800e160:	2120      	movs	r1, #32
 800e162:	683a      	ldr	r2, [r7, #0]
 800e164:	4798      	blx	r3
    memset(buffer,0,8);
 800e166:	68f8      	ldr	r0, [r7, #12]
 800e168:	2100      	movs	r1, #0
 800e16a:	2208      	movs	r2, #8
 800e16c:	f000 fa70 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 2, &msg->health);
 800e170:	68bb      	ldr	r3, [r7, #8]
 800e172:	3304      	adds	r3, #4
 800e174:	68f8      	ldr	r0, [r7, #12]
 800e176:	2100      	movs	r1, #0
 800e178:	2202      	movs	r2, #2
 800e17a:	f7ff f9f1 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 2, ctx);
 800e17e:	687b      	ldr	r3, [r7, #4]
 800e180:	68f8      	ldr	r0, [r7, #12]
 800e182:	2102      	movs	r1, #2
 800e184:	683a      	ldr	r2, [r7, #0]
 800e186:	4798      	blx	r3
    memset(buffer,0,8);
 800e188:	68f8      	ldr	r0, [r7, #12]
 800e18a:	2100      	movs	r1, #0
 800e18c:	2208      	movs	r2, #8
 800e18e:	f000 fa5f 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->mode);
 800e192:	68bb      	ldr	r3, [r7, #8]
 800e194:	3305      	adds	r3, #5
 800e196:	68f8      	ldr	r0, [r7, #12]
 800e198:	2100      	movs	r1, #0
 800e19a:	2203      	movs	r2, #3
 800e19c:	f7ff f9e0 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800e1a0:	687b      	ldr	r3, [r7, #4]
 800e1a2:	68f8      	ldr	r0, [r7, #12]
 800e1a4:	2103      	movs	r1, #3
 800e1a6:	683a      	ldr	r2, [r7, #0]
 800e1a8:	4798      	blx	r3
    memset(buffer,0,8);
 800e1aa:	68f8      	ldr	r0, [r7, #12]
 800e1ac:	2100      	movs	r1, #0
 800e1ae:	2208      	movs	r2, #8
 800e1b0:	f000 fa4e 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 3, &msg->sub_mode);
 800e1b4:	68bb      	ldr	r3, [r7, #8]
 800e1b6:	3306      	adds	r3, #6
 800e1b8:	68f8      	ldr	r0, [r7, #12]
 800e1ba:	2100      	movs	r1, #0
 800e1bc:	2203      	movs	r2, #3
 800e1be:	f7ff f9cf 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 3, ctx);
 800e1c2:	687b      	ldr	r3, [r7, #4]
 800e1c4:	68f8      	ldr	r0, [r7, #12]
 800e1c6:	2103      	movs	r1, #3
 800e1c8:	683a      	ldr	r2, [r7, #0]
 800e1ca:	4798      	blx	r3
    memset(buffer,0,8);
 800e1cc:	68f8      	ldr	r0, [r7, #12]
 800e1ce:	2100      	movs	r1, #0
 800e1d0:	2208      	movs	r2, #8
 800e1d2:	f000 fa3d 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 16, &msg->vendor_specific_status_code);
 800e1d6:	68bb      	ldr	r3, [r7, #8]
 800e1d8:	3308      	adds	r3, #8
 800e1da:	68f8      	ldr	r0, [r7, #12]
 800e1dc:	2100      	movs	r1, #0
 800e1de:	2210      	movs	r2, #16
 800e1e0:	f7ff f9be 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 16, ctx);
 800e1e4:	687b      	ldr	r3, [r7, #4]
 800e1e6:	68f8      	ldr	r0, [r7, #12]
 800e1e8:	2110      	movs	r1, #16
 800e1ea:	683a      	ldr	r2, [r7, #0]
 800e1ec:	4798      	blx	r3
}
 800e1ee:	3710      	adds	r7, #16
 800e1f0:	46bd      	mov	sp, r7
 800e1f2:	bd80      	pop	{r7, pc}

0800e1f4 <_decode_uavcan_protocol_NodeStatus>:

void _decode_uavcan_protocol_NodeStatus(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_NodeStatus_s* msg, bool tao) {
 800e1f4:	b580      	push	{r7, lr}
 800e1f6:	b086      	sub	sp, #24
 800e1f8:	af02      	add	r7, sp, #8
 800e1fa:	60f8      	str	r0, [r7, #12]
 800e1fc:	60b9      	str	r1, [r7, #8]
 800e1fe:	607a      	str	r2, [r7, #4]
 800e200:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 32, false, &msg->uptime_sec);
<<<<<<< HEAD
 800e17a:	68bb      	ldr	r3, [r7, #8]
 800e17c:	681a      	ldr	r2, [r3, #0]
 800e17e:	687b      	ldr	r3, [r7, #4]
 800e180:	9300      	str	r3, [sp, #0]
 800e182:	68f8      	ldr	r0, [r7, #12]
 800e184:	4611      	mov	r1, r2
 800e186:	2220      	movs	r2, #32
 800e188:	2300      	movs	r3, #0
 800e18a:	f7ff f82d 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 32;
 800e18e:	68bb      	ldr	r3, [r7, #8]
 800e190:	681b      	ldr	r3, [r3, #0]
 800e192:	f103 0220 	add.w	r2, r3, #32
 800e196:	68bb      	ldr	r3, [r7, #8]
 800e198:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 2, false, &msg->health);
 800e19a:	68bb      	ldr	r3, [r7, #8]
 800e19c:	681a      	ldr	r2, [r3, #0]
 800e19e:	687b      	ldr	r3, [r7, #4]
 800e1a0:	3304      	adds	r3, #4
 800e1a2:	9300      	str	r3, [sp, #0]
 800e1a4:	68f8      	ldr	r0, [r7, #12]
 800e1a6:	4611      	mov	r1, r2
 800e1a8:	2202      	movs	r2, #2
 800e1aa:	2300      	movs	r3, #0
 800e1ac:	f7ff f81c 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 2;
 800e1b0:	68bb      	ldr	r3, [r7, #8]
 800e1b2:	681b      	ldr	r3, [r3, #0]
 800e1b4:	1c9a      	adds	r2, r3, #2
 800e1b6:	68bb      	ldr	r3, [r7, #8]
 800e1b8:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->mode);
 800e1ba:	68bb      	ldr	r3, [r7, #8]
 800e1bc:	681a      	ldr	r2, [r3, #0]
 800e1be:	687b      	ldr	r3, [r7, #4]
 800e1c0:	3305      	adds	r3, #5
 800e1c2:	9300      	str	r3, [sp, #0]
 800e1c4:	68f8      	ldr	r0, [r7, #12]
 800e1c6:	4611      	mov	r1, r2
 800e1c8:	2203      	movs	r2, #3
 800e1ca:	2300      	movs	r3, #0
 800e1cc:	f7ff f80c 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 3;
 800e1d0:	68bb      	ldr	r3, [r7, #8]
 800e1d2:	681b      	ldr	r3, [r3, #0]
 800e1d4:	1cda      	adds	r2, r3, #3
 800e1d6:	68bb      	ldr	r3, [r7, #8]
 800e1d8:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->sub_mode);
 800e1da:	68bb      	ldr	r3, [r7, #8]
 800e1dc:	681a      	ldr	r2, [r3, #0]
 800e1de:	687b      	ldr	r3, [r7, #4]
 800e1e0:	3306      	adds	r3, #6
 800e1e2:	9300      	str	r3, [sp, #0]
 800e1e4:	68f8      	ldr	r0, [r7, #12]
 800e1e6:	4611      	mov	r1, r2
 800e1e8:	2203      	movs	r2, #3
 800e1ea:	2300      	movs	r3, #0
 800e1ec:	f7fe fffc 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 3;
 800e1f0:	68bb      	ldr	r3, [r7, #8]
 800e1f2:	681b      	ldr	r3, [r3, #0]
 800e1f4:	1cda      	adds	r2, r3, #3
 800e1f6:	68bb      	ldr	r3, [r7, #8]
 800e1f8:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 16, false, &msg->vendor_specific_status_code);
 800e1fa:	68bb      	ldr	r3, [r7, #8]
 800e1fc:	681a      	ldr	r2, [r3, #0]
 800e1fe:	687b      	ldr	r3, [r7, #4]
 800e200:	3308      	adds	r3, #8
 800e202:	9300      	str	r3, [sp, #0]
 800e204:	68f8      	ldr	r0, [r7, #12]
 800e206:	4611      	mov	r1, r2
 800e208:	2210      	movs	r2, #16
 800e20a:	2300      	movs	r3, #0
 800e20c:	f7fe ffec 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 16;
 800e210:	68bb      	ldr	r3, [r7, #8]
 800e212:	681b      	ldr	r3, [r3, #0]
 800e214:	f103 0210 	add.w	r2, r3, #16
 800e218:	68bb      	ldr	r3, [r7, #8]
 800e21a:	601a      	str	r2, [r3, #0]

}
 800e21c:	3710      	adds	r7, #16
 800e21e:	46bd      	mov	sp, r7
 800e220:	bd80      	pop	{r7, pc}
 800e222:	bf00      	nop

0800e224 <encode_func.lto_priv.49>:
=======
 800e202:	68bb      	ldr	r3, [r7, #8]
 800e204:	681a      	ldr	r2, [r3, #0]
 800e206:	687b      	ldr	r3, [r7, #4]
 800e208:	9300      	str	r3, [sp, #0]
 800e20a:	68f8      	ldr	r0, [r7, #12]
 800e20c:	4611      	mov	r1, r2
 800e20e:	2220      	movs	r2, #32
 800e210:	2300      	movs	r3, #0
 800e212:	f7ff f82d 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 32;
 800e216:	68bb      	ldr	r3, [r7, #8]
 800e218:	681b      	ldr	r3, [r3, #0]
 800e21a:	f103 0220 	add.w	r2, r3, #32
 800e21e:	68bb      	ldr	r3, [r7, #8]
 800e220:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 2, false, &msg->health);
 800e222:	68bb      	ldr	r3, [r7, #8]
 800e224:	681a      	ldr	r2, [r3, #0]
 800e226:	687b      	ldr	r3, [r7, #4]
 800e228:	3304      	adds	r3, #4
 800e22a:	9300      	str	r3, [sp, #0]
 800e22c:	68f8      	ldr	r0, [r7, #12]
 800e22e:	4611      	mov	r1, r2
 800e230:	2202      	movs	r2, #2
 800e232:	2300      	movs	r3, #0
 800e234:	f7ff f81c 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 2;
 800e238:	68bb      	ldr	r3, [r7, #8]
 800e23a:	681b      	ldr	r3, [r3, #0]
 800e23c:	1c9a      	adds	r2, r3, #2
 800e23e:	68bb      	ldr	r3, [r7, #8]
 800e240:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->mode);
 800e242:	68bb      	ldr	r3, [r7, #8]
 800e244:	681a      	ldr	r2, [r3, #0]
 800e246:	687b      	ldr	r3, [r7, #4]
 800e248:	3305      	adds	r3, #5
 800e24a:	9300      	str	r3, [sp, #0]
 800e24c:	68f8      	ldr	r0, [r7, #12]
 800e24e:	4611      	mov	r1, r2
 800e250:	2203      	movs	r2, #3
 800e252:	2300      	movs	r3, #0
 800e254:	f7ff f80c 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 3;
 800e258:	68bb      	ldr	r3, [r7, #8]
 800e25a:	681b      	ldr	r3, [r3, #0]
 800e25c:	1cda      	adds	r2, r3, #3
 800e25e:	68bb      	ldr	r3, [r7, #8]
 800e260:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 3, false, &msg->sub_mode);
 800e262:	68bb      	ldr	r3, [r7, #8]
 800e264:	681a      	ldr	r2, [r3, #0]
 800e266:	687b      	ldr	r3, [r7, #4]
 800e268:	3306      	adds	r3, #6
 800e26a:	9300      	str	r3, [sp, #0]
 800e26c:	68f8      	ldr	r0, [r7, #12]
 800e26e:	4611      	mov	r1, r2
 800e270:	2203      	movs	r2, #3
 800e272:	2300      	movs	r3, #0
 800e274:	f7fe fffc 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 3;
 800e278:	68bb      	ldr	r3, [r7, #8]
 800e27a:	681b      	ldr	r3, [r3, #0]
 800e27c:	1cda      	adds	r2, r3, #3
 800e27e:	68bb      	ldr	r3, [r7, #8]
 800e280:	601a      	str	r2, [r3, #0]

    canardDecodeScalar(transfer, *bit_ofs, 16, false, &msg->vendor_specific_status_code);
 800e282:	68bb      	ldr	r3, [r7, #8]
 800e284:	681a      	ldr	r2, [r3, #0]
 800e286:	687b      	ldr	r3, [r7, #4]
 800e288:	3308      	adds	r3, #8
 800e28a:	9300      	str	r3, [sp, #0]
 800e28c:	68f8      	ldr	r0, [r7, #12]
 800e28e:	4611      	mov	r1, r2
 800e290:	2210      	movs	r2, #16
 800e292:	2300      	movs	r3, #0
 800e294:	f7fe ffec 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 16;
 800e298:	68bb      	ldr	r3, [r7, #8]
 800e29a:	681b      	ldr	r3, [r3, #0]
 800e29c:	f103 0210 	add.w	r2, r3, #16
 800e2a0:	68bb      	ldr	r3, [r7, #8]
 800e2a2:	601a      	str	r2, [r3, #0]

}
 800e2a4:	3710      	adds	r7, #16
 800e2a6:	46bd      	mov	sp, r7
 800e2a8:	bd80      	pop	{r7, pc}
 800e2aa:	bf00      	nop

0800e2ac <encode_func.lto_priv.49>:
>>>>>>> 752c83b... update binaries
#include <uavcan.protocol.RestartNode_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e224:	b580      	push	{r7, lr}
 800e226:	b084      	sub	sp, #16
 800e228:	af00      	add	r7, sp, #0
 800e22a:	60f8      	str	r0, [r7, #12]
 800e22c:	60b9      	str	r1, [r7, #8]
 800e22e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_res(msg, chunk_cb, ctx);
 800e230:	68f8      	ldr	r0, [r7, #12]
 800e232:	68b9      	ldr	r1, [r7, #8]
 800e234:	687a      	ldr	r2, [r7, #4]
 800e236:	f000 f811 	bl	800e25c <encode_uavcan_protocol_RestartNode_res>
}
 800e23a:	3710      	adds	r7, #16
 800e23c:	46bd      	mov	sp, r7
 800e23e:	bd80      	pop	{r7, pc}

0800e240 <decode_func.lto_priv.57>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e240:	b580      	push	{r7, lr}
 800e242:	b082      	sub	sp, #8
 800e244:	af00      	add	r7, sp, #0
 800e246:	6078      	str	r0, [r7, #4]
 800e248:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_res(transfer, msg);
 800e24a:	6878      	ldr	r0, [r7, #4]
 800e24c:	6839      	ldr	r1, [r7, #0]
 800e24e:	f000 f819 	bl	800e284 <decode_uavcan_protocol_RestartNode_res>
 800e252:	4603      	mov	r3, r0
}
 800e254:	4618      	mov	r0, r3
 800e256:	3708      	adds	r7, #8
 800e258:	46bd      	mov	sp, r7
 800e25a:	bd80      	pop	{r7, pc}

0800e25c <encode_uavcan_protocol_RestartNode_res>:
=======
 800e2ac:	b580      	push	{r7, lr}
 800e2ae:	b084      	sub	sp, #16
 800e2b0:	af00      	add	r7, sp, #0
 800e2b2:	60f8      	str	r0, [r7, #12]
 800e2b4:	60b9      	str	r1, [r7, #8]
 800e2b6:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_res(msg, chunk_cb, ctx);
 800e2b8:	68f8      	ldr	r0, [r7, #12]
 800e2ba:	68b9      	ldr	r1, [r7, #8]
 800e2bc:	687a      	ldr	r2, [r7, #4]
 800e2be:	f000 f811 	bl	800e2e4 <encode_uavcan_protocol_RestartNode_res>
}
 800e2c2:	3710      	adds	r7, #16
 800e2c4:	46bd      	mov	sp, r7
 800e2c6:	bd80      	pop	{r7, pc}

0800e2c8 <decode_func.lto_priv.57>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e2c8:	b580      	push	{r7, lr}
 800e2ca:	b082      	sub	sp, #8
 800e2cc:	af00      	add	r7, sp, #0
 800e2ce:	6078      	str	r0, [r7, #4]
 800e2d0:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_res(transfer, msg);
 800e2d2:	6878      	ldr	r0, [r7, #4]
 800e2d4:	6839      	ldr	r1, [r7, #0]
 800e2d6:	f000 f819 	bl	800e30c <decode_uavcan_protocol_RestartNode_res>
 800e2da:	4603      	mov	r3, r0
}
 800e2dc:	4618      	mov	r0, r3
 800e2de:	3708      	adds	r7, #8
 800e2e0:	46bd      	mov	sp, r7
 800e2e2:	bd80      	pop	{r7, pc}

0800e2e4 <encode_uavcan_protocol_RestartNode_res>:
>>>>>>> 752c83b... update binaries
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_RestartNode_res(struct uavcan_protocol_RestartNode_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e25c:	b580      	push	{r7, lr}
 800e25e:	b088      	sub	sp, #32
 800e260:	af02      	add	r7, sp, #8
 800e262:	60f8      	str	r0, [r7, #12]
 800e264:	60b9      	str	r1, [r7, #8]
 800e266:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_res(buffer, msg, chunk_cb, ctx, true);
 800e268:	f107 0210 	add.w	r2, r7, #16
 800e26c:	2301      	movs	r3, #1
 800e26e:	9300      	str	r3, [sp, #0]
 800e270:	4610      	mov	r0, r2
 800e272:	68f9      	ldr	r1, [r7, #12]
 800e274:	68ba      	ldr	r2, [r7, #8]
 800e276:	687b      	ldr	r3, [r7, #4]
 800e278:	f000 f81a 	bl	800e2b0 <_encode_uavcan_protocol_RestartNode_res>
}
 800e27c:	3718      	adds	r7, #24
 800e27e:	46bd      	mov	sp, r7
 800e280:	bd80      	pop	{r7, pc}
 800e282:	bf00      	nop

0800e284 <decode_uavcan_protocol_RestartNode_res>:

uint32_t decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_res_s* msg) {
 800e284:	b580      	push	{r7, lr}
 800e286:	b084      	sub	sp, #16
 800e288:	af00      	add	r7, sp, #0
 800e28a:	6078      	str	r0, [r7, #4]
 800e28c:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e28e:	2300      	movs	r3, #0
 800e290:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_res(transfer, &bit_ofs, msg, true);
 800e292:	f107 030c 	add.w	r3, r7, #12
 800e296:	6878      	ldr	r0, [r7, #4]
 800e298:	4619      	mov	r1, r3
 800e29a:	683a      	ldr	r2, [r7, #0]
 800e29c:	2301      	movs	r3, #1
 800e29e:	f000 f821 	bl	800e2e4 <_decode_uavcan_protocol_RestartNode_res>
    return (bit_ofs+7)/8;
 800e2a2:	68fb      	ldr	r3, [r7, #12]
 800e2a4:	3307      	adds	r3, #7
 800e2a6:	08db      	lsrs	r3, r3, #3
}
 800e2a8:	4618      	mov	r0, r3
 800e2aa:	3710      	adds	r7, #16
 800e2ac:	46bd      	mov	sp, r7
 800e2ae:	bd80      	pop	{r7, pc}

0800e2b0 <_encode_uavcan_protocol_RestartNode_res>:

void _encode_uavcan_protocol_RestartNode_res(uint8_t* buffer, struct uavcan_protocol_RestartNode_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e2b0:	b580      	push	{r7, lr}
 800e2b2:	b084      	sub	sp, #16
 800e2b4:	af00      	add	r7, sp, #0
 800e2b6:	60f8      	str	r0, [r7, #12]
 800e2b8:	60b9      	str	r1, [r7, #8]
 800e2ba:	607a      	str	r2, [r7, #4]
 800e2bc:	603b      	str	r3, [r7, #0]
=======
 800e2e4:	b580      	push	{r7, lr}
 800e2e6:	b088      	sub	sp, #32
 800e2e8:	af02      	add	r7, sp, #8
 800e2ea:	60f8      	str	r0, [r7, #12]
 800e2ec:	60b9      	str	r1, [r7, #8]
 800e2ee:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_res(buffer, msg, chunk_cb, ctx, true);
 800e2f0:	f107 0210 	add.w	r2, r7, #16
 800e2f4:	2301      	movs	r3, #1
 800e2f6:	9300      	str	r3, [sp, #0]
 800e2f8:	4610      	mov	r0, r2
 800e2fa:	68f9      	ldr	r1, [r7, #12]
 800e2fc:	68ba      	ldr	r2, [r7, #8]
 800e2fe:	687b      	ldr	r3, [r7, #4]
 800e300:	f000 f81a 	bl	800e338 <_encode_uavcan_protocol_RestartNode_res>
}
 800e304:	3718      	adds	r7, #24
 800e306:	46bd      	mov	sp, r7
 800e308:	bd80      	pop	{r7, pc}
 800e30a:	bf00      	nop

0800e30c <decode_uavcan_protocol_RestartNode_res>:

uint32_t decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_res_s* msg) {
 800e30c:	b580      	push	{r7, lr}
 800e30e:	b084      	sub	sp, #16
 800e310:	af00      	add	r7, sp, #0
 800e312:	6078      	str	r0, [r7, #4]
 800e314:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e316:	2300      	movs	r3, #0
 800e318:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_res(transfer, &bit_ofs, msg, true);
 800e31a:	f107 030c 	add.w	r3, r7, #12
 800e31e:	6878      	ldr	r0, [r7, #4]
 800e320:	4619      	mov	r1, r3
 800e322:	683a      	ldr	r2, [r7, #0]
 800e324:	2301      	movs	r3, #1
 800e326:	f000 f821 	bl	800e36c <_decode_uavcan_protocol_RestartNode_res>
    return (bit_ofs+7)/8;
 800e32a:	68fb      	ldr	r3, [r7, #12]
 800e32c:	3307      	adds	r3, #7
 800e32e:	08db      	lsrs	r3, r3, #3
}
 800e330:	4618      	mov	r0, r3
 800e332:	3710      	adds	r7, #16
 800e334:	46bd      	mov	sp, r7
 800e336:	bd80      	pop	{r7, pc}

0800e338 <_encode_uavcan_protocol_RestartNode_res>:

void _encode_uavcan_protocol_RestartNode_res(uint8_t* buffer, struct uavcan_protocol_RestartNode_res_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e338:	b580      	push	{r7, lr}
 800e33a:	b084      	sub	sp, #16
 800e33c:	af00      	add	r7, sp, #0
 800e33e:	60f8      	str	r0, [r7, #12]
 800e340:	60b9      	str	r1, [r7, #8]
 800e342:	607a      	str	r2, [r7, #4]
 800e344:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
<<<<<<< HEAD
 800e2be:	68f8      	ldr	r0, [r7, #12]
 800e2c0:	2100      	movs	r1, #0
 800e2c2:	2208      	movs	r2, #8
 800e2c4:	f000 f980 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->ok);
 800e2c8:	68bb      	ldr	r3, [r7, #8]
 800e2ca:	68f8      	ldr	r0, [r7, #12]
 800e2cc:	2100      	movs	r1, #0
 800e2ce:	2201      	movs	r2, #1
 800e2d0:	f7ff f902 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800e2d4:	687b      	ldr	r3, [r7, #4]
 800e2d6:	68f8      	ldr	r0, [r7, #12]
 800e2d8:	2101      	movs	r1, #1
 800e2da:	683a      	ldr	r2, [r7, #0]
 800e2dc:	4798      	blx	r3
}
 800e2de:	3710      	adds	r7, #16
 800e2e0:	46bd      	mov	sp, r7
 800e2e2:	bd80      	pop	{r7, pc}

0800e2e4 <_decode_uavcan_protocol_RestartNode_res>:

void _decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_res_s* msg, bool tao) {
 800e2e4:	b580      	push	{r7, lr}
 800e2e6:	b086      	sub	sp, #24
 800e2e8:	af02      	add	r7, sp, #8
 800e2ea:	60f8      	str	r0, [r7, #12]
 800e2ec:	60b9      	str	r1, [r7, #8]
 800e2ee:	607a      	str	r2, [r7, #4]
 800e2f0:	70fb      	strb	r3, [r7, #3]
=======
 800e346:	68f8      	ldr	r0, [r7, #12]
 800e348:	2100      	movs	r1, #0
 800e34a:	2208      	movs	r2, #8
 800e34c:	f000 f980 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->ok);
 800e350:	68bb      	ldr	r3, [r7, #8]
 800e352:	68f8      	ldr	r0, [r7, #12]
 800e354:	2100      	movs	r1, #0
 800e356:	2201      	movs	r2, #1
 800e358:	f7ff f902 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800e35c:	687b      	ldr	r3, [r7, #4]
 800e35e:	68f8      	ldr	r0, [r7, #12]
 800e360:	2101      	movs	r1, #1
 800e362:	683a      	ldr	r2, [r7, #0]
 800e364:	4798      	blx	r3
}
 800e366:	3710      	adds	r7, #16
 800e368:	46bd      	mov	sp, r7
 800e36a:	bd80      	pop	{r7, pc}

0800e36c <_decode_uavcan_protocol_RestartNode_res>:

void _decode_uavcan_protocol_RestartNode_res(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_res_s* msg, bool tao) {
 800e36c:	b580      	push	{r7, lr}
 800e36e:	b086      	sub	sp, #24
 800e370:	af02      	add	r7, sp, #8
 800e372:	60f8      	str	r0, [r7, #12]
 800e374:	60b9      	str	r1, [r7, #8]
 800e376:	607a      	str	r2, [r7, #4]
 800e378:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 1, false, &msg->ok);
<<<<<<< HEAD
 800e2f2:	68bb      	ldr	r3, [r7, #8]
 800e2f4:	681a      	ldr	r2, [r3, #0]
 800e2f6:	687b      	ldr	r3, [r7, #4]
 800e2f8:	9300      	str	r3, [sp, #0]
 800e2fa:	68f8      	ldr	r0, [r7, #12]
 800e2fc:	4611      	mov	r1, r2
 800e2fe:	2201      	movs	r2, #1
 800e300:	2300      	movs	r3, #0
 800e302:	f7fe ff71 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 1;
 800e306:	68bb      	ldr	r3, [r7, #8]
 800e308:	681b      	ldr	r3, [r3, #0]
 800e30a:	1c5a      	adds	r2, r3, #1
 800e30c:	68bb      	ldr	r3, [r7, #8]
 800e30e:	601a      	str	r2, [r3, #0]

}
 800e310:	3710      	adds	r7, #16
 800e312:	46bd      	mov	sp, r7
 800e314:	bd80      	pop	{r7, pc}
 800e316:	bf00      	nop

0800e318 <encode_func.lto_priv.50>:
=======
 800e37a:	68bb      	ldr	r3, [r7, #8]
 800e37c:	681a      	ldr	r2, [r3, #0]
 800e37e:	687b      	ldr	r3, [r7, #4]
 800e380:	9300      	str	r3, [sp, #0]
 800e382:	68f8      	ldr	r0, [r7, #12]
 800e384:	4611      	mov	r1, r2
 800e386:	2201      	movs	r2, #1
 800e388:	2300      	movs	r3, #0
 800e38a:	f7fe ff71 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 1;
 800e38e:	68bb      	ldr	r3, [r7, #8]
 800e390:	681b      	ldr	r3, [r3, #0]
 800e392:	1c5a      	adds	r2, r3, #1
 800e394:	68bb      	ldr	r3, [r7, #8]
 800e396:	601a      	str	r2, [r3, #0]

}
 800e398:	3710      	adds	r7, #16
 800e39a:	46bd      	mov	sp, r7
 800e39c:	bd80      	pop	{r7, pc}
 800e39e:	bf00      	nop

0800e3a0 <encode_func.lto_priv.50>:
>>>>>>> 752c83b... update binaries
#include <uavcan.protocol.RestartNode_req.h>
#include <uavcan.protocol.RestartNode_res.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e318:	b580      	push	{r7, lr}
 800e31a:	b084      	sub	sp, #16
 800e31c:	af00      	add	r7, sp, #0
 800e31e:	60f8      	str	r0, [r7, #12]
 800e320:	60b9      	str	r1, [r7, #8]
 800e322:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_req(msg, chunk_cb, ctx);
 800e324:	68f8      	ldr	r0, [r7, #12]
 800e326:	68b9      	ldr	r1, [r7, #8]
 800e328:	687a      	ldr	r2, [r7, #4]
 800e32a:	f000 f811 	bl	800e350 <encode_uavcan_protocol_RestartNode_req>
}
 800e32e:	3710      	adds	r7, #16
 800e330:	46bd      	mov	sp, r7
 800e332:	bd80      	pop	{r7, pc}

0800e334 <decode_func.lto_priv.58>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e334:	b580      	push	{r7, lr}
 800e336:	b082      	sub	sp, #8
 800e338:	af00      	add	r7, sp, #0
 800e33a:	6078      	str	r0, [r7, #4]
 800e33c:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_req(transfer, msg);
 800e33e:	6878      	ldr	r0, [r7, #4]
 800e340:	6839      	ldr	r1, [r7, #0]
 800e342:	f000 f819 	bl	800e378 <decode_uavcan_protocol_RestartNode_req>
 800e346:	4603      	mov	r3, r0
}
 800e348:	4618      	mov	r0, r3
 800e34a:	3708      	adds	r7, #8
 800e34c:	46bd      	mov	sp, r7
 800e34e:	bd80      	pop	{r7, pc}

0800e350 <encode_uavcan_protocol_RestartNode_req>:
=======
 800e3a0:	b580      	push	{r7, lr}
 800e3a2:	b084      	sub	sp, #16
 800e3a4:	af00      	add	r7, sp, #0
 800e3a6:	60f8      	str	r0, [r7, #12]
 800e3a8:	60b9      	str	r1, [r7, #8]
 800e3aa:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_RestartNode_req(msg, chunk_cb, ctx);
 800e3ac:	68f8      	ldr	r0, [r7, #12]
 800e3ae:	68b9      	ldr	r1, [r7, #8]
 800e3b0:	687a      	ldr	r2, [r7, #4]
 800e3b2:	f000 f811 	bl	800e3d8 <encode_uavcan_protocol_RestartNode_req>
}
 800e3b6:	3710      	adds	r7, #16
 800e3b8:	46bd      	mov	sp, r7
 800e3ba:	bd80      	pop	{r7, pc}

0800e3bc <decode_func.lto_priv.58>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e3bc:	b580      	push	{r7, lr}
 800e3be:	b082      	sub	sp, #8
 800e3c0:	af00      	add	r7, sp, #0
 800e3c2:	6078      	str	r0, [r7, #4]
 800e3c4:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_RestartNode_req(transfer, msg);
 800e3c6:	6878      	ldr	r0, [r7, #4]
 800e3c8:	6839      	ldr	r1, [r7, #0]
 800e3ca:	f000 f819 	bl	800e400 <decode_uavcan_protocol_RestartNode_req>
 800e3ce:	4603      	mov	r3, r0
}
 800e3d0:	4618      	mov	r0, r3
 800e3d2:	3708      	adds	r7, #8
 800e3d4:	46bd      	mov	sp, r7
 800e3d6:	bd80      	pop	{r7, pc}

0800e3d8 <encode_uavcan_protocol_RestartNode_req>:
>>>>>>> 752c83b... update binaries
    encode_func,
    decode_func,
    &uavcan_protocol_RestartNode_res_descriptor
};

void encode_uavcan_protocol_RestartNode_req(struct uavcan_protocol_RestartNode_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e350:	b580      	push	{r7, lr}
 800e352:	b088      	sub	sp, #32
 800e354:	af02      	add	r7, sp, #8
 800e356:	60f8      	str	r0, [r7, #12]
 800e358:	60b9      	str	r1, [r7, #8]
 800e35a:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_req(buffer, msg, chunk_cb, ctx, true);
 800e35c:	f107 0210 	add.w	r2, r7, #16
 800e360:	2301      	movs	r3, #1
 800e362:	9300      	str	r3, [sp, #0]
 800e364:	4610      	mov	r0, r2
 800e366:	68f9      	ldr	r1, [r7, #12]
 800e368:	68ba      	ldr	r2, [r7, #8]
 800e36a:	687b      	ldr	r3, [r7, #4]
 800e36c:	f000 f81a 	bl	800e3a4 <_encode_uavcan_protocol_RestartNode_req>
}
 800e370:	3718      	adds	r7, #24
 800e372:	46bd      	mov	sp, r7
 800e374:	bd80      	pop	{r7, pc}
 800e376:	bf00      	nop

0800e378 <decode_uavcan_protocol_RestartNode_req>:

uint32_t decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_req_s* msg) {
 800e378:	b580      	push	{r7, lr}
 800e37a:	b084      	sub	sp, #16
 800e37c:	af00      	add	r7, sp, #0
 800e37e:	6078      	str	r0, [r7, #4]
 800e380:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e382:	2300      	movs	r3, #0
 800e384:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_req(transfer, &bit_ofs, msg, true);
 800e386:	f107 030c 	add.w	r3, r7, #12
 800e38a:	6878      	ldr	r0, [r7, #4]
 800e38c:	4619      	mov	r1, r3
 800e38e:	683a      	ldr	r2, [r7, #0]
 800e390:	2301      	movs	r3, #1
 800e392:	f000 f821 	bl	800e3d8 <_decode_uavcan_protocol_RestartNode_req>
    return (bit_ofs+7)/8;
 800e396:	68fb      	ldr	r3, [r7, #12]
 800e398:	3307      	adds	r3, #7
 800e39a:	08db      	lsrs	r3, r3, #3
}
 800e39c:	4618      	mov	r0, r3
 800e39e:	3710      	adds	r7, #16
 800e3a0:	46bd      	mov	sp, r7
 800e3a2:	bd80      	pop	{r7, pc}

0800e3a4 <_encode_uavcan_protocol_RestartNode_req>:

void _encode_uavcan_protocol_RestartNode_req(uint8_t* buffer, struct uavcan_protocol_RestartNode_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e3a4:	b580      	push	{r7, lr}
 800e3a6:	b084      	sub	sp, #16
 800e3a8:	af00      	add	r7, sp, #0
 800e3aa:	60f8      	str	r0, [r7, #12]
 800e3ac:	60b9      	str	r1, [r7, #8]
 800e3ae:	607a      	str	r2, [r7, #4]
 800e3b0:	603b      	str	r3, [r7, #0]
=======
 800e3d8:	b580      	push	{r7, lr}
 800e3da:	b088      	sub	sp, #32
 800e3dc:	af02      	add	r7, sp, #8
 800e3de:	60f8      	str	r0, [r7, #12]
 800e3e0:	60b9      	str	r1, [r7, #8]
 800e3e2:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_RestartNode_req(buffer, msg, chunk_cb, ctx, true);
 800e3e4:	f107 0210 	add.w	r2, r7, #16
 800e3e8:	2301      	movs	r3, #1
 800e3ea:	9300      	str	r3, [sp, #0]
 800e3ec:	4610      	mov	r0, r2
 800e3ee:	68f9      	ldr	r1, [r7, #12]
 800e3f0:	68ba      	ldr	r2, [r7, #8]
 800e3f2:	687b      	ldr	r3, [r7, #4]
 800e3f4:	f000 f81a 	bl	800e42c <_encode_uavcan_protocol_RestartNode_req>
}
 800e3f8:	3718      	adds	r7, #24
 800e3fa:	46bd      	mov	sp, r7
 800e3fc:	bd80      	pop	{r7, pc}
 800e3fe:	bf00      	nop

0800e400 <decode_uavcan_protocol_RestartNode_req>:

uint32_t decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, struct uavcan_protocol_RestartNode_req_s* msg) {
 800e400:	b580      	push	{r7, lr}
 800e402:	b084      	sub	sp, #16
 800e404:	af00      	add	r7, sp, #0
 800e406:	6078      	str	r0, [r7, #4]
 800e408:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e40a:	2300      	movs	r3, #0
 800e40c:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_RestartNode_req(transfer, &bit_ofs, msg, true);
 800e40e:	f107 030c 	add.w	r3, r7, #12
 800e412:	6878      	ldr	r0, [r7, #4]
 800e414:	4619      	mov	r1, r3
 800e416:	683a      	ldr	r2, [r7, #0]
 800e418:	2301      	movs	r3, #1
 800e41a:	f000 f821 	bl	800e460 <_decode_uavcan_protocol_RestartNode_req>
    return (bit_ofs+7)/8;
 800e41e:	68fb      	ldr	r3, [r7, #12]
 800e420:	3307      	adds	r3, #7
 800e422:	08db      	lsrs	r3, r3, #3
}
 800e424:	4618      	mov	r0, r3
 800e426:	3710      	adds	r7, #16
 800e428:	46bd      	mov	sp, r7
 800e42a:	bd80      	pop	{r7, pc}

0800e42c <_encode_uavcan_protocol_RestartNode_req>:

void _encode_uavcan_protocol_RestartNode_req(uint8_t* buffer, struct uavcan_protocol_RestartNode_req_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e42c:	b580      	push	{r7, lr}
 800e42e:	b084      	sub	sp, #16
 800e430:	af00      	add	r7, sp, #0
 800e432:	60f8      	str	r0, [r7, #12]
 800e434:	60b9      	str	r1, [r7, #8]
 800e436:	607a      	str	r2, [r7, #4]
 800e438:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
<<<<<<< HEAD
 800e3b2:	68f8      	ldr	r0, [r7, #12]
 800e3b4:	2100      	movs	r1, #0
 800e3b6:	2208      	movs	r2, #8
 800e3b8:	f000 f906 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 40, &msg->magic_number);
 800e3bc:	68bb      	ldr	r3, [r7, #8]
 800e3be:	68f8      	ldr	r0, [r7, #12]
 800e3c0:	2100      	movs	r1, #0
 800e3c2:	2228      	movs	r2, #40	; 0x28
 800e3c4:	f7ff f888 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 40, ctx);
 800e3c8:	687b      	ldr	r3, [r7, #4]
 800e3ca:	68f8      	ldr	r0, [r7, #12]
 800e3cc:	2128      	movs	r1, #40	; 0x28
 800e3ce:	683a      	ldr	r2, [r7, #0]
 800e3d0:	4798      	blx	r3
}
 800e3d2:	3710      	adds	r7, #16
 800e3d4:	46bd      	mov	sp, r7
 800e3d6:	bd80      	pop	{r7, pc}

0800e3d8 <_decode_uavcan_protocol_RestartNode_req>:

void _decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_req_s* msg, bool tao) {
 800e3d8:	b580      	push	{r7, lr}
 800e3da:	b086      	sub	sp, #24
 800e3dc:	af02      	add	r7, sp, #8
 800e3de:	60f8      	str	r0, [r7, #12]
 800e3e0:	60b9      	str	r1, [r7, #8]
 800e3e2:	607a      	str	r2, [r7, #4]
 800e3e4:	70fb      	strb	r3, [r7, #3]
=======
 800e43a:	68f8      	ldr	r0, [r7, #12]
 800e43c:	2100      	movs	r1, #0
 800e43e:	2208      	movs	r2, #8
 800e440:	f000 f906 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 40, &msg->magic_number);
 800e444:	68bb      	ldr	r3, [r7, #8]
 800e446:	68f8      	ldr	r0, [r7, #12]
 800e448:	2100      	movs	r1, #0
 800e44a:	2228      	movs	r2, #40	; 0x28
 800e44c:	f7ff f888 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 40, ctx);
 800e450:	687b      	ldr	r3, [r7, #4]
 800e452:	68f8      	ldr	r0, [r7, #12]
 800e454:	2128      	movs	r1, #40	; 0x28
 800e456:	683a      	ldr	r2, [r7, #0]
 800e458:	4798      	blx	r3
}
 800e45a:	3710      	adds	r7, #16
 800e45c:	46bd      	mov	sp, r7
 800e45e:	bd80      	pop	{r7, pc}

0800e460 <_decode_uavcan_protocol_RestartNode_req>:

void _decode_uavcan_protocol_RestartNode_req(const CanardRxTransfer* transfer, uint32_t* bit_ofs, struct uavcan_protocol_RestartNode_req_s* msg, bool tao) {
 800e460:	b580      	push	{r7, lr}
 800e462:	b086      	sub	sp, #24
 800e464:	af02      	add	r7, sp, #8
 800e466:	60f8      	str	r0, [r7, #12]
 800e468:	60b9      	str	r1, [r7, #8]
 800e46a:	607a      	str	r2, [r7, #4]
 800e46c:	70fb      	strb	r3, [r7, #3]
>>>>>>> 752c83b... update binaries
    (void)transfer;
    (void)bit_ofs;
    (void)msg;
    (void)tao;

    canardDecodeScalar(transfer, *bit_ofs, 40, false, &msg->magic_number);
<<<<<<< HEAD
 800e3e6:	68bb      	ldr	r3, [r7, #8]
 800e3e8:	681a      	ldr	r2, [r3, #0]
 800e3ea:	687b      	ldr	r3, [r7, #4]
 800e3ec:	9300      	str	r3, [sp, #0]
 800e3ee:	68f8      	ldr	r0, [r7, #12]
 800e3f0:	4611      	mov	r1, r2
 800e3f2:	2228      	movs	r2, #40	; 0x28
 800e3f4:	2300      	movs	r3, #0
 800e3f6:	f7fe fef7 	bl	800d1e8 <canardDecodeScalar>
    *bit_ofs += 40;
 800e3fa:	68bb      	ldr	r3, [r7, #8]
 800e3fc:	681b      	ldr	r3, [r3, #0]
 800e3fe:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800e402:	68bb      	ldr	r3, [r7, #8]
 800e404:	601a      	str	r2, [r3, #0]

}
 800e406:	3710      	adds	r7, #16
 800e408:	46bd      	mov	sp, r7
 800e40a:	bd80      	pop	{r7, pc}

0800e40c <encode_func.lto_priv.51>:
=======
 800e46e:	68bb      	ldr	r3, [r7, #8]
 800e470:	681a      	ldr	r2, [r3, #0]
 800e472:	687b      	ldr	r3, [r7, #4]
 800e474:	9300      	str	r3, [sp, #0]
 800e476:	68f8      	ldr	r0, [r7, #12]
 800e478:	4611      	mov	r1, r2
 800e47a:	2228      	movs	r2, #40	; 0x28
 800e47c:	2300      	movs	r3, #0
 800e47e:	f7fe fef7 	bl	800d270 <canardDecodeScalar>
    *bit_ofs += 40;
 800e482:	68bb      	ldr	r3, [r7, #8]
 800e484:	681b      	ldr	r3, [r3, #0]
 800e486:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800e48a:	68bb      	ldr	r3, [r7, #8]
 800e48c:	601a      	str	r2, [r3, #0]

}
 800e48e:	3710      	adds	r7, #16
 800e490:	46bd      	mov	sp, r7
 800e492:	bd80      	pop	{r7, pc}

0800e494 <encode_func.lto_priv.51>:
>>>>>>> 752c83b... update binaries
#include <uavcan.protocol.dynamic_node_id.Allocation.h>
#include <string.h>

static void encode_func(void* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e40c:	b580      	push	{r7, lr}
 800e40e:	b084      	sub	sp, #16
 800e410:	af00      	add	r7, sp, #0
 800e412:	60f8      	str	r0, [r7, #12]
 800e414:	60b9      	str	r1, [r7, #8]
 800e416:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_dynamic_node_id_Allocation(msg, chunk_cb, ctx);
 800e418:	68f8      	ldr	r0, [r7, #12]
 800e41a:	68b9      	ldr	r1, [r7, #8]
 800e41c:	687a      	ldr	r2, [r7, #4]
 800e41e:	f000 f811 	bl	800e444 <encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800e422:	3710      	adds	r7, #16
 800e424:	46bd      	mov	sp, r7
 800e426:	bd80      	pop	{r7, pc}

0800e428 <decode_func.lto_priv.59>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e428:	b580      	push	{r7, lr}
 800e42a:	b082      	sub	sp, #8
 800e42c:	af00      	add	r7, sp, #0
 800e42e:	6078      	str	r0, [r7, #4]
 800e430:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, msg);
 800e432:	6878      	ldr	r0, [r7, #4]
 800e434:	6839      	ldr	r1, [r7, #0]
 800e436:	f000 f819 	bl	800e46c <decode_uavcan_protocol_dynamic_node_id_Allocation>
 800e43a:	4603      	mov	r3, r0
}
 800e43c:	4618      	mov	r0, r3
 800e43e:	3708      	adds	r7, #8
 800e440:	46bd      	mov	sp, r7
 800e442:	bd80      	pop	{r7, pc}

0800e444 <encode_uavcan_protocol_dynamic_node_id_Allocation>:
=======
 800e494:	b580      	push	{r7, lr}
 800e496:	b084      	sub	sp, #16
 800e498:	af00      	add	r7, sp, #0
 800e49a:	60f8      	str	r0, [r7, #12]
 800e49c:	60b9      	str	r1, [r7, #8]
 800e49e:	607a      	str	r2, [r7, #4]
    encode_uavcan_protocol_dynamic_node_id_Allocation(msg, chunk_cb, ctx);
 800e4a0:	68f8      	ldr	r0, [r7, #12]
 800e4a2:	68b9      	ldr	r1, [r7, #8]
 800e4a4:	687a      	ldr	r2, [r7, #4]
 800e4a6:	f000 f811 	bl	800e4cc <encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800e4aa:	3710      	adds	r7, #16
 800e4ac:	46bd      	mov	sp, r7
 800e4ae:	bd80      	pop	{r7, pc}

0800e4b0 <decode_func.lto_priv.59>:

static uint32_t decode_func(CanardRxTransfer* transfer, void* msg) {
 800e4b0:	b580      	push	{r7, lr}
 800e4b2:	b082      	sub	sp, #8
 800e4b4:	af00      	add	r7, sp, #0
 800e4b6:	6078      	str	r0, [r7, #4]
 800e4b8:	6039      	str	r1, [r7, #0]
    return decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, msg);
 800e4ba:	6878      	ldr	r0, [r7, #4]
 800e4bc:	6839      	ldr	r1, [r7, #0]
 800e4be:	f000 f819 	bl	800e4f4 <decode_uavcan_protocol_dynamic_node_id_Allocation>
 800e4c2:	4603      	mov	r3, r0
}
 800e4c4:	4618      	mov	r0, r3
 800e4c6:	3708      	adds	r7, #8
 800e4c8:	46bd      	mov	sp, r7
 800e4ca:	bd80      	pop	{r7, pc}

0800e4cc <encode_uavcan_protocol_dynamic_node_id_Allocation>:
>>>>>>> 752c83b... update binaries
    encode_func,
    decode_func,
    NULL
};

void encode_uavcan_protocol_dynamic_node_id_Allocation(struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx) {
<<<<<<< HEAD
 800e444:	b580      	push	{r7, lr}
 800e446:	b088      	sub	sp, #32
 800e448:	af02      	add	r7, sp, #8
 800e44a:	60f8      	str	r0, [r7, #12]
 800e44c:	60b9      	str	r1, [r7, #8]
 800e44e:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_dynamic_node_id_Allocation(buffer, msg, chunk_cb, ctx, true);
 800e450:	f107 0210 	add.w	r2, r7, #16
 800e454:	2301      	movs	r3, #1
 800e456:	9300      	str	r3, [sp, #0]
 800e458:	4610      	mov	r0, r2
 800e45a:	68f9      	ldr	r1, [r7, #12]
 800e45c:	68ba      	ldr	r2, [r7, #8]
 800e45e:	687b      	ldr	r3, [r7, #4]
 800e460:	f000 f81a 	bl	800e498 <_encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800e464:	3718      	adds	r7, #24
 800e466:	46bd      	mov	sp, r7
 800e468:	bd80      	pop	{r7, pc}
 800e46a:	bf00      	nop

0800e46c <decode_uavcan_protocol_dynamic_node_id_Allocation>:

uint32_t decode_uavcan_protocol_dynamic_node_id_Allocation(const CanardRxTransfer* transfer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg) {
 800e46c:	b580      	push	{r7, lr}
 800e46e:	b084      	sub	sp, #16
 800e470:	af00      	add	r7, sp, #0
 800e472:	6078      	str	r0, [r7, #4]
 800e474:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e476:	2300      	movs	r3, #0
 800e478:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, &bit_ofs, msg, true);
 800e47a:	f107 030c 	add.w	r3, r7, #12
 800e47e:	6878      	ldr	r0, [r7, #4]
 800e480:	4619      	mov	r1, r3
 800e482:	683a      	ldr	r2, [r7, #0]
 800e484:	2301      	movs	r3, #1
 800e486:	f7fd fb83 	bl	800bb90 <_decode_uavcan_protocol_dynamic_node_id_Allocation>
    return (bit_ofs+7)/8;
 800e48a:	68fb      	ldr	r3, [r7, #12]
 800e48c:	3307      	adds	r3, #7
 800e48e:	08db      	lsrs	r3, r3, #3
}
 800e490:	4618      	mov	r0, r3
 800e492:	3710      	adds	r7, #16
 800e494:	46bd      	mov	sp, r7
 800e496:	bd80      	pop	{r7, pc}

0800e498 <_encode_uavcan_protocol_dynamic_node_id_Allocation>:

void _encode_uavcan_protocol_dynamic_node_id_Allocation(uint8_t* buffer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e498:	b580      	push	{r7, lr}
 800e49a:	b086      	sub	sp, #24
 800e49c:	af00      	add	r7, sp, #0
 800e49e:	60f8      	str	r0, [r7, #12]
 800e4a0:	60b9      	str	r1, [r7, #8]
 800e4a2:	607a      	str	r2, [r7, #4]
 800e4a4:	603b      	str	r3, [r7, #0]
=======
 800e4cc:	b580      	push	{r7, lr}
 800e4ce:	b088      	sub	sp, #32
 800e4d0:	af02      	add	r7, sp, #8
 800e4d2:	60f8      	str	r0, [r7, #12]
 800e4d4:	60b9      	str	r1, [r7, #8]
 800e4d6:	607a      	str	r2, [r7, #4]
    uint8_t buffer[8];
    _encode_uavcan_protocol_dynamic_node_id_Allocation(buffer, msg, chunk_cb, ctx, true);
 800e4d8:	f107 0210 	add.w	r2, r7, #16
 800e4dc:	2301      	movs	r3, #1
 800e4de:	9300      	str	r3, [sp, #0]
 800e4e0:	4610      	mov	r0, r2
 800e4e2:	68f9      	ldr	r1, [r7, #12]
 800e4e4:	68ba      	ldr	r2, [r7, #8]
 800e4e6:	687b      	ldr	r3, [r7, #4]
 800e4e8:	f000 f81a 	bl	800e520 <_encode_uavcan_protocol_dynamic_node_id_Allocation>
}
 800e4ec:	3718      	adds	r7, #24
 800e4ee:	46bd      	mov	sp, r7
 800e4f0:	bd80      	pop	{r7, pc}
 800e4f2:	bf00      	nop

0800e4f4 <decode_uavcan_protocol_dynamic_node_id_Allocation>:

uint32_t decode_uavcan_protocol_dynamic_node_id_Allocation(const CanardRxTransfer* transfer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg) {
 800e4f4:	b580      	push	{r7, lr}
 800e4f6:	b084      	sub	sp, #16
 800e4f8:	af00      	add	r7, sp, #0
 800e4fa:	6078      	str	r0, [r7, #4]
 800e4fc:	6039      	str	r1, [r7, #0]
    uint32_t bit_ofs = 0;
 800e4fe:	2300      	movs	r3, #0
 800e500:	60fb      	str	r3, [r7, #12]
    _decode_uavcan_protocol_dynamic_node_id_Allocation(transfer, &bit_ofs, msg, true);
 800e502:	f107 030c 	add.w	r3, r7, #12
 800e506:	6878      	ldr	r0, [r7, #4]
 800e508:	4619      	mov	r1, r3
 800e50a:	683a      	ldr	r2, [r7, #0]
 800e50c:	2301      	movs	r3, #1
 800e50e:	f7fd fb83 	bl	800bc18 <_decode_uavcan_protocol_dynamic_node_id_Allocation>
    return (bit_ofs+7)/8;
 800e512:	68fb      	ldr	r3, [r7, #12]
 800e514:	3307      	adds	r3, #7
 800e516:	08db      	lsrs	r3, r3, #3
}
 800e518:	4618      	mov	r0, r3
 800e51a:	3710      	adds	r7, #16
 800e51c:	46bd      	mov	sp, r7
 800e51e:	bd80      	pop	{r7, pc}

0800e520 <_encode_uavcan_protocol_dynamic_node_id_Allocation>:

void _encode_uavcan_protocol_dynamic_node_id_Allocation(uint8_t* buffer, struct uavcan_protocol_dynamic_node_id_Allocation_s* msg, uavcan_serializer_chunk_cb_ptr_t chunk_cb, void* ctx, bool tao) {
 800e520:	b580      	push	{r7, lr}
 800e522:	b086      	sub	sp, #24
 800e524:	af00      	add	r7, sp, #0
 800e526:	60f8      	str	r0, [r7, #12]
 800e528:	60b9      	str	r1, [r7, #8]
 800e52a:	607a      	str	r2, [r7, #4]
 800e52c:	603b      	str	r3, [r7, #0]
>>>>>>> 752c83b... update binaries
    (void)msg;
    (void)chunk_cb;
    (void)ctx;
    (void)tao;

    memset(buffer,0,8);
<<<<<<< HEAD
 800e4a6:	68f8      	ldr	r0, [r7, #12]
 800e4a8:	2100      	movs	r1, #0
 800e4aa:	2208      	movs	r2, #8
 800e4ac:	f000 f88c 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 7, &msg->node_id);
 800e4b0:	68bb      	ldr	r3, [r7, #8]
 800e4b2:	68f8      	ldr	r0, [r7, #12]
 800e4b4:	2100      	movs	r1, #0
 800e4b6:	2207      	movs	r2, #7
 800e4b8:	f7ff f80e 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 7, ctx);
 800e4bc:	687b      	ldr	r3, [r7, #4]
 800e4be:	68f8      	ldr	r0, [r7, #12]
 800e4c0:	2107      	movs	r1, #7
 800e4c2:	683a      	ldr	r2, [r7, #0]
 800e4c4:	4798      	blx	r3
    memset(buffer,0,8);
 800e4c6:	68f8      	ldr	r0, [r7, #12]
 800e4c8:	2100      	movs	r1, #0
 800e4ca:	2208      	movs	r2, #8
 800e4cc:	f000 f87c 	bl	800e5c8 <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->first_part_of_unique_id);
 800e4d0:	68bb      	ldr	r3, [r7, #8]
 800e4d2:	3301      	adds	r3, #1
 800e4d4:	68f8      	ldr	r0, [r7, #12]
 800e4d6:	2100      	movs	r1, #0
 800e4d8:	2201      	movs	r2, #1
 800e4da:	f7fe fffd 	bl	800d4d8 <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800e4de:	687b      	ldr	r3, [r7, #4]
 800e4e0:	68f8      	ldr	r0, [r7, #12]
 800e4e2:	2101      	movs	r1, #1
 800e4e4:	683a      	ldr	r2, [r7, #0]
 800e4e6:	4798      	blx	r3
    if (!tao) {
 800e4e8:	f897 3020 	ldrb.w	r3, [r7, #32]
 800e4ec:	f083 0301 	eor.w	r3, r3, #1
 800e4f0:	b2db      	uxtb	r3, r3
 800e4f2:	2b00      	cmp	r3, #0
 800e4f4:	d010      	beq.n	800e518 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x80>
        memset(buffer,0,8);
 800e4f6:	68f8      	ldr	r0, [r7, #12]
 800e4f8:	2100      	movs	r1, #0
 800e4fa:	2208      	movs	r2, #8
 800e4fc:	f000 f864 	bl	800e5c8 <memset>
        canardEncodeScalar(buffer, 0, 5, &msg->unique_id_len);
 800e500:	68bb      	ldr	r3, [r7, #8]
 800e502:	3302      	adds	r3, #2
 800e504:	68f8      	ldr	r0, [r7, #12]
 800e506:	2100      	movs	r1, #0
 800e508:	2205      	movs	r2, #5
 800e50a:	f7fe ffe5 	bl	800d4d8 <canardEncodeScalar>
        chunk_cb(buffer, 5, ctx);
 800e50e:	687b      	ldr	r3, [r7, #4]
 800e510:	68f8      	ldr	r0, [r7, #12]
 800e512:	2105      	movs	r1, #5
 800e514:	683a      	ldr	r2, [r7, #0]
 800e516:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->unique_id_len; i++) {
 800e518:	2300      	movs	r3, #0
 800e51a:	617b      	str	r3, [r7, #20]
 800e51c:	e015      	b.n	800e54a <_encode_uavcan_protocol_dynamic_node_id_Allocation+0xb2>
            memset(buffer,0,8);
 800e51e:	68f8      	ldr	r0, [r7, #12]
 800e520:	2100      	movs	r1, #0
 800e522:	2208      	movs	r2, #8
 800e524:	f000 f850 	bl	800e5c8 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800e528:	68ba      	ldr	r2, [r7, #8]
 800e52a:	697b      	ldr	r3, [r7, #20]
 800e52c:	4413      	add	r3, r2
 800e52e:	3303      	adds	r3, #3
 800e530:	68f8      	ldr	r0, [r7, #12]
 800e532:	2100      	movs	r1, #0
 800e534:	2208      	movs	r2, #8
 800e536:	f7fe ffcf 	bl	800d4d8 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800e53a:	687b      	ldr	r3, [r7, #4]
 800e53c:	68f8      	ldr	r0, [r7, #12]
 800e53e:	2108      	movs	r1, #8
 800e540:	683a      	ldr	r2, [r7, #0]
 800e542:	4798      	blx	r3
=======
 800e52e:	68f8      	ldr	r0, [r7, #12]
 800e530:	2100      	movs	r1, #0
 800e532:	2208      	movs	r2, #8
 800e534:	f000 f88c 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 7, &msg->node_id);
 800e538:	68bb      	ldr	r3, [r7, #8]
 800e53a:	68f8      	ldr	r0, [r7, #12]
 800e53c:	2100      	movs	r1, #0
 800e53e:	2207      	movs	r2, #7
 800e540:	f7ff f80e 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 7, ctx);
 800e544:	687b      	ldr	r3, [r7, #4]
 800e546:	68f8      	ldr	r0, [r7, #12]
 800e548:	2107      	movs	r1, #7
 800e54a:	683a      	ldr	r2, [r7, #0]
 800e54c:	4798      	blx	r3
    memset(buffer,0,8);
 800e54e:	68f8      	ldr	r0, [r7, #12]
 800e550:	2100      	movs	r1, #0
 800e552:	2208      	movs	r2, #8
 800e554:	f000 f87c 	bl	800e650 <memset>
    canardEncodeScalar(buffer, 0, 1, &msg->first_part_of_unique_id);
 800e558:	68bb      	ldr	r3, [r7, #8]
 800e55a:	3301      	adds	r3, #1
 800e55c:	68f8      	ldr	r0, [r7, #12]
 800e55e:	2100      	movs	r1, #0
 800e560:	2201      	movs	r2, #1
 800e562:	f7fe fffd 	bl	800d560 <canardEncodeScalar>
    chunk_cb(buffer, 1, ctx);
 800e566:	687b      	ldr	r3, [r7, #4]
 800e568:	68f8      	ldr	r0, [r7, #12]
 800e56a:	2101      	movs	r1, #1
 800e56c:	683a      	ldr	r2, [r7, #0]
 800e56e:	4798      	blx	r3
    if (!tao) {
 800e570:	f897 3020 	ldrb.w	r3, [r7, #32]
 800e574:	f083 0301 	eor.w	r3, r3, #1
 800e578:	b2db      	uxtb	r3, r3
 800e57a:	2b00      	cmp	r3, #0
 800e57c:	d010      	beq.n	800e5a0 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x80>
        memset(buffer,0,8);
 800e57e:	68f8      	ldr	r0, [r7, #12]
 800e580:	2100      	movs	r1, #0
 800e582:	2208      	movs	r2, #8
 800e584:	f000 f864 	bl	800e650 <memset>
        canardEncodeScalar(buffer, 0, 5, &msg->unique_id_len);
 800e588:	68bb      	ldr	r3, [r7, #8]
 800e58a:	3302      	adds	r3, #2
 800e58c:	68f8      	ldr	r0, [r7, #12]
 800e58e:	2100      	movs	r1, #0
 800e590:	2205      	movs	r2, #5
 800e592:	f7fe ffe5 	bl	800d560 <canardEncodeScalar>
        chunk_cb(buffer, 5, ctx);
 800e596:	687b      	ldr	r3, [r7, #4]
 800e598:	68f8      	ldr	r0, [r7, #12]
 800e59a:	2105      	movs	r1, #5
 800e59c:	683a      	ldr	r2, [r7, #0]
 800e59e:	4798      	blx	r3
    }
    for (size_t i=0; i < msg->unique_id_len; i++) {
 800e5a0:	2300      	movs	r3, #0
 800e5a2:	617b      	str	r3, [r7, #20]
 800e5a4:	e015      	b.n	800e5d2 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0xb2>
            memset(buffer,0,8);
 800e5a6:	68f8      	ldr	r0, [r7, #12]
 800e5a8:	2100      	movs	r1, #0
 800e5aa:	2208      	movs	r2, #8
 800e5ac:	f000 f850 	bl	800e650 <memset>
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
 800e5b0:	68ba      	ldr	r2, [r7, #8]
 800e5b2:	697b      	ldr	r3, [r7, #20]
 800e5b4:	4413      	add	r3, r2
 800e5b6:	3303      	adds	r3, #3
 800e5b8:	68f8      	ldr	r0, [r7, #12]
 800e5ba:	2100      	movs	r1, #0
 800e5bc:	2208      	movs	r2, #8
 800e5be:	f7fe ffcf 	bl	800d560 <canardEncodeScalar>
            chunk_cb(buffer, 8, ctx);
 800e5c2:	687b      	ldr	r3, [r7, #4]
 800e5c4:	68f8      	ldr	r0, [r7, #12]
 800e5c6:	2108      	movs	r1, #8
 800e5c8:	683a      	ldr	r2, [r7, #0]
 800e5ca:	4798      	blx	r3
>>>>>>> 752c83b... update binaries
    if (!tao) {
        memset(buffer,0,8);
        canardEncodeScalar(buffer, 0, 5, &msg->unique_id_len);
        chunk_cb(buffer, 5, ctx);
    }
    for (size_t i=0; i < msg->unique_id_len; i++) {
<<<<<<< HEAD
 800e544:	697b      	ldr	r3, [r7, #20]
 800e546:	3301      	adds	r3, #1
 800e548:	617b      	str	r3, [r7, #20]
 800e54a:	68bb      	ldr	r3, [r7, #8]
 800e54c:	789b      	ldrb	r3, [r3, #2]
 800e54e:	461a      	mov	r2, r3
 800e550:	697b      	ldr	r3, [r7, #20]
 800e552:	429a      	cmp	r2, r3
 800e554:	d8e3      	bhi.n	800e51e <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x86>
=======
 800e5cc:	697b      	ldr	r3, [r7, #20]
 800e5ce:	3301      	adds	r3, #1
 800e5d0:	617b      	str	r3, [r7, #20]
 800e5d2:	68bb      	ldr	r3, [r7, #8]
 800e5d4:	789b      	ldrb	r3, [r3, #2]
 800e5d6:	461a      	mov	r2, r3
 800e5d8:	697b      	ldr	r3, [r7, #20]
 800e5da:	429a      	cmp	r2, r3
 800e5dc:	d8e3      	bhi.n	800e5a6 <_encode_uavcan_protocol_dynamic_node_id_Allocation+0x86>
>>>>>>> 752c83b... update binaries
            memset(buffer,0,8);
            canardEncodeScalar(buffer, 0, 8, &msg->unique_id[i]);
            chunk_cb(buffer, 8, ctx);
    }
}
<<<<<<< HEAD
 800e556:	3718      	adds	r7, #24
 800e558:	46bd      	mov	sp, r7
 800e55a:	bd80      	pop	{r7, pc}

0800e55c <memcmp>:
 800e55c:	b510      	push	{r4, lr}
 800e55e:	440a      	add	r2, r1
 800e560:	1e44      	subs	r4, r0, #1
 800e562:	4291      	cmp	r1, r2
 800e564:	d008      	beq.n	800e578 <memcmp+0x1c>
 800e566:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 800e56a:	7808      	ldrb	r0, [r1, #0]
 800e56c:	4283      	cmp	r3, r0
 800e56e:	d001      	beq.n	800e574 <memcmp+0x18>
 800e570:	1a18      	subs	r0, r3, r0
 800e572:	bd10      	pop	{r4, pc}
 800e574:	3101      	adds	r1, #1
 800e576:	e7f4      	b.n	800e562 <memcmp+0x6>
 800e578:	2000      	movs	r0, #0
 800e57a:	bd10      	pop	{r4, pc}

0800e57c <memcpy>:
 800e57c:	b510      	push	{r4, lr}
 800e57e:	1e43      	subs	r3, r0, #1
 800e580:	440a      	add	r2, r1
 800e582:	4291      	cmp	r1, r2
 800e584:	d004      	beq.n	800e590 <memcpy+0x14>
 800e586:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e58a:	f803 4f01 	strb.w	r4, [r3, #1]!
 800e58e:	e7f8      	b.n	800e582 <memcpy+0x6>
 800e590:	bd10      	pop	{r4, pc}

0800e592 <memmove>:
 800e592:	4281      	cmp	r1, r0
 800e594:	b510      	push	{r4, lr}
 800e596:	eb01 0302 	add.w	r3, r1, r2
 800e59a:	d301      	bcc.n	800e5a0 <memmove+0xe>
 800e59c:	1e42      	subs	r2, r0, #1
 800e59e:	e00b      	b.n	800e5b8 <memmove+0x26>
 800e5a0:	4298      	cmp	r0, r3
 800e5a2:	d2fb      	bcs.n	800e59c <memmove+0xa>
 800e5a4:	1881      	adds	r1, r0, r2
 800e5a6:	1ad2      	subs	r2, r2, r3
 800e5a8:	42d3      	cmn	r3, r2
 800e5aa:	d004      	beq.n	800e5b6 <memmove+0x24>
 800e5ac:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800e5b0:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800e5b4:	e7f8      	b.n	800e5a8 <memmove+0x16>
 800e5b6:	bd10      	pop	{r4, pc}
 800e5b8:	4299      	cmp	r1, r3
 800e5ba:	d004      	beq.n	800e5c6 <memmove+0x34>
 800e5bc:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e5c0:	f802 4f01 	strb.w	r4, [r2, #1]!
 800e5c4:	e7f8      	b.n	800e5b8 <memmove+0x26>
 800e5c6:	bd10      	pop	{r4, pc}

0800e5c8 <memset>:
 800e5c8:	4603      	mov	r3, r0
 800e5ca:	4402      	add	r2, r0
 800e5cc:	4293      	cmp	r3, r2
 800e5ce:	d002      	beq.n	800e5d6 <memset+0xe>
 800e5d0:	f803 1b01 	strb.w	r1, [r3], #1
 800e5d4:	e7fa      	b.n	800e5cc <memset+0x4>
 800e5d6:	4770      	bx	lr

0800e5d8 <strnlen>:
 800e5d8:	4602      	mov	r2, r0
 800e5da:	b510      	push	{r4, lr}
 800e5dc:	4401      	add	r1, r0
 800e5de:	428a      	cmp	r2, r1
 800e5e0:	4613      	mov	r3, r2
 800e5e2:	d003      	beq.n	800e5ec <strnlen+0x14>
 800e5e4:	781c      	ldrb	r4, [r3, #0]
 800e5e6:	3201      	adds	r2, #1
 800e5e8:	2c00      	cmp	r4, #0
 800e5ea:	d1f8      	bne.n	800e5de <strnlen+0x6>
 800e5ec:	1a18      	subs	r0, r3, r0
 800e5ee:	bd10      	pop	{r4, pc}
=======
 800e5de:	3718      	adds	r7, #24
 800e5e0:	46bd      	mov	sp, r7
 800e5e2:	bd80      	pop	{r7, pc}

0800e5e4 <memcmp>:
 800e5e4:	b510      	push	{r4, lr}
 800e5e6:	440a      	add	r2, r1
 800e5e8:	1e44      	subs	r4, r0, #1
 800e5ea:	4291      	cmp	r1, r2
 800e5ec:	d008      	beq.n	800e600 <memcmp+0x1c>
 800e5ee:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 800e5f2:	7808      	ldrb	r0, [r1, #0]
 800e5f4:	4283      	cmp	r3, r0
 800e5f6:	d001      	beq.n	800e5fc <memcmp+0x18>
 800e5f8:	1a18      	subs	r0, r3, r0
 800e5fa:	bd10      	pop	{r4, pc}
 800e5fc:	3101      	adds	r1, #1
 800e5fe:	e7f4      	b.n	800e5ea <memcmp+0x6>
 800e600:	2000      	movs	r0, #0
 800e602:	bd10      	pop	{r4, pc}

0800e604 <memcpy>:
 800e604:	b510      	push	{r4, lr}
 800e606:	1e43      	subs	r3, r0, #1
 800e608:	440a      	add	r2, r1
 800e60a:	4291      	cmp	r1, r2
 800e60c:	d004      	beq.n	800e618 <memcpy+0x14>
 800e60e:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e612:	f803 4f01 	strb.w	r4, [r3, #1]!
 800e616:	e7f8      	b.n	800e60a <memcpy+0x6>
 800e618:	bd10      	pop	{r4, pc}

0800e61a <memmove>:
 800e61a:	4281      	cmp	r1, r0
 800e61c:	b510      	push	{r4, lr}
 800e61e:	eb01 0302 	add.w	r3, r1, r2
 800e622:	d301      	bcc.n	800e628 <memmove+0xe>
 800e624:	1e42      	subs	r2, r0, #1
 800e626:	e00b      	b.n	800e640 <memmove+0x26>
 800e628:	4298      	cmp	r0, r3
 800e62a:	d2fb      	bcs.n	800e624 <memmove+0xa>
 800e62c:	1881      	adds	r1, r0, r2
 800e62e:	1ad2      	subs	r2, r2, r3
 800e630:	42d3      	cmn	r3, r2
 800e632:	d004      	beq.n	800e63e <memmove+0x24>
 800e634:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800e638:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800e63c:	e7f8      	b.n	800e630 <memmove+0x16>
 800e63e:	bd10      	pop	{r4, pc}
 800e640:	4299      	cmp	r1, r3
 800e642:	d004      	beq.n	800e64e <memmove+0x34>
 800e644:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e648:	f802 4f01 	strb.w	r4, [r2, #1]!
 800e64c:	e7f8      	b.n	800e640 <memmove+0x26>
 800e64e:	bd10      	pop	{r4, pc}

0800e650 <memset>:
 800e650:	4603      	mov	r3, r0
 800e652:	4402      	add	r2, r0
 800e654:	4293      	cmp	r3, r2
 800e656:	d002      	beq.n	800e65e <memset+0xe>
 800e658:	f803 1b01 	strb.w	r1, [r3], #1
 800e65c:	e7fa      	b.n	800e654 <memset+0x4>
 800e65e:	4770      	bx	lr

0800e660 <strnlen>:
 800e660:	4602      	mov	r2, r0
 800e662:	b510      	push	{r4, lr}
 800e664:	4401      	add	r1, r0
 800e666:	428a      	cmp	r2, r1
 800e668:	4613      	mov	r3, r2
 800e66a:	d003      	beq.n	800e674 <strnlen+0x14>
 800e66c:	781c      	ldrb	r4, [r3, #0]
 800e66e:	3201      	adds	r2, #1
 800e670:	2c00      	cmp	r4, #0
 800e672:	d1f8      	bne.n	800e666 <strnlen+0x6>
 800e674:	1a18      	subs	r0, r3, r0
 800e676:	bd10      	pop	{r4, pc}
>>>>>>> 752c83b... update binaries
